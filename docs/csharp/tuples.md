---
title: Tipos de tupla – Guia C#
description: Saiba mais sobre os tipos de tupla nomeadas e sem nome em C#
ms.date: 05/15/2018
ms.assetid: ee8bf7c3-aa3e-4c9e-a5c6-e05cc6138baa
ms.openlocfilehash: 2c2b25c34555699c196099c0e1c51681fba8c358
ms.sourcegitcommit: 0069cb3de8eed4e92b2195d29e5769a76111acdd
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 02/16/2019
ms.locfileid: "56332748"
---
# <a name="c-tuple-types"></a><span data-ttu-id="c94e3-103">Tipos de tupla do C#</span><span class="sxs-lookup"><span data-stu-id="c94e3-103">C# tuple types</span></span> #

<span data-ttu-id="c94e3-104">As tuplas do C# são tipos que você define usando uma sintaxe leve.</span><span class="sxs-lookup"><span data-stu-id="c94e3-104">C# tuples are types that you define using a lightweight syntax.</span></span> <span data-ttu-id="c94e3-105">As vantagens incluem sintaxe mais simples, regras para conversões baseadas em números (conhecidas como cardinalidade) e em tipos de elementos, além de regras compatíveis para cópias, testes de igualdade e atribuições.</span><span class="sxs-lookup"><span data-stu-id="c94e3-105">The advantages include a simpler syntax, rules for conversions based on number (referred to as cardinality) and types of elements, and consistent rules for copies, equality tests, and assignments.</span></span> <span data-ttu-id="c94e3-106">Em contrapartida, as tuplas não oferecem suporte a algumas das expressões orientadas a objeto associadas à herança.</span><span class="sxs-lookup"><span data-stu-id="c94e3-106">As a tradeoff, tuples do not support some of the object-oriented idioms associated with inheritance.</span></span> <span data-ttu-id="c94e3-107">Você pode obter uma visão geral na seção sobre [tuplas no artigo Novidades no C# 7.0](whats-new/csharp-7.md#tuples).</span><span class="sxs-lookup"><span data-stu-id="c94e3-107">You can get an overview in the section on [tuples in the What's new in C# 7.0](whats-new/csharp-7.md#tuples) article.</span></span>

<span data-ttu-id="c94e3-108">Neste artigo, você aprenderá as regras de linguagem que regem as tuplas no C# 7.0 e em versões posteriores, além de diferentes maneiras de usá-las e as diretrizes iniciais para trabalhar com tuplas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-108">In this article, you'll learn the language rules governing tuples in C# 7.0 and later versions, different ways to use them, and initial guidance on working with tuples.</span></span>

> [!NOTE]
> <span data-ttu-id="c94e3-109">Os novos recursos de tuplas exigem os tipos <xref:System.ValueTuple>.</span><span class="sxs-lookup"><span data-stu-id="c94e3-109">The new tuples features require the <xref:System.ValueTuple> types.</span></span>
> <span data-ttu-id="c94e3-110">Você deve adicionar o pacote NuGet [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) para usá-lo em plataformas que não incluem os tipos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-110">You must add the NuGet package [`System.ValueTuple`](https://www.nuget.org/packages/System.ValueTuple/) in order to use it on platforms that do not include the types.</span></span>
>
> <span data-ttu-id="c94e3-111">Isso é semelhante a outros recursos de linguagem que dependem de tipos entregues no framework.</span><span class="sxs-lookup"><span data-stu-id="c94e3-111">This is similar to other language features that rely on types delivered in the framework.</span></span> <span data-ttu-id="c94e3-112">Os exemplos incluem `async` e `await` que dependem da interface `INotifyCompletion`, além do LINQ que depende de `IEnumerable<T>`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-112">Examples include `async` and `await` relying on the `INotifyCompletion` interface, and LINQ relying on `IEnumerable<T>`.</span></span> <span data-ttu-id="c94e3-113">No entanto, o mecanismo de entrega está mudando conforme o .NET se torna mais independente de plataforma.</span><span class="sxs-lookup"><span data-stu-id="c94e3-113">However, the delivery mechanism is changing as .NET is becoming more platform independent.</span></span> <span data-ttu-id="c94e3-114">O .NET Framework pode não ser enviados sempre na mesma cadência que o compilador de linguagem.</span><span class="sxs-lookup"><span data-stu-id="c94e3-114">The .NET Framework may not always ship on the same cadence as the language compiler.</span></span> <span data-ttu-id="c94e3-115">Quando novos recursos de linguagem dependerem de novos tipos, esses tipos estarão disponíveis como pacotes do NuGet quando os recursos de linguagem forem enviados.</span><span class="sxs-lookup"><span data-stu-id="c94e3-115">When new language features rely on new types, those types will be available as NuGet packages when the language features ship.</span></span> <span data-ttu-id="c94e3-116">Conforme esses novos tipos são adicionados à API padrão do .NET e fornecidos como parte do framework, o requisito de pacote do NuGet será removido.</span><span class="sxs-lookup"><span data-stu-id="c94e3-116">As these new types get added to the .NET Standard API and delivered as part of the framework, the NuGet package requirement will be removed.</span></span>

<span data-ttu-id="c94e3-117">Vamos começar com os motivos para adicionar o novo suporte de tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-117">Let's start with the reasons for adding new tuple support.</span></span> <span data-ttu-id="c94e3-118">Métodos retornam um único objeto.</span><span class="sxs-lookup"><span data-stu-id="c94e3-118">Methods return a single object.</span></span> <span data-ttu-id="c94e3-119">Tuplas permitem que você empacote vários valores nesse único objeto mais facilmente.</span><span class="sxs-lookup"><span data-stu-id="c94e3-119">Tuples enable you to package multiple values in that single object more easily.</span></span>

<span data-ttu-id="c94e3-120">O .NET Framework já tem classes `Tuple` genéricas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-120">The .NET Framework already has generic `Tuple` classes.</span></span> <span data-ttu-id="c94e3-121">Essas classes, no entanto, têm duas limitações importantes.</span><span class="sxs-lookup"><span data-stu-id="c94e3-121">These classes, however, had two major limitations.</span></span> <span data-ttu-id="c94e3-122">Por exemplo, as classes `Tuple` nomearam suas propriedades como `Item1`, `Item2` e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="c94e3-122">For one, the `Tuple` classes named their properties `Item1`, `Item2`, and so on.</span></span> <span data-ttu-id="c94e3-123">Esses nomes não carregam informações semânticas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-123">Those names carry no semantic information.</span></span> <span data-ttu-id="c94e3-124">O uso desses tipos `Tuple` não permite comunicar o significado de cada uma das propriedades.</span><span class="sxs-lookup"><span data-stu-id="c94e3-124">Using these `Tuple` types does not enable communicating the meaning of each of the properties.</span></span> <span data-ttu-id="c94e3-125">Os novos recursos de linguagem permitem que você declare e use nomes semanticamente significativos para os elementos em uma tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-125">The new language features enable you to declare and use semantically meaningful names for the elements in a tuple.</span></span>

<span data-ttu-id="c94e3-126">As classes de `Tuple` causam mais problemas de desempenho porque elas são tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="c94e3-126">The `Tuple` classes cause more performance concerns because they are reference types.</span></span> <span data-ttu-id="c94e3-127">O uso de um dos tipos `Tuple` significa alocar objetos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-127">Using one of the `Tuple` types means allocating objects.</span></span> <span data-ttu-id="c94e3-128">Em afunilamentos, alocar muitos objetos pequenos pode ter um impacto mensurável no desempenho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="c94e3-128">On hot paths, allocating many small objects can have a measurable impact on your application's performance.</span></span> <span data-ttu-id="c94e3-129">Portanto, o suporte de linguagem para tuplas aproveita os novos structs `ValueTuple`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-129">Therefore, the language support for tuples leverages the new `ValueTuple` structs.</span></span>

<span data-ttu-id="c94e3-130">Para evitar essas deficiências, você pode criar uma `class` ou um `struct` para carregar vários elementos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-130">To avoid those deficiencies, you could create a `class` or a `struct` to carry multiple elements.</span></span> <span data-ttu-id="c94e3-131">Infelizmente, isso significa mais trabalho para você e obscurece a intenção do design.</span><span class="sxs-lookup"><span data-stu-id="c94e3-131">Unfortunately, that's more work for you, and it obscures your design intent.</span></span> <span data-ttu-id="c94e3-132">Fazer uma `struct` ou `class` significa que você está definindo um tipo com os dados e comportamento.</span><span class="sxs-lookup"><span data-stu-id="c94e3-132">Making a `struct` or `class` implies that you are defining a type with both data and behavior.</span></span> <span data-ttu-id="c94e3-133">Muitas vezes, você simplesmente deseja armazenar diversos valores em um único objeto.</span><span class="sxs-lookup"><span data-stu-id="c94e3-133">Many times, you simply want to store multiple values in a single object.</span></span>

<span data-ttu-id="c94e3-134">Os recursos de linguagem e os structs genéricos `ValueTuple` aplicam a regra de que você não pode adicionar nenhum comportamento (método) a esses tipos de tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-134">The language features and the `ValueTuple` generic structs enforce the rule that you cannot add any behavior (methods) to these tuple types.</span></span>
<span data-ttu-id="c94e3-135">Todos os tipos `ValueTuple` são *structs mutáveis*.</span><span class="sxs-lookup"><span data-stu-id="c94e3-135">All the `ValueTuple` types are *mutable structs*.</span></span> <span data-ttu-id="c94e3-136">Cada campo membro é um campo público.</span><span class="sxs-lookup"><span data-stu-id="c94e3-136">Each member field is a public field.</span></span> <span data-ttu-id="c94e3-137">Isso os torna muito simples.</span><span class="sxs-lookup"><span data-stu-id="c94e3-137">That makes them very lightweight.</span></span> <span data-ttu-id="c94e3-138">No entanto, isso significa que as tuplas não devem ser usadas quando a imutabilidade é importante.</span><span class="sxs-lookup"><span data-stu-id="c94e3-138">However, that means tuples should not be used where immutability is important.</span></span>

<span data-ttu-id="c94e3-139">As tuplas são contêineres de dados mais simples e mais flexíveis do que os tipos `class` e `struct`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-139">Tuples are both simpler and more flexible data containers than `class` and `struct` types.</span></span> <span data-ttu-id="c94e3-140">Vamos explorar essas diferenças.</span><span class="sxs-lookup"><span data-stu-id="c94e3-140">Let's explore those differences.</span></span>

## <a name="named-and-unnamed-tuples"></a><span data-ttu-id="c94e3-141">Tuplas nomeadas e sem nome</span><span class="sxs-lookup"><span data-stu-id="c94e3-141">Named and unnamed tuples</span></span>

<span data-ttu-id="c94e3-142">O struct `ValueTuple` tem campos nomeados `Item1`, `Item2`, `Item3` e assim por diante, semelhante às propriedades definidas nos tipos de `Tuple` existentes.</span><span class="sxs-lookup"><span data-stu-id="c94e3-142">The `ValueTuple` struct has fields named `Item1`, `Item2`, `Item3`, and so on, similar to the properties defined in the existing `Tuple` types.</span></span>
<span data-ttu-id="c94e3-143">Esses nomes são os únicos nomes que você pode usar para *tuplas sem nome*.</span><span class="sxs-lookup"><span data-stu-id="c94e3-143">These names are the only names you can use for *unnamed tuples*.</span></span> <span data-ttu-id="c94e3-144">Quando você não fornece nomes de campo alternativos para uma tupla, cria uma tupla sem nome:</span><span class="sxs-lookup"><span data-stu-id="c94e3-144">When you do not provide any alternative field names to a tuple, you've created an unnamed tuple:</span></span>

[!code-csharp[UnnamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#01_UnNamedTuple "Unnamed tuple")]

<span data-ttu-id="c94e3-145">A tupla no exemplo anterior foi inicializada usando constantes literais e não terá nomes de elemento criados usando as *projeções de nome de campo de tupla* no C# 7.1.</span><span class="sxs-lookup"><span data-stu-id="c94e3-145">The tuple in the previous example was initialized using literal constants and won't have element names created using *tuple field name projections* in C# 7.1.</span></span>

<span data-ttu-id="c94e3-146">No entanto, quando você inicializa uma tupla, pode usar novos recursos de linguagem que fornecem nomes melhores para cada campo.</span><span class="sxs-lookup"><span data-stu-id="c94e3-146">However, when you initialize a tuple, you can use new language features that give better names to each field.</span></span> <span data-ttu-id="c94e3-147">Fazer isso cria uma *tupla nomeada*.</span><span class="sxs-lookup"><span data-stu-id="c94e3-147">Doing so creates a *named tuple*.</span></span>
<span data-ttu-id="c94e3-148">As tuplas nomeadas ainda têm elementos chamados `Item1`, `Item2`, `Item3` e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="c94e3-148">Named tuples still have elements named `Item1`, `Item2`, `Item3` and so on.</span></span>
<span data-ttu-id="c94e3-149">Mas também têm sinônimos para qualquer um desses elementos que você tenha nomeado.</span><span class="sxs-lookup"><span data-stu-id="c94e3-149">But they also have synonyms for any of those elements that you have named.</span></span>
<span data-ttu-id="c94e3-150">Você cria uma tupla nomeada especificando os nomes de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="c94e3-150">You create a named tuple by specifying the names for each element.</span></span> <span data-ttu-id="c94e3-151">Uma maneira é especificar os nomes como parte da inicialização da tupla:</span><span class="sxs-lookup"><span data-stu-id="c94e3-151">One way is to specify the names as part of the tuple initialization:</span></span>

[!code-csharp[NamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#02_NamedTuple "Named tuple")]

<span data-ttu-id="c94e3-152">Esses sinônimos são manipulados pelo compilador e pela linguagem para que você possa usar as tuplas nomeadas de forma eficaz.</span><span class="sxs-lookup"><span data-stu-id="c94e3-152">These synonyms are handled by the compiler and the language so that you can use named tuples effectively.</span></span> <span data-ttu-id="c94e3-153">Os editores e IDEs podem ler esses nomes semânticos usando APIs Roslyn.</span><span class="sxs-lookup"><span data-stu-id="c94e3-153">IDEs and editors can read these semantic names using the Roslyn APIs.</span></span> <span data-ttu-id="c94e3-154">É possível fazer referência aos elementos de uma tupla nomeada com nomes semânticos em qualquer lugar no mesmo assembly.</span><span class="sxs-lookup"><span data-stu-id="c94e3-154">You can reference the elements of a named tuple by those semantic names anywhere in the same assembly.</span></span> <span data-ttu-id="c94e3-155">O compilador substitui os nomes que você definiu com equivalentes `Item*` ao gerar a saída compilada.</span><span class="sxs-lookup"><span data-stu-id="c94e3-155">The compiler replaces the names you've defined with `Item*` equivalents when generating the compiled output.</span></span> <span data-ttu-id="c94e3-156">A MSIL (Microsoft Intermediate Language) compilada não inclui os nomes que você atribuiu a esses elementos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-156">The compiled Microsoft Intermediate Language (MSIL) does not include the names you've given these elements.</span></span>

<span data-ttu-id="c94e3-157">Começando com o C# 7.1, os nomes de campo para uma tupla podem ser fornecidos por meio das variáveis usadas para inicializar a tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-157">Beginning with C# 7.1, the field names for a tuple may be provided from the variables used to initialize the tuple.</span></span> <span data-ttu-id="c94e3-158">Isso é conhecido como **[inicializadores de projeção de tupla](#tuple-projection-initializers)**.</span><span class="sxs-lookup"><span data-stu-id="c94e3-158">This is referred to as **[tuple projection initializers](#tuple-projection-initializers)**.</span></span> <span data-ttu-id="c94e3-159">O código a seguir cria uma tupla denominada `accumulation` com elementos `count` (um inteiro) e `sum` (um duplo).</span><span class="sxs-lookup"><span data-stu-id="c94e3-159">The following code creates a tuple named `accumulation` with elements `count` (an integer), and `sum` (a double).</span></span>

[!code-csharp[ProjectedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectedTupleNames "Named tuple")]

<span data-ttu-id="c94e3-160">O compilador deve comunicar esses nomes que você criou para tuplas retornadas de métodos públicos ou propriedades.</span><span class="sxs-lookup"><span data-stu-id="c94e3-160">The compiler must communicate those names you created for tuples that are returned from public methods or properties.</span></span> <span data-ttu-id="c94e3-161">Nesses casos, o compilador adiciona um atributo <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> no método.</span><span class="sxs-lookup"><span data-stu-id="c94e3-161">In those cases, the compiler adds a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute> attribute on the method.</span></span> <span data-ttu-id="c94e3-162">Esse atributo contém uma propriedade de lista <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> que inclui os nomes dados a cada um desses elementos na tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-162">This attribute contains a <xref:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames> list property that contains the names given to each of the elements in the tuple.</span></span>

> [!NOTE]
> <span data-ttu-id="c94e3-163">Ferramentas de desenvolvimento, como o Visual Studio, também leem esses metadados e fornecem IntelliSense e outros recursos usando os nomes de campo de metadados.</span><span class="sxs-lookup"><span data-stu-id="c94e3-163">Development Tools, such as Visual Studio, also read that metadata, and provide IntelliSense and other features using the metadata field names.</span></span>

<span data-ttu-id="c94e3-164">É importante entender esses conceitos básicos subjacentes das novas tuplas e do tipo `ValueTuple` para entender as regras para atribuir tuplas nomeadas entre si.</span><span class="sxs-lookup"><span data-stu-id="c94e3-164">It is important to understand these underlying fundamentals of the new tuples and the `ValueTuple` type in order to understand the rules for assigning named tuples to each other.</span></span>

## <a name="tuple-projection-initializers"></a><span data-ttu-id="c94e3-165">Inicializadores de projeção de tupla</span><span class="sxs-lookup"><span data-stu-id="c94e3-165">Tuple projection initializers</span></span>

<span data-ttu-id="c94e3-166">Em geral, os inicializadores de projeção de tupla funcionam com o uso dos nomes de campo ou de variáveis do lado direito de uma instrução de inicialização de tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-166">In general, tuple projection initializers work by using the variable or field names from the right-hand side of a tuple initialization statement.</span></span>
<span data-ttu-id="c94e3-167">Se for fornecido um nome explícito, ele terá precedência sobre qualquer nome projetado.</span><span class="sxs-lookup"><span data-stu-id="c94e3-167">If an explicit name is given, that takes precedence over any projected name.</span></span> <span data-ttu-id="c94e3-168">Por exemplo, no seguinte inicializador, os elementos são `explicitFieldOne` e `explicitFieldTwo`, não `localVariableOne` e `localVariableTwo`:</span><span class="sxs-lookup"><span data-stu-id="c94e3-168">For example, in the following initializer, the elements are `explicitFieldOne` and `explicitFieldTwo`, not `localVariableOne` and `localVariableTwo`:</span></span>

[!code-csharp[ExplicitNamedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionExample_Explicit "Explicitly named tuple")]

<span data-ttu-id="c94e3-169">Para qualquer campo em que um nome explícito não for fornecido, será projetado um nome implícito aplicável.</span><span class="sxs-lookup"><span data-stu-id="c94e3-169">For any field where an explicit name is not provided, an applicable implicit name is projected.</span></span> <span data-ttu-id="c94e3-170">Não há nenhum requisito para fornecer nomes semânticos, explícita ou implicitamente.</span><span class="sxs-lookup"><span data-stu-id="c94e3-170">There is no requirement to provide semantic names, either explicitly or implicitly.</span></span> <span data-ttu-id="c94e3-171">O inicializador a seguir terá nomes de campo `Item1`, cujo valor é `42` e `stringContent`, cujo valor é "A resposta para tudo":</span><span class="sxs-lookup"><span data-stu-id="c94e3-171">The following initializer has     field names `Item1`, whose value is `42` and `stringContent`, whose value is "The answer to everything":</span></span>

[!code-csharp[MixedTuple](../../samples/snippets/csharp/tuples/tuples/program.cs#MixedTuple "mixed tuple")]

<span data-ttu-id="c94e3-172">Há duas condições nas quais os possíveis nomes de campos não são projetados no campo da tupla:</span><span class="sxs-lookup"><span data-stu-id="c94e3-172">There are two conditions where candidate field names are not projected onto the tuple field:</span></span>

1. <span data-ttu-id="c94e3-173">Quando o possível nome é um nome de tupla reservado.</span><span class="sxs-lookup"><span data-stu-id="c94e3-173">When the candidate name is a reserved tuple name.</span></span> <span data-ttu-id="c94e3-174">Os exemplos incluem `Item3`, `ToString`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-174">Examples include `Item3`, `ToString`.</span></span> <span data-ttu-id="c94e3-175">ou `Rest`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-175">or `Rest`.</span></span>
1. <span data-ttu-id="c94e3-176">Quando o possível nome é uma duplicata de outro nome de campo de tupla, seja explícito ou implícito.</span><span class="sxs-lookup"><span data-stu-id="c94e3-176">When the candidate name is a duplicate of another tuple field name, either explicit or implicit.</span></span>

<span data-ttu-id="c94e3-177">Essas condições evitam a ambiguidade.</span><span class="sxs-lookup"><span data-stu-id="c94e3-177">These conditions avoid ambiguity.</span></span> <span data-ttu-id="c94e3-178">Esses nomes causariam ambiguidade se fossem usados como nomes de campo em uma tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-178">These names would cause an ambiguity if they were used as the field names for a field in a tuple.</span></span> <span data-ttu-id="c94e3-179">Nenhuma dessas condições causa erros de tempo de compilação.</span><span class="sxs-lookup"><span data-stu-id="c94e3-179">Neither of these conditions cause compile-time errors.</span></span> <span data-ttu-id="c94e3-180">Em vez disso, os elementos sem nomes projetados não terão nomes semânticos projetados para eles.</span><span class="sxs-lookup"><span data-stu-id="c94e3-180">Instead, the elements without projected names do not have semantic names projected for them.</span></span>  <span data-ttu-id="c94e3-181">Os exemplos a seguir demonstram essas condições:</span><span class="sxs-lookup"><span data-stu-id="c94e3-181">The following examples demonstrate these conditions:</span></span>

[!code-csharp-interactive[Ambiguity](../../samples/snippets/csharp/tuples/tuples/program.cs#ProjectionAmbiguities "tuples where projections are not performed")]

<span data-ttu-id="c94e3-182">Essas situações não causam erros de compilador porque essa seria uma alteração significativa nos códigos escritos com C# 7.0, em que as projeções de nome de campo de tupla não estavam disponíveis.</span><span class="sxs-lookup"><span data-stu-id="c94e3-182">These situations do not cause compiler errors because that would be a breaking change for code written with C# 7.0, when tuple field name projections were not available.</span></span>

## <a name="equality-and-tuples"></a><span data-ttu-id="c94e3-183">Igualdade e tuplas</span><span class="sxs-lookup"><span data-stu-id="c94e3-183">Equality and tuples</span></span>

<span data-ttu-id="c94e3-184">Começando com o C# 7.3, os tipos de tupla oferecem suporte aos operadores `==` e `!=`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-184">Beginning with C# 7.3, tuple types support the `==` and `!=` operators.</span></span> <span data-ttu-id="c94e3-185">Esses operadores comparam cada membro do argumento da esquerda com cada membro do argumento da direita na ordem.</span><span class="sxs-lookup"><span data-stu-id="c94e3-185">These operators work by comparing each member of the left argument to each member of the right argument in order.</span></span> <span data-ttu-id="c94e3-186">Essas comparações são de curto-circuito.</span><span class="sxs-lookup"><span data-stu-id="c94e3-186">These comparisons short-circuit.</span></span> <span data-ttu-id="c94e3-187">Elas interromperão a avaliação de membros assim que um par não for igual.</span><span class="sxs-lookup"><span data-stu-id="c94e3-187">They will stop evaluating members as soon as one pair is not equal.</span></span> <span data-ttu-id="c94e3-188">O código a seguir exemplifica o uso de `==`, mas todas as regras de comparação se aplicam a `!=`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-188">The following code examples use `==`, but the comparison rules all apply to `!=`.</span></span> <span data-ttu-id="c94e3-189">O exemplo de código a seguir mostra uma comparação de igualdade de dois pares de inteiros:</span><span class="sxs-lookup"><span data-stu-id="c94e3-189">The following code example shows an equality comparison for two pairs of integers:</span></span>

[!code-csharp-interactive[TupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#Equality "Testing tuples for equality")]

<span data-ttu-id="c94e3-190">Há várias regras que tornam os testes de igualdade de tuplas mais convenientes.</span><span class="sxs-lookup"><span data-stu-id="c94e3-190">There are several rules that make tuple equality tests more convenient.</span></span> <span data-ttu-id="c94e3-191">A igualdade de tupla executa [conversões lifted](~/_csharplang/spec/conversions.md#lifted-conversion-operators) se uma das tuplas for uma tupla que permite valor nulo, conforme mostrado no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="c94e3-191">Tuple equality performs [lifted conversions](~/_csharplang/spec/conversions.md#lifted-conversion-operators) if one of the tuples is a nullable tuple, as shown in the following code:</span></span>

[!code-csharp-interactive[NullableTupleEquality](../../samples/snippets/csharp/tuples/tuples/program.cs#NullableEquality "Comparing Tuples and nullable tuples")]

<span data-ttu-id="c94e3-192">A igualdade de tupla também executa conversões implícitas em cada membro de ambas as tuplas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-192">Tuple equality also performs implicit conversions on each member of both tuples.</span></span> <span data-ttu-id="c94e3-193">Esses incluem conversões lifted, conversões widening ou outras conversões implícitas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-193">These include lifted conversions, widening conversions, or other implicit conversions.</span></span> <span data-ttu-id="c94e3-194">Os exemplos a seguir mostram que um inteiro de uma tupla 2 pode ser comparado a um longo de tupla 2 devido à conversão implícita do inteiro para um longo:</span><span class="sxs-lookup"><span data-stu-id="c94e3-194">The following examples show that an integer 2-tuple can be compared to a long 2-tuple because of the implicit conversion from integer to long:</span></span>

[!code-csharp-interactive[SnippetMemberConversions](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberConversions "converting tuples for equality tests")]

<span data-ttu-id="c94e3-195">Os nomes dos membros da tupla não participam em testes de igualdade.</span><span class="sxs-lookup"><span data-stu-id="c94e3-195">The names of the tuple members do not participate in tests for equality.</span></span> <span data-ttu-id="c94e3-196">No entanto, se um dos operandos for uma tupla literal com nomes explícitos, o compilador gera o aviso CS8383 caso os nomes não correspondam aos nomes do outro operando.</span><span class="sxs-lookup"><span data-stu-id="c94e3-196">However, if one of the operands is a tuple literal with explicit names, the compiler generates warning CS8383 if those names do not match the names of the other operand.</span></span>
<span data-ttu-id="c94e3-197">No caso em que ambos os operandos são literais de tupla, o aviso é no operando à direita, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="c94e3-197">In the case where both operands are tuple literals, the warning is on the right operand as shown in the following example:</span></span>

[!code-csharp-interactive[MemberNames](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetMemberNames "Tuple member names do not participate in equality tests")]

<span data-ttu-id="c94e3-198">Por fim, as tuplas podem conter tuplas aninhadas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-198">Finally, tuples may contain nested tuples.</span></span> <span data-ttu-id="c94e3-199">A igualdade de tupla compara a "forma" de cada operando por meio de tuplas aninhadas, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="c94e3-199">Tuple equality compares the "shape" of each operand through nested tuples as shown in the following example:</span></span>

[!code-csharp-interactive[NestedTuples](../../samples/snippets/csharp/tuples/tuples/program.cs#SnippetNestedTuples "Tuples may contain nested tuples that participate in tuple equality.")]

<span data-ttu-id="c94e3-200">É um erro de tempo de compilação comparar duas tuplas por igualdade (ou desigualdade) quando elas têm formas diferentes.</span><span class="sxs-lookup"><span data-stu-id="c94e3-200">It's a compile time error to compare two tuples for equality (or inequality) when they have different shapes.</span></span> <span data-ttu-id="c94e3-201">O compilador não tentará nenhuma desconstrução das tuplas aninhadas para compará-las.</span><span class="sxs-lookup"><span data-stu-id="c94e3-201">The compiler won' attempt any deconstruction of nested tuples in order to compare them.</span></span>

## <a name="assignment-and-tuples"></a><span data-ttu-id="c94e3-202">Atribuição e tuplas</span><span class="sxs-lookup"><span data-stu-id="c94e3-202">Assignment and tuples</span></span>

<span data-ttu-id="c94e3-203">A linguagem oferece suporte à atribuição entre tipos de tuplas que têm o mesmo número de elementos, em que cada elemento do lado direito pode ser convertido implicitamente em seu elemento correspondente do lado esquerdo.</span><span class="sxs-lookup"><span data-stu-id="c94e3-203">The language supports assignment between tuple types that have the same number of elements, where each right-hand side element can be implicitly converted to its corresponding left-hand side element.</span></span> <span data-ttu-id="c94e3-204">Outras conversões não são consideradas para atribuições.</span><span class="sxs-lookup"><span data-stu-id="c94e3-204">Other conversions aren't considered for assignments.</span></span> <span data-ttu-id="c94e3-205">É um erro de tempo de compilação atribuir uma tupla a outra quando elas têm formas diferentes.</span><span class="sxs-lookup"><span data-stu-id="c94e3-205">It's a compile time error to assign one tuple to another when they have different shapes.</span></span> <span data-ttu-id="c94e3-206">O compilador não tentará nenhuma desconstrução das tuplas aninhadas para atribuí-las.</span><span class="sxs-lookup"><span data-stu-id="c94e3-206">The compiler won't attempt any deconstruction of nested tuples in order to assign them.</span></span>
<span data-ttu-id="c94e3-207">Vamos examinar os tipos de atribuições que são permitidos entre tipos de tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-207">Let's look at the kinds of assignments that are allowed between tuple types.</span></span>

<span data-ttu-id="c94e3-208">Considere estas variáveis usadas nos exemplos a seguir:</span><span class="sxs-lookup"><span data-stu-id="c94e3-208">Consider these variables used in the following examples:</span></span>

[!code-csharp[VariableCreation](../../samples/snippets/csharp/tuples/tuples/program.cs#03_VariableCreation "Variable creation")]

<span data-ttu-id="c94e3-209">As primeiras duas variáveis, `unnamed` e `anonymous`, não têm nomes semânticos fornecidos para os elementos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-209">The first two variables, `unnamed` and `anonymous` do not have semantic names provided for the elements.</span></span> <span data-ttu-id="c94e3-210">Os nomes de campo são `Item1` e `Item2`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-210">The field names are `Item1` and `Item2`.</span></span>
<span data-ttu-id="c94e3-211">As duas últimas variáveis, `named` e `differentName`, têm nomes semânticos fornecidos para os elementos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-211">The last two variables, `named` and `differentName` have semantic names given for the elements.</span></span> <span data-ttu-id="c94e3-212">Estas duas tuplas têm nomes diferentes para os elementos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-212">These two tuples have different names for the elements.</span></span>

<span data-ttu-id="c94e3-213">Todas essas quatro tuplas têm o mesmo número de elementos (chamados de "cardinalidade") e os tipos desses elementos são idênticos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-213">All four of these tuples have the same number of elements (referred to as 'cardinality') and the types of those elements are identical.</span></span> <span data-ttu-id="c94e3-214">Portanto, todas essas atribuições funcionam:</span><span class="sxs-lookup"><span data-stu-id="c94e3-214">Therefore, all of these assignments work:</span></span>

[!code-csharp[VariableAssignment](../../samples/snippets/csharp/tuples/tuples/program.cs#04_VariableAssignment "Variable assignment")]

<span data-ttu-id="c94e3-215">Observe que os nomes das tuplas não são atribuídos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-215">Notice that the names of the tuples are not assigned.</span></span> <span data-ttu-id="c94e3-216">Os valores dos elementos são atribuídos na ordem dos elementos na tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-216">The values of the elements are assigned following the order of the elements in the tuple.</span></span>

<span data-ttu-id="c94e3-217">As tuplas com tipos ou números de elementos diferentes não são atribuíveis:</span><span class="sxs-lookup"><span data-stu-id="c94e3-217">Tuples of different types or numbers of elements are not assignable:</span></span>

```csharp
// Does not compile.
// CS0029: Cannot assign Tuple(int,int,int) to Tuple(int, string)
var differentShape = (1, 2, 3);
named = differentShape;
```

## <a name="tuples-as-method-return-values"></a><span data-ttu-id="c94e3-218">Tuplas como valores retornados do método</span><span class="sxs-lookup"><span data-stu-id="c94e3-218">Tuples as method return values</span></span>

<span data-ttu-id="c94e3-219">Um dos usos mais comuns de tuplas é como um valor retornado do método.</span><span class="sxs-lookup"><span data-stu-id="c94e3-219">One of the most common uses for tuples is as a method return value.</span></span> <span data-ttu-id="c94e3-220">Vamos examinar um exemplo.</span><span class="sxs-lookup"><span data-stu-id="c94e3-220">Let's walk through one example.</span></span> <span data-ttu-id="c94e3-221">Considere este método que calcula o desvio padrão para uma sequência de números:</span><span class="sxs-lookup"><span data-stu-id="c94e3-221">Consider this method that computes the standard deviation for a sequence of numbers:</span></span>

[!code-csharp[StandardDeviation](../../samples/snippets/csharp/tuples/tuples/statistics.cs#05_StandardDeviation "Compute Standard Deviation")]

> [!NOTE]
> <span data-ttu-id="c94e3-222">Esses exemplos calculam o desvio padrão de exemplo não corrigido.</span><span class="sxs-lookup"><span data-stu-id="c94e3-222">These examples compute the uncorrected sample standard deviation.</span></span>
> <span data-ttu-id="c94e3-223">A fórmula do desvio padrão de exemplo corrigida dividiria a soma das diferenças da média ao quadrado por (N-1) em vez de N, como o método de extensão `Average` faz.</span><span class="sxs-lookup"><span data-stu-id="c94e3-223">The corrected sample standard deviation formula would divide the sum of the squared differences from the mean by (N-1) instead of N, as the `Average` extension method does.</span></span> <span data-ttu-id="c94e3-224">Consulte um texto sobre estatísticas para obter mais detalhes sobre as diferenças entre essas fórmulas para desvio padrão.</span><span class="sxs-lookup"><span data-stu-id="c94e3-224">Consult a statistics text for more details on the differences between these formulas for standard deviation.</span></span>

<span data-ttu-id="c94e3-225">O código anterior segue a fórmula típica para o desvio padrão.</span><span class="sxs-lookup"><span data-stu-id="c94e3-225">The preceding code follows the textbook formula for the standard deviation.</span></span> <span data-ttu-id="c94e3-226">Ele produz a resposta correta, mas é uma implementação ineficiente.</span><span class="sxs-lookup"><span data-stu-id="c94e3-226">It produces the correct answer, but it's an inefficient implementation.</span></span> <span data-ttu-id="c94e3-227">Esse método enumera a sequência duas vezes: uma vez para produzir a média, e uma vez para produzir a média do quadrado da diferença da média.</span><span class="sxs-lookup"><span data-stu-id="c94e3-227">This method enumerates the sequence twice: Once to produce the average, and once to produce the average of the square of the difference of the average.</span></span>
<span data-ttu-id="c94e3-228">(Lembre-se de que consultas LINQ são avaliadas lentamente, então o cálculo das diferenças da média e a média dessas diferenças compõem apenas uma enumeração.)</span><span class="sxs-lookup"><span data-stu-id="c94e3-228">(Remember that LINQ queries are evaluated lazily, so the computation of the differences from the mean and the average of those differences makes only one enumeration.)</span></span>

<span data-ttu-id="c94e3-229">Há uma alternativa fórmula que calcula o desvio padrão usando apenas uma enumeração da sequência.</span><span class="sxs-lookup"><span data-stu-id="c94e3-229">There is an alternative formula that computes standard deviation using only one enumeration of the sequence.</span></span>  <span data-ttu-id="c94e3-230">Esse cálculo produz dois valores conforme enumera a sequência: a soma de todos os itens na sequência e a soma de cada valor ao quadrado:</span><span class="sxs-lookup"><span data-stu-id="c94e3-230">This computation produces two values as it enumerates the sequence: the sum of all items in the sequence, and the sum of the each value squared:</span></span>

[!code-csharp[SumOfSquaresFormula](../../samples/snippets/csharp/tuples/tuples/statistics.cs#06_SumOfSquaresFormula "Compute Standard Deviation using the sum of squares")]

<span data-ttu-id="c94e3-231">Essa versão enumera a sequência exatamente uma vez.</span><span class="sxs-lookup"><span data-stu-id="c94e3-231">This version enumerates the sequence exactly once.</span></span> <span data-ttu-id="c94e3-232">Mas não é um código reutilizável.</span><span class="sxs-lookup"><span data-stu-id="c94e3-232">But it's not reusable code.</span></span> <span data-ttu-id="c94e3-233">Conforme você continua a trabalhar, descobrirá que muitos cálculos estatísticos diferentes usam o número de itens na sequência, a soma da sequência e a soma dos quadrados da sequência.</span><span class="sxs-lookup"><span data-stu-id="c94e3-233">As you keep working, you'll find that many different statistical computations use the number of items in the sequence, the sum of the sequence, and the sum of the squares of the sequence.</span></span> <span data-ttu-id="c94e3-234">Vamos refatorar esse método e escrever um método utilitário que produz todos esses três valores.</span><span class="sxs-lookup"><span data-stu-id="c94e3-234">Let's refactor this method and write a utility method that produces all three of those values.</span></span> <span data-ttu-id="c94e3-235">Todos os três valores podem retornar como uma tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-235">All three values can be returned as a tuple.</span></span>

<span data-ttu-id="c94e3-236">Vamos atualizar esse método para que os três valores calculados durante a enumeração sejam armazenados em uma tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-236">Let's update this method so the three values computed during the enumeration are stored in a tuple.</span></span> <span data-ttu-id="c94e3-237">Isso cria essa versão:</span><span class="sxs-lookup"><span data-stu-id="c94e3-237">That creates this version:</span></span>

[!code-csharp[TupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#07_TupleVersion "Refactor to use tuples")]

<span data-ttu-id="c94e3-238">O suporte à refatoração do Visual Studio facilita a extração da funcionalidade para as estatísticas principais em um método privado.</span><span class="sxs-lookup"><span data-stu-id="c94e3-238">Visual Studio's Refactoring support makes it easy to extract the functionality for the core statistics into a private method.</span></span> <span data-ttu-id="c94e3-239">Isso fornece a você um método `private static` que retorna o tipo de tupla com os três valores de `Sum`, `SumOfSquares` e `Count`:</span><span class="sxs-lookup"><span data-stu-id="c94e3-239">That gives you a `private static` method that returns the tuple type with the three values of `Sum`, `SumOfSquares`, and `Count`:</span></span>

[!code-csharp[TupleMethodVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#08_TupleMethodVersion "After extracting utility method")]
 
<span data-ttu-id="c94e3-240">A linguagem permite algumas opções adicionais que podem ser usadas se você desejar fazer algumas edições rápidas manualmente.</span><span class="sxs-lookup"><span data-stu-id="c94e3-240">The language enables a couple more options that you can use, if you want to make a few quick edits by hand.</span></span> <span data-ttu-id="c94e3-241">Primeiro, você pode usar a declaração `var` para inicializar o resultado da tupla da chamada do método `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-241">First, you can use the `var` declaration to initialize the tuple result from the `ComputeSumAndSumOfSquares` method call.</span></span> <span data-ttu-id="c94e3-242">Você também pode criar três variáveis discretas dentro do método `ComputeSumAndSumOfSquares`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-242">You can also create three discrete variables inside the `ComputeSumAndSumOfSquares` method.</span></span> <span data-ttu-id="c94e3-243">A versão final é mostrada no código a seguir:</span><span class="sxs-lookup"><span data-stu-id="c94e3-243">The final version is shown in the following code:</span></span>

[!code-csharp[CleanedTupleVersion](../../samples/snippets/csharp/tuples/tuples/statistics.cs#09_CleanedTupleVersion "After final cleanup")]

<span data-ttu-id="c94e3-244">Esta versão final pode ser usada para qualquer método que precise desses três valores ou qualquer subconjunto deles.</span><span class="sxs-lookup"><span data-stu-id="c94e3-244">This final version can be used for any method that needs those three values, or any subset of them.</span></span>

<span data-ttu-id="c94e3-245">A linguagem dá suporte a outras opções no gerenciamento dos nomes dos elementos nesses métodos de retorno de tupla.</span><span class="sxs-lookup"><span data-stu-id="c94e3-245">The language supports other options in managing the names of the elements in these tuple-returning methods.</span></span>

<span data-ttu-id="c94e3-246">Você pode remover os nomes de campo da declaração de valor retornado e retornar uma tupla sem nome:</span><span class="sxs-lookup"><span data-stu-id="c94e3-246">You can remove the field names from the return value declaration and return an unnamed tuple:</span></span>

```csharp
private static (double, double, int) ComputeSumAndSumOfSquares(IEnumerable<double> sequence)
{
    double sum = 0;
    double sumOfSquares = 0;
    int count = 0;

    foreach (var item in sequence)
    {
        count++;
        sum += item;
        sumOfSquares += item * item;
    }

    return (sum, sumOfSquares, count);
}
```

<span data-ttu-id="c94e3-247">Os campos nesta tupla são nomeados `Item1`, `Item2` e `Item3`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-247">The fields of this tuple are named `Item1`, `Item2`, and `Item3`.</span></span>
<span data-ttu-id="c94e3-248">É recomendável que você forneça nomes semânticos para os elementos de tuplas retornados dos métodos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-248">It's recommended that you provide semantic names to the elements of tuples returned from methods.</span></span>

<span data-ttu-id="c94e3-249">Outra linguagem em que as tuplas podem ser úteis é quando você estiver criando consultas LINQ.</span><span class="sxs-lookup"><span data-stu-id="c94e3-249">Another idiom where tuples can be useful is when you are authoring LINQ queries.</span></span> <span data-ttu-id="c94e3-250">O resultado final projetado geralmente contém algumas, mas não todas, propriedades dos objetos que estão sendo selecionados.</span><span class="sxs-lookup"><span data-stu-id="c94e3-250">The final projected result often contains some, but not all, of the properties of the objects being selected.</span></span>

<span data-ttu-id="c94e3-251">Tradicionalmente, você poderia projetar os resultados da consulta em uma sequência de objetos que eram um tipo anônimo.</span><span class="sxs-lookup"><span data-stu-id="c94e3-251">You would traditionally project the results of the query into a sequence of objects that were an anonymous type.</span></span> <span data-ttu-id="c94e3-252">Isso apresentava muitas limitações, principalmente porque os tipos anônimos não poderiam ser nomeados de forma conveniente no tipo de retorno de um método.</span><span class="sxs-lookup"><span data-stu-id="c94e3-252">That presented many limitations, primarily because anonymous types could not conveniently be named in the return type for a method.</span></span> <span data-ttu-id="c94e3-253">Alternativas usando `object` ou `dynamic` como o tipo de resultado acompanham os custos de desempenho significativos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-253">Alternatives using `object` or `dynamic` as the type of the result came with significant performance costs.</span></span>

<span data-ttu-id="c94e3-254">Retornar uma sequência de um tipo de tupla é fácil e os nomes e tipos desses elementos estão disponíveis no tempo de compilação e por meio de ferramentas de IDE.</span><span class="sxs-lookup"><span data-stu-id="c94e3-254">Returning a sequence of a tuple type is easy, and the names and types of the elements are available at compile time and through IDE tools.</span></span>
<span data-ttu-id="c94e3-255">Por exemplo, imagine um aplicativo de tarefas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-255">For example, consider a ToDo application.</span></span> <span data-ttu-id="c94e3-256">Você pode definir uma classe semelhante à seguinte para representar uma única entrada na lista de tarefas:</span><span class="sxs-lookup"><span data-stu-id="c94e3-256">You might define a class similar to the following to represent a single entry in the ToDo list:</span></span>

[!code-csharp[ToDoItem](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#14_ToDoItem "To Do Item")]

<span data-ttu-id="c94e3-257">Seus aplicativos móveis podem dar suporte a um formato compacto dos itens de tarefas atuais que exibem apenas o título.</span><span class="sxs-lookup"><span data-stu-id="c94e3-257">Your mobile applications may support a compact form of the current ToDo items that only displays the title.</span></span> <span data-ttu-id="c94e3-258">Essa consulta LINQ faria uma projeção que inclui somente a ID e o título.</span><span class="sxs-lookup"><span data-stu-id="c94e3-258">That LINQ query would make a projection that includes only the ID and the title.</span></span> <span data-ttu-id="c94e3-259">Um método que retorna uma sequência de tuplas expressa bem esse design:</span><span class="sxs-lookup"><span data-stu-id="c94e3-259">A method that returns a sequence of tuples expresses that design well:</span></span>

[!code-csharp[QueryReturningTuple](../../samples/snippets/csharp/tuples/tuples/projectionsample.cs#15_QueryReturningTuple "Query returning a tuple")]

> [!NOTE]
> <span data-ttu-id="c94e3-260">No C# 7.1, as projeções de tupla permitem criar tuplas nomeadas usando elementos, de maneira semelhante à nomeação de propriedade nos tipos anônimos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-260">In C# 7.1, tuple projections enable you to create named tuples using elements, in a manner similar to the property naming in anonymous types.</span></span> <span data-ttu-id="c94e3-261">No código acima, a instrução `select` na projeção de consulta cria uma tupla que tem elementos `ID` e `Title`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-261">In the above code, the `select` statement in the query projection creates a tuple that has elements `ID` and `Title`.</span></span>

<span data-ttu-id="c94e3-262">A tupla nomeada pode ser parte da assinatura.</span><span class="sxs-lookup"><span data-stu-id="c94e3-262">The named tuple can be part of the signature.</span></span> <span data-ttu-id="c94e3-263">Ela permite que o compilador e as ferramentas de IDE forneçam verificações estáticas de que você está usando o resultado corretamente.</span><span class="sxs-lookup"><span data-stu-id="c94e3-263">It lets the compiler and IDE tools provide static checking that you are using the result correctly.</span></span> <span data-ttu-id="c94e3-264">A tupla nomeada também contém as informações de tipo estático, portanto, não há necessidade de usar recursos caros de tempo de execução como reflexão ou associação dinâmica para trabalhar com os resultados.</span><span class="sxs-lookup"><span data-stu-id="c94e3-264">The named tuple also carries the static type information so there is no need to use expensive run time features like reflection or dynamic binding to work with the results.</span></span>

## <a name="deconstruction"></a><span data-ttu-id="c94e3-265">Desconstrução</span><span class="sxs-lookup"><span data-stu-id="c94e3-265">Deconstruction</span></span>

<span data-ttu-id="c94e3-266">Você pode descompactar todos os itens em uma tupla *desconstruindo* a tupla retornada por um método.</span><span class="sxs-lookup"><span data-stu-id="c94e3-266">You can unpackage all the items in a tuple by *deconstructing* the tuple returned by a method.</span></span> <span data-ttu-id="c94e3-267">Há três abordagens diferentes para desconstruir tuplas.</span><span class="sxs-lookup"><span data-stu-id="c94e3-267">There are three different approaches to deconstructing tuples.</span></span>  <span data-ttu-id="c94e3-268">Primeiro, você pode declarar explicitamente o tipo de cada campo dentro de parênteses para criar variáveis discretas para cada um dos elementos na tupla:</span><span class="sxs-lookup"><span data-stu-id="c94e3-268">First, you can explicitly declare the type of each field inside parentheses to create discrete variables for each of the elements in the tuple:</span></span>

[!code-csharp[Deconstruct](../../samples/snippets/csharp/tuples/tuples/statistics.cs#10_Deconstruct "Deconstruct")]

<span data-ttu-id="c94e3-269">Você também pode declarar variáveis de tipo implícito para cada campo em uma tupla usando a palavra-chave `var` fora dos parênteses:</span><span class="sxs-lookup"><span data-stu-id="c94e3-269">You can also declare implicitly typed variables for each field in a tuple by using the `var` keyword outside the parentheses:</span></span>

[!code-csharp[DeconstructToVar](../../samples/snippets/csharp/tuples/tuples/statistics.cs#11_DeconstructToVar "Deconstruct to Var")]

<span data-ttu-id="c94e3-270">Também é válido usar a palavra-chave `var` com qualquer uma ou todas as declarações de variável dentro dos parênteses.</span><span class="sxs-lookup"><span data-stu-id="c94e3-270">It is also legal to use the `var` keyword with any, or all of the variable declarations inside the parentheses.</span></span> 

```csharp
(double sum, var sumOfSquares, var count) = ComputeSumAndSumOfSquares(sequence);
```

<span data-ttu-id="c94e3-271">Você não poderá usar um tipo específico fora dos parênteses, mesmo se todos os campos na tupla tiverem o mesmo tipo.</span><span class="sxs-lookup"><span data-stu-id="c94e3-271">You cannot use a specific type outside the parentheses, even if every field in the tuple has the same type.</span></span>

<span data-ttu-id="c94e3-272">Você também pode desconstruir tuplas com declarações existentes:</span><span class="sxs-lookup"><span data-stu-id="c94e3-272">You can deconstruct tuples with existing declarations as well:</span></span>

```csharp
public class Point
{
    public int X { get; set; }
    public int Y { get; set; }

    public Point(int x, int y) => (X, Y) = (x, y);
}
```

> [!WARNING]
>  <span data-ttu-id="c94e3-273">Você não pode combinar as declarações existentes com as declarações dentro dos parênteses.</span><span class="sxs-lookup"><span data-stu-id="c94e3-273">You cannot mix existing declarations with declarations inside the parentheses.</span></span> <span data-ttu-id="c94e3-274">Por exemplo, o seguinte não é permitido: `(var x, y) = MyMethod();`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-274">For instance, the following is not allowed: `(var x, y) = MyMethod();`.</span></span> <span data-ttu-id="c94e3-275">Isso gera o erro CS8184 porque *x* está declarado dentro dos parênteses e *y* já foi declarado em outro lugar.</span><span class="sxs-lookup"><span data-stu-id="c94e3-275">This produces error CS8184 because *x* is declared inside the parentheses and *y* is previously declared elsewhere.</span></span>

### <a name="deconstructing-user-defined-types"></a><span data-ttu-id="c94e3-276">Desconstruindo tipos definidos pelo usuário</span><span class="sxs-lookup"><span data-stu-id="c94e3-276">Deconstructing user-defined types</span></span>

<span data-ttu-id="c94e3-277">Qualquer tipo de tupla pode ser desconstruído, conforme mostrado acima.</span><span class="sxs-lookup"><span data-stu-id="c94e3-277">Any tuple type can be deconstructed as shown above.</span></span> <span data-ttu-id="c94e3-278">Também é fácil habilitar a desconstrução em qualquer tipo definido pelo usuário (classes, structs ou até mesmo interfaces).</span><span class="sxs-lookup"><span data-stu-id="c94e3-278">It's also easy to enable deconstruction on any user-defined type (classes, structs, or even interfaces).</span></span>

<span data-ttu-id="c94e3-279">O autor do tipo pode definir um ou mais métodos `Deconstruct` que atribuem valores a qualquer número de variáveis `out` que representam os elementos de dados que compõem o tipo.</span><span class="sxs-lookup"><span data-stu-id="c94e3-279">The type author can define one or more `Deconstruct` methods that assign values to any number of `out` variables representing the data elements that make up the type.</span></span> <span data-ttu-id="c94e3-280">Por exemplo, o tipo `Person` a seguir define um método `Deconstruct` que desconstrói um objeto person nos elementos representando o nome e o sobrenome:</span><span class="sxs-lookup"><span data-stu-id="c94e3-280">For example, the following `Person` type defines a `Deconstruct` method that deconstructs a person object into the elements representing the first name and last name:</span></span>

[!code-csharp[TypeWithDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#12_TypeWithDeconstructMethod "Type with a deconstruct method")]

<span data-ttu-id="c94e3-281">O método deconstruct permite a atribuição de um `Person` para duas cadeias de caracteres, representando as propriedades `FirstName` e `LastName`:</span><span class="sxs-lookup"><span data-stu-id="c94e3-281">The deconstruct method enables assignment from a `Person` to two strings, representing the `FirstName` and `LastName` properties:</span></span>

[!code-csharp[Deconstruct Type](../../samples/snippets/csharp/tuples/tuples/program.cs#12A_DeconstructType "Deconstruct a class type")]

<span data-ttu-id="c94e3-282">Você pode habilitar a desconstrução mesmo para os tipos que você não criou.</span><span class="sxs-lookup"><span data-stu-id="c94e3-282">You can enable deconstruction even for types you did not author.</span></span>
<span data-ttu-id="c94e3-283">O método `Deconstruct` pode ser um método de extensão que retira do pacote os membros de dados acessíveis de um objeto.</span><span class="sxs-lookup"><span data-stu-id="c94e3-283">The `Deconstruct` method can be an extension method that unpackages the accessible data members of an object.</span></span> <span data-ttu-id="c94e3-284">O exemplo a seguir mostra um tipo `Student`, derivado do tipo `Person` e um método de extensão que desconstrói um `Student` em três variáveis, representando a `FirstName`, a `LastName` e a `GPA`:</span><span class="sxs-lookup"><span data-stu-id="c94e3-284">The example below shows a `Student` type, derived from the `Person` type, and an extension method that deconstructs a `Student` into three variables, representing the `FirstName`, the `LastName`, and the `GPA`:</span></span>

[!code-csharp[ExtensionDeconstructMethod](../../samples/snippets/csharp/tuples/tuples/person.cs#13_ExtensionDeconstructMethod "Type with a deconstruct extension method")]

<span data-ttu-id="c94e3-285">Um objeto `Student` agora tem dois métodos `Deconstruct` acessíveis: o método de extensão declarado para tipos `Student` e o membro do tipo `Person`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-285">A `Student` object now has two accessible `Deconstruct` methods: the extension method declared for `Student` types, and the member of the `Person` type.</span></span> <span data-ttu-id="c94e3-286">Ambos estão no escopo e isso permite que um `Student` seja desconstruído em duas ou três variáveis.</span><span class="sxs-lookup"><span data-stu-id="c94e3-286">Both are in scope, and that enables a `Student` to be deconstructed into either two variables or three.</span></span>
<span data-ttu-id="c94e3-287">Se você atribuir um aluno a três variáveis, o nome, o sobrenome e a GPA serão retornados.</span><span class="sxs-lookup"><span data-stu-id="c94e3-287">If you assign a student to three variables, the first name, last name, and GPA are all returned.</span></span> <span data-ttu-id="c94e3-288">Se você atribuir um aluno a duas variáveis, apenas o nome e o sobrenome serão retornados.</span><span class="sxs-lookup"><span data-stu-id="c94e3-288">If you assign a student to two variables, only the first name and the last name are returned.</span></span>

[!code-csharp[Deconstruct extension method](../../samples/snippets/csharp/tuples/tuples/program.cs#13A_DeconstructExtension "Deconstruct a class type using an extension method")]

<span data-ttu-id="c94e3-289">Você deve tomar cuidado ao definir vários métodos `Deconstruct` em uma classe ou hierarquia de classes.</span><span class="sxs-lookup"><span data-stu-id="c94e3-289">You should be careful defining multiple `Deconstruct` methods in a class or a class hierarchy.</span></span> <span data-ttu-id="c94e3-290">Vários métodos `Deconstruct` que têm o mesmo número de parâmetros `out` podem causar ambiguidades rapidamente.</span><span class="sxs-lookup"><span data-stu-id="c94e3-290">Multiple `Deconstruct` methods that have the same number of `out` parameters can quickly cause ambiguities.</span></span> <span data-ttu-id="c94e3-291">Os chamadores podem não conseguir chamar facilmente o método `Deconstruct` desejado.</span><span class="sxs-lookup"><span data-stu-id="c94e3-291">Callers may not be able to easily call the desired `Deconstruct` method.</span></span>

<span data-ttu-id="c94e3-292">Neste exemplo, há uma chance mínima de uma chamada ambígua porque o método `Deconstruct` para `Person` tem dois parâmetros de saída e o método `Deconstruct` para `Student` tem três.</span><span class="sxs-lookup"><span data-stu-id="c94e3-292">In this example, there is minimal chance for an ambiguous call because the `Deconstruct` method for `Person` has two output parameters, and the `Deconstruct` method for `Student` has three.</span></span>

<span data-ttu-id="c94e3-293">Os operadores de desconstrução não participam do teste de igualdade.</span><span class="sxs-lookup"><span data-stu-id="c94e3-293">Deconstruction operators do not participate in testing equality.</span></span> <span data-ttu-id="c94e3-294">O exemplo a seguir gera o erro do compilador CS0019:</span><span class="sxs-lookup"><span data-stu-id="c94e3-294">The following example generates compiler error CS0019:</span></span>

```csharp
Person p = new Person("Althea", "Goodwin");
if (("Althea", "Goodwin") == p)
    Console.WriteLine(p);
```

<span data-ttu-id="c94e3-295">O método `Deconstruct` pôde converter o objeto`Person` `p` em uma tupla que contém duas cadeias de caracteres, mas não é aplicável no contexto de testes de igualdade.</span><span class="sxs-lookup"><span data-stu-id="c94e3-295">The `Deconstruct` method could convert the `Person` object `p` to a tuple containing two strings, but it is not applicable in the context of equality tests.</span></span>

## <a name="conclusion"></a><span data-ttu-id="c94e3-296">Conclusão</span><span class="sxs-lookup"><span data-stu-id="c94e3-296">Conclusion</span></span> 

<span data-ttu-id="c94e3-297">O novo suporte de linguagem e biblioteca para tuplas nomeadas torna muito mais fácil trabalhar com designs que usam estruturas de dados que armazenam vários elementos, mas não definem comportamento, como as classes e os structs fazem.</span><span class="sxs-lookup"><span data-stu-id="c94e3-297">The new language and library support for named tuples makes it much easier to work with designs that use data structures that store multiple elements but do not define behavior, as classes and structs do.</span></span> <span data-ttu-id="c94e3-298">É fácil e sucinto usar tuplas para esses tipos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-298">It's easy and concise to use tuples for those types.</span></span> <span data-ttu-id="c94e3-299">Você obtém todos os benefícios da verificação de tipo estático, sem precisar criar tipos usando a sintaxe de `class` ou de `struct` mais detalhada.</span><span class="sxs-lookup"><span data-stu-id="c94e3-299">You get all the benefits of static type checking, without needing to author types using the more verbose `class` or `struct` syntax.</span></span> <span data-ttu-id="c94e3-300">Mesmo assim, elas são mais úteis para métodos utilitários que são `private` ou `internal`.</span><span class="sxs-lookup"><span data-stu-id="c94e3-300">Even so, they are most useful for utility methods that are `private`, or `internal`.</span></span> <span data-ttu-id="c94e3-301">Cria tipos definidos pelo usuário, tipos `class` ou `struct`, quando seus métodos públicos retornam um valor que tem vários elementos.</span><span class="sxs-lookup"><span data-stu-id="c94e3-301">Create user-defined types, either `class` or `struct` types when your public methods return a value that has multiple elements.</span></span>
