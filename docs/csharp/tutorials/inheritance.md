---
title: Herança em C#
description: Aprenda a usar a herança em bibliotecas e aplicativos em C#.
author: rpetrusha
ms.author: ronpet
ms.date: 07/05/2018
ms.assetid: aeb68c74-0ea0-406f-9fbe-2ce02d47ef31
ms.openlocfilehash: 41377cb47836624160a5b402e0a85270b68eba4f
ms.sourcegitcommit: 205b9a204742e9c77256d43ac9d94c3f82909808
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/10/2019
ms.locfileid: "70850994"
---
# <a name="inheritance-in-c-and-net"></a><span data-ttu-id="f192c-103">Herança em C# e .NET</span><span class="sxs-lookup"><span data-stu-id="f192c-103">Inheritance in C# and .NET</span></span>

<span data-ttu-id="f192c-104">Este tutorial apresenta a herança em C#.</span><span class="sxs-lookup"><span data-stu-id="f192c-104">This tutorial introduces you to inheritance in C#.</span></span> <span data-ttu-id="f192c-105">Herança é um recurso das linguagens de programação orientadas a objeto que permite a definição de uma classe base que, por sua vez, fornece uma funcionalidade específica (dados e comportamento), e a definição de classes derivadas que herdam ou substituem essa funcionalidade.</span><span class="sxs-lookup"><span data-stu-id="f192c-105">Inheritance is a feature of object-oriented programming languages that allows you to define a base class that provides specific functionality (data and behavior) and to define derived classes that either inherit or override that functionality.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="f192c-106">Pré-requisitos</span><span class="sxs-lookup"><span data-stu-id="f192c-106">Prerequisites</span></span>

<span data-ttu-id="f192c-107">Este tutorial pressupõe que você instalou o SDK do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="f192c-107">This tutorial assumes that you've installed the .NET Core SDK.</span></span> <span data-ttu-id="f192c-108">Visite a página de [downloads do .NET Core](https://dotnet.microsoft.com/download) para baixá-lo.</span><span class="sxs-lookup"><span data-stu-id="f192c-108">Visit the [.NET Core Downloads](https://dotnet.microsoft.com/download) page to download it.</span></span> <span data-ttu-id="f192c-109">Você também precisa de um editor de código.</span><span class="sxs-lookup"><span data-stu-id="f192c-109">You also need a code editor.</span></span> <span data-ttu-id="f192c-110">Este tutorial usa o [Visual Studio Code](https://code.visualstudio.com), embora você possa usar qualquer editor de código que quiser.</span><span class="sxs-lookup"><span data-stu-id="f192c-110">This tutorial uses [Visual Studio Code](https://code.visualstudio.com), although you can use any code editor of your choice.</span></span>

## <a name="running-the-examples"></a><span data-ttu-id="f192c-111">Como executar os exemplos</span><span class="sxs-lookup"><span data-stu-id="f192c-111">Running the examples</span></span>

<span data-ttu-id="f192c-112">Para criar e executar os exemplos neste tutorial, use o utilitário [dotnet](../../core/tools/dotnet.md) na linha de comando.</span><span class="sxs-lookup"><span data-stu-id="f192c-112">To create and run the examples in this tutorial, you use the [dotnet](../../core/tools/dotnet.md) utility from the command line.</span></span> <span data-ttu-id="f192c-113">Execute estas etapas para cada exemplo:</span><span class="sxs-lookup"><span data-stu-id="f192c-113">Follow these steps for each example:</span></span>

1. <span data-ttu-id="f192c-114">Crie um diretório para armazenar o exemplo.</span><span class="sxs-lookup"><span data-stu-id="f192c-114">Create a directory to store the example.</span></span>
1. <span data-ttu-id="f192c-115">Insira o comando [dotnet new console](../../core/tools/dotnet-new.md) no prompt de comando para criar um novo projeto do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="f192c-115">Enter the [dotnet new console](../../core/tools/dotnet-new.md) command at a command prompt to create a new .NET Core project.</span></span>
1. <span data-ttu-id="f192c-116">Copie e cole o código do exemplo em seu editor de código.</span><span class="sxs-lookup"><span data-stu-id="f192c-116">Copy and paste the code from the example into your code editor.</span></span>
1. <span data-ttu-id="f192c-117">Insira o comando [dotnet restore](../../core/tools/dotnet-restore.md) na linha de comando para carregar ou restaurar as dependências do projeto.</span><span class="sxs-lookup"><span data-stu-id="f192c-117">Enter the [dotnet restore](../../core/tools/dotnet-restore.md) command from the command line to load or restore the project's dependencies.</span></span>

  [!INCLUDE[DotNet Restore Note](~/includes/dotnet-restore-note.md)]

1. <span data-ttu-id="f192c-118">Insira o comando [dotnet run](../../core/tools/dotnet-run.md) para compilar e executar o exemplo.</span><span class="sxs-lookup"><span data-stu-id="f192c-118">Enter the [dotnet run](../../core/tools/dotnet-run.md) command to compile and execute the example.</span></span>

## <a name="background-what-is-inheritance"></a><span data-ttu-id="f192c-119">Segundo plano: O que é a herança?</span><span class="sxs-lookup"><span data-stu-id="f192c-119">Background: What is inheritance?</span></span>

<span data-ttu-id="f192c-120">*Herança* é um dos atributos fundamentais da programação orientada a objeto.</span><span class="sxs-lookup"><span data-stu-id="f192c-120">*Inheritance* is one of the fundamental attributes of object-oriented programming.</span></span> <span data-ttu-id="f192c-121">Ela permite que você defina uma classe filha que reutiliza (herda), estende ou modifica o comportamento de uma classe pai.</span><span class="sxs-lookup"><span data-stu-id="f192c-121">It allows you to define a child class that reuses (inherits), extends, or modifies the behavior of a parent class.</span></span> <span data-ttu-id="f192c-122">A classe cujos membros são herdados é chamada de *classe base*.</span><span class="sxs-lookup"><span data-stu-id="f192c-122">The class whose members are inherited is called the *base class*.</span></span> <span data-ttu-id="f192c-123">A classe que herda os membros da classe base é chamada de *classe derivada*.</span><span class="sxs-lookup"><span data-stu-id="f192c-123">The class that inherits the members of the base class is called the *derived class*.</span></span>

<span data-ttu-id="f192c-124">C# e .NET oferecem suporte apenas à *herança única*.</span><span class="sxs-lookup"><span data-stu-id="f192c-124">C# and .NET support *single inheritance* only.</span></span> <span data-ttu-id="f192c-125">Ou seja, uma classe pode herdar apenas de uma única classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-125">That is, a class can only inherit from a single class.</span></span> <span data-ttu-id="f192c-126">No entanto, a herança é transitiva, o que permite que você defina uma hierarquia de herança para um conjunto de tipos.</span><span class="sxs-lookup"><span data-stu-id="f192c-126">However, inheritance is transitive, which allows you to define an inheritance hierarchy for a set of types.</span></span> <span data-ttu-id="f192c-127">Em outras palavras, o tipo `D` pode herdar do tipo `C`, que herda do tipo `B`, que herda do tipo de classe base `A`.</span><span class="sxs-lookup"><span data-stu-id="f192c-127">In other words, type `D` can inherit from type `C`, which inherits from type `B`, which inherits from the base class type `A`.</span></span> <span data-ttu-id="f192c-128">Como a herança é transitiva, os membros do tipo `A` estão disponíveis ao tipo `D`.</span><span class="sxs-lookup"><span data-stu-id="f192c-128">Because inheritance is transitive, the members of type `A` are available to type `D`.</span></span>

<span data-ttu-id="f192c-129">Nem todos os membros de uma classe base são herdados por classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f192c-129">Not all members of a base class are inherited by derived classes.</span></span> <span data-ttu-id="f192c-130">Os membros a seguir não são herdados:</span><span class="sxs-lookup"><span data-stu-id="f192c-130">The following members are not inherited:</span></span>

- <span data-ttu-id="f192c-131">[Construtores estáticos](../programming-guide/classes-and-structs/static-constructors.md), que inicializam os dados estáticos de uma classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-131">[Static constructors](../programming-guide/classes-and-structs/static-constructors.md), which initialize the static data of a class.</span></span>

- <span data-ttu-id="f192c-132">[Construtores de instância](../programming-guide/classes-and-structs/constructors.md), que você chama para criar uma nova instância da classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-132">[Instance constructors](../programming-guide/classes-and-structs/constructors.md), which you call to create a new instance of the class.</span></span> <span data-ttu-id="f192c-133">Cada classe deve definir seus próprios construtores.</span><span class="sxs-lookup"><span data-stu-id="f192c-133">Each class must define its own constructors.</span></span>

- <span data-ttu-id="f192c-134">[Finalizadores](../programming-guide/classes-and-structs/destructors.md), que são chamados pelo coletor de lixo do tempo de execução para destruir as instâncias de uma classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-134">[Finalizers](../programming-guide/classes-and-structs/destructors.md), which are called by the runtime's garbage collector to destroy instances of a class.</span></span>

<span data-ttu-id="f192c-135">Enquanto todos os outros membros de uma classe base são herdados por classes derivadas, o fato de serem visíveis ou não depende de sua acessibilidade.</span><span class="sxs-lookup"><span data-stu-id="f192c-135">While all other members of a base class are inherited by derived classes, whether they are visible or not depends on their accessibility.</span></span> <span data-ttu-id="f192c-136">A acessibilidade de um membro afeta sua visibilidade para classes derivadas da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="f192c-136">A member's accessibility affects its visibility for derived classes as follows:</span></span>

- <span data-ttu-id="f192c-137">Membros [Privados](../language-reference/keywords/private.md) são visíveis apenas em classes derivadas que estão aninhadas em sua classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-137">[Private](../language-reference/keywords/private.md) members are visible only in derived classes that are nested in their base class.</span></span> <span data-ttu-id="f192c-138">Caso contrário, eles não são visíveis em classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f192c-138">Otherwise, they are not visible in derived classes.</span></span> <span data-ttu-id="f192c-139">No exemplo a seguir, `A.B` é uma classe aninhada derivada de `A`, e `C` deriva de `A`.</span><span class="sxs-lookup"><span data-stu-id="f192c-139">In the following example, `A.B` is a nested class that derives from `A`, and `C` derives from `A`.</span></span> <span data-ttu-id="f192c-140">O campo `A.value` privado fica visível em A.B.</span><span class="sxs-lookup"><span data-stu-id="f192c-140">The private `A.value` field is visible in A.B.</span></span> <span data-ttu-id="f192c-141">No entanto, se você remover os comentários do método `C.GetValue` e tentar compilar o exemplo, ele produzirá um erro do compilador CS0122: "'A.value' está inacessível devido ao seu nível de proteção".</span><span class="sxs-lookup"><span data-stu-id="f192c-141">However, if you remove the comments from the `C.GetValue` method and attempt to compile the example, it produces compiler error CS0122: "'A.value' is inaccessible due to its protection level."</span></span>

  [!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/private.cs#1)]

- <span data-ttu-id="f192c-142">Membros [Protegidos](../language-reference/keywords/protected.md) são visíveis apenas em classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f192c-142">[Protected](../language-reference/keywords/protected.md) members are visible only in derived classes.</span></span>

- <span data-ttu-id="f192c-143">Membros [Internos](../language-reference/keywords/internal.md) são visíveis apenas em classes derivadas localizadas no mesmo assembly que a classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-143">[Internal](../language-reference/keywords/internal.md) members are visible only in derived classes that are located in the same assembly as the base class.</span></span> <span data-ttu-id="f192c-144">Eles não são visíveis em classes derivadas localizadas em um assembly diferente da classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-144">They are not visible in derived classes located in a different assembly from the base class.</span></span>

- <span data-ttu-id="f192c-145">Membros [Públicos](../language-reference/keywords/public.md) são visíveis em classes derivadas e fazem parte da interface pública da classe derivada.</span><span class="sxs-lookup"><span data-stu-id="f192c-145">[Public](../language-reference/keywords/public.md) members are visible in derived classes and are part of the derived class' public interface.</span></span> <span data-ttu-id="f192c-146">Os membros públicos herdados podem ser chamados como se estivessem definidos na classe derivada.</span><span class="sxs-lookup"><span data-stu-id="f192c-146">Public inherited members can be called just as if they are defined in the derived class.</span></span> <span data-ttu-id="f192c-147">No exemplo a seguir, a classe `A` define um método chamado `Method1`, e a classe `B` herda da classe `A`.</span><span class="sxs-lookup"><span data-stu-id="f192c-147">In the following example, class `A` defines a method named `Method1`, and class `B` inherits from class `A`.</span></span> <span data-ttu-id="f192c-148">Depois, o exemplo chama `Method1` como se fosse um método de instância em `B`.</span><span class="sxs-lookup"><span data-stu-id="f192c-148">The example then calls `Method1` as if it were an instance method on `B`.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/basics.cs#1)]

<span data-ttu-id="f192c-149">Classes derivadas também podem *substituir* membros herdados fornecendo uma implementação alternativa.</span><span class="sxs-lookup"><span data-stu-id="f192c-149">Derived classes can also *override* inherited members by providing an alternate implementation.</span></span> <span data-ttu-id="f192c-150">Para poder substituir um membro, o membro na classe base deve ser marcado com a palavra-chave [virtual](../language-reference/keywords/virtual.md).</span><span class="sxs-lookup"><span data-stu-id="f192c-150">In order to be able to override a member, the member in the base class must be marked with the [virtual](../language-reference/keywords/virtual.md) keyword.</span></span> <span data-ttu-id="f192c-151">Por padrão, os membros da classe base não são marcados como `virtual` e não podem ser substituídos.</span><span class="sxs-lookup"><span data-stu-id="f192c-151">By default, base class members are not marked as `virtual` and cannot be overridden.</span></span> <span data-ttu-id="f192c-152">A tentativa de substituir um membro não virtual, como faz o exemplo a seguir, gera o erro do compilador CS0506: "O \<member> não pode substituir o membro herdado \<member>, pois não está marcado como virtual, abstrato ou de substituição".</span><span class="sxs-lookup"><span data-stu-id="f192c-152">Attempting to override a non-virtual member, as the following example does, generates compiler error CS0506: "\<member> cannot override inherited member \<member> because it is not marked virtual, abstract, or override.</span></span>

```csharp
public class A
{
    public void Method1()
    {
        // Do something.
    }
}

public class B : A
{
    public override void Method1() // Generates CS0506.
    {
        // Do something else.
    }
}
```

<span data-ttu-id="f192c-153">Em alguns casos, uma classe derivada *deve* substituir a implementação da classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-153">In some cases, a derived class *must* override the base class implementation.</span></span> <span data-ttu-id="f192c-154">Membros de classe base marcados com a palavra-chave [abstrato](../language-reference/keywords/abstract.md) exigem que as classes derivadas os substituam.</span><span class="sxs-lookup"><span data-stu-id="f192c-154">Base class members marked with the [abstract](../language-reference/keywords/abstract.md) keyword require that derived classes override them.</span></span> <span data-ttu-id="f192c-155">A tentativa de compilar o exemplo a seguir gera um erro do compilador CS0534, a "&lt;classe&gt; não implementa o membro abstrato herdado &lt;membro&gt;", pois a classe `B` não fornece uma implementação para `A.Method1`.</span><span class="sxs-lookup"><span data-stu-id="f192c-155">Attempting to compile the following example generates compiler error CS0534, "&lt;class&gt; does not implement inherited abstract member &lt;member&gt;", because class `B` provides no implementation for `A.Method1`.</span></span>

```csharp
public abstract class A
{
    public abstract void Method1();
}

public class B : A // Generates CS0534.
{
    public void Method3()
    {
        // Do something.
    }
}
```

<span data-ttu-id="f192c-156">A herança se aplica apenas a classes e interfaces.</span><span class="sxs-lookup"><span data-stu-id="f192c-156">Inheritance applies only to classes and interfaces.</span></span> <span data-ttu-id="f192c-157">Outras categorias de tipo (structs, delegados e enumerações) não dão suporte à herança.</span><span class="sxs-lookup"><span data-stu-id="f192c-157">Other type categories (structs, delegates, and enums) do not support inheritance.</span></span> <span data-ttu-id="f192c-158">Devido a essas regras, a tentativa de compilar o código como no exemplo a seguir gera o erro do compilador CS0527: “O tipo ‘ValueType’ na lista de interfaces não é uma interface”.</span><span class="sxs-lookup"><span data-stu-id="f192c-158">Because of these rules, attempting to compile code like the following example produces compiler error CS0527: "Type 'ValueType' in interface list is not an interface."</span></span> <span data-ttu-id="f192c-159">A mensagem de erro indica que, embora você possa definir as interfaces implementadas por um struct, não há suporte para a herança.</span><span class="sxs-lookup"><span data-stu-id="f192c-159">The error message indicates that, although you can define the interfaces that a struct implements, inheritance is not supported.</span></span>

```csharp
using System;

public struct ValueStructure : ValueType // Generates CS0527.
{
}
```

## <a name="implicit-inheritance"></a><span data-ttu-id="f192c-160">Herança implícita</span><span class="sxs-lookup"><span data-stu-id="f192c-160">Implicit inheritance</span></span>

<span data-ttu-id="f192c-161">Apesar dos tipos possíveis de herança por meio de herança única, todos os tipos no sistema de tipo .NET herdam implicitamente de <xref:System.Object> ou de um tipo derivado dele.</span><span class="sxs-lookup"><span data-stu-id="f192c-161">Besides any types that they may inherit from through single inheritance, all types in the .NET type system implicitly inherit from <xref:System.Object> or a type derived from it.</span></span> <span data-ttu-id="f192c-162">A funcionalidade comum de <xref:System.Object> está disponível para qualquer tipo.</span><span class="sxs-lookup"><span data-stu-id="f192c-162">The common functionality of <xref:System.Object> is available to any type.</span></span>

<span data-ttu-id="f192c-163">Para ver o que significa herança implícita, vamos definir uma nova classe, `SimpleClass`, que é simplesmente uma definição de classe vazia:</span><span class="sxs-lookup"><span data-stu-id="f192c-163">To see what implicit inheritance means, let's define a new class, `SimpleClass`, that is simply an empty class definition:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#1)]

<span data-ttu-id="f192c-164">É possível usar reflexão (o que permite inspecionar os metadados de um tipo para obter informações sobre esse tipo) para obter uma lista dos membros que pertencem ao tipo `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="f192c-164">You can then use reflection (which lets you inspect a type's metadata to get information about that type) to get a list of the members that belong to the `SimpleClass` type.</span></span> <span data-ttu-id="f192c-165">Embora você ainda não tenha definido membros na classe `SimpleClass`, a saída do exemplo indica que, na verdade, ela tem nove membros.</span><span class="sxs-lookup"><span data-stu-id="f192c-165">Although you haven't defined any members in your `SimpleClass` class, output from the example indicates that it actually has nine members.</span></span> <span data-ttu-id="f192c-166">Um desses membros é um construtor sem parâmetros (ou padrão) que é fornecido automaticamente para o tipo `SimpleClass` pelo compilador de C#.</span><span class="sxs-lookup"><span data-stu-id="f192c-166">One of these members is a parameterless (or default) constructor that is automatically supplied for the `SimpleClass` type by the C# compiler.</span></span> <span data-ttu-id="f192c-167">Os oito são membros do <xref:System.Object>, o tipo do qual todas as classes e interfaces no sistema do tipo .NET herdam implicitamente.</span><span class="sxs-lookup"><span data-stu-id="f192c-167">The remaining eight are members of <xref:System.Object>, the type from which all classes and interfaces in the .NET type system ultimately implicitly inherit.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass.cs#2)]

<span data-ttu-id="f192c-168">A herança implícita da classe <xref:System.Object> torna esses métodos disponíveis para a classe `SimpleClass`:</span><span class="sxs-lookup"><span data-stu-id="f192c-168">Implicit inheritance from the <xref:System.Object> class makes these methods available to the `SimpleClass` class:</span></span>

- <span data-ttu-id="f192c-169">O método `ToString` público, que converte um objeto `SimpleClass` em sua representação de cadeia de caracteres, retorna o nome de tipo totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="f192c-169">The public `ToString` method, which converts a `SimpleClass` object to its string representation, returns the fully qualified type name.</span></span> <span data-ttu-id="f192c-170">Nesse caso, o método `ToString` retorna a cadeia de caracteres "SimpleClass".</span><span class="sxs-lookup"><span data-stu-id="f192c-170">In this case, the `ToString` method returns the string "SimpleClass".</span></span>

- <span data-ttu-id="f192c-171">Três métodos de teste de igualdade de dois objetos: o método `Equals(Object)` da instância pública, o método `Equals(Object, Object)` do público estático e o método `ReferenceEquals(Object, Object)` de público estático.</span><span class="sxs-lookup"><span data-stu-id="f192c-171">Three methods that test for equality of two objects: the public instance `Equals(Object)` method, the public static `Equals(Object, Object)` method, and the public static `ReferenceEquals(Object, Object)` method.</span></span> <span data-ttu-id="f192c-172">Por padrão, esses métodos testam a igualdade de referência; ou seja, para que seja iguais, duas variáveis de objeto devem fazer referência ao mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="f192c-172">By default, these methods test for reference equality; that is, to be equal, two object variables must refer to the same object.</span></span>

- <span data-ttu-id="f192c-173">O método público `GetHashCode`, que calcula um valor que permite o uso de uma instância do tipo em conjuntos de hash.</span><span class="sxs-lookup"><span data-stu-id="f192c-173">The public `GetHashCode` method, which computes a value that allows an instance of the type to be used in hashed collections.</span></span>

- <span data-ttu-id="f192c-174">O método público `GetType`, que retorna um objeto <xref:System.Type> que representa o tipo `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="f192c-174">The public `GetType` method, which returns a <xref:System.Type> object that represents the `SimpleClass` type.</span></span>

- <span data-ttu-id="f192c-175">O método protegido <xref:System.Object.Finalize%2A>, que é projetado para liberar recursos não gerenciados antes que a memória de um objeto seja reivindicada pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="f192c-175">The protected <xref:System.Object.Finalize%2A> method, which is designed to release unmanaged resources before an object's memory is reclaimed by the garbage collector.</span></span>

- <span data-ttu-id="f192c-176">O método protegido <xref:System.Object.MemberwiseClone%2A>, que cria um clone superficial do objeto atual.</span><span class="sxs-lookup"><span data-stu-id="f192c-176">The protected <xref:System.Object.MemberwiseClone%2A> method, which creates a shallow clone of the current object.</span></span>

<span data-ttu-id="f192c-177">Devido à herança implícita, você pode chamar qualquer membro herdado de um objeto `SimpleClass` como se ele fosse, na verdade, um membro definido na classe `SimpleClass`.</span><span class="sxs-lookup"><span data-stu-id="f192c-177">Because of implicit inheritance, you can call any inherited member from a `SimpleClass` object just as if it was actually a member defined in the `SimpleClass` class.</span></span> <span data-ttu-id="f192c-178">Por exemplo, o exemplo a seguir chama o método `SimpleClass.ToString`, que `SimpleClass` herda de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f192c-178">For instance, the following example calls the `SimpleClass.ToString` method, which `SimpleClass` inherits from <xref:System.Object>.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/simpleclass2.cs#1)]

<span data-ttu-id="f192c-179">A tabela a seguir lista as categorias de tipos que você pode criar em C#, e os tipos de onde eles herdam implicitamente.</span><span class="sxs-lookup"><span data-stu-id="f192c-179">The following table lists the categories of types that you can create in C# and the types from which they implicitly inherit.</span></span> <span data-ttu-id="f192c-180">Cada tipo base disponibiliza um conjunto diferente de membros por meio de herança para tipos derivados implicitamente.</span><span class="sxs-lookup"><span data-stu-id="f192c-180">Each base type makes a different set of members available through inheritance to implicitly derived types.</span></span>

| <span data-ttu-id="f192c-181">Categoria do tipo</span><span class="sxs-lookup"><span data-stu-id="f192c-181">Type category</span></span> | <span data-ttu-id="f192c-182">Herda implicitamente de</span><span class="sxs-lookup"><span data-stu-id="f192c-182">Implicitly inherits from</span></span>                                                      |
| ------------- | ----------------------------------------------------------------------------- |
| <span data-ttu-id="f192c-183">classe</span><span class="sxs-lookup"><span data-stu-id="f192c-183">class</span></span>         | <xref:System.Object>                                                          |
| <span data-ttu-id="f192c-184">struct</span><span class="sxs-lookup"><span data-stu-id="f192c-184">struct</span></span>        | <span data-ttu-id="f192c-185"><xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="f192c-185"><xref:System.ValueType>, <xref:System.Object></span></span>                                 |
| <span data-ttu-id="f192c-186">enum</span><span class="sxs-lookup"><span data-stu-id="f192c-186">enum</span></span>          | <span data-ttu-id="f192c-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="f192c-187"><xref:System.Enum>, <xref:System.ValueType>, <xref:System.Object></span></span>             |
| <span data-ttu-id="f192c-188">delegado</span><span class="sxs-lookup"><span data-stu-id="f192c-188">delegate</span></span>      | <span data-ttu-id="f192c-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="f192c-189"><xref:System.MulticastDelegate>, <xref:System.Delegate>, <xref:System.Object></span></span> |

## <a name="inheritance-and-an-is-a-relationship"></a><span data-ttu-id="f192c-190">Herança e um relacionamento "é um(a)"</span><span class="sxs-lookup"><span data-stu-id="f192c-190">Inheritance and an "is a" relationship</span></span>

<span data-ttu-id="f192c-191">Normalmente, a herança é usada para expressar um relacionamento "é um(a)" entre uma classe base e uma ou mais classes derivadas, em que as classes derivadas são versões especializadas da classe base; a classe derivada é um tipo de classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-191">Ordinarily, inheritance is used to express an "is a" relationship between a base class and one or more derived classes, where the derived classes are specialized versions of the base class; the derived class is a type of the base class.</span></span> <span data-ttu-id="f192c-192">Por exemplo, a classe `Publication` representa uma publicação de qualquer tipo e as classes `Book` e `Magazine` representam tipos específicos de publicações.</span><span class="sxs-lookup"><span data-stu-id="f192c-192">For example, the `Publication` class represents a publication of any kind, and the `Book` and `Magazine` classes represent specific types of publications.</span></span>

> [!NOTE]
> <span data-ttu-id="f192c-193">Uma classe ou struct pode implementar uma ou mais interfaces.</span><span class="sxs-lookup"><span data-stu-id="f192c-193">A class or struct can implement one or more interfaces.</span></span> <span data-ttu-id="f192c-194">Embora a implementação da interface seja apresentada geralmente como uma alternativa para herança única, ou como uma forma de usar a herança com structs, ela tem como objetivo expressar um relacionamento diferente (um relacionamento "pode fazer") entre uma interface e seu tipo de implementação em comparação com a herança.</span><span class="sxs-lookup"><span data-stu-id="f192c-194">While interface implementation is often presented as a workaround for single inheritance or as a way of using inheritance with structs, it is intended to express a different relationship (a "can do" relationship) between an interface and its implementing type than inheritance.</span></span> <span data-ttu-id="f192c-195">Uma interface define um subconjunto de funcionalidades (como a capacidade de testar a igualdade, comparar ou classificar objetos ou dar suporte à formatação e análise sensível à cultura) que disponibiliza para seus tipos de implementação.</span><span class="sxs-lookup"><span data-stu-id="f192c-195">An interface defines a subset of functionality (such as the ability to test for equality, to compare or sort objects, or to support culture-sensitive parsing and formatting) that the interface makes available to its implementing types.</span></span>

<span data-ttu-id="f192c-196">Observe que "é um(a)" também expressa o relacionamento entre um tipo e uma instanciação específica desse tipo.</span><span class="sxs-lookup"><span data-stu-id="f192c-196">Note that "is a" also expresses the relationship between a type and a specific instantiation of that type.</span></span> <span data-ttu-id="f192c-197">No exemplo a seguir, `Automobile` é uma classe que tem três propriedades somente leitura exclusivas: `Make`, o fabricante do automóvel; `Model`, o tipo de automóvel; e `Year`, o ano de fabricação.</span><span class="sxs-lookup"><span data-stu-id="f192c-197">In the following example, `Automobile` is a class that has three unique read-only properties: `Make`, the manufacturer of the automobile; `Model`, the kind of automobile; and `Year`, its year of manufacture.</span></span> <span data-ttu-id="f192c-198">A classe `Automobile` também tem um construtor cujos argumentos são atribuídos aos valores de propriedade. Ela também substitui o método <xref:System.Object.ToString%2A?displayProperty=nameWithType> para produzir uma cadeia de caracteres que identifica exclusivamente a instância `Automobile` em vez da classe `Automobile`.</span><span class="sxs-lookup"><span data-stu-id="f192c-198">Your `Automobile` class also has a constructor whose arguments are assigned to the property values, and it overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to produce a string that uniquely identifies the `Automobile` instance rather than the `Automobile` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#1)]

<span data-ttu-id="f192c-199">Nesse caso, você não deve depender da herança para representar marcas e modelos de carro específicos.</span><span class="sxs-lookup"><span data-stu-id="f192c-199">In this case, you shouldn't rely on inheritance to represent specific car makes and models.</span></span> <span data-ttu-id="f192c-200">Por exemplo, você não precisa definir um tipo `Packard` para representar automóveis fabricados pela empresa Packard Motor Car.</span><span class="sxs-lookup"><span data-stu-id="f192c-200">For example, you don't need to define a `Packard` type to represent automobiles manufactured by the Packard Motor Car Company.</span></span> <span data-ttu-id="f192c-201">Nesse caso, é possível representá-los criando um objeto `Automobile` com os valores apropriados passados ao construtor de classe, como no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="f192c-201">Instead, you can represent them by creating an `Automobile` object with the appropriate values passed to its class constructor, as the following example does.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/is-a.cs#2)]

<span data-ttu-id="f192c-202">Um relacionamento é-um(a) baseado na herança é mais bem aplicado a uma classe base e em classes derivadas que adicionam outros membros à classe base, ou que exigem funcionalidades adicionais não incluídas na classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-202">An is-a relationship based on inheritance is best applied to a base class and to derived classes that add additional members to the base class or that require additional functionality not present in the base class.</span></span>

## <a name="designing-the-base-class-and-derived-classes"></a><span data-ttu-id="f192c-203">Criação da classe base e das classes derivadas</span><span class="sxs-lookup"><span data-stu-id="f192c-203">Designing the base class and derived classes</span></span>

<span data-ttu-id="f192c-204">Vamos examinar o processo de criação de uma classe base e de suas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f192c-204">Let's look at the process of designing a base class and its derived classes.</span></span> <span data-ttu-id="f192c-205">Nesta seção, você definirá uma classe base, a `Publication`, que representa uma publicação de qualquer tipo, como um livro, uma revista, um jornal, um diário, um artigo etc. Você também definirá uma classe `Book` derivada de `Publication`.</span><span class="sxs-lookup"><span data-stu-id="f192c-205">In this section, you'll define a base class, `Publication`, which represents a publication of any kind, such as a book, a magazine, a newspaper, a journal, an article, etc. You'll also define a `Book` class that derives from `Publication`.</span></span> <span data-ttu-id="f192c-206">É possível estender facilmente o exemplo para definir outras classes derivadas, como `Magazine`, `Journal`, `Newspaper` e `Article`.</span><span class="sxs-lookup"><span data-stu-id="f192c-206">You could easily extend the example to define other derived classes, such as `Magazine`, `Journal`, `Newspaper`, and `Article`.</span></span>

### <a name="the-base-publication-class"></a><span data-ttu-id="f192c-207">A classe base de Publicação</span><span class="sxs-lookup"><span data-stu-id="f192c-207">The base Publication class</span></span>

<span data-ttu-id="f192c-208">Em projetar a classe `Publication`, você precisa tomar várias decisões de design:</span><span class="sxs-lookup"><span data-stu-id="f192c-208">In designing your `Publication` class, you need to make several design decisions:</span></span>

- <span data-ttu-id="f192c-209">Quais membros devem ser incluídos na classe base `Publication` e se os membros de `Publication` fornecem implementações de método, ou se `Publication` é uma classe base abstrata que funciona como um modelo para suas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f192c-209">What members to include in your base `Publication` class, and whether the `Publication` members provide method implementations or whether `Publication` is an abstract base class that serves as a template for its derived classes.</span></span>

  <span data-ttu-id="f192c-210">Nesse caso, a classe `Publication` fornecerá implementações de método.</span><span class="sxs-lookup"><span data-stu-id="f192c-210">In this case, the `Publication` class will provide method implementations.</span></span> <span data-ttu-id="f192c-211">A seção [Criação de classes base abstratas e de suas classes derivadas](#abstract) contém um exemplo que usa uma classe base abstrata para definir os métodos que as classes derivadas devem substituir.</span><span class="sxs-lookup"><span data-stu-id="f192c-211">The [Designing abstract base classes and their derived classes](#abstract) section contains an example that uses an abstract base class to define the methods that derived classes must override.</span></span> <span data-ttu-id="f192c-212">As classes derivadas são livres para fornecer qualquer implementação adequada ao tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="f192c-212">Derived classes are free to provide any implementation that is suitable for the derived type.</span></span>

  <span data-ttu-id="f192c-213">A capacidade de reutilizar o código (ou seja, várias classes derivadas compartilham a declaração e a implementação dos métodos de classe base, e não é necessário substituí-las) é uma vantagem das classes base não abstratas.</span><span class="sxs-lookup"><span data-stu-id="f192c-213">The ability to reuse code (that is, multiple derived classes share the declaration and implementation of base class methods and do not need to override them) is an advantage of non-abstract base classes.</span></span> <span data-ttu-id="f192c-214">Portanto, você deverá adicionar membros à `Publication` se o código precisar ser compartilhado por um ou mais tipos `Publication` especializados.</span><span class="sxs-lookup"><span data-stu-id="f192c-214">Therefore, you should add members to `Publication` if their code is likely to be shared by some or most specialized `Publication` types.</span></span> <span data-ttu-id="f192c-215">Se você não conseguir fornecer implementações da classe base de forma eficiente, será necessário fornecer implementações de membro praticamente idênticas em classes derivadas em vez de uma única implementação na classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-215">If you fail to provide base class implementations efficiently, you'll end up having to provide largely identical member implementations in derived classes rather a single implementation in the base class.</span></span> <span data-ttu-id="f192c-216">A necessidade de manter o código duplicado em vários locais é uma possível fonte de bugs.</span><span class="sxs-lookup"><span data-stu-id="f192c-216">The need to maintain duplicated code in multiple locations is a potential source of bugs.</span></span>

  <span data-ttu-id="f192c-217">Para maximizar a reutilização do código e criar uma hierarquia de herança lógica e intuitiva, inclua na classe `Publication` apenas dos dados e a funcionalidade comuns a todas as publicações ou à maioria delas.</span><span class="sxs-lookup"><span data-stu-id="f192c-217">Both to maximize code reuse and to create a logical and intuitive inheritance hierarchy, you want to be sure that you include in the `Publication` class only the data and functionality that is common to all or to most publications.</span></span> <span data-ttu-id="f192c-218">Depois, as classes derivadas implementam os membros exclusivos a determinados tipos de publicação que eles representam.</span><span class="sxs-lookup"><span data-stu-id="f192c-218">Derived classes then implement members that are unique to the particular kinds of publication that they represent.</span></span>

- <span data-ttu-id="f192c-219">O quanto devemos ampliar a hierarquia de classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-219">How far to extend your class hierarchy.</span></span> <span data-ttu-id="f192c-220">Você deseja desenvolver uma hierarquia de três ou mais classes, em vez de simplesmente uma classe base e uma ou mais classes derivadas?</span><span class="sxs-lookup"><span data-stu-id="f192c-220">Do you want to develop a hierarchy of three or more classes, rather than simply a base class and one or more derived classes?</span></span> <span data-ttu-id="f192c-221">Por exemplo, `Publication` poderia ser uma classe base de `Periodical`, que por sua vez é uma classe base de `Magazine`, `Journal` e `Newspaper`.</span><span class="sxs-lookup"><span data-stu-id="f192c-221">For example, `Publication` could be a base class of `Periodical`, which in turn is a base class of `Magazine`, `Journal` and `Newspaper`.</span></span>

  <span data-ttu-id="f192c-222">Para o seu exemplo, você usará a hierarquia pequena de uma classe `Publication` e uma única classe derivada, a `Book`.</span><span class="sxs-lookup"><span data-stu-id="f192c-222">For your example, you'll use the small hierarchy of a `Publication` class and a single derived class, `Book`.</span></span> <span data-ttu-id="f192c-223">É possível ampliar o exemplo facilmente para criar várias classes adicionais derivadas de `Publication`, como `Magazine` e `Article`.</span><span class="sxs-lookup"><span data-stu-id="f192c-223">You could easily extend the example to create a number of additional   classes that derive from `Publication`, such as `Magazine` and `Article`.</span></span>

- <span data-ttu-id="f192c-224">Se faz sentido instanciar a classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-224">Whether it makes sense to instantiate the base class.</span></span> <span data-ttu-id="f192c-225">Se não fizer, você deverá aplicar a palavra-chave [abstract](../language-reference/keywords/abstract.md) à classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-225">If it does not, you should apply the [abstract](../language-reference/keywords/abstract.md) keyword to the class.</span></span> <span data-ttu-id="f192c-226">Caso contrário, a instância da classe `Publication` poderá ser criada chamando seu construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-226">Otherwise, your `Publication` class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="f192c-227">Se for feita uma tentativa de instanciar uma classe marcada com a palavra-chave `abstract` por uma chamada direta para o construtor de classe, o compilador de C# gerará o erro CS0144, "Não é possível criar uma instância da classe abstrata ou interface".</span><span class="sxs-lookup"><span data-stu-id="f192c-227">If an attempt is made to instantiate a class marked with the `abstract` keyword by a direct call to its class constructor, the C# compiler generates error CS0144, "Cannot create an instance of the abstract class or interface."</span></span> <span data-ttu-id="f192c-228">Se for feita uma tentativa de instanciar a classe por meio da reflexão, o método de reflexão lançará um <xref:System.MemberAccessException>.</span><span class="sxs-lookup"><span data-stu-id="f192c-228">If an attempt is made to instantiate the class by using reflection, the reflection method throws a <xref:System.MemberAccessException>.</span></span>

  <span data-ttu-id="f192c-229">Por padrão, uma classe base pode ser instanciada chamando seu construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="f192c-229">By default, a base class can be instantiated by calling its class constructor.</span></span> <span data-ttu-id="f192c-230">Você não precisa definir um construtor de classe explicitamente.</span><span class="sxs-lookup"><span data-stu-id="f192c-230">You do not have to explicitly define a class constructor.</span></span> <span data-ttu-id="f192c-231">Se não houver um presente no código-fonte da classe base, o compilador de C# fornecerá automaticamente um construtor (sem parâmetros) padrão.</span><span class="sxs-lookup"><span data-stu-id="f192c-231">If one is not present in the base class' source code, the C# compiler automatically provides a default (parameterless) constructor.</span></span>

  <span data-ttu-id="f192c-232">No seu exemplo, você marcará a classe `Publication` como [abstract](../language-reference/keywords/abstract.md), para que não seja possível criar uma instância dela.</span><span class="sxs-lookup"><span data-stu-id="f192c-232">For your example, you'll mark the `Publication` class as [abstract](../language-reference/keywords/abstract.md) so that it cannot be instantiated.</span></span>  <span data-ttu-id="f192c-233">Uma classe `abstract` sem nenhum método `abstract` indica que essa classe representa um conceito abstrato que é compartilhado entre várias classes concretas (como `Book`, `Journal`).</span><span class="sxs-lookup"><span data-stu-id="f192c-233">An `abstract` class without any `abstract` methods indicates that this class represents an abstract concept that is shared among several concrete classes (like a `Book`, `Journal`).</span></span>

- <span data-ttu-id="f192c-234">Se as classes derivadas precisam herdar a implementação de membros específicos da classe base, se elas têm a opção de substituir a implementação da classe base ou se precisam fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="f192c-234">Whether derived classes must inherit the base class implementation of particular members, whether they have the option to override the base class implementation, or whether they must provide an implementation.</span></span> <span data-ttu-id="f192c-235">Use a palavra-chave [abstract](../language-reference/keywords/abstract.md) para forçar as classes derivadas a fornecer uma implementação.</span><span class="sxs-lookup"><span data-stu-id="f192c-235">You use the [abstract](../language-reference/keywords/abstract.md) keyword to force derived classes to provide an implementation.</span></span> <span data-ttu-id="f192c-236">Use a palavra-chave [virtual](../language-reference/keywords/virtual.md) para permitir que as classes derivadas substituam um método de classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-236">You use the [virtual](../language-reference/keywords/virtual.md) keyword to allow derived classes to override a base class method.</span></span> <span data-ttu-id="f192c-237">Por padrão, os métodos definidos na classe base *não* são substituíveis.</span><span class="sxs-lookup"><span data-stu-id="f192c-237">By default, methods defined in the base class are *not* overridable.</span></span>

 <span data-ttu-id="f192c-238">A classe `Publication` não tem nenhum método `abstract`, mas a classe em si é `abstract`.</span><span class="sxs-lookup"><span data-stu-id="f192c-238">The `Publication` class does not have any `abstract` methods, but the class itself is `abstract`.</span></span>

- <span data-ttu-id="f192c-239">Se uma classe derivada representa a classe final na hierarquia de herança e não pode se ser usada como uma classe base para outras classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="f192c-239">Whether a derived class represents the final class in the inheritance hierarchy and cannot itself be used as a base class for additional derived classes.</span></span> <span data-ttu-id="f192c-240">Por padrão, qualquer classe pode servir como classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-240">By default, any class can serve as a base class.</span></span> <span data-ttu-id="f192c-241">Você pode aplicar a palavra-chave [sealed](../language-reference/keywords/sealed.md) para indicar que uma classe não pode funcionar como uma classe base para quaisquer classes adicionais.</span><span class="sxs-lookup"><span data-stu-id="f192c-241">You can apply the [sealed](../language-reference/keywords/sealed.md) keyword to indicate that a class cannot serve as a base class for any additional classes.</span></span> <span data-ttu-id="f192c-242">A tentativa de derivar de uma classe selada gerou o erro do compilador CS0509, "Não é possível derivar do tipo selado \<typeName>".</span><span class="sxs-lookup"><span data-stu-id="f192c-242">Attempting to derive from a sealed class generated compiler error CS0509, "cannot derive from sealed type \<typeName>".</span></span>

  <span data-ttu-id="f192c-243">No seu exemplo, você marcará a classe derivada como `sealed`.</span><span class="sxs-lookup"><span data-stu-id="f192c-243">For your example, you'll mark your derived class as `sealed`.</span></span>

<span data-ttu-id="f192c-244">O exemplo a seguir mostra o código-fonte para a classe `Publication`, bem como uma enumeração `PublicationType` que é retornada pela propriedade `Publication.PublicationType`.</span><span class="sxs-lookup"><span data-stu-id="f192c-244">The following example shows the source code for the `Publication` class, as well as a `PublicationType` enumeration that is returned by the `Publication.PublicationType` property.</span></span> <span data-ttu-id="f192c-245">Além dos membros herdados de <xref:System.Object>, a classe `Publication` define os seguintes membros exclusivos e substituições de membro:</span><span class="sxs-lookup"><span data-stu-id="f192c-245">In addition to the members that it inherits from <xref:System.Object>, the `Publication` class defines the following unique members and member overrides:</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#1)]

- <span data-ttu-id="f192c-246">Um construtor</span><span class="sxs-lookup"><span data-stu-id="f192c-246">A constructor</span></span>

  <span data-ttu-id="f192c-247">Como a classe `Publication` é `abstract`, sua instância não pode ser criada diretamente no código, com no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="f192c-247">Because the `Publication` class is `abstract`, it cannot be instantiated directly from code like the following example:</span></span>

  ```csharp
  var publication = new Publication("Tiddlywinks for Experts", "Fun and Games",
                                    PublicationType.Book);
  ```

  <span data-ttu-id="f192c-248">No entanto, o construtor de instância pode ser chamado diretamente dos construtores de classe derivada, como mostra o código-fonte para a classe `Book`.</span><span class="sxs-lookup"><span data-stu-id="f192c-248">However, its instance constructor can be called directly from derived class constructors, as the source code for the `Book` class shows.</span></span>

- <span data-ttu-id="f192c-249">Duas propriedades relacionadas à publicação</span><span class="sxs-lookup"><span data-stu-id="f192c-249">Two publication-related properties</span></span>

  <span data-ttu-id="f192c-250">`Title` é uma propriedade <xref:System.String> somente leitura cujo valor é fornecido pela chamada do construtor `Publication`.</span><span class="sxs-lookup"><span data-stu-id="f192c-250">`Title` is a read-only <xref:System.String> property whose value is supplied by calling the `Publication` constructor.</span></span>

  <span data-ttu-id="f192c-251">`Pages` é uma propriedade <xref:System.Int32> de leitura-gravação que indica o número total de páginas da publicação.</span><span class="sxs-lookup"><span data-stu-id="f192c-251">`Pages` is a read-write <xref:System.Int32> property that indicates how many total pages the publication has.</span></span> <span data-ttu-id="f192c-252">O valor é armazenado em um campo privado chamado `totalPages`.</span><span class="sxs-lookup"><span data-stu-id="f192c-252">The value is stored in a private field named `totalPages`.</span></span> <span data-ttu-id="f192c-253">O lançamento deve ser de um número positivo ou de um <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="f192c-253">It must be a positive number or an <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>

- <span data-ttu-id="f192c-254">Membros relacionados ao publicador</span><span class="sxs-lookup"><span data-stu-id="f192c-254">Publisher-related members</span></span>

  <span data-ttu-id="f192c-255">Duas propriedades somente leitura, `Publisher` e `Type`.</span><span class="sxs-lookup"><span data-stu-id="f192c-255">Two read-only properties, `Publisher` and `Type`.</span></span> <span data-ttu-id="f192c-256">Originalmente, os valores eram fornecidos pela chamada para o construtor da classe `Publication`.</span><span class="sxs-lookup"><span data-stu-id="f192c-256">The values are originally supplied by the call to the `Publication` class constructor.</span></span>

- <span data-ttu-id="f192c-257">Membros relacionados à publicação</span><span class="sxs-lookup"><span data-stu-id="f192c-257">Publishing-related members</span></span>

  <span data-ttu-id="f192c-258">Dois métodos, `Publish` e `GetPublicationDate`, definem e retornam a data de publicação.</span><span class="sxs-lookup"><span data-stu-id="f192c-258">Two methods, `Publish` and `GetPublicationDate`, set and return the publication date.</span></span> <span data-ttu-id="f192c-259">O método `Publish` define um sinalizador `published` privado como `true` quando ele é chamado, e atribui a data passada para ele como um argumento para o campo `datePublished` privado.</span><span class="sxs-lookup"><span data-stu-id="f192c-259">The `Publish` method sets a private  `published` flag to `true` when it is called and assigns the date passed to it as an argument to the private `datePublished` field.</span></span> <span data-ttu-id="f192c-260">O método `GetPublicationDate` retorna a cadeia de caracteres "NYP" se o sinalizador `published` for `false`, e o valor do campo `datePublished` for `true`.</span><span class="sxs-lookup"><span data-stu-id="f192c-260">The `GetPublicationDate` method returns the string "NYP" if the `published` flag is `false`, and the value of the `datePublished` field if it is `true`.</span></span>

- <span data-ttu-id="f192c-261">Membros relacionados a direitos autorais</span><span class="sxs-lookup"><span data-stu-id="f192c-261">Copyright-related members</span></span>

  <span data-ttu-id="f192c-262">O método `Copyright` usa o nome do proprietário dos direitos autorais e o ano dos direitos autorais como argumentos e os atribui às propriedades `CopyrightName` e `CopyrightDate`.</span><span class="sxs-lookup"><span data-stu-id="f192c-262">The `Copyright` method takes the name of the copyright holder and the year of the copyright as arguments and assigns them to the `CopyrightName` and `CopyrightDate` properties.</span></span>

- <span data-ttu-id="f192c-263">Uma substituição do método `ToString`</span><span class="sxs-lookup"><span data-stu-id="f192c-263">An override of the `ToString` method</span></span>

  <span data-ttu-id="f192c-264">Se um tipo não substituir o método <xref:System.Object.ToString%2A?displayProperty=nameWithType>, ele retornará o nome totalmente qualificado do tipo, que é de pouca utilidade na diferenciação de uma instância para outra.</span><span class="sxs-lookup"><span data-stu-id="f192c-264">If a type does not override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, it returns the fully qualified name of the type, which is of little use in differentiating one instance from another.</span></span> <span data-ttu-id="f192c-265">A classe `Publication` substitui <xref:System.Object.ToString%2A?displayProperty=nameWithType> para retornar o valor da propriedade `Title`.</span><span class="sxs-lookup"><span data-stu-id="f192c-265">The `Publication` class overrides <xref:System.Object.ToString%2A?displayProperty=nameWithType> to return the value of the `Title` property.</span></span>

<span data-ttu-id="f192c-266">A figura a seguir ilustra o relacionamento entre a classe base `Publication` e sua classe herdada implicitamente <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="f192c-266">The following figure illustrates the relationship between your base `Publication` class and its implicitly inherited <xref:System.Object> class.</span></span>

![As classes Object e Publication](media/publication-class.jpg)

### <a name="the-book-class"></a><span data-ttu-id="f192c-268">A classe `Book`</span><span class="sxs-lookup"><span data-stu-id="f192c-268">The `Book` class</span></span>

<span data-ttu-id="f192c-269">A classe `Book` representa um livro como tipo especializado de publicação.</span><span class="sxs-lookup"><span data-stu-id="f192c-269">The `Book` class represents a book as a specialized type of publication.</span></span> <span data-ttu-id="f192c-270">O exemplo a seguir mostra o código-fonte para a classe `Book`.</span><span class="sxs-lookup"><span data-stu-id="f192c-270">The following example shows the source code for the `Book` class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/base-and-derived.cs#2)]

<span data-ttu-id="f192c-271">Além dos membros herdados de `Publication`, a classe `Book` define os seguintes membros exclusivos e substituições de membro:</span><span class="sxs-lookup"><span data-stu-id="f192c-271">In addition to the members that it inherits from `Publication`, the `Book` class defines the following unique members and member overrides:</span></span>

- <span data-ttu-id="f192c-272">Dois construtores</span><span class="sxs-lookup"><span data-stu-id="f192c-272">Two constructors</span></span>

  <span data-ttu-id="f192c-273">Os dois construtores `Book` compartilham três parâmetros comuns.</span><span class="sxs-lookup"><span data-stu-id="f192c-273">The two `Book` constructors share three common parameters.</span></span> <span data-ttu-id="f192c-274">Dois, *title* e *publisher*, correspondem aos parâmetros do construtor `Publication`.</span><span class="sxs-lookup"><span data-stu-id="f192c-274">Two, *title* and *publisher*, correspond to parameters of the `Publication` constructor.</span></span> <span data-ttu-id="f192c-275">O terceiro é *author*, que é armazenado em uma propriedade pública `Author` imutável.</span><span class="sxs-lookup"><span data-stu-id="f192c-275">The third is *author*, which is stored to a public immutable `Author` property.</span></span> <span data-ttu-id="f192c-276">Um construtor inclui um parâmetro *isbn*, que é armazenado na propriedade automática `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="f192c-276">One constructor includes an *isbn* parameter, which is stored in the `ISBN` auto-property.</span></span>

  <span data-ttu-id="f192c-277">O primeiro construtor usa a palavra-chave [this](../language-reference/keywords/this.md) para chamar o outro construtor.</span><span class="sxs-lookup"><span data-stu-id="f192c-277">The first constructor uses the [this](../language-reference/keywords/this.md) keyword to call the other constructor.</span></span> <span data-ttu-id="f192c-278">O encadeamento do construtor é um padrão comum na definição de construtores.</span><span class="sxs-lookup"><span data-stu-id="f192c-278">Constructor chaining is a common pattern in defining constructors.</span></span> <span data-ttu-id="f192c-279">Construtores com menos parâmetros fornecem valores padrão ao chamar o construtor com o maior número de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f192c-279">Constructors with fewer parameters provide default values when calling the constructor with the greatest number of parameters.</span></span>

  <span data-ttu-id="f192c-280">O segundo construtor usa a palavra-chave [base](../language-reference/keywords/base.md) para passar o título e o nome do publicador para o construtor da classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-280">The second constructor uses the [base](../language-reference/keywords/base.md) keyword to pass the title and publisher name to the base class constructor.</span></span> <span data-ttu-id="f192c-281">Se você não fizer uma chamada explícita para um construtor de classe base em seu código-fonte, o compilador de C# fornecerá automaticamente uma chamada para a classe base padrão ou para o construtor sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="f192c-281">If you don't make an explicit call to a base class constructor in your source code, the C# compiler automatically supplies a call to the base class' default or parameterless constructor.</span></span>

- <span data-ttu-id="f192c-282">Uma propriedade `ISBN` somente leitura, que retorna o ISBN (International Standard Book Number) do objeto `Book`, um número exclusivo com 10 ou 13 dígitos.</span><span class="sxs-lookup"><span data-stu-id="f192c-282">A read-only `ISBN` property, which returns the `Book` object's International Standard Book Number, a unique 10- or 13-digit number.</span></span> <span data-ttu-id="f192c-283">O ISBN é fornecido como um argumento para um dos construtores `Book`.</span><span class="sxs-lookup"><span data-stu-id="f192c-283">The ISBN is supplied as an argument to one of the `Book` constructors.</span></span> <span data-ttu-id="f192c-284">O ISBN é armazenado em um campo de suporte particular, gerado automaticamente pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="f192c-284">The ISBN is stored in a private backing field, which is auto-generated by the compiler.</span></span>

- <span data-ttu-id="f192c-285">Uma propriedade `Author` somente leitura.</span><span class="sxs-lookup"><span data-stu-id="f192c-285">A read-only `Author` property.</span></span> <span data-ttu-id="f192c-286">O nome do autor é fornecido como um argumento para os dois construtores `Book` e é armazenado na propriedade.</span><span class="sxs-lookup"><span data-stu-id="f192c-286">The author name is supplied as an argument to both `Book` constructors and is stored in the property.</span></span>

- <span data-ttu-id="f192c-287">Duas propriedades somente leitura relacionadas ao preço, `Price` e `Currency`.</span><span class="sxs-lookup"><span data-stu-id="f192c-287">Two read-only price-related properties, `Price` and `Currency`.</span></span> <span data-ttu-id="f192c-288">Seus valores são fornecidos como argumentos em uma chamada do método `SetPrice`.</span><span class="sxs-lookup"><span data-stu-id="f192c-288">Their values are provided as arguments in a `SetPrice` method call.</span></span> <span data-ttu-id="f192c-289">A propriedade `Currency` é o símbolo de moeda ISO de três dígitos (por exemplo, USD para dólar americano).</span><span class="sxs-lookup"><span data-stu-id="f192c-289">The `Currency` property is the three-digit ISO currency symbol (for example, USD for the U.S. dollar).</span></span> <span data-ttu-id="f192c-290">Símbolos de moeda ISO podem ser obtidos da propriedade <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A>.</span><span class="sxs-lookup"><span data-stu-id="f192c-290">ISO currency symbols can be retrieved from the <xref:System.Globalization.RegionInfo.ISOCurrencySymbol%2A> property.</span></span> <span data-ttu-id="f192c-291">Ambas as propriedades são somente leitura externamente, mas podem ser definidas por código na classe `Book`.</span><span class="sxs-lookup"><span data-stu-id="f192c-291">Both of these properties are externally read-only, but both can be set by code in the `Book` class.</span></span>

- <span data-ttu-id="f192c-292">Um método `SetPrice`, que define os valores das propriedades `Price` e `Currency`.</span><span class="sxs-lookup"><span data-stu-id="f192c-292">A `SetPrice` method, which sets the values of the `Price` and `Currency` properties.</span></span> <span data-ttu-id="f192c-293">Esses valores são retornados por essas mesmas propriedades.</span><span class="sxs-lookup"><span data-stu-id="f192c-293">Those values are returned by those same properties.</span></span>

- <span data-ttu-id="f192c-294">Substitui o método `ToString` (herdado de `Publication`) e os métodos <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> e <xref:System.Object.GetHashCode%2A> (herdados de <xref:System.Object>).</span><span class="sxs-lookup"><span data-stu-id="f192c-294">Overrides to the `ToString` method (inherited from `Publication`) and the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> and <xref:System.Object.GetHashCode%2A> methods (inherited from <xref:System.Object>).</span></span>

  <span data-ttu-id="f192c-295">A menos que seja substituído, o método <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> testa a igualdade de referência.</span><span class="sxs-lookup"><span data-stu-id="f192c-295">Unless it is overridden, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method tests for reference equality.</span></span> <span data-ttu-id="f192c-296">Ou seja, duas variáveis de objeto são consideradas iguais se fizerem referência ao mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="f192c-296">That is, two object variables are considered to be equal if they refer to the same object.</span></span> <span data-ttu-id="f192c-297">Na classe `Book`, por outro lado, dois objetos `Book` devem ser iguais quando têm o mesmo ISBN.</span><span class="sxs-lookup"><span data-stu-id="f192c-297">In the `Book` class, on the other hand, two `Book` objects should be equal if they have the same ISBN.</span></span>

  <span data-ttu-id="f192c-298">Ao substituir o método <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, substitua também o método <xref:System.Object.GetHashCode%2A>, que retorna um valor usado pelo tempo de execução para armazenar itens em coleções de hash para uma recuperação eficiente.</span><span class="sxs-lookup"><span data-stu-id="f192c-298">When you override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, you must also override the <xref:System.Object.GetHashCode%2A> method, which returns a value that the runtime uses to store items in hashed collections for efficient retrieval.</span></span> <span data-ttu-id="f192c-299">O código de hash deve retornar um valor que é consistente com o teste de igualdade.</span><span class="sxs-lookup"><span data-stu-id="f192c-299">The hash code should return a value that's consistent with the test for equality.</span></span> <span data-ttu-id="f192c-300">Como você substituiu <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> para retornar `true`, se as propriedades de ISBN de dois objetos `Book` forem iguais, retorne o código hash computado chamando o método <xref:System.String.GetHashCode%2A> da cadeia de caracteres retornada pela propriedade `ISBN`.</span><span class="sxs-lookup"><span data-stu-id="f192c-300">Since you've overridden <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to return `true` if the ISBN properties of two `Book` objects are equal, you return the hash code computed by calling the <xref:System.String.GetHashCode%2A> method of the string returned by the `ISBN` property.</span></span>

<span data-ttu-id="f192c-301">A figura a seguir ilustra o relacionamento entre a classe `Book` e `Publication`, sua classe base.</span><span class="sxs-lookup"><span data-stu-id="f192c-301">The following figure illustrates the relationship between the `Book` class and `Publication`, its base class.</span></span>

![Classes Publication e Book](media/book-class.jpg)

<span data-ttu-id="f192c-303">Agora você pode criar a instância de um objeto `Book`, invocar seus membros exclusivos e herdados e passá-lo como um argumento a um método que espera um parâmetro do tipo `Publication` ou do tipo `Book`, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="f192c-303">You can now instantiate a `Book` object, invoke both its unique and inherited members, and pass it as an argument to a method that expects a parameter of type `Publication` or of type `Book`, as the following example shows.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/use-publication.cs#1)]

## <a name="designing-abstract-base-classes-and-their-derived-classes"></a><span data-ttu-id="f192c-304">Criando classes base abstratas e suas classes derivadas</span><span class="sxs-lookup"><span data-stu-id="f192c-304">Designing abstract base classes and their derived classes</span></span>
<a name="abstract"></a>

<span data-ttu-id="f192c-305">No exemplo anterior, você definiu uma classe base que forneceu uma implementação de diversos métodos para permitir que classes derivadas compartilhem código.</span><span class="sxs-lookup"><span data-stu-id="f192c-305">In the previous example, you defined a base class that provided an implementation for a number of methods to allow derived classes to share code.</span></span> <span data-ttu-id="f192c-306">Em muitos casos, no entanto, não espera-se que a classe base forneça uma implementação.</span><span class="sxs-lookup"><span data-stu-id="f192c-306">In many cases, however, the base class is not expected to provide an implementation.</span></span> <span data-ttu-id="f192c-307">Nesse caso, a classe base é uma *classe abstrata* que declara *métodos abstratos*. Ela funciona como um modelo que define os membros que cada classe derivada precisa implementar.</span><span class="sxs-lookup"><span data-stu-id="f192c-307">Instead, the base class is an *abstract class* that declares *abstract methods*; it serves as a template that defines the members that each derived class must implement.</span></span> <span data-ttu-id="f192c-308">Normalmente em uma classe base abstrata, a implementação de cada tipo derivado é exclusiva para esse tipo.</span><span class="sxs-lookup"><span data-stu-id="f192c-308">Typically in an abstract base class, the implementation of each derived type is unique to that type.</span></span> <span data-ttu-id="f192c-309">Você marcou a classe com a palavra-chave abstract porque não fazia sentido criar uma instância de um objeto `Publication`, embora a classe fornecesse implementações de funcionalidades comuns para publicações.</span><span class="sxs-lookup"><span data-stu-id="f192c-309">You marked the class with the abstract keyword because it made no sense to instantiate a `Publication` object, although the class did provide implementations of functionality common to publications.</span></span>

<span data-ttu-id="f192c-310">Por exemplo, cada forma geométrica bidimensional fechada inclui duas propriedades: área, a extensão interna da forma; e perímetro, ou a distância entre as bordas da forma.</span><span class="sxs-lookup"><span data-stu-id="f192c-310">For example, each closed two-dimensional geometric shape includes two properties: area, the inner extent of the shape; and perimeter, or the distance along the edges of the shape.</span></span> <span data-ttu-id="f192c-311">A maneira com a qual essas propriedades são calculadas, no entanto, depende completamente da forma específica.</span><span class="sxs-lookup"><span data-stu-id="f192c-311">The way in which these properties are calculated, however, depends completely on the specific shape.</span></span> <span data-ttu-id="f192c-312">A fórmula para calcular o perímetro (ou a circunferência) de um círculo, por exemplo, é diferente da fórmula de um triângulo.</span><span class="sxs-lookup"><span data-stu-id="f192c-312">The formula for calculating the perimeter (or circumference) of a circle, for example, is different from that of a triangle.</span></span> <span data-ttu-id="f192c-313">A classe `Shape` é uma classe `abstract` com métodos `abstract`.</span><span class="sxs-lookup"><span data-stu-id="f192c-313">The `Shape` class is an `abstract` class with `abstract` methods.</span></span> <span data-ttu-id="f192c-314">Isso indica que as classes derivadas compartilham a mesma funcionalidade, mas essas classes derivadas implementam essa funcionalidade de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="f192c-314">That indicates derived classes share the same functionality, but those derived classes implement that functionality differently.</span></span>

<span data-ttu-id="f192c-315">O exemplo a seguir define uma classe base abstrata denominada `Shape` que define duas propriedades: `Area` e `Perimeter`.</span><span class="sxs-lookup"><span data-stu-id="f192c-315">The following example defines an abstract base class named `Shape` that defines two properties: `Area` and `Perimeter`.</span></span> <span data-ttu-id="f192c-316">Além da classe ser marcada com a palavra-chave [abstract](../language-reference/keywords/abstract.md), cada membro da instância também é marcado com a palavra-chave [abstract](../language-reference/keywords/abstract.md).</span><span class="sxs-lookup"><span data-stu-id="f192c-316">In addition to marking the class with the [abstract](../language-reference/keywords/abstract.md) keyword, each instance member is also marked with the [abstract](../language-reference/keywords/abstract.md) keyword.</span></span> <span data-ttu-id="f192c-317">Nesse caso, o `Shape` também substitui o método <xref:System.Object.ToString%2A?displayProperty=nameWithType> para retornar o nome do tipo, em vez de seu nome totalmente qualificado.</span><span class="sxs-lookup"><span data-stu-id="f192c-317">In this case, `Shape` also overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the name of the type, rather than its fully qualified name.</span></span> <span data-ttu-id="f192c-318">E define dois membros estáticos, `GetArea` e `GetPerimeter`, que permitem a recuperação fácil da área e do perímetro de uma instância de qualquer classe derivada.</span><span class="sxs-lookup"><span data-stu-id="f192c-318">And it defines two static members, `GetArea` and `GetPerimeter`, that allow callers to easily retrieve the area and perimeter of an instance of any derived class.</span></span> <span data-ttu-id="f192c-319">Quando você passa uma instância de uma classe derivada para um desses métodos, o tempo de execução chama a substituição do método da classe derivada.</span><span class="sxs-lookup"><span data-stu-id="f192c-319">When you pass an instance of a derived class to either of these methods, the runtime calls the method override of the derived class.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#1)]

<span data-ttu-id="f192c-320">Em seguida, você pode derivar algumas classes de `Shape` que representam formas específicas.</span><span class="sxs-lookup"><span data-stu-id="f192c-320">You can then derive some classes from `Shape` that represent specific shapes.</span></span> <span data-ttu-id="f192c-321">O exemplo a seguir define três classes, `Triangle`, `Rectangle` e `Circle`.</span><span class="sxs-lookup"><span data-stu-id="f192c-321">The following example defines three classes, `Triangle`, `Rectangle`, and `Circle`.</span></span> <span data-ttu-id="f192c-322">Cada uma usa uma fórmula exclusiva para essa forma específica para calcular a área e o perímetro.</span><span class="sxs-lookup"><span data-stu-id="f192c-322">Each uses a formula unique for that particular shape to compute the area and perimeter.</span></span> <span data-ttu-id="f192c-323">Algumas das classes derivadas também definem propriedades, como `Rectangle.Diagonal` e `Circle.Diameter`, que são exclusivas para a forma que representam.</span><span class="sxs-lookup"><span data-stu-id="f192c-323">Some of the derived classes also define properties, such as `Rectangle.Diagonal` and `Circle.Diameter`, that are unique to the shape that they represent.</span></span>

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#2)]

<span data-ttu-id="f192c-324">O exemplo a seguir usa objetos derivados de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="f192c-324">The following example uses objects derived from `Shape`.</span></span> <span data-ttu-id="f192c-325">Ele cria uma matriz de objetos derivados de `Shape` e chama os métodos estáticos da classe `Shape`, que retorna valores de propriedade `Shape`.</span><span class="sxs-lookup"><span data-stu-id="f192c-325">It instantiates an array of objects derived from `Shape` and calls the static methods of the `Shape` class, which wraps return `Shape` property values.</span></span> <span data-ttu-id="f192c-326">O tempo de execução recupera os valores das propriedades substituídas dos tipos derivados.</span><span class="sxs-lookup"><span data-stu-id="f192c-326">The runtime retrieves values from the overridden properties of the derived types.</span></span> <span data-ttu-id="f192c-327">O exemplo também converte cada objeto `Shape` na matriz ao seu tipo derivado e, se a conversão for bem-sucedida, recupera as propriedades dessa subclasse específica de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="f192c-327">The example also casts each `Shape` object in the array to its derived type and, if the cast succeeds, retrieves properties of that particular subclass of `Shape`.</span></span> 

[!code-csharp[Inheritance](../../../samples/snippets/csharp/tutorials/inheritance/shape.cs#3)]

## <a name="see-also"></a><span data-ttu-id="f192c-328">Consulte também</span><span class="sxs-lookup"><span data-stu-id="f192c-328">See also</span></span>

- [<span data-ttu-id="f192c-329">Classes e objetos</span><span class="sxs-lookup"><span data-stu-id="f192c-329">Classes and objects</span></span>](../tour-of-csharp/classes-and-objects.md)
- [<span data-ttu-id="f192c-330">Herança (Guia de programação em C#)</span><span class="sxs-lookup"><span data-stu-id="f192c-330">Inheritance (C# Programming Guide)</span></span>](../programming-guide/classes-and-structs/inheritance.md)
