---
title: O que há de novo no C# 9,0 – Guia C#
description: Obtenha uma visão geral dos novos recursos disponíveis no C# 9,0.
ms.date: 09/04/2020
ms.openlocfilehash: 5b3695dee8fc26f69e713d1d6811acdf0cfa9764
ms.sourcegitcommit: f99115e12a5eb75638abe45072e023a3ce3351ac
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/12/2020
ms.locfileid: "94557214"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="78e7d-103">Novidades do C# 9.0</span><span class="sxs-lookup"><span data-stu-id="78e7d-103">What's new in C# 9.0</span></span>

<span data-ttu-id="78e7d-104">O c# 9,0 adiciona os seguintes recursos e aprimoramentos à linguagem C#:</span><span class="sxs-lookup"><span data-stu-id="78e7d-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="78e7d-105">Registros</span><span class="sxs-lookup"><span data-stu-id="78e7d-105">Records</span></span>](#record-types)
- [<span data-ttu-id="78e7d-106">Setters somente init</span><span class="sxs-lookup"><span data-stu-id="78e7d-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="78e7d-107">Instruções de nível superior</span><span class="sxs-lookup"><span data-stu-id="78e7d-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="78e7d-108">Melhorias na correspondência de padrões</span><span class="sxs-lookup"><span data-stu-id="78e7d-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- <span data-ttu-id="78e7d-109">Inteiros de tamanho nativo</span><span class="sxs-lookup"><span data-stu-id="78e7d-109">Native sized integers</span></span>
- <span data-ttu-id="78e7d-110">Ponteiros de função</span><span class="sxs-lookup"><span data-stu-id="78e7d-110">Function pointers</span></span>
- <span data-ttu-id="78e7d-111">Suprimir emissão do sinalizador localsinit</span><span class="sxs-lookup"><span data-stu-id="78e7d-111">Suppress emitting localsinit flag</span></span>
- <span data-ttu-id="78e7d-112">Expressões new com tipo de destino</span><span class="sxs-lookup"><span data-stu-id="78e7d-112">Target-typed new expressions</span></span>
- <span data-ttu-id="78e7d-113">funções anônimas estáticas</span><span class="sxs-lookup"><span data-stu-id="78e7d-113">static anonymous functions</span></span>
- <span data-ttu-id="78e7d-114">Expressões condicionais de tipo de destino</span><span class="sxs-lookup"><span data-stu-id="78e7d-114">Target-typed conditional expressions</span></span>
- <span data-ttu-id="78e7d-115">Tipos de retorno covariantes</span><span class="sxs-lookup"><span data-stu-id="78e7d-115">Covariant return types</span></span>
- <span data-ttu-id="78e7d-116">`GetEnumerator`Suporte de extensão para `foreach` loops</span><span class="sxs-lookup"><span data-stu-id="78e7d-116">Extension `GetEnumerator` support for `foreach` loops</span></span>
- <span data-ttu-id="78e7d-117">Parâmetros discard de lambda</span><span class="sxs-lookup"><span data-stu-id="78e7d-117">Lambda discard parameters</span></span>
- <span data-ttu-id="78e7d-118">Atributos em funções locais</span><span class="sxs-lookup"><span data-stu-id="78e7d-118">Attributes on local functions</span></span>
- <span data-ttu-id="78e7d-119">Inicializadores de módulo</span><span class="sxs-lookup"><span data-stu-id="78e7d-119">Module initializers</span></span>
- <span data-ttu-id="78e7d-120">Novos recursos para métodos parciais</span><span class="sxs-lookup"><span data-stu-id="78e7d-120">New features for partial methods</span></span>

<span data-ttu-id="78e7d-121">O C# 9,0 tem suporte no **.NET 5**.</span><span class="sxs-lookup"><span data-stu-id="78e7d-121">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="78e7d-122">Para obter mais informações, consulte [controle de versão da linguagem C#](../language-reference/configure-language-version.md).</span><span class="sxs-lookup"><span data-stu-id="78e7d-122">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="78e7d-123">Você pode baixar o SDK do .NET mais recente na [página de downloads do .net](https://dotnet.microsoft.com/download).</span><span class="sxs-lookup"><span data-stu-id="78e7d-123">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="78e7d-124">Tipos de registro</span><span class="sxs-lookup"><span data-stu-id="78e7d-124">Record types</span></span>

<span data-ttu-id="78e7d-125">O C# 9,0 introduz \* *_tipos de registro_* _, que são um tipo de referência que fornece métodos sintetizados para fornecer a semântica de valor para igualdade.</span><span class="sxs-lookup"><span data-stu-id="78e7d-125">C# 9.0 introduces \* *_record types_* _, which are a reference type that provides synthesized methods to provide value semantics for equality.</span></span> <span data-ttu-id="78e7d-126">Os registros são imutáveis por padrão.</span><span class="sxs-lookup"><span data-stu-id="78e7d-126">Records are immutable by default.</span></span>

<span data-ttu-id="78e7d-127">Os tipos de registro facilitam a criação de tipos de referência imutáveis no .NET.</span><span class="sxs-lookup"><span data-stu-id="78e7d-127">Record types make it easy to create immutable reference types in .NET.</span></span> <span data-ttu-id="78e7d-128">Historicamente, os tipos .NET são classificados em grande parte como tipos de referência (incluindo classes e tipos anônimos) e tipos de valor (incluindo structs e tuplas).</span><span class="sxs-lookup"><span data-stu-id="78e7d-128">Historically, .NET types are largely classified as reference types (including classes and anonymous types) and value types (including structs and tuples).</span></span> <span data-ttu-id="78e7d-129">Embora tipos de valor imutáveis sejam recomendados, os tipos de valores mutáveis geralmente não introduzem erros.</span><span class="sxs-lookup"><span data-stu-id="78e7d-129">While immutable value types are recommended, mutable value types don’t often introduce errors.</span></span> <span data-ttu-id="78e7d-130">As variáveis de tipo de valor contêm os valores para que as alterações sejam feitas em uma cópia dos dados originais quando os tipos de valor são passados para métodos.</span><span class="sxs-lookup"><span data-stu-id="78e7d-130">Value type variables hold the values so changes are made to a copy of the original data when value types are passed to methods.</span></span>

<span data-ttu-id="78e7d-131">Também há muitas vantagens em tipos de referência imutáveis.</span><span class="sxs-lookup"><span data-stu-id="78e7d-131">There are many advantages to immutable reference types as well.</span></span> <span data-ttu-id="78e7d-132">Essas vantagens são mais pronunciadas em programas simultâneos com dados compartilhados.</span><span class="sxs-lookup"><span data-stu-id="78e7d-132">These advantages are more pronounced in concurrent programs with shared data.</span></span> <span data-ttu-id="78e7d-133">Infelizmente, o C# forçou você a escrever um pouco de código extra para criar tipos de referência imutáveis.</span><span class="sxs-lookup"><span data-stu-id="78e7d-133">Unfortunately, C# forced you to write quite a bit of extra code to create immutable reference types.</span></span> <span data-ttu-id="78e7d-134">Os registros fornecem uma declaração de tipo para um tipo de referência imutável que usa semântica de valor para igualdade.</span><span class="sxs-lookup"><span data-stu-id="78e7d-134">Records provide a type declaration for an immutable reference type that uses value semantics for equality.</span></span> <span data-ttu-id="78e7d-135">Os métodos sintetizados para códigos de igualdade e hash consideram dois registros iguais se suas propriedades forem iguais.</span><span class="sxs-lookup"><span data-stu-id="78e7d-135">The synthesized methods for equality and hash codes consider two records equal if their properties are all equal.</span></span> <span data-ttu-id="78e7d-136">Considere esta definição:</span><span class="sxs-lookup"><span data-stu-id="78e7d-136">Consider this definition:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordDefinition":::

<span data-ttu-id="78e7d-137">A definição de registro cria um `Person` tipo que contém duas propriedades ReadOnly: `FirstName` e `LastName` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-137">The record definition creates a `Person` type that contains two readonly properties: `FirstName` and `LastName`.</span></span> <span data-ttu-id="78e7d-138">O `Person` tipo é um tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="78e7d-138">The `Person` type is a reference type.</span></span> <span data-ttu-id="78e7d-139">Se você examinou o IL, ele é uma classe.</span><span class="sxs-lookup"><span data-stu-id="78e7d-139">If you looked at the IL, it’s a class.</span></span> <span data-ttu-id="78e7d-140">É imutável, pois nenhuma das propriedades pode ser modificada depois de ser criada.</span><span class="sxs-lookup"><span data-stu-id="78e7d-140">It’s immutable in that none of the properties can be modified once it's been created.</span></span> <span data-ttu-id="78e7d-141">Quando você define um tipo de registro, o compilador sintetiza vários outros métodos para você:</span><span class="sxs-lookup"><span data-stu-id="78e7d-141">When you define a record type, the compiler synthesizes several other methods for you:</span></span>

- <span data-ttu-id="78e7d-142">Métodos para comparações de igualdade com base em valor</span><span class="sxs-lookup"><span data-stu-id="78e7d-142">Methods for value-based equality comparisons</span></span>
- <span data-ttu-id="78e7d-143">Substituir para <xref:System.Object.GetHashCode></span><span class="sxs-lookup"><span data-stu-id="78e7d-143">Override for <xref:System.Object.GetHashCode></span></span>
- <span data-ttu-id="78e7d-144">Copiar e clonar Membros</span><span class="sxs-lookup"><span data-stu-id="78e7d-144">Copy and Clone members</span></span>
- <span data-ttu-id="78e7d-145">`PrintMembers` e <xref:System.Object.ToString></span><span class="sxs-lookup"><span data-stu-id="78e7d-145">`PrintMembers` and <xref:System.Object.ToString></span></span>

<span data-ttu-id="78e7d-146">Registra o suporte à herança.</span><span class="sxs-lookup"><span data-stu-id="78e7d-146">Records support inheritance.</span></span> <span data-ttu-id="78e7d-147">Você pode declarar um novo registro derivado do da `Person` seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="78e7d-147">You can declare a new record derived from `Person` as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="InheritedRecord":::

<span data-ttu-id="78e7d-148">Você também pode lacrar registros para evitar uma maior derivação:</span><span class="sxs-lookup"><span data-stu-id="78e7d-148">You can also seal records to prevent further derivation:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="SealedRecord":::

<span data-ttu-id="78e7d-149">O compilador sintetiza versões diferentes dos métodos acima.</span><span class="sxs-lookup"><span data-stu-id="78e7d-149">The compiler synthesizes different versions of the methods above.</span></span> <span data-ttu-id="78e7d-150">As assinaturas de método dependem de se o tipo de registro é lacrado e se a classe base direta é Object.</span><span class="sxs-lookup"><span data-stu-id="78e7d-150">The method signatures depend on if the record type is sealed and if the direct base class is object.</span></span> <span data-ttu-id="78e7d-151">Os registros devem ter os seguintes recursos:</span><span class="sxs-lookup"><span data-stu-id="78e7d-151">Records should have the following capabilities:</span></span>

- <span data-ttu-id="78e7d-152">A igualdade é baseada em valor e inclui uma verificação de que os tipos correspondem.</span><span class="sxs-lookup"><span data-stu-id="78e7d-152">Equality is value-based, and includes a check that the types match.</span></span> <span data-ttu-id="78e7d-153">Por exemplo, um `Student` não pode ser igual a a `Person` , mesmo que os dois registros compartilhem o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="78e7d-153">For example, a `Student` can't be equal to a `Person`, even if the two records share the same name.</span></span>
- <span data-ttu-id="78e7d-154">Os registros têm uma representação de cadeia de caracteres consistente gerada para você.</span><span class="sxs-lookup"><span data-stu-id="78e7d-154">Records have a consistent string representation generated for you.</span></span>
- <span data-ttu-id="78e7d-155">Os registros dão suporte à construção de cópia.</span><span class="sxs-lookup"><span data-stu-id="78e7d-155">Records support copy construction.</span></span> <span data-ttu-id="78e7d-156">A construção correta da cópia deve incluir hierarquias de herança e propriedades adicionadas por desenvolvedores.</span><span class="sxs-lookup"><span data-stu-id="78e7d-156">Correct copy construction must include inheritance hierarchies, and properties added by developers.</span></span>
- <span data-ttu-id="78e7d-157">Os registros podem ser copiados com modificações.</span><span class="sxs-lookup"><span data-stu-id="78e7d-157">Records can be copied with modification.</span></span> <span data-ttu-id="78e7d-158">Essas operações de cópia e modificação oferecem suporte a mutação não destrutiva.</span><span class="sxs-lookup"><span data-stu-id="78e7d-158">These copy and modify operations supports non-destructive mutation.</span></span>

<span data-ttu-id="78e7d-159">Além das `Equals` sobrecargas conhecidas, `operator ==` e `operator !=` , o compilador sintetiza uma nova `EqualityContract` propriedade.</span><span class="sxs-lookup"><span data-stu-id="78e7d-159">In addition to the familiar `Equals` overloads, `operator ==`, and `operator !=`, the compiler synthesizes a new `EqualityContract` property.</span></span> <span data-ttu-id="78e7d-160">A propriedade retorna um `Type` objeto que corresponde ao tipo do registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-160">The property returns a `Type` object that matches the type of the record.</span></span> <span data-ttu-id="78e7d-161">Se o tipo base for `object` , a propriedade será `virtual` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-161">If the base type is `object`, the property is `virtual`.</span></span> <span data-ttu-id="78e7d-162">Se o tipo base for outro tipo de registro, a propriedade será um `override` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-162">If the base type is another record type, the property is an `override`.</span></span> <span data-ttu-id="78e7d-163">Se o tipo de registro for `sealed` , a propriedade será `sealed` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-163">If the record type is `sealed`, the property is `sealed`.</span></span> <span data-ttu-id="78e7d-164">O sintetizado `GetHashCode` usa o `GetHashCode` de todas as propriedades e campos declarados no tipo base e no tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-164">The synthesized `GetHashCode` uses the `GetHashCode` from all properties and fields declared in the base type and the record type.</span></span> <span data-ttu-id="78e7d-165">Esses métodos sintetizados impõem a igualdade baseada em valor em uma hierarquia de herança.</span><span class="sxs-lookup"><span data-stu-id="78e7d-165">These synthesized methods enforce value-based equality throughout an inheritance hierarchy.</span></span> <span data-ttu-id="78e7d-166">Isso significa que um `Student` nunca será considerado igual a um `Person` com o mesmo nome.</span><span class="sxs-lookup"><span data-stu-id="78e7d-166">That means a `Student` will never be considered equal to a `Person` with the same name.</span></span> <span data-ttu-id="78e7d-167">Os tipos dos dois registros devem corresponder e todas as propriedades compartilhadas entre os tipos de registro são iguais.</span><span class="sxs-lookup"><span data-stu-id="78e7d-167">The types of the two records must match as well as all properties shared among the record types being equal.</span></span>

<span data-ttu-id="78e7d-168">Os registros também têm um Construtor sintetizado e um método de "clonagem" para a criação de cópias.</span><span class="sxs-lookup"><span data-stu-id="78e7d-168">Records also have a synthesized constructor and a "clone" method for creating copies.</span></span> <span data-ttu-id="78e7d-169">O Construtor sintetizado tem um único parâmetro do tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-169">The synthesized constructor has a single parameter of the record type.</span></span> <span data-ttu-id="78e7d-170">Ele produz um novo registro com os mesmos valores para todas as propriedades do registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-170">It produces a new record with the same values for all properties of the record.</span></span> <span data-ttu-id="78e7d-171">Esse construtor é privado se o registro estiver lacrado, caso contrário, será protegido.</span><span class="sxs-lookup"><span data-stu-id="78e7d-171">This constructor is private if the record is sealed, otherwise it's protected.</span></span> <span data-ttu-id="78e7d-172">O método "clone" sintetizado dá suporte à construção de cópia para hierarquias de registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-172">The synthesized "clone" method supports copy construction for record hierarchies.</span></span> <span data-ttu-id="78e7d-173">O termo "clone" está entre aspas porque o nome real é gerado pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="78e7d-173">The term "clone" is in quotes because the actual name is compiler generated.</span></span> <span data-ttu-id="78e7d-174">Você não pode criar um método chamado `Clone` em um tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-174">You can't create a method named `Clone` in a record type.</span></span> <span data-ttu-id="78e7d-175">O método "clone" sintetizado retorna o tipo de registro que está sendo copiado usando a expedição virtual.</span><span class="sxs-lookup"><span data-stu-id="78e7d-175">The synthesized "clone" method returns the type of record being copied using virtual dispatch.</span></span> <span data-ttu-id="78e7d-176">O compilador adiciona diferentes modificadores para o método "clone" dependendo dos modificadores de acesso no `record` :</span><span class="sxs-lookup"><span data-stu-id="78e7d-176">The compiler adds different modifiers for the "clone" method depending on the access modifiers on the `record`:</span></span>

- <span data-ttu-id="78e7d-177">Se o tipo de registro for `abstract` , o método "clone" também será `abstract` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-177">If the record type is `abstract`, the "clone" method is also `abstract`.</span></span> <span data-ttu-id="78e7d-178">Se o tipo base não for `object` , o método também será `override` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-178">If the base type isn't `object`, the method is also `override`.</span></span>
- <span data-ttu-id="78e7d-179">Para tipos de registro que não são `abstract` quando o tipo base é `object` :</span><span class="sxs-lookup"><span data-stu-id="78e7d-179">For record types that aren't `abstract` when the base type is `object`:</span></span>
  - <span data-ttu-id="78e7d-180">Se o registro for `sealed` , nenhum modificador adicional será adicionado ao método "clone" (o que significa que ele não é `virtual` ).</span><span class="sxs-lookup"><span data-stu-id="78e7d-180">If the record is `sealed`, no additional modifiers are added to the "clone" method (meaning it is not `virtual`).</span></span>
  - <span data-ttu-id="78e7d-181">Se o registro não for `sealed` , o método "clone" será `virtual` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-181">If the record isn't `sealed`, the "clone" method is `virtual`.</span></span>
- <span data-ttu-id="78e7d-182">Para tipos de registro que não são `abstract` quando o tipo base não é `object` :</span><span class="sxs-lookup"><span data-stu-id="78e7d-182">For record types that aren't `abstract` when the base type is not `object`:</span></span>
  - <span data-ttu-id="78e7d-183">Se o registro for `sealed` , o método "clone" também será `sealed` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-183">If the record is `sealed`, the "clone" method is also `sealed`.</span></span>
  - <span data-ttu-id="78e7d-184">Se o registro não for `sealed` , o método "clone" será `override` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-184">If the record isn't `sealed`, the "clone" method is `override`.</span></span>

<span data-ttu-id="78e7d-185">O resultado de todas essas regras é que a igualdade é implementada consistentemente em qualquer hierarquia de tipos de registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-185">The result of all these rules is the equality is implemented consistently across any hierarchy of record types.</span></span> <span data-ttu-id="78e7d-186">Dois registros são iguais entre si se suas propriedades forem iguais e seus tipos forem os mesmos, conforme mostrado no exemplo a seguir:</span><span class="sxs-lookup"><span data-stu-id="78e7d-186">Two records are equal to each other if their properties are equal and their types are the same, as shown in the following example:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/RecordsExamples.cs" ID="RecordsEquality":::

<span data-ttu-id="78e7d-187">O compilador sintetiza dois métodos que dão suporte à saída impressa: uma <xref:System.Object.ToString> substituição e `PrintMembers` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-187">The compiler synthesizes two methods that support printed output: a <xref:System.Object.ToString> override, and `PrintMembers`.</span></span> <span data-ttu-id="78e7d-188">O `PrintMembers` usa <xref:System.Text.StringBuilder?displayProperty=nameWithType> como argumento.</span><span class="sxs-lookup"><span data-stu-id="78e7d-188">The `PrintMembers` takes a <xref:System.Text.StringBuilder?displayProperty=nameWithType> as its argument.</span></span> <span data-ttu-id="78e7d-189">Ele acrescenta uma lista separada por vírgulas de nomes de propriedade e valores para todas as propriedades no tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-189">It appends a comma-separated list of property names and values for all properties in the record type.</span></span> <span data-ttu-id="78e7d-190">`PrintMembers` chama a implementação de base para todos os registros derivados de outros registros.</span><span class="sxs-lookup"><span data-stu-id="78e7d-190">`PrintMembers` calls the base implementation for any records derived from other records.</span></span> <span data-ttu-id="78e7d-191">A <xref:System.Object.ToString> substituição retorna a cadeia de caracteres produzida por `PrintMembers` , cercada por `{` e `}` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-191">The <xref:System.Object.ToString> override returns the string produced by `PrintMembers`, surrounded by `{` and `}`.</span></span> <span data-ttu-id="78e7d-192">Por exemplo, o <xref:System.Object.ToString> método para `Student` retorna um `string` semelhante ao seguinte código:</span><span class="sxs-lookup"><span data-stu-id="78e7d-192">For example, the <xref:System.Object.ToString> method for `Student` returns a `string` like the following code:</span></span>

```csharp
"Student { LastName = Wagner, FirstName = Bill, Level = 11 }"
```

<span data-ttu-id="78e7d-193">Os exemplos mostrados até agora usam a sintaxe tradicional para declarar Propriedades.</span><span class="sxs-lookup"><span data-stu-id="78e7d-193">The examples shown so far use traditional syntax to declare properties.</span></span> <span data-ttu-id="78e7d-194">Há uma forma mais concisa chamada _*_registros posicionais_*_.</span><span class="sxs-lookup"><span data-stu-id="78e7d-194">There's a more concise form called _*_positional records_*_.</span></span>  <span data-ttu-id="78e7d-195">Aqui estão os três tipos de registro definidos anteriormente como registros posicionais:</span><span class="sxs-lookup"><span data-stu-id="78e7d-195">Here are the three record types defined earlier as positional records:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="PositionalRecords":::

<span data-ttu-id="78e7d-196">Essas declarações criam a mesma funcionalidade da versão anterior (com alguns recursos extras abordados na seção a seguir).</span><span class="sxs-lookup"><span data-stu-id="78e7d-196">These declarations create the same functionality as the earlier version (with a couple extra features covered in the following section).</span></span> <span data-ttu-id="78e7d-197">Essas declarações terminam com um ponto e vírgula em vez de colchetes porque esses registros não adicionam outros métodos.</span><span class="sxs-lookup"><span data-stu-id="78e7d-197">These declarations end with a semicolon instead of brackets because these records don't add additional methods.</span></span> <span data-ttu-id="78e7d-198">Você pode adicionar um corpo e também incluir outros métodos:</span><span class="sxs-lookup"><span data-stu-id="78e7d-198">You can add a body, and include any additional methods as well:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="RecordsWithMethods":::

<span data-ttu-id="78e7d-199">O compilador produz um `Deconstruct` método para registros posicionais.</span><span class="sxs-lookup"><span data-stu-id="78e7d-199">The compiler produces a `Deconstruct` method for positional records.</span></span> <span data-ttu-id="78e7d-200">O `Deconstruct` método tem parâmetros que correspondem aos nomes de todas as propriedades públicas no tipo de registro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-200">The `Deconstruct` method has parameters that match the names of all public properties in the record type.</span></span> <span data-ttu-id="78e7d-201">O `Deconstruct` método pode ser usado para desconstruir o registro em suas propriedades de componente:</span><span class="sxs-lookup"><span data-stu-id="78e7d-201">The `Deconstruct` method can be used to deconstruct the record into its component properties:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="DeconstructRecord":::

<span data-ttu-id="78e7d-202">Por fim, o registra as [ `with` expressões](../language-reference/operators/with-expression.md)de suporte.</span><span class="sxs-lookup"><span data-stu-id="78e7d-202">Finally, records support [`with` expressions](../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="78e7d-203">Um _\*_ `with` expression_ *_ instrui o compilador a criar uma cópia de um registro, mas _with* propriedades especificadas modificadas:</span><span class="sxs-lookup"><span data-stu-id="78e7d-203">A _\*_`with` expression_ *_ instructs the compiler to create a copy of a record, but _with* specified properties modified:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PositionalRecords.cs" ID="Wither":::

<span data-ttu-id="78e7d-204">A linha acima cria um novo `Person` registro no qual a `LastName` propriedade é uma cópia de `person` e o `FirstName` é `"Paul"` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-204">The above line creates a new `Person` record where the `LastName` property is a copy of `person`, and the `FirstName` is `"Paul"`.</span></span> <span data-ttu-id="78e7d-205">Você pode definir qualquer número de propriedades em uma `with` expressão.</span><span class="sxs-lookup"><span data-stu-id="78e7d-205">You can set any number of properties in a `with` expression.</span></span>

<span data-ttu-id="78e7d-206">Qualquer um dos membros sintetizados, exceto o método "clone", pode ser escrito por você.</span><span class="sxs-lookup"><span data-stu-id="78e7d-206">Any of the synthesized members except the "clone" method may be written by you.</span></span> <span data-ttu-id="78e7d-207">Se um tipo de registro tiver um método que corresponda à assinatura de qualquer método sintetizado, o compilador não sintetizará esse método.</span><span class="sxs-lookup"><span data-stu-id="78e7d-207">If a record type has a method that matches the signature of any synthesized method, the compiler doesn't synthesize that method.</span></span> <span data-ttu-id="78e7d-208">O `Dog` exemplo de registro anterior contém um método codificado <xref:System.String.ToString> por mão como um exemplo.</span><span class="sxs-lookup"><span data-stu-id="78e7d-208">The earlier `Dog` record example contains a hand coded <xref:System.String.ToString> method as an example.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="78e7d-209">Setters somente init</span><span class="sxs-lookup"><span data-stu-id="78e7d-209">Init only setters</span></span>

<span data-ttu-id="78e7d-210">\***Init somente setters** _ fornecem sintaxe consistente para inicializar membros de um objeto.</span><span class="sxs-lookup"><span data-stu-id="78e7d-210">\***Init only setters** _ provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="78e7d-211">Os inicializadores de propriedade tornam claro qual valor está definindo qual propriedade.</span><span class="sxs-lookup"><span data-stu-id="78e7d-211">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="78e7d-212">A desvantagem é que essas propriedades devem ser configurável.</span><span class="sxs-lookup"><span data-stu-id="78e7d-212">The downside is that those properties must be settable.</span></span> <span data-ttu-id="78e7d-213">A partir do C# 9,0, você pode criar `init` acessadores em vez de `set` acessadores para propriedades e indexadores.</span><span class="sxs-lookup"><span data-stu-id="78e7d-213">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="78e7d-214">Os chamadores podem usar a sintaxe do inicializador de propriedade para definir esses valores em expressões de criação, mas essas propriedades são ReadOnly quando a construção é concluída.</span><span class="sxs-lookup"><span data-stu-id="78e7d-214">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="78e7d-215">Os setters somente init fornecem uma janela para alterar o estado.</span><span class="sxs-lookup"><span data-stu-id="78e7d-215">Init only setters provide a window to change state.</span></span> <span data-ttu-id="78e7d-216">Essa janela fecha quando a fase de construção termina.</span><span class="sxs-lookup"><span data-stu-id="78e7d-216">That window closes when the construction phase ends.</span></span> <span data-ttu-id="78e7d-217">A fase de construção termina com eficiência após toda a inicialização, incluindo inicializadores de propriedade e with-Expressions concluídos.</span><span class="sxs-lookup"><span data-stu-id="78e7d-217">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="78e7d-218">Você pode declarar `init` somente setters em qualquer tipo que escrever.</span><span class="sxs-lookup"><span data-stu-id="78e7d-218">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="78e7d-219">Por exemplo, a seguinte estrutura define uma estrutura de observação do clima:</span><span class="sxs-lookup"><span data-stu-id="78e7d-219">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="78e7d-220">Os chamadores podem usar a sintaxe do inicializador de propriedade para definir os valores, enquanto ainda preservam a imutabilidade:</span><span class="sxs-lookup"><span data-stu-id="78e7d-220">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="78e7d-221">Mas, a alteração de uma observação após a inicialização é um erro ao atribuir a uma propriedade somente init fora da inicialização:</span><span class="sxs-lookup"><span data-stu-id="78e7d-221">But, changing an observation after initialization is an error by assigning to an init-only property outside of initialization:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="78e7d-222">Os setters somente init podem ser úteis para definir propriedades de classe base de classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="78e7d-222">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="78e7d-223">Eles também podem definir propriedades derivadas por meio de auxiliares em uma classe base.</span><span class="sxs-lookup"><span data-stu-id="78e7d-223">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="78e7d-224">Registros posicionais declaram propriedades usando somente init setters.</span><span class="sxs-lookup"><span data-stu-id="78e7d-224">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="78e7d-225">Esses setters são usados em with-Expressions.</span><span class="sxs-lookup"><span data-stu-id="78e7d-225">Those setters are used in with-expressions.</span></span> <span data-ttu-id="78e7d-226">Você pode declarar setters somente init para qualquer um `class` ou `struct` definir.</span><span class="sxs-lookup"><span data-stu-id="78e7d-226">You can declare init only setters for any `class` or `struct` you define.</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="78e7d-227">Instruções de nível superior</span><span class="sxs-lookup"><span data-stu-id="78e7d-227">Top-level statements</span></span>

<span data-ttu-id="78e7d-228">As _*_instruções de nível superior_*_ removem a cerimônia desnecessária de muitos aplicativos.</span><span class="sxs-lookup"><span data-stu-id="78e7d-228">_*_Top-level statements_*_ remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="78e7d-229">Considere o canônico "Olá, Mundo!"</span><span class="sxs-lookup"><span data-stu-id="78e7d-229">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="78e7d-230">Program</span><span class="sxs-lookup"><span data-stu-id="78e7d-230">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="78e7d-231">Há apenas uma linha de código que faz qualquer coisa.</span><span class="sxs-lookup"><span data-stu-id="78e7d-231">There’s only one line of code that does anything.</span></span> <span data-ttu-id="78e7d-232">Com as instruções de nível superior, você pode substituir todo o texto clichê pela `using` instrução e a única linha que faz o trabalho:</span><span class="sxs-lookup"><span data-stu-id="78e7d-232">With top-level statements, you can replace all that boilerplate with the `using` statement and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="78e7d-233">Se você quisesse um programa de uma linha, poderia remover a `using` diretiva e usar o nome do tipo totalmente qualificado:</span><span class="sxs-lookup"><span data-stu-id="78e7d-233">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="78e7d-234">Somente um arquivo em seu aplicativo pode usar instruções de nível superior.</span><span class="sxs-lookup"><span data-stu-id="78e7d-234">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="78e7d-235">Se o compilador encontrar instruções de nível superior em vários arquivos de origem, será um erro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-235">If the compiler finds top-level statements in multiple source files, it’s an error.</span></span> <span data-ttu-id="78e7d-236">Também será um erro se você combinar instruções de nível superior com um método de ponto de entrada de programa declarado, normalmente um `Main` método.</span><span class="sxs-lookup"><span data-stu-id="78e7d-236">It’s also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="78e7d-237">De certa forma, você pode imaginar que um arquivo contém as instruções que normalmente estaria no `Main` método de uma `Program` classe.</span><span class="sxs-lookup"><span data-stu-id="78e7d-237">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="78e7d-238">Um dos usos mais comuns para esse recurso é a criação de materiais de ensino.</span><span class="sxs-lookup"><span data-stu-id="78e7d-238">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="78e7d-239">Desenvolvedores de C# iniciantes podem escrever o "Olá, Mundo!" canônico</span><span class="sxs-lookup"><span data-stu-id="78e7d-239">Beginner C# developers can write the canonical “Hello World!”</span></span> <span data-ttu-id="78e7d-240">em uma ou duas linhas de código.</span><span class="sxs-lookup"><span data-stu-id="78e7d-240">in one or two lines of code.</span></span> <span data-ttu-id="78e7d-241">Nenhuma das cerimônias extras é necessária.</span><span class="sxs-lookup"><span data-stu-id="78e7d-241">None of the extra ceremony is needed.</span></span> <span data-ttu-id="78e7d-242">No entanto, os desenvolvedores experientes também encontrarão muitos usos para esse recurso.</span><span class="sxs-lookup"><span data-stu-id="78e7d-242">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="78e7d-243">As instruções de nível superior permitem uma experiência semelhante a um script para experimentação semelhante ao que os notebooks Jupyter fornecem.</span><span class="sxs-lookup"><span data-stu-id="78e7d-243">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="78e7d-244">As instruções de nível superior são ótimas para pequenos programas de console e utilitários.</span><span class="sxs-lookup"><span data-stu-id="78e7d-244">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="78e7d-245">Azure Functions são um caso de uso ideal para instruções de nível superior.</span><span class="sxs-lookup"><span data-stu-id="78e7d-245">Azure Functions are an ideal use case for top-level statements.</span></span>

<span data-ttu-id="78e7d-246">O mais importante é que as instruções de nível superior não limitam o escopo ou a complexidade do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="78e7d-246">Most importantly, top-level statements don't limit your application’s scope or complexity.</span></span> <span data-ttu-id="78e7d-247">Essas instruções podem acessar ou usar qualquer classe .NET.</span><span class="sxs-lookup"><span data-stu-id="78e7d-247">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="78e7d-248">Eles também não limitam o uso de argumentos de linha de comando ou valores de retorno.</span><span class="sxs-lookup"><span data-stu-id="78e7d-248">They also don’t limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="78e7d-249">Instruções de nível superior podem acessar uma matriz de cadeias de caracteres denominadas args.</span><span class="sxs-lookup"><span data-stu-id="78e7d-249">Top-level statements can access an array of strings named args.</span></span> <span data-ttu-id="78e7d-250">Se as instruções de nível superior retornarem um valor inteiro, esse valor se tornará o código de retorno de inteiro de um método sintetizado `Main` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-250">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="78e7d-251">As instruções de nível superior podem conter expressões assíncronas.</span><span class="sxs-lookup"><span data-stu-id="78e7d-251">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="78e7d-252">Nesse caso, o ponto de entrada sintetizado retorna um `Task` , ou `Task<int>` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-252">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="78e7d-253">Melhorias na correspondência de padrões</span><span class="sxs-lookup"><span data-stu-id="78e7d-253">Pattern matching enhancements</span></span>

<span data-ttu-id="78e7d-254">O C# 9 inclui novas melhorias de correspondência de padrões:</span><span class="sxs-lookup"><span data-stu-id="78e7d-254">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="78e7d-255">_*_Padrões de tipo_*_ correspondem a uma variável é um tipo</span><span class="sxs-lookup"><span data-stu-id="78e7d-255">_*_Type patterns_*_ match a variable is a type</span></span>
- <span data-ttu-id="78e7d-256">_*_Padrões entre parênteses_*_ impõem ou enfatizam a precedência de combinações de padrões</span><span class="sxs-lookup"><span data-stu-id="78e7d-256">_*_Parenthesized patterns_*_ enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="78e7d-257">_\*_`and` Padrões de conjuntiva_\*_ exigem os dois padrões para corresponder</span><span class="sxs-lookup"><span data-stu-id="78e7d-257">_*_Conjunctive `and` patterns_*_ require both patterns to match</span></span>
- <span data-ttu-id="78e7d-258">_\*_`or` Padrões de disjunctive_\*_ exigem qualquer padrão para corresponder</span><span class="sxs-lookup"><span data-stu-id="78e7d-258">_*_Disjunctive `or` patterns_*_ require either pattern to match</span></span>
- <span data-ttu-id="78e7d-259">_\*_`not` Padrões negados_\*_ exigem que um padrão não corresponda</span><span class="sxs-lookup"><span data-stu-id="78e7d-259">_*_Negated `not` patterns_*_ require that a pattern doesn’t match</span></span>
- <span data-ttu-id="78e7d-260">Os _*_padrões relacionais_*_ exigem que a entrada seja menor que, maior que, menor ou igual ou maior ou igual a uma determinada constante.</span><span class="sxs-lookup"><span data-stu-id="78e7d-260">_*_Relational patterns_*_ require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="78e7d-261">Esses padrões enriquecem a sintaxe para padrões.</span><span class="sxs-lookup"><span data-stu-id="78e7d-261">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="78e7d-262">Considere estes exemplos:</span><span class="sxs-lookup"><span data-stu-id="78e7d-262">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="78e7d-263">Como alternativa, com parênteses opcionais para deixá-lo claro que `and` tem precedência maior do que `or` :</span><span class="sxs-lookup"><span data-stu-id="78e7d-263">Alternatively, with optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="78e7d-264">Um dos usos mais comuns é uma nova sintaxe para uma verificação nula:</span><span class="sxs-lookup"><span data-stu-id="78e7d-264">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="78e7d-265">Qualquer um desses padrões pode ser usado em qualquer contexto em que os padrões são permitidos: `is` expressões `switch` de padrão, expressões, padrões aninhados e o padrão do rótulo de uma `switch` instrução `case` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-265">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement’s `case` label.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="78e7d-266">Desempenho e interoperabilidade</span><span class="sxs-lookup"><span data-stu-id="78e7d-266">Performance and interop</span></span>

<span data-ttu-id="78e7d-267">Três novos recursos melhoram o suporte para a interoperabilidade nativa e bibliotecas de nível baixo que exigem alto desempenho: inteiros de tamanho nativo, ponteiros de função e omissão do `localsinit` sinalizador.</span><span class="sxs-lookup"><span data-stu-id="78e7d-267">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="78e7d-268">Inteiros de tamanho nativo `nint` e `nuint` , são tipos inteiros.</span><span class="sxs-lookup"><span data-stu-id="78e7d-268">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="78e7d-269">Eles são expressos pelos tipos subjacentes <xref:System.IntPtr?displayProperty=nameWithType> e <xref:System.UIntPtr?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="78e7d-269">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="78e7d-270">O compilador superfícies de conversões e operações adicionais para esses tipos como ints nativas.</span><span class="sxs-lookup"><span data-stu-id="78e7d-270">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="78e7d-271">Os inteiros de tamanho nativo definem propriedades para `MaxValue` ou `MinValue` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-271">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="78e7d-272">Esses valores não podem ser expressos como constantes de tempo de compilação porque dependem do tamanho nativo de um inteiro no computador de destino.</span><span class="sxs-lookup"><span data-stu-id="78e7d-272">These values can't be expressed as compile time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="78e7d-273">Esses valores são ReadOnly no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="78e7d-273">Those values are readonly at runtime.</span></span> <span data-ttu-id="78e7d-274">Você pode usar valores constantes para `nint` no intervalo [ `int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="78e7d-274">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="78e7d-275">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="78e7d-275">`int.MaxValue`].</span></span> <span data-ttu-id="78e7d-276">Você pode usar valores constantes para `nuint` no intervalo [ `uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="78e7d-276">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="78e7d-277">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="78e7d-277">`uint.MaxValue`].</span></span> <span data-ttu-id="78e7d-278">O compilador executa o dobramento constante para todos os operadores unários e binários usando os <xref:System.Int32?displayProperty=nameWithType> <xref:System.UInt32?displayProperty=nameWithType> tipos e.</span><span class="sxs-lookup"><span data-stu-id="78e7d-278">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="78e7d-279">Se o resultado não couber em 32 bits, a operação será executada em tempo de execução e não será considerada uma constante.</span><span class="sxs-lookup"><span data-stu-id="78e7d-279">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="78e7d-280">Os inteiros de tamanho nativo podem aumentar o desempenho em cenários em que a matemática de inteiros é usada extensivamente e precisa ter o desempenho mais rápido possível.</span><span class="sxs-lookup"><span data-stu-id="78e7d-280">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span>

<span data-ttu-id="78e7d-281">Ponteiros de função fornecem uma sintaxe fácil para acessar os opcodes de IL `ldftn` e `calli` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-281">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="78e7d-282">Você pode declarar ponteiros de função usando a nova `delegate_` sintaxe.</span><span class="sxs-lookup"><span data-stu-id="78e7d-282">You can declare function pointers using new `delegate_` syntax.</span></span> <span data-ttu-id="78e7d-283">Um `delegate*` tipo é um tipo de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-283">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="78e7d-284">Invocar o `delegate*` tipo usa `calli` , em contraste com um delegado que usa `callvirt` no `Invoke()` método.</span><span class="sxs-lookup"><span data-stu-id="78e7d-284">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="78e7d-285">Sintaticamente, as invocações são idênticas.</span><span class="sxs-lookup"><span data-stu-id="78e7d-285">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="78e7d-286">Invocação de ponteiro de função usa a `managed` Convenção de chamada.</span><span class="sxs-lookup"><span data-stu-id="78e7d-286">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="78e7d-287">Você adiciona a `unmanaged` palavra-chave após a `delegate*` sintaxe para declarar que deseja a `unmanaged` Convenção de chamada.</span><span class="sxs-lookup"><span data-stu-id="78e7d-287">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="78e7d-288">Outras convenções de chamada podem ser especificadas usando atributos na `delegate*` declaração.</span><span class="sxs-lookup"><span data-stu-id="78e7d-288">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span>

<span data-ttu-id="78e7d-289">Por fim, você pode adicionar o <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> para instruir o compilador a não emitir o `localsinit` sinalizador.</span><span class="sxs-lookup"><span data-stu-id="78e7d-289">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="78e7d-290">Esse sinalizador instrui o CLR a inicializar zero todas as variáveis locais.</span><span class="sxs-lookup"><span data-stu-id="78e7d-290">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="78e7d-291">O `localsinit` sinalizador tem sido o comportamento padrão para C# desde 1,0.</span><span class="sxs-lookup"><span data-stu-id="78e7d-291">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="78e7d-292">No entanto, a inicialização zero extra pode ter um impacto mensurável no desempenho em alguns cenários.</span><span class="sxs-lookup"><span data-stu-id="78e7d-292">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="78e7d-293">Em particular, quando você usa o `stackalloc` .</span><span class="sxs-lookup"><span data-stu-id="78e7d-293">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="78e7d-294">Nesses casos, você pode adicionar o <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute> .</span><span class="sxs-lookup"><span data-stu-id="78e7d-294">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="78e7d-295">Você pode adicioná-lo a um único método ou propriedade, ou a um `class` ,, `struct` `interface` ou até mesmo a um módulo.</span><span class="sxs-lookup"><span data-stu-id="78e7d-295">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="78e7d-296">Esse atributo não afeta `abstract` os métodos; ele afeta o código gerado para a implementação.</span><span class="sxs-lookup"><span data-stu-id="78e7d-296">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span>

<span data-ttu-id="78e7d-297">Esses recursos podem melhorar o desempenho em alguns cenários.</span><span class="sxs-lookup"><span data-stu-id="78e7d-297">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="78e7d-298">Eles devem ser usados somente após um parâmetro de comparação cuidadoso antes e depois da adoção.</span><span class="sxs-lookup"><span data-stu-id="78e7d-298">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="78e7d-299">O código que envolve inteiros de tamanho nativo deve ser testado em várias plataformas de destino com tamanhos de inteiro diferentes.</span><span class="sxs-lookup"><span data-stu-id="78e7d-299">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="78e7d-300">Os outros recursos exigem código não seguro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-300">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="78e7d-301">Recursos de ajuste e término</span><span class="sxs-lookup"><span data-stu-id="78e7d-301">Fit and finish features</span></span>

<span data-ttu-id="78e7d-302">Muitos dos outros recursos ajudam a escrever código com mais eficiência.</span><span class="sxs-lookup"><span data-stu-id="78e7d-302">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="78e7d-303">No C# 9,0, você pode omitir o tipo em uma [ `new` expressão](../language-reference/operators/new-operator.md) quando o tipo do objeto criado já é conhecido.</span><span class="sxs-lookup"><span data-stu-id="78e7d-303">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="78e7d-304">O uso mais comum está em declarações de campo:</span><span class="sxs-lookup"><span data-stu-id="78e7d-304">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="78e7d-305">O tipo de destino `new` também pode ser usado quando você precisa criar um novo objeto para passar como um argumento para um método.</span><span class="sxs-lookup"><span data-stu-id="78e7d-305">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="78e7d-306">Considere um `ForecastFor()` método com a seguinte assinatura:</span><span class="sxs-lookup"><span data-stu-id="78e7d-306">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="78e7d-307">Você pode chamá-lo da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="78e7d-307">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="78e7d-308">Outro bom uso para esse recurso é combiná-lo com propriedades init somente para inicializar um novo objeto:</span><span class="sxs-lookup"><span data-stu-id="78e7d-308">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="78e7d-309">Você pode retornar uma instância criada pelo construtor padrão usando uma `return new();` instrução.</span><span class="sxs-lookup"><span data-stu-id="78e7d-309">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="78e7d-310">Um recurso semelhante melhora a resolução de tipo de destino de [expressões condicionais](../language-reference/operators/conditional-operator.md).</span><span class="sxs-lookup"><span data-stu-id="78e7d-310">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="78e7d-311">Com essa alteração, as duas expressões não precisam ter uma conversão implícita de uma para a outra, mas podem ter conversões implícitas em um tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="78e7d-311">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="78e7d-312">Você provavelmente não perceberá essa alteração.</span><span class="sxs-lookup"><span data-stu-id="78e7d-312">You likely won’t notice this change.</span></span> <span data-ttu-id="78e7d-313">O que você observará é que algumas expressões condicionais que antes exigiam conversões ou que não compilaram agora só funcionam.</span><span class="sxs-lookup"><span data-stu-id="78e7d-313">What you will notice is that some conditional expressions that previously required casts or wouldn’t compile now just work.</span></span>

<span data-ttu-id="78e7d-314">A partir do C# 9,0, você pode adicionar o `static` modificador a [expressões lambda](../language-reference/operators/lambda-expressions.md) ou a [métodos anônimos](../language-reference/operators/delegate-operator.md).</span><span class="sxs-lookup"><span data-stu-id="78e7d-314">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="78e7d-315">As expressões lambda estáticas são análogas às `static` funções locais: um método lambda ou anônimo estático não pode capturar variáveis locais ou estado de instância.</span><span class="sxs-lookup"><span data-stu-id="78e7d-315">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="78e7d-316">O `static` modificador impede a captura acidental de outras variáveis.</span><span class="sxs-lookup"><span data-stu-id="78e7d-316">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="78e7d-317">Os tipos de retorno covariantes fornecem flexibilidade para os tipos de retorno dos métodos de [substituição](../language-reference/keywords/override.md) .</span><span class="sxs-lookup"><span data-stu-id="78e7d-317">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="78e7d-318">Um método override pode retornar um tipo derivado do tipo de retorno do método base substituído.</span><span class="sxs-lookup"><span data-stu-id="78e7d-318">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="78e7d-319">Isso pode ser útil para registros e outros tipos que dão suporte a métodos de clonagem ou de alocador virtual.</span><span class="sxs-lookup"><span data-stu-id="78e7d-319">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="78e7d-320">Além disso, o [ `foreach` loop](../language-reference/keywords/foreach-in.md) reconhecerá e usará um método de extensão `GetEnumerator` que, de outra forma, atende ao `foreach` padrão.</span><span class="sxs-lookup"><span data-stu-id="78e7d-320">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="78e7d-321">Essa alteração significa `foreach` ser consistente com outras construções baseadas em padrão, como o padrão assíncrono e a desconstrução baseada em padrões.</span><span class="sxs-lookup"><span data-stu-id="78e7d-321">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="78e7d-322">Na prática, essa alteração significa que você pode adicionar `foreach` suporte a qualquer tipo.</span><span class="sxs-lookup"><span data-stu-id="78e7d-322">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="78e7d-323">Você deve limitar seu uso ao ao enumerar um objeto faz sentido em seu design.</span><span class="sxs-lookup"><span data-stu-id="78e7d-323">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="78e7d-324">Em seguida, você pode usar os descartes como parâmetros para expressões lambda.</span><span class="sxs-lookup"><span data-stu-id="78e7d-324">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="78e7d-325">Essa conveniência permite que você evite nomear o argumento, e o compilador pode evitar usá-lo.</span><span class="sxs-lookup"><span data-stu-id="78e7d-325">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="78e7d-326">Você usa o `_` para qualquer argumento.</span><span class="sxs-lookup"><span data-stu-id="78e7d-326">You use the `_` for any argument.</span></span> <span data-ttu-id="78e7d-327">Para obter mais informações, consulte a seção [parâmetros de entrada de uma expressão lambda](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) do artigo [expressões lambda](../language-reference/operators/lambda-expressions.md) .</span><span class="sxs-lookup"><span data-stu-id="78e7d-327">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="78e7d-328">Por fim, agora você pode aplicar atributos a [funções locais](../programming-guide/classes-and-structs/local-functions.md).</span><span class="sxs-lookup"><span data-stu-id="78e7d-328">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="78e7d-329">Por exemplo, você pode aplicar [anotações de atributo anulável](../language-reference/attributes/nullable-analysis.md) a funções locais.</span><span class="sxs-lookup"><span data-stu-id="78e7d-329">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="78e7d-330">Suporte para geradores de código</span><span class="sxs-lookup"><span data-stu-id="78e7d-330">Support for code generators</span></span>

<span data-ttu-id="78e7d-331">Dois recursos finais dão suporte a geradores de código C#.</span><span class="sxs-lookup"><span data-stu-id="78e7d-331">Two final features support C# code generators.</span></span> <span data-ttu-id="78e7d-332">Os geradores de código C# são um componente que você pode escrever que é semelhante a um analisador de Roslyn ou a uma correção de código.</span><span class="sxs-lookup"><span data-stu-id="78e7d-332">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="78e7d-333">A diferença é que os geradores de código analisam o código e gravam novos arquivos de código-fonte como parte do processo de compilação.</span><span class="sxs-lookup"><span data-stu-id="78e7d-333">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="78e7d-334">Um gerador de código típico pesquisa código em busca de atributos ou outras convenções.</span><span class="sxs-lookup"><span data-stu-id="78e7d-334">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="78e7d-335">Um gerador de código lê atributos ou outros elementos de código usando as APIs de análise de Roslyn.</span><span class="sxs-lookup"><span data-stu-id="78e7d-335">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="78e7d-336">A partir dessas informações, ele adiciona um novo código à compilação.</span><span class="sxs-lookup"><span data-stu-id="78e7d-336">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="78e7d-337">Os geradores de origem só podem adicionar código; Eles não têm permissão para modificar nenhum código existente na compilação.</span><span class="sxs-lookup"><span data-stu-id="78e7d-337">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="78e7d-338">Os dois recursos adicionados para geradores de código são extensões para \* **sintaxe do método parcial** _ e _*_inicializadores de módulo_*_.</span><span class="sxs-lookup"><span data-stu-id="78e7d-338">The two features added for code generators are extensions to \* **partial method syntax** _, and _*_module initializers_*_.</span></span> <span data-ttu-id="78e7d-339">Primeiro, as alterações em métodos parciais.</span><span class="sxs-lookup"><span data-stu-id="78e7d-339">First, the changes to partial methods.</span></span> <span data-ttu-id="78e7d-340">Antes do C# 9,0, os métodos parciais são `private` , mas não podem especificar um modificador de acesso, ter um `void` retorno e não podem ter `out` parâmetros.</span><span class="sxs-lookup"><span data-stu-id="78e7d-340">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="78e7d-341">Essas restrições destinam-se que, se nenhuma implementação de método for fornecida, o compilador removerá todas as chamadas para o método parcial.</span><span class="sxs-lookup"><span data-stu-id="78e7d-341">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="78e7d-342">O C# 9,0 remove essas restrições, mas requer que as declarações de método parciais tenham uma implementação.</span><span class="sxs-lookup"><span data-stu-id="78e7d-342">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="78e7d-343">Os geradores de código podem fornecer essa implementação.</span><span class="sxs-lookup"><span data-stu-id="78e7d-343">Code generators can provide that implementation.</span></span> <span data-ttu-id="78e7d-344">Para evitar a introdução de uma alteração significativa, o compilador considera qualquer método parcial sem um modificador de acesso para seguir as regras antigas.</span><span class="sxs-lookup"><span data-stu-id="78e7d-344">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="78e7d-345">Se o método parcial incluir o `private` modificador de acesso, as novas regras regem esse método parcial.</span><span class="sxs-lookup"><span data-stu-id="78e7d-345">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span>

<span data-ttu-id="78e7d-346">O segundo novo recurso para geradores de código é _ \* _inicializadores de módulo_ \* \*.</span><span class="sxs-lookup"><span data-stu-id="78e7d-346">The second new feature for code generators is _\* _module initializers_ \*\*.</span></span> <span data-ttu-id="78e7d-347">Inicializadores de módulo são métodos que têm o <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> atributo anexado a eles.</span><span class="sxs-lookup"><span data-stu-id="78e7d-347">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="78e7d-348">Esses métodos serão chamados pelo tempo de execução antes de qualquer outro acesso de campo ou invocação de método dentro do módulo inteiro.</span><span class="sxs-lookup"><span data-stu-id="78e7d-348">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="78e7d-349">Um método inicializador de módulo:</span><span class="sxs-lookup"><span data-stu-id="78e7d-349">A module initializer method:</span></span>

- <span data-ttu-id="78e7d-350">Deve ser estático</span><span class="sxs-lookup"><span data-stu-id="78e7d-350">Must be static</span></span>
- <span data-ttu-id="78e7d-351">Não deve ter parâmetros</span><span class="sxs-lookup"><span data-stu-id="78e7d-351">Must be parameterless</span></span>
- <span data-ttu-id="78e7d-352">Deve retornar void</span><span class="sxs-lookup"><span data-stu-id="78e7d-352">Must return void</span></span>
- <span data-ttu-id="78e7d-353">Não deve ser um método genérico</span><span class="sxs-lookup"><span data-stu-id="78e7d-353">Must not be a generic method</span></span>
- <span data-ttu-id="78e7d-354">Não deve estar contido em uma classe genérica</span><span class="sxs-lookup"><span data-stu-id="78e7d-354">Must not be contained in a generic class</span></span>
- <span data-ttu-id="78e7d-355">Deve ser acessível do módulo que a contém</span><span class="sxs-lookup"><span data-stu-id="78e7d-355">Must be accessible from the containing module</span></span>

<span data-ttu-id="78e7d-356">Esse último ponto de marcador efetivamente significa que o método e sua classe recipiente devem ser internos ou públicos.</span><span class="sxs-lookup"><span data-stu-id="78e7d-356">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="78e7d-357">O método não pode ser uma função local.</span><span class="sxs-lookup"><span data-stu-id="78e7d-357">The method can't be a local function.</span></span>
