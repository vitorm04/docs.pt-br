---
title: Assincronia detalhada
description: Saiba como escrever código assíncrono associado à CPU ou à E/S é simples usando o modelo assíncrono baseado em tarefas do .NET.
author: cartermp
ms.author: wiwagn
ms.date: 06/20/2016
ms.technology: dotnet-standard
ms.assetid: 1e38f9d9-8f84-46ee-a15f-199aec4f2e34
ms.openlocfilehash: 0c098d0697dff3e1e772c348597a84ac9d262104
ms.sourcegitcommit: 64f4baed249341e5bf64d1385bf48e3f2e1a0211
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/07/2018
ms.locfileid: "44085310"
---
# <a name="async-in-depth"></a><span data-ttu-id="093f6-103">Assincronia detalhada</span><span class="sxs-lookup"><span data-stu-id="093f6-103">Async in depth</span></span>

<span data-ttu-id="093f6-104">Escrever código assíncrono vinculado à CPU ou à E/S é simples usando o modelo assíncrono baseado em Tarefas do .NET.</span><span class="sxs-lookup"><span data-stu-id="093f6-104">Writing I/O- and CPU-bound asynchronous code is straightforward using the .NET Task-based async model.</span></span> <span data-ttu-id="093f6-105">O modelo é exposto pelos tipos `Task` e `Task<T>` e pelas palavras-chave `async` e `await` no C# e no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="093f6-105">The model is exposed by the `Task` and `Task<T>` types and the `async` and `await` keywords in C# and Visual Basic.</span></span> <span data-ttu-id="093f6-106">(Recursos específicos a um idioma podem ser encontrados na seção [Consulte também](#see-also)). Este artigo explica como usar a assincronia do .NET e fornece informações sobre a estrutura de assincronia usada nos bastidores.</span><span class="sxs-lookup"><span data-stu-id="093f6-106">(Language-specific resources are found in the [See also](#see-also) section.) This article explains how to use .NET async and provides insight into the async framework used under the covers.</span></span>

## <a name="task-and-tasklttgt"></a><span data-ttu-id="093f6-107">Task e Task&lt;T&gt;</span><span class="sxs-lookup"><span data-stu-id="093f6-107">Task and Task&lt;T&gt;</span></span>

<span data-ttu-id="093f6-108">Tarefas são constructos usados para implementar o que é conhecido como o [modelo de promessa de simultaneidade](https://en.wikipedia.org/wiki/Futures_and_promises).</span><span class="sxs-lookup"><span data-stu-id="093f6-108">Tasks are constructs used to implement what is known as the [Promise Model of Concurrency](https://en.wikipedia.org/wiki/Futures_and_promises).</span></span>  <span data-ttu-id="093f6-109">Em resumo, elas oferecem a você uma “promessa” de que o trabalho será concluído em um momento posterior, permitindo que você coordene a promessa com uma API limpa.</span><span class="sxs-lookup"><span data-stu-id="093f6-109">In short, they offer you a "promise" that work will be completed at a later point, letting you coordinate with the promise with a clean API.</span></span>

*   <span data-ttu-id="093f6-110">`Task` representa uma única operação que não retorna um valor.</span><span class="sxs-lookup"><span data-stu-id="093f6-110">`Task` represents a single operation which does not return a value.</span></span>
*   <span data-ttu-id="093f6-111">`Task<T>` representa uma única operação que retorna um valor do tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="093f6-111">`Task<T>` represents a single operation which returns a value of type `T`.</span></span>

<span data-ttu-id="093f6-112">É importante pensar nas tarefas como abstrações do trabalho ocorrendo de maneira assíncrona e *não* uma abstração de threading.</span><span class="sxs-lookup"><span data-stu-id="093f6-112">It’s important to reason about tasks as abstractions of work happening asynchronously, and *not* an abstraction over threading.</span></span> <span data-ttu-id="093f6-113">Por padrão, as tarefas são executadas no thread atual e delegam o trabalho para o sistema operacional, conforme apropriado.</span><span class="sxs-lookup"><span data-stu-id="093f6-113">By default, tasks execute on the current thread and delegate work to the Operating System, as appropriate.</span></span> <span data-ttu-id="093f6-114">Opcionalmente, as tarefas podem ser solicitadas explicitamente para serem executadas em um thread separado por meio da API `Task.Run`.</span><span class="sxs-lookup"><span data-stu-id="093f6-114">Optionally, tasks can be explicitly requested to run on a separate thread via the `Task.Run` API.</span></span>

<span data-ttu-id="093f6-115">As tarefas expõem um protocolo de API para monitoramento, aguardando e acessando o valor do resultado (no caso de `Task<T>`) de uma tarefa.</span><span class="sxs-lookup"><span data-stu-id="093f6-115">Tasks expose an API protocol for monitoring, waiting upon and accessing the result value (in the case of `Task<T>`) of a task.</span></span> <span data-ttu-id="093f6-116">A integração de linguagem, com a palavra-chave `await`, fornece uma abstração de nível mais alto para o uso de tarefas.</span><span class="sxs-lookup"><span data-stu-id="093f6-116">Language integration, with the `await` keyword, provides a higher-level abstraction for using tasks.</span></span> 

<span data-ttu-id="093f6-117">O uso de `await` permite que seu aplicativo ou serviço realize um trabalho útil enquanto uma tarefa estiver em execução gerando o controle para seu chamador até que a tarefa seja concluída.</span><span class="sxs-lookup"><span data-stu-id="093f6-117">Using `await` allows your application or service to perform useful work while a task is running by yielding control to its caller until the task is done.</span></span> <span data-ttu-id="093f6-118">Seu código não precisa contar com retornos de chamada ou eventos para continuar a execução após a tarefa ter sido concluída.</span><span class="sxs-lookup"><span data-stu-id="093f6-118">Your code does not need to rely on callbacks or events to continue execution after the task has been completed.</span></span> <span data-ttu-id="093f6-119">A integração da API da tarefa e da linguagem faz isso para você.</span><span class="sxs-lookup"><span data-stu-id="093f6-119">The language and task API integration does that for you.</span></span> <span data-ttu-id="093f6-120">Se você estiver usando `Task<T>`, a palavra-chave `await` "desencapsulará" adicionalmente o valor retornado quando a Tarefa for concluída.</span><span class="sxs-lookup"><span data-stu-id="093f6-120">If you’re using `Task<T>`, the `await` keyword will additionally "unwrap" the value returned when the Task is complete.</span></span>  <span data-ttu-id="093f6-121">Os detalhes de como isso funciona são explicados mais abaixo.</span><span class="sxs-lookup"><span data-stu-id="093f6-121">The details of how this works are explained further below.</span></span>

<span data-ttu-id="093f6-122">Você pode aprender mais sobre as tarefas e as diferentes maneiras de interagir com elas no tópico [Padrão assíncrono baseado em tarefa (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="093f6-122">You can learn more about tasks and the different ways to interact with them in the [Task-based Asynchronous Pattern (TAP)](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md) topic.</span></span>

## <a name="deeper-dive-into-tasks-for-an-io-bound-operation"></a><span data-ttu-id="093f6-123">Aprofundamento em tarefas para uma operação vinculada à E/S</span><span class="sxs-lookup"><span data-stu-id="093f6-123">Deeper Dive into Tasks for an I/O-Bound Operation</span></span>

<span data-ttu-id="093f6-124">A seção a seguir descreve uma exibição de 10.000 pés do que acontece com uma chamada de E/S assíncrona típica.</span><span class="sxs-lookup"><span data-stu-id="093f6-124">The following section describes a 10,000 foot view of what happens with a typical async I/O call.</span></span> <span data-ttu-id="093f6-125">Vamos começar com alguns exemplos.</span><span class="sxs-lookup"><span data-stu-id="093f6-125">Let's start with a couple examples.</span></span>

<span data-ttu-id="093f6-126">O primeiro exemplo chama um método assíncrono e retorna uma tarefa ativa, provavelmente ainda para ser concluída.</span><span class="sxs-lookup"><span data-stu-id="093f6-126">The first example calls an async method and returns an active task, likely yet to complete.</span></span>

```csharp
public Task<string> GetHtmlAsync()
{
    // Execution is synchronous here
    var client = new HttpClient();
    
    return client.GetStringAsync("http://www.dotnetfoundation.org");
}
```

<span data-ttu-id="093f6-127">O segundo exemplo adiciona o uso das palavras-chave `async` e `await` para operar na tarefa.</span><span class="sxs-lookup"><span data-stu-id="093f6-127">The second example adds the use of the `async` and `await` keywords to operate on the task.</span></span>

```csharp
public async Task<string> GetFirstCharactersCountAsync(string url, int count)
{
    // Execution is synchronous here
    var client = new HttpClient();
    
    // Execution of GetFirstCharactersCountAsync() is yielded to the caller here
    // GetStringAsync returns a Task<string>, which is *awaited*
    var page = await client.GetStringAsync("http://www.dotnetfoundation.org");
    
    // Execution resumes when the client.GetStringAsync task completes,
    // becoming synchronous again.
    
    if (count > page.Length)
    {
        return page;
    }
    else
    {
        return page.Substring(0, count);
    }
}
```

<span data-ttu-id="093f6-128">A chamada para `GetStringAsync()` realiza a chamada por bibliotecas .NET de níveis inferiores (talvez chamando outros métodos assíncronos) até atingir uma chamada de interoperabilidade P/Invoke em uma biblioteca de rede nativa.</span><span class="sxs-lookup"><span data-stu-id="093f6-128">The call to `GetStringAsync()` calls through lower-level .NET libraries (perhaps calling other async methods) until it reaches a P/Invoke interop call into a native networking library.</span></span> <span data-ttu-id="093f6-129">A biblioteca nativa pode chamar subsequentemente uma chamada à API do sistema (como `write()` para um soquete no Linux).</span><span class="sxs-lookup"><span data-stu-id="093f6-129">The native library may subsequently call into a System API call (such as `write()` to a socket on Linux).</span></span> <span data-ttu-id="093f6-130">Um objeto de tarefa será criado no limite nativo/gerenciado, possivelmente usando [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span><span class="sxs-lookup"><span data-stu-id="093f6-130">A task object will be created at the native/managed boundary, possibly using [TaskCompletionSource](xref:System.Threading.Tasks.TaskCompletionSource%601.SetResult(%600)).</span></span> <span data-ttu-id="093f6-131">O objeto de tarefa será passado pelas camadas, possivelmente operado ou retornado diretamente, finalmente retornado ao chamador inicial.</span><span class="sxs-lookup"><span data-stu-id="093f6-131">The task object will be passed up through the layers, possibly operated on or directly returned, eventually returned to the initial caller.</span></span> 

<span data-ttu-id="093f6-132">No segundo exemplo acima, um objeto `Task<T>` será retornado de `GetStringAsync`.</span><span class="sxs-lookup"><span data-stu-id="093f6-132">In the second example above, a `Task<T>` object will be returned from `GetStringAsync`.</span></span> <span data-ttu-id="093f6-133">O uso da palavra-chave `await` faz com que o método retorne um objeto de tarefa recém-criado.</span><span class="sxs-lookup"><span data-stu-id="093f6-133">The use of the `await` keyword causes the method to return a newly created task object.</span></span> <span data-ttu-id="093f6-134">O controle retorna para o chamador desse local no método `GetFirstCharactersCountAsync`.</span><span class="sxs-lookup"><span data-stu-id="093f6-134">Control returns to the caller from this location in the `GetFirstCharactersCountAsync` method.</span></span> <span data-ttu-id="093f6-135">Os métodos e propriedades do objeto [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) permitem que os chamadores monitorem o progresso da tarefa, que será concluída quando o código restante em GetFirstCharactersCountAsync for executado.</span><span class="sxs-lookup"><span data-stu-id="093f6-135">The methods and properties of the [Task&lt;T&gt;](xref:System.Threading.Tasks.Task%601) object enable callers to monitor the progress of the task, which will complete when the remaining code in GetFirstCharactersCountAsync has executed.</span></span>

<span data-ttu-id="093f6-136">Após a chamada à API do sistema, a solicitação está no espaço de kernel, trilhando seu caminho para o subsistema de rede do sistema operacional (como `/net` no Kernel do Linux).</span><span class="sxs-lookup"><span data-stu-id="093f6-136">After the System API call, the request is now in kernel space, making its way to the networking subsystem of the OS (such as `/net` in the Linux Kernel).</span></span>  <span data-ttu-id="093f6-137">Aqui, o sistema operacional tratará a solicitação de rede *assincronamente*.</span><span class="sxs-lookup"><span data-stu-id="093f6-137">Here the OS will handle the networking request *asynchronously*.</span></span>  <span data-ttu-id="093f6-138">Os detalhes podem ser diferentes dependendo do sistema operacional usado (a chamada de driver de dispositivo pode ser agendada como um sinal enviado de volta para o tempo de execução ou pode ser feita uma chamada de driver de dispositivo e *em seguida,* um sinal enviado de volta), mas, no fim, o tempo de execução será informado de que a solicitação de rede está em andamento.</span><span class="sxs-lookup"><span data-stu-id="093f6-138">Details may be different depending on the OS used (the device driver call may be scheduled as a signal sent back to the runtime, or a device driver call may be made and *then* a signal sent back), but eventually the runtime will be informed that the networking request is in progress.</span></span>  <span data-ttu-id="093f6-139">Neste momento, o trabalho para o driver de dispositivo estará agendado, em andamento ou já finalizado (a solicitação já está “durante a transmissão”), mas como tudo isso está ocorrendo assincronamente, o driver do dispositivo pode manipular outra coisa imediatamente.</span><span class="sxs-lookup"><span data-stu-id="093f6-139">At this time, the work for the device driver will either be scheduled, in-progress, or already finished (the request is already out "over the wire") - but because this is all happening asynchronously, the device driver is able to immediately handle something else!</span></span>

<span data-ttu-id="093f6-140">Por exemplo, no Windows, um thread de sistema operacional faz uma chamada para o driver de dispositivo de rede e solicita que ele realize a operação de rede por meio de um IRP (Pacote de Solicitação de Interrupção), que representa a operação.</span><span class="sxs-lookup"><span data-stu-id="093f6-140">For example, in Windows an OS thread makes a call to the network device driver and asks it to perform the networking operation via an Interrupt Request Packet (IRP) which represents the operation.</span></span>  <span data-ttu-id="093f6-141">O driver de dispositivo recebe o IRP, faz a chamada para a rede, marca o IRP como "pendente" e retorna para o sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="093f6-141">The device driver receives the IRP, makes the call to the network, marks the IRP as "pending", and returns back to the OS.</span></span>  <span data-ttu-id="093f6-142">Como o thread do sistema operacional agora sabe que o IRP está "pendente", ele não tem mais nenhum trabalho para fazer para esse trabalho e “retorna” para que possa ser usado para realizar outro trabalho.</span><span class="sxs-lookup"><span data-stu-id="093f6-142">Because the OS thread now knows that the IRP is "pending", it doesn't have any more work to do for this job and "returns" back so that it can be used to perform other work.</span></span>

<span data-ttu-id="093f6-143">Quando a solicitação é atendida e os dados voltam por meio do driver de dispositivo, ele notifica a CPU sobre os novos dados recebidos por meio de uma interrupção.</span><span class="sxs-lookup"><span data-stu-id="093f6-143">When the request is fulfilled and data comes back through the device driver, it notifies the CPU of new data received via an interrupt.</span></span>  <span data-ttu-id="093f6-144">Como essa interrupção é tratada variará dependendo do sistema operacional, mas, no fim, os dados serão passados pelo sistema operacional até atingirem uma chamada de interoperabilidade do sistema (por exemplo, no Linux um manipulador de interrupção agendará a metade inferior da IRQ para passar os dados pelo sistema operacional assincronamente).</span><span class="sxs-lookup"><span data-stu-id="093f6-144">How this interrupt gets handled will vary depending on the OS, but eventually the data will be passed through the OS until it reaches a system interop call (for example, in Linux an interrupt handler will schedule the bottom half of the IRQ to pass the data up through the OS asynchronously).</span></span>  <span data-ttu-id="093f6-145">Observe que isso *também* ocorre assincronamente.</span><span class="sxs-lookup"><span data-stu-id="093f6-145">Note that this *also* happens asynchronously!</span></span>  <span data-ttu-id="093f6-146">O resultado é colocado na fila até que o próximo thread disponível possa executar o método assíncrono e “desencapsular” o resultado da tarefa concluída.</span><span class="sxs-lookup"><span data-stu-id="093f6-146">The result is queued up until the next available thread is able execute the async method and "unwrap" the result of the completed task.</span></span>

<span data-ttu-id="093f6-147">Durante todo esse processo, uma consideração importante é que **nenhum thread é dedicado a executar a tarefa**.</span><span class="sxs-lookup"><span data-stu-id="093f6-147">Throughout this entire process, a key takeaway is that **no thread is dedicated to running the task**.</span></span>  <span data-ttu-id="093f6-148">Embora o trabalho seja executado em algum contexto (ou seja, o sistema operacional tem de passar os dados para um driver de dispositivo e responder a uma interrupção), nenhum thread é dedicado a *esperar* os dados da solicitação voltarem.</span><span class="sxs-lookup"><span data-stu-id="093f6-148">Although work is executed in some context (that is, the OS does have to pass data to a device driver and respond to an interrupt), there is no thread dedicated to *waiting* for data from the request to come back.</span></span>  <span data-ttu-id="093f6-149">Isso permite que o sistema lide com um volume muito maior de trabalho em vez de esperar que alguma chamada de E/S seja concluída.</span><span class="sxs-lookup"><span data-stu-id="093f6-149">This allows the system to handle a much larger volume of work rather than waiting for some I/O call to finish.</span></span>

<span data-ttu-id="093f6-150">Embora o descrito acima possa parecer muito trabalho a ser feito, quando medido em termos de tempo total, ele é minúsculo em comparação com o tempo necessário para realizar o trabalho real de E/S.</span><span class="sxs-lookup"><span data-stu-id="093f6-150">Although the above may seem like a lot of work to be done, when measured in terms of wall clock time, it’s miniscule compared to the time it takes to do the actual I/O work.</span></span> <span data-ttu-id="093f6-151">Embora não seja precisa, uma linha do tempo possível para essa chamada teria esta aparência:</span><span class="sxs-lookup"><span data-stu-id="093f6-151">Although not at all precise, a potential timeline for such a call would look like this:</span></span>

<span data-ttu-id="093f6-152">0-1————————————————————————————————————————————————–2-3</span><span class="sxs-lookup"><span data-stu-id="093f6-152">0-1————————————————————————————————————————————————–2-3</span></span>

*   <span data-ttu-id="093f6-153">O tempo gasto dos pontos `0` até `1` é tudo até um método assíncrono gerar o controle para seu chamador.</span><span class="sxs-lookup"><span data-stu-id="093f6-153">Time spent from points `0` to `1` is everything up until an async method yields control to its caller.</span></span>
*   <span data-ttu-id="093f6-154">O tempo gasto dos pontos `1` até `2` é o tempo gasto na E/S, sem custo de CPU.</span><span class="sxs-lookup"><span data-stu-id="093f6-154">Time spent from points `1` to `2` is the time spent on I/O, with no CPU cost.</span></span>
*   <span data-ttu-id="093f6-155">Por fim, o tempo gasto dos pontos `2` até `3` está passando o controle de volta (e potencialmente um valor) para o método assíncrono, ponto no qual está sendo executado novamente.</span><span class="sxs-lookup"><span data-stu-id="093f6-155">Finally, time spent from points `2` to `3` is passing control back (and potentially a value) to the async method, at which point it is executing again.</span></span>

### <a name="what-does-this-mean-for-a-server-scenario"></a><span data-ttu-id="093f6-156">O que isso significa para um cenário de servidor?</span><span class="sxs-lookup"><span data-stu-id="093f6-156">What does this mean for a server scenario?</span></span>

<span data-ttu-id="093f6-157">Esse modelo funciona bem com uma carga de trabalho de cenário de servidor típica.</span><span class="sxs-lookup"><span data-stu-id="093f6-157">This model works well with a typical server scenario workload.</span></span>  <span data-ttu-id="093f6-158">Como não há nenhum thread dedicado para bloquear tarefas não concluídas, o pool de threads do servidor pode atender a um volume muito maior de solicitações da Web.</span><span class="sxs-lookup"><span data-stu-id="093f6-158">Because there are no threads dedicated to blocking on unfinished tasks, the server threadpool can service a much higher volume of web requests.</span></span>

<span data-ttu-id="093f6-159">Considere dois servidores: um que executa o código assíncrono e que não faz isso.</span><span class="sxs-lookup"><span data-stu-id="093f6-159">Consider two servers: one that runs async code, and one that does not.</span></span>  <span data-ttu-id="093f6-160">Para esse exemplo, cada servidor tem apenas cinco threads disponíveis para solicitações de serviço.</span><span class="sxs-lookup"><span data-stu-id="093f6-160">For the purpose of this example, each server only has 5 threads available to service requests.</span></span>  <span data-ttu-id="093f6-161">Observe que esses números são imaginariamente pequenos e servem apenas em um contexto de demonstração.</span><span class="sxs-lookup"><span data-stu-id="093f6-161">Note that these numbers are imaginarily small and serve only in a demonstrative context.</span></span>

<span data-ttu-id="093f6-162">Suponha que ambos os servidores recebem seis solicitações simultâneas.</span><span class="sxs-lookup"><span data-stu-id="093f6-162">Assume both servers receive 6 concurrent requests.</span></span> <span data-ttu-id="093f6-163">Cada solicitação executa uma operação de E/S.</span><span class="sxs-lookup"><span data-stu-id="093f6-163">Each request performs an I/O operation.</span></span>  <span data-ttu-id="093f6-164">O servidor *sem* o código assíncrono precisa enfileirar a sexta solicitação até que um dos cinco threads tenham concluído o trabalho vinculado à E/S e escrito uma resposta.</span><span class="sxs-lookup"><span data-stu-id="093f6-164">The server *without* async code has to queue up the 6th request until one of the 5 threads have finished the I/O-bound work and written a response.</span></span> <span data-ttu-id="093f6-165">No ponto em que a 20ª solicitação chega, o servidor pode começar a ficar lento, pois a fila está ficando muito longa.</span><span class="sxs-lookup"><span data-stu-id="093f6-165">At the point that the 20th request comes in, the server might start to slow down, because the queue is getting too long.</span></span>

<span data-ttu-id="093f6-166">O servidor *com* o código assíncrono em execução ainda enfileira a sexta solicitação, mas como ele usa `async` e `await`, cada um de seus threads é liberado quando o trabalho vinculado à E/S começa, em vez de quando ele é concluído.</span><span class="sxs-lookup"><span data-stu-id="093f6-166">The server *with* async code running on it still queues up the 6th request, but because it uses `async` and `await`, each of its threads are freed up when the I/O-bound work starts, rather than when it finishes.</span></span>  <span data-ttu-id="093f6-167">No momento em que a 20ª solicitação chega, a fila para as solicitações recebidas é muito menor (se ela tiver algo em absoluto) e o servidor não fica lento.</span><span class="sxs-lookup"><span data-stu-id="093f6-167">By the time the 20th request comes in, the queue for incoming requests will be far smaller (if it has anything in it at all), and the server won't slow down.</span></span>

<span data-ttu-id="093f6-168">Embora esse seja um exemplo inventado, ele funciona de maneira muito semelhante no mundo real.</span><span class="sxs-lookup"><span data-stu-id="093f6-168">Although this is a contrived example, it works in a very similar fashion in the real world.</span></span>  <span data-ttu-id="093f6-169">Na verdade, você pode esperar que um servidor seja capaz de lidar com uma ordem de grandeza de mais solicitações usando `async` e `await` do que se ele estivesse dedicando um thread para cada solicitação recebida.</span><span class="sxs-lookup"><span data-stu-id="093f6-169">In fact, you can expect a server to be able to handle an order of magnitude more requests using `async` and `await` than if it were dedicating a thread for each request it receives.</span></span>

### <a name="what-does-this-mean-for-client-scenario"></a><span data-ttu-id="093f6-170">O que isso significa para um cenário de cliente?</span><span class="sxs-lookup"><span data-stu-id="093f6-170">What does this mean for client scenario?</span></span>

<span data-ttu-id="093f6-171">O maior ganho do uso do `async` e `await` para um aplicativo cliente é um aumento na capacidade de resposta.</span><span class="sxs-lookup"><span data-stu-id="093f6-171">The biggest gain for using `async` and `await` for a client app is an increase in responsiveness.</span></span>  <span data-ttu-id="093f6-172">Embora você possa fazer um aplicativo responsivo gerando threads manualmente, o ato de gerar um thread é uma operação cara em relação a apenas usar o `async` e `await`.</span><span class="sxs-lookup"><span data-stu-id="093f6-172">Although you can make an app responsive by spawning threads manually, the act of spawning a thread is an expensive operation relative to just using `async` and `await`.</span></span>  <span data-ttu-id="093f6-173">Especialmente para algo como um jogo para dispositivos móveis, afetar o thread da interface do usuário o mínimo possível no que concerne à E/S é crucial.</span><span class="sxs-lookup"><span data-stu-id="093f6-173">Especially for something like a mobile game, impacting the UI thread as little as possible where I/O is concerned is crucial.</span></span>

<span data-ttu-id="093f6-174">Mais importante, como o trabalho vinculado à E/S passa praticamente nenhum tempo na CPU, dedicar um thread de CPU inteiro para realizar quase nenhum trabalho útil seria um uso inadequado dos recursos.</span><span class="sxs-lookup"><span data-stu-id="093f6-174">More importantly, because I/O-bound work spends virtually no time on the CPU, dedicating an entire CPU thread to perform barely any useful work would be a poor use of resources.</span></span>

<span data-ttu-id="093f6-175">Além disso, distribuir o trabalho para o thread de interface do usuário (como atualizar uma interface do usuário) é muito simples com os métodos `async` e não requer trabalho extra (como chamar um delegado thread-safe).</span><span class="sxs-lookup"><span data-stu-id="093f6-175">Additionally, dispatching work to the UI thread (such as updating a UI) is very simple with `async` methods, and does not require extra work (such as calling a thread-safe delegate).</span></span>

## <a name="deeper-dive-into-task-and-tasklttgt-for-a-cpu-bound-operation"></a><span data-ttu-id="093f6-176">Aprofundamento em Task e Task&lt;T&gt; para uma operação vinculada à CPU</span><span class="sxs-lookup"><span data-stu-id="093f6-176">Deeper Dive into Task and Task&lt;T&gt; for a CPU-Bound Operation</span></span>

<span data-ttu-id="093f6-177">O código `async` vinculado à CPU é um pouco diferente do código `async` vinculado à E/S.</span><span class="sxs-lookup"><span data-stu-id="093f6-177">CPU-bound `async` code is a bit different than I/O-bound `async` code.</span></span>  <span data-ttu-id="093f6-178">Como o trabalho é feito na CPU, não há como contornar a dedicação de um thread à computação.</span><span class="sxs-lookup"><span data-stu-id="093f6-178">Because the work is done on the CPU, there's no way to get around dedicating a thread to the computation.</span></span>  <span data-ttu-id="093f6-179">O uso de `async` e `await` fornece uma maneira simples de interagir com thread em segundo plano e manter o chamador do método assíncrono responsivo.</span><span class="sxs-lookup"><span data-stu-id="093f6-179">The use of `async` and `await` provides you with a clean way to interact with a background thread and keep the caller of the async method responsive.</span></span>  <span data-ttu-id="093f6-180">Observe que isso não fornece nenhuma proteção para dados compartilhados.</span><span class="sxs-lookup"><span data-stu-id="093f6-180">Note that this does not provide any protection for shared data.</span></span>  <span data-ttu-id="093f6-181">Se você estiver usando dados compartilhados, ainda precisará aplicar uma estratégia de sincronização apropriada.</span><span class="sxs-lookup"><span data-stu-id="093f6-181">If you are using shared data, you will still need to apply an appropriate synchronization strategy.</span></span>

<span data-ttu-id="093f6-182">Esta é uma exibição de 10.000 pés de uma chamada assíncrona vinculada à CPU:</span><span class="sxs-lookup"><span data-stu-id="093f6-182">Here's a 10,000 foot view of a CPU-bound async call:</span></span>

```csharp
public async Task<int> CalculateResult(InputData data)
{
    // This queues up the work on the threadpool.
    var expensiveResultTask = Task.Run(() => DoExpensiveCalculation(data));
    
    // Note that at this point, you can do some other work concurrently,
    // as CalculateResult() is still executing!
    
    // Execution of CalculateResult is yielded here!
    var result = await expensiveResultTask;
    
    return result;
}
```

<span data-ttu-id="093f6-183">`CalculateResult()` executa no thread no qual foi chamado.</span><span class="sxs-lookup"><span data-stu-id="093f6-183">`CalculateResult()` executes on the thread it was called on.</span></span>  <span data-ttu-id="093f6-184">Quando ele chama `Task.Run`, coloca na fila cara operação vinculada à CPU, `DoExpensiveCalculation()`, no pool de threads e recebe um identificador `Task<int>`.</span><span class="sxs-lookup"><span data-stu-id="093f6-184">When it calls `Task.Run`, it queues the expensive CPU-bound operation, `DoExpensiveCalculation()`, on the thread pool and receives a `Task<int>` handle.</span></span>  <span data-ttu-id="093f6-185">`DoExpensiveCalculation()` é finalmente executado simultaneamente no próximo thread disponível, provavelmente em outro núcleo da CPU.</span><span class="sxs-lookup"><span data-stu-id="093f6-185">`DoExpensiveCalculation()` is eventually run concurrently on the next available thread, likely on another CPU core.</span></span>  <span data-ttu-id="093f6-186">É possível fazer o trabalho simultâneo enquanto `DoExpensiveCalculation()` está ocupado em outro thread, pois o thread que chamou `CalculateResult()` ainda está em execução.</span><span class="sxs-lookup"><span data-stu-id="093f6-186">It's possible to do concurrent work while `DoExpensiveCalculation()` is busy on another thread, because the thread which called `CalculateResult()` is still executing.</span></span>

<span data-ttu-id="093f6-187">Uma vez que `await` é encontrado, a execução de `CalculateResult()` é gerada para seu chamador, permitindo que outro trabalho seja realizado com o thread atual enquanto `DoExpensiveCalculation()` está produzindo um resultado.</span><span class="sxs-lookup"><span data-stu-id="093f6-187">Once `await` is encountered, the execution of `CalculateResult()` is yielded to its caller, allowing other work to be done with the current thread while `DoExpensiveCalculation()` is churning out a result.</span></span>  <span data-ttu-id="093f6-188">Ao terminar, o resultado é enfileirado para ser executado no thread principal.</span><span class="sxs-lookup"><span data-stu-id="093f6-188">Once it has finished, the result is queued up to run on the main thread.</span></span>  <span data-ttu-id="093f6-189">No fim, o thread principal retornará para a execução de `CalculateResult()`, ponto em que ele terá o resultado de `DoExpensiveCalculation()`.</span><span class="sxs-lookup"><span data-stu-id="093f6-189">Eventually, the main thread will return to executing `CalculateResult()`, at which point it will have the result of `DoExpensiveCalculation()`.</span></span>

### <a name="why-does-async-help-here"></a><span data-ttu-id="093f6-190">Por que a assincronia ajuda aqui?</span><span class="sxs-lookup"><span data-stu-id="093f6-190">Why does async help here?</span></span>

<span data-ttu-id="093f6-191">`async` e `await` são a melhor prática para gerenciar o trabalho vinculado à CPU quando você precisar de capacidade de resposta.</span><span class="sxs-lookup"><span data-stu-id="093f6-191">`async` and `await` are the best practice managing CPU-bound work when you need responsiveness.</span></span> <span data-ttu-id="093f6-192">Existem vários padrões para usar a assincronia com o trabalho vinculado à CPU.</span><span class="sxs-lookup"><span data-stu-id="093f6-192">There are multiple patterns for using async with CPU-bound work.</span></span> <span data-ttu-id="093f6-193">É importante observar que há um pequeno custo para usar a assincronia e não é recomendado para loops estreitos.</span><span class="sxs-lookup"><span data-stu-id="093f6-193">It's important to note that there is a small cost to using async and it's not recommended for tight loops.</span></span>  <span data-ttu-id="093f6-194">Cabe a você determinar como escrever seu código em torno dessa nova capacidade.</span><span class="sxs-lookup"><span data-stu-id="093f6-194">It's up to you to determine how you write your code around this new capability.</span></span>

## <a name="see-also"></a><span data-ttu-id="093f6-195">Consulte também</span><span class="sxs-lookup"><span data-stu-id="093f6-195">See also</span></span>

* [<span data-ttu-id="093f6-196">Programação assíncrona em C#</span><span class="sxs-lookup"><span data-stu-id="093f6-196">Asynchronous programming in C#</span></span>](~/docs/csharp/async.md)   
* [<span data-ttu-id="093f6-197">Programação assíncrona com async e await (C#)</span><span class="sxs-lookup"><span data-stu-id="093f6-197">Asynchronous programming with async and await (C#)</span></span>](../csharp/programming-guide/concepts/async/index.md)  
* [<span data-ttu-id="093f6-198">Programação assíncrona em F#</span><span class="sxs-lookup"><span data-stu-id="093f6-198">Async Programming in F#</span></span>](~/docs/fsharp/tutorials/asynchronous-and-concurrent-programming/async.md)   
* [<span data-ttu-id="093f6-199">Programação assíncrona com Async e Await (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="093f6-199">Asynchronous Programming with Async and Await (Visual Basic)</span></span>](~/docs/visual-basic/programming-guide/concepts/async/index.md)
