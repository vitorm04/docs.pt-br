---
title: Detalhes do comportamento de expressões regulares
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET Framework regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
author: rpetrusha
ms.author: ronpet
ms.openlocfilehash: bd0611cc8a6d257192b389b023c4dcda8f1b7ec3
ms.sourcegitcommit: 2701302a99cafbe0d86d53d540eb0fa7e9b46b36
ms.translationtype: HT
ms.contentlocale: pt-BR
ms.lasthandoff: 04/28/2019
ms.locfileid: "64634415"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="1bcb6-102">Detalhes do comportamento de expressões regulares</span><span class="sxs-lookup"><span data-stu-id="1bcb6-102">Details of Regular Expression Behavior</span></span>
<span data-ttu-id="1bcb6-103">O mecanismo de expressões regulares do .NET Framework é um correspondente de expressão regular de retrocesso que incorpora um mecanismo de NFA (Automação Finita Não Determinística) tradicional, como o usado pelo Perl, Python, Emacs e Tcl.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-103">The .NET Framework regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="1bcb6-104">Isso o distingue de mecanismos de DFA (Autômato finito determinístico) de expressões regulares puras mais rápidos, porém mais limitados, como os encontrados em awk, egrep ou lex.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="1bcb6-105">Também o distingue de NFAs POSIX padronizados, porém mais lentos.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="1bcb6-106">A seção a seguir descreve os três tipos de mecanismos de expressões regulares e explica por que as expressões regulares no .NET Framework são implementadas usando um mecanismo de NFA tradicional.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-106">The following section describes the three types of regular expression engines, and explains why regular expressions in the .NET Framework are implemented by using a traditional NFA engine.</span></span>  
  
## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="1bcb6-107">Benefícios do mecanismo de NFA</span><span class="sxs-lookup"><span data-stu-id="1bcb6-107">Benefits of the NFA Engine</span></span>  
 <span data-ttu-id="1bcb6-108">Quando mecanismos de DFA executam a correspondência de padrões, a ordem de processamento é orientada pela cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="1bcb6-109">O mecanismo começa no início da cadeia de caracteres de entrada e continua sequencialmente para determinar se o próximo caractere corresponde ao padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="1bcb6-110">Podem assegurar uma correspondência com a cadeia de caracteres mais longa possível.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="1bcb6-111">Como nunca testam o mesmo caractere duas vezes, os mecanismos de DFA não dão suporte ao retrocesso.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="1bcb6-112">No entanto, como um mecanismo de DFA contém somente o estado finito, não pode corresponder a um padrão com referências inversas; além disso, uma vez que não constrói uma expansão explícita, não pode capturar subexpressões.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>  
  
 <span data-ttu-id="1bcb6-113">Ao contrário de mecanismos de DFA, quando mecanismos de NFA tradicionais executam a correspondência de padrões, a ordem de processamento é orientada pelo padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="1bcb6-114">Como processa um elemento de linguagem específico, o mecanismo usa a correspondência Greedy; ou seja, corresponde à maior parte possível da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="1bcb6-115">Contudo, também consegue salvar seu estado correspondendo a uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="1bcb6-116">Se uma correspondência falhar, o mecanismo poderá retornar para um estado salvo a fim de tentar correspondências adicionais.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="1bcb6-117">Esse processo de abandonar uma correspondência de subexpressão bem-sucedida para que elementos de linguagem posteriores na expressão regular também possam corresponder é conhecido como *retrocesso*.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking*.</span></span> <span data-ttu-id="1bcb6-118">Os mecanismos de NFA usam o retrocesso para testar todas as possíveis expansões de uma expressão regular em uma ordem específica e aceitam a primeira correspondência.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="1bcb6-119">Como um mecanismo de NFA tradicional constrói uma expansão específica da expressão regular para uma correspondência de sucesso, pode capturar correspondências de subexpressões e referências inversas correspondentes.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="1bcb6-120">Entretanto, como um NFA tradicional retrocede, pode visitar o mesmo estado diversas vezes se chegar no estado por diferentes caminhos.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="1bcb6-121">Como resultado, pode executar de modo exponencial lentamente na pior das hipóteses.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="1bcb6-122">Já que um mecanismo de NFA tradicional aceita a primeira correspondência que encontra, também pode deixar outras correspondências (possivelmente mais longas) não descobertas.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>  
  
 <span data-ttu-id="1bcb6-123">Os mecanismos de NFA POSIX são como mecanismos de NFA tradicionais, exceto pelo fato de continuarem retrocedendo até poderem assegurar que encontraram a correspondência mais longa possível.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="1bcb6-124">Como resultado, um mecanismo de NFA POSIX é mais lento do que um mecanismo de NFA tradicional; quando você usa um mecanismo de NFA POSIX, não pode favorecer uma correspondência menor em detrimento de uma maior alterando a ordem da pesquisa de retrocesso.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>  
  
 <span data-ttu-id="1bcb6-125">Os mecanismos de NFA tradicionais são favorecidos por programadores porque oferecem maior controle sobre a correspondência da cadeia de caracteres do que mecanismos de DFA ou NFA POSIX.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="1bcb6-126">Embora, na pior das hipóteses, possam ser executados mais lentamente, você pode orientá-los para encontrar correspondências em tempo linear ou polinomial usando padrões que reduzem ambiguidades e limitam o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="1bcb6-127">Em outras palavras, apesar de os mecanismos de NFA trocarem o desempenho por força e flexibilidade, na maioria dos casos, eles oferecem um desempenho bom ou aceitável se uma expressão regular for bem escrita e evitar casos em que o retrocesso degrada o desempenho exponencialmente.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well-written and avoids cases in which backtracking degrades performance exponentially.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="1bcb6-128">Para obter informações sobre a penalidade de desempenho causada por retrocesso excessivo e maneiras de criar uma expressão regular para solucioná-lo, consulte [Retrocesso](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](../../../docs/standard/base-types/backtracking-in-regular-expressions.md).</span></span>  
  
## <a name="net-framework-engine-capabilities"></a><span data-ttu-id="1bcb6-129">Recursos do mecanismo do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="1bcb6-129">.NET Framework Engine Capabilities</span></span>  
 <span data-ttu-id="1bcb6-130">Para tirar proveito dos benefícios de um mecanismo de NFA tradicional, o mecanismo de expressões regulares do .NET Framework inclui um conjunto completo de constructos para permitir que os programadores conduzam o mecanismo de retrocesso.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-130">To take advantage of the benefits of a traditional NFA engine, the .NET Framework regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="1bcb6-131">Tais constructos podem ser usados para encontrar correspondências mais rapidamente ou favorecer expansões específicas em detrimento de outras.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>  
  
 <span data-ttu-id="1bcb6-132">Outros recursos do mecanismo de expressões regulares do .NET Framework incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="1bcb6-132">Other features of the .NET Framework regular expression engine include the following:</span></span>  
  
- <span data-ttu-id="1bcb6-133">Quantificadores lentos: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="1bcb6-134">Esses constructos instruem o mecanismo de retrocesso a pesquisar o número mínimo de repetições primeiro.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="1bcb6-135">Por outro lado, quantificadores Greedy comuns tentam corresponder ao número máximo de repetições primeiro.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="1bcb6-136">O exemplo a seguir mostra a diferença entre os dois.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="1bcb6-137">Uma expressão regular corresponde a uma frase que termina em um número e um grupo de captura deve extrair esse número.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="1bcb6-138">A expressão regular `.+(\d+)\.` inclui o quantificador Greedy `.+`, que faz com que o mecanismo de expressões regulares capture o último dígito do número.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="1bcb6-139">Por outro lado, a expressão regular `.+?(\d+)\.` inclui o quantificador lento `.+?`, que faz com que o mecanismo de expressões regulares capture o número inteiro.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]  
  
     <span data-ttu-id="1bcb6-140">As versões Greedy e lenta dessa expressão regular são definidas como mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-140">The greedy and lazy versions of this regular expression are defined as shown in the following table.\`</span></span>  
  
    |<span data-ttu-id="1bcb6-141">Padrão</span><span class="sxs-lookup"><span data-stu-id="1bcb6-141">Pattern</span></span>|<span data-ttu-id="1bcb6-142">Descrição</span><span class="sxs-lookup"><span data-stu-id="1bcb6-142">Description</span></span>|  
    |-------------|-----------------|  
    |<span data-ttu-id="1bcb6-143">`.+` (quantificador Greedy)</span><span class="sxs-lookup"><span data-stu-id="1bcb6-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="1bcb6-144">Corresponder a pelo menos uma ocorrência de qualquer caractere.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="1bcb6-145">Isso faz com que o mecanismo de expressões regulares corresponda à cadeia de caracteres inteira e, em seguida, retroceda da forma necessária para corresponder ao restante do padrão.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|  
    |<span data-ttu-id="1bcb6-146">`.+?` (quantificador lento)</span><span class="sxs-lookup"><span data-stu-id="1bcb6-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="1bcb6-147">Corresponder a pelo menos uma ocorrência de qualquer caractere, mas ao menor número possível.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|  
    |`(\d+)`|<span data-ttu-id="1bcb6-148">Corresponder a pelo menos um caractere numérico e atribuí-lo ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|  
    |`\.`|<span data-ttu-id="1bcb6-149">Corresponde a um ponto final.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-149">Match a period.</span></span>|  
  
     <span data-ttu-id="1bcb6-150">Para obter mais informações sobre quantificadores lentos, confira [Quantificadores](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-150">For more information about lazy quantifiers, see [Quantifiers](../../../docs/standard/base-types/quantifiers-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="1bcb6-151">Lookahead positivo: `(?=`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="1bcb6-152">Esse recurso permite que o mecanismo de retrocesso retorne ao mesmo ponto no texto após corresponder a uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="1bcb6-153">É útil para pesquisar em todo o texto verificando vários padrões que iniciam na mesma posição.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="1bcb6-154">Também permite que o mecanismo verifique se existe uma subcadeia de caracteres no final da correspondência sem incluir a subcadeia de caracteres no texto correspondente.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="1bcb6-155">O exemplo a seguir usa lookahead positivo para extrair as palavras de uma frase que não são seguidas por símbolos de pontuação.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]  
  
     <span data-ttu-id="1bcb6-156">A expressão regular `\b[A-Z]+\b(?=\P{P})` é definida conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="1bcb6-157">Padrão</span><span class="sxs-lookup"><span data-stu-id="1bcb6-157">Pattern</span></span>|<span data-ttu-id="1bcb6-158">Descrição</span><span class="sxs-lookup"><span data-stu-id="1bcb6-158">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="1bcb6-159">Começa a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-159">Begin the match at a word boundary.</span></span>|  
    |`[A-Z]+`|<span data-ttu-id="1bcb6-160">Corresponder a qualquer caractere alfabético uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="1bcb6-161">Como o método <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> é chamado com a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, essa comparação não diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|  
    |`\b`|<span data-ttu-id="1bcb6-162">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-162">End the match at a word boundary.</span></span>|  
    |`(?=\P{P})`|<span data-ttu-id="1bcb6-163">Antecipe para determinar se o próximo caractere é um símbolo de pontuação.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="1bcb6-164">Se não for, a correspondência será bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-164">If it is not, the match succeeds.</span></span>|  
  
     <span data-ttu-id="1bcb6-165">Para obter mais informações sobre as asserções de lookahead positivo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-165">For more information about positive lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="1bcb6-166">Lookahead negativo: `(?!`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="1bcb6-167">Esse recurso adiciona a capacidade de corresponder a uma expressão somente se uma subexpressão não corresponder.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="1bcb6-168">Ele é indicado especialmente para refinar uma pesquisa, porque, muitas vezes, é mais simples fornecer uma expressão para um caso que deve ser eliminado do que uma expressão para casos que precisam ser incluídos.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-168">This is particularly powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="1bcb6-169">Por exemplo, é difícil escrever uma expressão para palavras que não começam com “non”.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="1bcb6-170">O exemplo a seguir usa lookahead negativo para excluir.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-170">The following example uses negative lookahead to exclude them.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]  
  
     <span data-ttu-id="1bcb6-171">O padrão de expressão regular `\b(?!non)\w+\b` é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="1bcb6-172">Padrão</span><span class="sxs-lookup"><span data-stu-id="1bcb6-172">Pattern</span></span>|<span data-ttu-id="1bcb6-173">Descrição</span><span class="sxs-lookup"><span data-stu-id="1bcb6-173">Description</span></span>|  
    |-------------|-----------------|  
    |`\b`|<span data-ttu-id="1bcb6-174">Começa a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-174">Begin the match at a word boundary.</span></span>|  
    |`(?!non)`|<span data-ttu-id="1bcb6-175">Antecipar para garantir que a cadeia de caracteres atual não comece com “non”.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="1bcb6-176">Se isso acontecer, a correspondência falha.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-176">If it does, the match fails.</span></span>|  
    |`(\w+)`|<span data-ttu-id="1bcb6-177">Corresponde a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-177">Match one or more word characters.</span></span>|  
    |`\b`|<span data-ttu-id="1bcb6-178">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-178">End the match at a word boundary.</span></span>|  
  
     <span data-ttu-id="1bcb6-179">Para obter mais informações sobre as asserções de lookahead negativo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-179">For more information about negative lookahead assertions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="1bcb6-180">Avaliação condicional: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, onde *expression* é uma subexpressão para corresponder, *name* é o nome de um grupo de captura, *yes* é a cadeia de caracteres para corresponder se *expression* for correspondente ou se *name* for um grupo capturado válido não vazio e *no* é a subexpressão para corresponder se *expression* não é correspondente ou se *name* não for um grupo capturado válido não vazio.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="1bcb6-181">Esse recurso permite que o mecanismo pesquise usando mais de um padrão alternativo, dependendo do resultado de uma correspondência de subexpressão anterior ou do resultado de uma asserção de largura zero.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="1bcb6-182">Isso possibilita uma forma mais potente de referência inversa que permite, por exemplo, corresponder a uma subexpressão com base no fato de uma subexpressão anterior ser correspondente.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="1bcb6-183">A expressão regular no exemplo a seguir corresponde a parágrafos que são destinados a uso público e interno.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="1bcb6-184">Os parágrafos destinados apenas a uso interno começam com uma marca `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="1bcb6-185">O padrão de expressão regular `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` usa avaliação condicional para atribuir o conteúdo de parágrafos destinados a uso público e interno a grupos de captura separados.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="1bcb6-186">Esses parágrafos podem ser tratados de maneiras diferentes.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-186">These paragraphs can then be handled differently.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]  
  
     <span data-ttu-id="1bcb6-187">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-187">The regular expression pattern is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="1bcb6-188">Padrão</span><span class="sxs-lookup"><span data-stu-id="1bcb6-188">Pattern</span></span>|<span data-ttu-id="1bcb6-189">Descrição</span><span class="sxs-lookup"><span data-stu-id="1bcb6-189">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="1bcb6-190">Começar a correspondência no início de uma linha.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-190">Begin the match at the beginning of a line.</span></span>|  
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="1bcb6-191">Corresponder a zero ou uma ocorrência da cadeia de caracteres `<PRIVATE>` seguida para um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="1bcb6-192">Atribuir a correspondência a um grupo de captura chamado `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-192">Assign the match to a capturing group named `Pvt`.</span></span>|  
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="1bcb6-193">Se o grupo de captura `Pvt` existir, corresponder a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por zero ou um separador de pontuação, seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="1bcb6-194">Atribuir a subcadeia de caracteres ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-194">Assign the substring to the first capturing group.</span></span>|  
    |<code>&#124;((\w+\p{P}?\s)+))<code>|<span data-ttu-id="1bcb6-195">Se o grupo de captura `Pvt` não existir, corresponder a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por zero ou um separador de pontuação, seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="1bcb6-196">Atribuir a subcadeia de caracteres ao terceiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-196">Assign the substring to the third capturing group.</span></span>|  
    |`\r?$`|<span data-ttu-id="1bcb6-197">Corresponder ao final de uma linha ou ao final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-197">Match the end of a line or the end of the string.</span></span>|  
  
     <span data-ttu-id="1bcb6-198">Para obter mais informações sobre a avaliação condicional, consulte [Constructos de alternância](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-198">For more information about conditional evaluation, see [Alternation Constructs](../../../docs/standard/base-types/alternation-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="1bcb6-199">Equilibrando definições do grupo: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="1bcb6-200">Esse recurso permite que o mecanismo de expressões regulares controle constructos aninhados, como parênteses ou colchetes de abertura e fechamento.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="1bcb6-201">Para ver um exemplo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-201">For an example, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="1bcb6-202">Subexpressões sem retrocesso (também conhecidas como subexpressões Greedy): `(?>`*subexpression*`)`.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-202">Nonbacktracking subexpressions (also known as greedy subexpressions): `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="1bcb6-203">Esse recurso permite que o mecanismo de retrocesso assegure que uma subexpressão corresponda apenas à primeira correspondência encontrada para ela, como se a expressão estivesse sendo executada independentemente da expressão que a contém.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="1bcb6-204">Se você não usar esse constructo, as pesquisas de retrocesso de expressões maiores poderão alterar o comportamento de uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="1bcb6-205">Por exemplo, a expressão regular `(a+)\w` corresponde um ou mais caracteres “a”, juntamente com um caractere de palavra que segue a cadeia de caracteres “a”, e atribui a cadeia de caracteres “a” para o primeiro grupo de captura. Contudo, se o caractere final da cadeia de caracteres de entrada também for um “a”, corresponderá ao elemento de linguagem `\w` e não estará incluído no grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group, However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]  
  
     <span data-ttu-id="1bcb6-206">A expressão regular `((?>a+))\w` impede esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-206">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="1bcb6-207">Como todos os caracteres “a” consecutivos são correspondidos sem retrocesso, o primeiro grupo de captura inclui todos os caracteres “a” consecutivos.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-207">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="1bcb6-208">Se os caracteres “a” não forem seguidos por pelo menos um caractere diferente de “a”, a correspondência falhará.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-208">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]  
  
     <span data-ttu-id="1bcb6-209">Para obter mais informações sobre as subexpressões sem retrocesso, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-209">For more information about nonbacktracking subexpressions, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
- <span data-ttu-id="1bcb6-210">Correspondência da direita para a esquerda, que é especificada fornecendo a opção <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> para um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou um método de correspondência de instância estática.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-210">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="1bcb6-211">Esse recurso é útil durante a pesquisa da direita para a esquerda em vez da esquerda para direita ou nos casos em que é mais eficiente iniciar uma correspondência na parte direita do padrão em vez de à esquerda.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-211">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="1bcb6-212">Como mostra o exemplo a seguir, o uso da correspondência da direita para esquerda pode alterar o comportamento de quantificadores Greedy.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-212">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="1bcb6-213">O exemplo realiza duas pesquisas por uma frase que termina em número.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-213">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="1bcb6-214">A pesquisa da esquerda para a direita que usa o quantificador Greedy `+` corresponde a um dos seis dígitos na frase, enquanto a pesquisa da direita para a esquerda corresponde a todos os seis dígitos.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-214">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="1bcb6-215">Para obter uma descrição do padrão de expressão regular, consulte o exemplo que mostra quantificadores lentos no início desta seção.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-215">For an description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]  
  
     <span data-ttu-id="1bcb6-216">Para obter mais informações sobre a correspondência da direita para a esquerda, consulte [Opções de expressões regulares](../../../docs/standard/base-types/regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-216">For more information about right-to-left matching, see [Regular Expression Options](../../../docs/standard/base-types/regular-expression-options.md).</span></span>  
  
- <span data-ttu-id="1bcb6-217">Lookbehind positivo e negativo: `(?<=`*subexpression*`)` para lookbehind positivo e `(?<!`*subexpression*`)` para lookbehind negativo.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-217">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="1bcb6-218">Esse recurso é semelhante ao lookahead, que é discutido neste tópico.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-218">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="1bcb6-219">Como o mecanismo de expressões regulares possibilita uma correspondência completa da direita para a esquerda, expressões regulares permitem lookbehinds irrestritos.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-219">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="1bcb6-220">O lookbehind positivo e negativo também pode ser usado para evitar o aninhamento de quantificadores quando a subexpressão aninhada é um superconjunto de uma expressão externa.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-220">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="1bcb6-221">Expressões regulares com tais quantificadores aninhados geralmente oferecem um desempenho ruim.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-221">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="1bcb6-222">Por exemplo, o exemplo a seguir verifica se uma cadeia de caracteres começa e termina com um caractere alfanumérico e se qualquer outro caractere na cadeia de caracteres faz parte de um subconjunto maior.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-222">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="1bcb6-223">Faz parte da expressão regular usada para validar endereços de email. Para obter mais informações, veja [Como: verificar se as cadeias de caracteres estão em um formato de email válido](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-223">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](../../../docs/standard/base-types/how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>  
  
     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]  
  
     <span data-ttu-id="1bcb6-224">A expressão regular `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])\*(?<=[A-Z0-9])$\` é definida conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-224">The regular expression `^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])\*(?<=[A-Z0-9])$\` is defined as shown in the following table.</span></span>  
  
    |<span data-ttu-id="1bcb6-225">Padrão</span><span class="sxs-lookup"><span data-stu-id="1bcb6-225">Pattern</span></span>|<span data-ttu-id="1bcb6-226">Descrição</span><span class="sxs-lookup"><span data-stu-id="1bcb6-226">Description</span></span>|  
    |-------------|-----------------|  
    |`^`|<span data-ttu-id="1bcb6-227">Começar a correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-227">Begin the match at the beginning of the string.</span></span>|  
    |`[A-Z0-9]`|<span data-ttu-id="1bcb6-228">Corresponder a qualquer caractere numérico ou alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-228">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="1bcb6-229">(A comparação não diferencia maiúsculas de minúsculas.)</span><span class="sxs-lookup"><span data-stu-id="1bcb6-229">(The comparison is case-insensitive.)</span></span>|  
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])*<code>|Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., *, +, /, =, ?, ^, \`, {, }, &#124;, or ~.|  
    |`(?<=[A-Z0-9])`|<span data-ttu-id="1bcb6-230">Olhar para o caractere anterior, que precisa ser numérico ou alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-230">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="1bcb6-231">(A comparação não diferencia maiúsculas de minúsculas.)</span><span class="sxs-lookup"><span data-stu-id="1bcb6-231">(The comparison is case-insensitive.)</span></span>|  
    |`$`|<span data-ttu-id="1bcb6-232">Encerrar a correspondência ao final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-232">End the match at the end of the string.</span></span>|  
  
     <span data-ttu-id="1bcb6-233">Para obter mais informações sobre lookbehind positivo e negativo, consulte [Constructos de agrupamento](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="1bcb6-233">For more information about positive and negative lookbehind, see [Grouping Constructs](../../../docs/standard/base-types/grouping-constructs-in-regular-expressions.md).</span></span>  
  
## <a name="related-topics"></a><span data-ttu-id="1bcb6-234">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="1bcb6-234">Related Topics</span></span>  
  
|<span data-ttu-id="1bcb6-235">Título</span><span class="sxs-lookup"><span data-stu-id="1bcb6-235">Title</span></span>|<span data-ttu-id="1bcb6-236">Descrição</span><span class="sxs-lookup"><span data-stu-id="1bcb6-236">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="1bcb6-237">Retrocesso</span><span class="sxs-lookup"><span data-stu-id="1bcb6-237">Backtracking</span></span>](../../../docs/standard/base-types/backtracking-in-regular-expressions.md)|<span data-ttu-id="1bcb6-238">Fornece informações sobre como o retrocesso de expressões regulares se ramifica para encontrar correspondências alternativas.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-238">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|  
|[<span data-ttu-id="1bcb6-239">Compilação e reutilização</span><span class="sxs-lookup"><span data-stu-id="1bcb6-239">Compilation and Reuse</span></span>](../../../docs/standard/base-types/compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="1bcb6-240">Fornece informações sobre a compilação e a reutilização de expressões regulares para aumentar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-240">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|  
|[<span data-ttu-id="1bcb6-241">Acesso thread-safe</span><span class="sxs-lookup"><span data-stu-id="1bcb6-241">Thread Safety</span></span>](../../../docs/standard/base-types/thread-safety-in-regular-expressions.md)|<span data-ttu-id="1bcb6-242">Fornece informações sobre a segurança de thread de expressões regulares e explica quando você deve sincronizar o acesso a objetos de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-242">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|  
|[<span data-ttu-id="1bcb6-243">Expressões regulares do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="1bcb6-243">.NET Framework Regular Expressions</span></span>](../../../docs/standard/base-types/regular-expressions.md)|<span data-ttu-id="1bcb6-244">Fornece uma visão geral sobre o aspecto de linguagem de programação das expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-244">Provides an overview of the programming language aspect of regular expressions.</span></span>|  
|[<span data-ttu-id="1bcb6-245">O modelo de objeto de expressão regular</span><span class="sxs-lookup"><span data-stu-id="1bcb6-245">The Regular Expression Object Model</span></span>](../../../docs/standard/base-types/the-regular-expression-object-model.md)|<span data-ttu-id="1bcb6-246">Oferece informações e exemplos de código que mostram como usar as classes de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-246">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|  
|[<span data-ttu-id="1bcb6-247">Exemplos de expressões regulares</span><span class="sxs-lookup"><span data-stu-id="1bcb6-247">Regular Expression Examples</span></span>](../../../docs/standard/base-types/regular-expression-examples.md)|<span data-ttu-id="1bcb6-248">Contém exemplos de código que mostram o uso de expressões regulares em aplicativos comuns.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-248">Contains code examples that illustrate the use of regular expressions in common applications.</span></span>|  
|[<span data-ttu-id="1bcb6-249">Linguagem de expressão regular – referência rápida</span><span class="sxs-lookup"><span data-stu-id="1bcb6-249">Regular Expression Language - Quick Reference</span></span>](../../../docs/standard/base-types/regular-expression-language-quick-reference.md)|<span data-ttu-id="1bcb6-250">Oferece informações a respeito do conjunto de caracteres, operadores e constructos que você pode usar para definir expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="1bcb6-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="1bcb6-251">Referência</span><span class="sxs-lookup"><span data-stu-id="1bcb6-251">Reference</span></span>  
 <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
