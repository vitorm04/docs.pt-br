---
title: Comportamento de expressão regular
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- regular expressions, behavior
- .NET regular expressions, behavior
ms.assetid: 0ee1a6b8-caac-41d2-917f-d35570021b10
ms.openlocfilehash: a93e0e7bac782d9a4ce47c1586796b063563d2b6
ms.sourcegitcommit: 4a938327bad8b2e20cabd0f46a9dc50882596f13
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/28/2020
ms.locfileid: "92888666"
---
# <a name="details-of-regular-expression-behavior"></a><span data-ttu-id="7e123-102">Detalhes do comportamento de expressões regulares</span><span class="sxs-lookup"><span data-stu-id="7e123-102">Details of regular expression behavior</span></span>

<span data-ttu-id="7e123-103">O mecanismo de expressões regulares do .NET é um correspondente de expressão regular de retrocesso que incorpora um mecanismo de NFA (Automação Finita Não Determinística) tradicional, como o usado pelo Perl, Python, Emacs e Tcl.</span><span class="sxs-lookup"><span data-stu-id="7e123-103">The .NET regular expression engine is a backtracking regular expression matcher that incorporates a traditional Nondeterministic Finite Automaton (NFA) engine such as that used by Perl, Python, Emacs, and Tcl.</span></span> <span data-ttu-id="7e123-104">Isso o distingue de mecanismos de DFA (Autômato finito determinístico) de expressões regulares puras mais rápidos, porém mais limitados, como os encontrados em awk, egrep ou lex.</span><span class="sxs-lookup"><span data-stu-id="7e123-104">This distinguishes it from faster, but more limited, pure regular expression Deterministic Finite Automaton (DFA) engines such as those found in awk, egrep, or lex.</span></span> <span data-ttu-id="7e123-105">Também o distingue de NFAs POSIX padronizados, porém mais lentos.</span><span class="sxs-lookup"><span data-stu-id="7e123-105">This also distinguishes it from standardized, but slower, POSIX NFAs.</span></span> <span data-ttu-id="7e123-106">A seção a seguir descreve os três tipos de mecanismos de expressões regulares e explica por que as expressões regulares no .NET são implementadas usando um mecanismo de NFA tradicional.</span><span class="sxs-lookup"><span data-stu-id="7e123-106">The following section describes the three types of regular expression engines, and explains why regular expressions in .NET are implemented by using a traditional NFA engine.</span></span>

## <a name="benefits-of-the-nfa-engine"></a><span data-ttu-id="7e123-107">Benefícios do mecanismo NFA</span><span class="sxs-lookup"><span data-stu-id="7e123-107">Benefits of the NFA engine</span></span>

 <span data-ttu-id="7e123-108">Quando mecanismos de DFA executam a correspondência de padrões, a ordem de processamento é orientada pela cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="7e123-108">When DFA engines perform pattern matching, their processing order is driven by the input string.</span></span> <span data-ttu-id="7e123-109">O mecanismo começa no início da cadeia de caracteres de entrada e continua sequencialmente para determinar se o próximo caractere corresponde ao padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7e123-109">The engine begins at the beginning of the input string and proceeds sequentially to determine whether the next character matches the regular expression pattern.</span></span> <span data-ttu-id="7e123-110">Podem assegurar uma correspondência com a cadeia de caracteres mais longa possível.</span><span class="sxs-lookup"><span data-stu-id="7e123-110">They can guarantee to match the longest string possible.</span></span> <span data-ttu-id="7e123-111">Como nunca testam o mesmo caractere duas vezes, os mecanismos de DFA não dão suporte ao retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7e123-111">Because they never test the same character twice, DFA engines do not support backtracking.</span></span> <span data-ttu-id="7e123-112">No entanto, como um mecanismo de DFA contém somente o estado finito, não pode corresponder a um padrão com referências inversas; além disso, uma vez que não constrói uma expansão explícita, não pode capturar subexpressões.</span><span class="sxs-lookup"><span data-stu-id="7e123-112">However, because a DFA engine contains only finite state, it cannot match a pattern with backreferences, and because it does not construct an explicit expansion, it cannot capture subexpressions.</span></span>

 <span data-ttu-id="7e123-113">Ao contrário de mecanismos de DFA, quando mecanismos de NFA tradicionais executam a correspondência de padrões, a ordem de processamento é orientada pelo padrão de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7e123-113">Unlike DFA engines, when traditional NFA engines perform pattern matching, their processing order is driven by the regular expression pattern.</span></span> <span data-ttu-id="7e123-114">Como processa um elemento de linguagem específico, o mecanismo usa a correspondência Greedy; ou seja, corresponde à maior parte possível da cadeia de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="7e123-114">As it processes a particular language element, the engine uses greedy matching; that is, it matches as much of the input string as it possibly can.</span></span> <span data-ttu-id="7e123-115">Contudo, também consegue salvar seu estado correspondendo a uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="7e123-115">But it also saves its state after successfully matching a subexpression.</span></span> <span data-ttu-id="7e123-116">Se uma correspondência falhar, o mecanismo poderá retornar para um estado salvo a fim de tentar correspondências adicionais.</span><span class="sxs-lookup"><span data-stu-id="7e123-116">If a match eventually fails, the engine can return to a saved state so it can try additional matches.</span></span> <span data-ttu-id="7e123-117">Esse processo de abandonar uma correspondência de subexpressão bem-sucedida para que elementos de linguagem posteriores na expressão regular também possam corresponder é conhecido como *retrocesso* .</span><span class="sxs-lookup"><span data-stu-id="7e123-117">This process of abandoning a successful subexpression match so that later language elements in the regular expression can also match is known as *backtracking* .</span></span> <span data-ttu-id="7e123-118">Os mecanismos de NFA usam o retrocesso para testar todas as possíveis expansões de uma expressão regular em uma ordem específica e aceitam a primeira correspondência.</span><span class="sxs-lookup"><span data-stu-id="7e123-118">NFA engines use backtracking to test all possible expansions of a regular expression in a specific order and accept the first match.</span></span> <span data-ttu-id="7e123-119">Como um mecanismo de NFA tradicional constrói uma expansão específica da expressão regular para uma correspondência de sucesso, pode capturar correspondências de subexpressões e referências inversas correspondentes.</span><span class="sxs-lookup"><span data-stu-id="7e123-119">Because a traditional NFA engine constructs a specific expansion of the regular expression for a successful match, it can capture subexpression matches and matching backreferences.</span></span> <span data-ttu-id="7e123-120">Entretanto, como um NFA tradicional retrocede, pode visitar o mesmo estado diversas vezes se chegar no estado por diferentes caminhos.</span><span class="sxs-lookup"><span data-stu-id="7e123-120">However, because a traditional NFA backtracks, it can visit the same state multiple times if it arrives at the state over different paths.</span></span> <span data-ttu-id="7e123-121">Como resultado, pode executar de modo exponencial lentamente na pior das hipóteses.</span><span class="sxs-lookup"><span data-stu-id="7e123-121">As a result, it can run exponentially slowly in the worst case.</span></span> <span data-ttu-id="7e123-122">Já que um mecanismo de NFA tradicional aceita a primeira correspondência que encontra, também pode deixar outras correspondências (possivelmente mais longas) não descobertas.</span><span class="sxs-lookup"><span data-stu-id="7e123-122">Because a traditional NFA engine accepts the first match it finds, it can also leave other (possibly longer) matches undiscovered.</span></span>

 <span data-ttu-id="7e123-123">Os mecanismos de NFA POSIX são como mecanismos de NFA tradicionais, exceto pelo fato de continuarem retrocedendo até poderem assegurar que encontraram a correspondência mais longa possível.</span><span class="sxs-lookup"><span data-stu-id="7e123-123">POSIX NFA engines are like traditional NFA engines, except that they continue to backtrack until they can guarantee that they have found the longest match possible.</span></span> <span data-ttu-id="7e123-124">Como resultado, um mecanismo de NFA POSIX é mais lento do que um mecanismo de NFA tradicional; quando você usa um mecanismo de NFA POSIX, não pode favorecer uma correspondência menor em detrimento de uma maior alterando a ordem da pesquisa de retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7e123-124">As a result, a POSIX NFA engine is slower than a traditional NFA engine, and when you use a POSIX NFA engine, you cannot favor a shorter match over a longer one by changing the order of the backtracking search.</span></span>

 <span data-ttu-id="7e123-125">Os mecanismos de NFA tradicionais são favorecidos por programadores porque oferecem maior controle sobre a correspondência da cadeia de caracteres do que mecanismos de DFA ou NFA POSIX.</span><span class="sxs-lookup"><span data-stu-id="7e123-125">Traditional NFA engines are favored by programmers because they offer greater control over string matching than either DFA or POSIX NFA engines.</span></span> <span data-ttu-id="7e123-126">Embora, na pior das hipóteses, possam ser executados mais lentamente, você pode orientá-los para encontrar correspondências em tempo linear ou polinomial usando padrões que reduzem ambiguidades e limitam o retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7e123-126">Although, in the worst case, they can run slowly, you can steer them to find matches in linear or polynomial time by using patterns that reduce ambiguities and limit backtracking.</span></span> <span data-ttu-id="7e123-127">Em outras palavras, embora os mecanismos de NFA negociem o desempenho de energia e flexibilidade, na maioria dos casos eles oferecem bom desempenho aceitável se uma expressão regular é bem escrita e evita casos em que o retrocesso degrada o desempenho exponencialmente.</span><span class="sxs-lookup"><span data-stu-id="7e123-127">In other words, although NFA engines trade performance for power and flexibility, in most cases they offer good to acceptable performance if a regular expression is well written and avoids cases in which backtracking degrades performance exponentially.</span></span>

> [!NOTE]
> <span data-ttu-id="7e123-128">Para obter informações sobre a penalidade de desempenho causada por retrocesso excessivo e maneiras de criar uma expressão regular para solucioná-lo, consulte [Retrocesso](backtracking-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-128">For information about the performance penalty caused by excessive backtracking and ways to craft a regular expression to work around them, see [Backtracking](backtracking-in-regular-expressions.md).</span></span>

## <a name="net-engine-capabilities"></a><span data-ttu-id="7e123-129">Recursos do mecanismo .NET</span><span class="sxs-lookup"><span data-stu-id="7e123-129">.NET engine capabilities</span></span>

 <span data-ttu-id="7e123-130">Para tirar proveito dos benefícios de um mecanismo de NFA tradicional, o mecanismo de expressões regulares do .NET inclui um conjunto completo de constructos para permitir que os programadores conduzam o mecanismo de retrocesso.</span><span class="sxs-lookup"><span data-stu-id="7e123-130">To take advantage of the benefits of a traditional NFA engine, the .NET regular expression engine includes a complete set of constructs to enable programmers to steer the backtracking engine.</span></span> <span data-ttu-id="7e123-131">Tais constructos podem ser usados para encontrar correspondências mais rapidamente ou favorecer expansões específicas em detrimento de outras.</span><span class="sxs-lookup"><span data-stu-id="7e123-131">These constructs can be used to find matches faster or to favor specific expansions over others.</span></span>

 <span data-ttu-id="7e123-132">Outros recursos do mecanismo de expressões regulares do .NET incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="7e123-132">Other features of the .NET regular expression engine include the following:</span></span>

- <span data-ttu-id="7e123-133">Quantificadores lentos: `??` , `*?` , `+?` , `{` *n* `,` *m* `}?` .</span><span class="sxs-lookup"><span data-stu-id="7e123-133">Lazy quantifiers: `??`, `*?`, `+?`, `{`*n*`,`*m*`}?`.</span></span> <span data-ttu-id="7e123-134">Esses constructos instruem o mecanismo de retrocesso a pesquisar o número mínimo de repetições primeiro.</span><span class="sxs-lookup"><span data-stu-id="7e123-134">These constructs tell the backtracking engine to search the minimum number of repetitions first.</span></span> <span data-ttu-id="7e123-135">Por outro lado, quantificadores Greedy comuns tentam corresponder ao número máximo de repetições primeiro.</span><span class="sxs-lookup"><span data-stu-id="7e123-135">In contrast, ordinary greedy quantifiers try to match the maximum number of repetitions first.</span></span> <span data-ttu-id="7e123-136">O exemplo a seguir mostra a diferença entre os dois.</span><span class="sxs-lookup"><span data-stu-id="7e123-136">The following example illustrates the difference between the two.</span></span> <span data-ttu-id="7e123-137">Uma expressão regular corresponde a uma frase que termina em um número e um grupo de captura deve extrair esse número.</span><span class="sxs-lookup"><span data-stu-id="7e123-137">A regular expression matches a sentence that ends in a number, and a capturing group is intended to extract that number.</span></span> <span data-ttu-id="7e123-138">A expressão regular `.+(\d+)\.` inclui o quantificador Greedy `.+`, que faz com que o mecanismo de expressões regulares capture o último dígito do número.</span><span class="sxs-lookup"><span data-stu-id="7e123-138">The regular expression `.+(\d+)\.` includes the greedy quantifier `.+`, which causes the regular expression engine to capture only the last digit of the number.</span></span> <span data-ttu-id="7e123-139">Por outro lado, a expressão regular `.+?(\d+)\.` inclui o quantificador lento `.+?`, que faz com que o mecanismo de expressões regulares capture o número inteiro.</span><span class="sxs-lookup"><span data-stu-id="7e123-139">In contrast, the regular expression `.+?(\d+)\.` includes the lazy quantifier `.+?`, which causes the regular expression engine to capture the entire number.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lazy1.cs#1)]
     [!code-vb[Conceptual.RegularExpressions.Design#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lazy1.vb#1)]

     <span data-ttu-id="7e123-140">As versões Greedy e lenta dessa expressão regular são definidas como mostrado na tabela a seguir:</span><span class="sxs-lookup"><span data-stu-id="7e123-140">The greedy and lazy versions of this regular expression are defined as shown in the following table:</span></span>

    |<span data-ttu-id="7e123-141">Padrão</span><span class="sxs-lookup"><span data-stu-id="7e123-141">Pattern</span></span>|<span data-ttu-id="7e123-142">Descrição</span><span class="sxs-lookup"><span data-stu-id="7e123-142">Description</span></span>|
    |-------------|-----------------|
    |<span data-ttu-id="7e123-143">`.+` (quantificador Greedy)</span><span class="sxs-lookup"><span data-stu-id="7e123-143">`.+` (greedy quantifier)</span></span>|<span data-ttu-id="7e123-144">Corresponder a pelo menos uma ocorrência de qualquer caractere.</span><span class="sxs-lookup"><span data-stu-id="7e123-144">Match at least one occurrence of any character.</span></span> <span data-ttu-id="7e123-145">Isso faz com que o mecanismo de expressões regulares corresponda à cadeia de caracteres inteira e, em seguida, retroceda da forma necessária para corresponder ao restante do padrão.</span><span class="sxs-lookup"><span data-stu-id="7e123-145">This causes the regular expression engine to match the entire string, and then to backtrack as needed to match the remainder of the pattern.</span></span>|
    |<span data-ttu-id="7e123-146">`.+?` (quantificador lento)</span><span class="sxs-lookup"><span data-stu-id="7e123-146">`.+?` (lazy quantifier)</span></span>|<span data-ttu-id="7e123-147">Corresponder a pelo menos uma ocorrência de qualquer caractere, mas ao menor número possível.</span><span class="sxs-lookup"><span data-stu-id="7e123-147">Match at least one occurrence of any character, but match as few as possible.</span></span>|
    |`(\d+)`|<span data-ttu-id="7e123-148">Corresponder a pelo menos um caractere numérico e atribuí-lo ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7e123-148">Match at least one numeric character, and assign it to the first capturing group.</span></span>|
    |`\.`|<span data-ttu-id="7e123-149">Corresponde a um ponto final.</span><span class="sxs-lookup"><span data-stu-id="7e123-149">Match a period.</span></span>|

     <span data-ttu-id="7e123-150">Para obter mais informações sobre quantificadores lentos, confira [Quantificadores](quantifiers-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-150">For more information about lazy quantifiers, see [Quantifiers](quantifiers-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7e123-151">Lookahead positivo: `(?=` *subexpressão* `)` .</span><span class="sxs-lookup"><span data-stu-id="7e123-151">Positive lookahead: `(?=`*subexpression*`)`.</span></span> <span data-ttu-id="7e123-152">Esse recurso permite que o mecanismo de retrocesso retorne ao mesmo ponto no texto após corresponder a uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="7e123-152">This feature allows the backtracking engine to return to the same spot in the text after matching a subexpression.</span></span> <span data-ttu-id="7e123-153">É útil para pesquisar em todo o texto verificando vários padrões que iniciam na mesma posição.</span><span class="sxs-lookup"><span data-stu-id="7e123-153">It is useful for searching throughout the text by verifying multiple patterns that start from the same position.</span></span> <span data-ttu-id="7e123-154">Também permite que o mecanismo verifique se existe uma subcadeia de caracteres no final da correspondência sem incluir a subcadeia de caracteres no texto correspondente.</span><span class="sxs-lookup"><span data-stu-id="7e123-154">It also allows the engine to verify that a substring exists at the end of the match without including the substring in the matched text.</span></span> <span data-ttu-id="7e123-155">O exemplo a seguir usa lookahead positivo para extrair as palavras de uma frase que não são seguidas por símbolos de pontuação.</span><span class="sxs-lookup"><span data-stu-id="7e123-155">The following example uses positive lookahead to extract the words in a sentence that are not followed by punctuation symbols.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead1.cs#2)]
     [!code-vb[Conceptual.RegularExpressions.Design#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead1.vb#2)]

     <span data-ttu-id="7e123-156">A expressão regular `\b[A-Z]+\b(?=\P{P})` é definida conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7e123-156">The regular expression `\b[A-Z]+\b(?=\P{P})` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7e123-157">Padrão</span><span class="sxs-lookup"><span data-stu-id="7e123-157">Pattern</span></span>|<span data-ttu-id="7e123-158">Descrição</span><span class="sxs-lookup"><span data-stu-id="7e123-158">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="7e123-159">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7e123-159">Begin the match at a word boundary.</span></span>|
    |`[A-Z]+`|<span data-ttu-id="7e123-160">Corresponder a qualquer caractere alfabético uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="7e123-160">Match any alphabetic character one or more times.</span></span> <span data-ttu-id="7e123-161">Como o método <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> é chamado com a opção <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType>, essa comparação não diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="7e123-161">Because the <xref:System.Text.RegularExpressions.Regex.Matches%2A?displayProperty=nameWithType> method is called with the <xref:System.Text.RegularExpressions.RegexOptions.IgnoreCase?displayProperty=nameWithType> option, the comparison is case-insensitive.</span></span>|
    |`\b`|<span data-ttu-id="7e123-162">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7e123-162">End the match at a word boundary.</span></span>|
    |`(?=\P{P})`|<span data-ttu-id="7e123-163">Antecipe para determinar se o próximo caractere é um símbolo de pontuação.</span><span class="sxs-lookup"><span data-stu-id="7e123-163">Look ahead to determine whether the next character is a punctuation symbol.</span></span> <span data-ttu-id="7e123-164">Se não for, a correspondência será bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="7e123-164">If it is not, the match succeeds.</span></span>|

     <span data-ttu-id="7e123-165">Para obter mais informações sobre as asserções de lookahead positivo, consulte [Constructos de agrupamento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-165">For more information about positive lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7e123-166">Visão antecipada negativa: `(?!` *subexpressão* `)` .</span><span class="sxs-lookup"><span data-stu-id="7e123-166">Negative lookahead: `(?!`*subexpression*`)`.</span></span> <span data-ttu-id="7e123-167">Esse recurso adiciona a capacidade de corresponder a uma expressão somente se uma subexpressão não corresponder.</span><span class="sxs-lookup"><span data-stu-id="7e123-167">This feature adds the ability to match an expression only if a subexpression fails to match.</span></span> <span data-ttu-id="7e123-168">Isso é poderoso para remover uma pesquisa, pois geralmente é mais simples fornecer uma expressão para um caso que deve ser eliminado do que uma expressão para casos que devem ser incluídos.</span><span class="sxs-lookup"><span data-stu-id="7e123-168">This is powerful for pruning a search, because it is often simpler to provide an expression for a case that should be eliminated than an expression for cases that must be included.</span></span> <span data-ttu-id="7e123-169">Por exemplo, é difícil escrever uma expressão para palavras que não começam com “non”.</span><span class="sxs-lookup"><span data-stu-id="7e123-169">For example, it is difficult to write an expression for words that do not begin with "non".</span></span> <span data-ttu-id="7e123-170">O exemplo a seguir usa lookahead negativo para excluir.</span><span class="sxs-lookup"><span data-stu-id="7e123-170">The following example uses negative lookahead to exclude them.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookahead2.cs#3)]
     [!code-vb[Conceptual.RegularExpressions.Design#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookahead2.vb#3)]

     <span data-ttu-id="7e123-171">O padrão de expressão regular `\b(?!non)\w+\b` é definido conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7e123-171">The regular expression pattern `\b(?!non)\w+\b` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7e123-172">Padrão</span><span class="sxs-lookup"><span data-stu-id="7e123-172">Pattern</span></span>|<span data-ttu-id="7e123-173">Descrição</span><span class="sxs-lookup"><span data-stu-id="7e123-173">Description</span></span>|
    |-------------|-----------------|
    |`\b`|<span data-ttu-id="7e123-174">Começar a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7e123-174">Begin the match at a word boundary.</span></span>|
    |`(?!non)`|<span data-ttu-id="7e123-175">Antecipar para garantir que a cadeia de caracteres atual não comece com “non”.</span><span class="sxs-lookup"><span data-stu-id="7e123-175">Look ahead to ensure that the current string does not begin with "non".</span></span> <span data-ttu-id="7e123-176">Se isso acontecer, a correspondência falha.</span><span class="sxs-lookup"><span data-stu-id="7e123-176">If it does, the match fails.</span></span>|
    |`(\w+)`|<span data-ttu-id="7e123-177">Fazer a correspondência a um ou mais caracteres de palavra.</span><span class="sxs-lookup"><span data-stu-id="7e123-177">Match one or more word characters.</span></span>|
    |`\b`|<span data-ttu-id="7e123-178">Termina a correspondência em um limite de palavra.</span><span class="sxs-lookup"><span data-stu-id="7e123-178">End the match at a word boundary.</span></span>|

     <span data-ttu-id="7e123-179">Para obter mais informações sobre as asserções de lookahead negativo, consulte [Constructos de agrupamento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-179">For more information about negative lookahead assertions, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7e123-180">Avaliação condicional: `(?(` *expressão* `)` *Sim* `|` *não* `)` e `(?(` *nome* `)` *Sim* `|` *não* `)` , em que *expressão* é uma subexpressão para corresponder, *nome* é o nome de um grupo de captura, *Sim* é a cadeia de caracteres a corresponder se *name* a *expressão* for correspondida ou se o nome for um grupo capturado válido, não vazio e *não* for a subexpressão a corresponder se a *expressão* não for correspondida ou o *nome* não for um grupo capturado válido</span><span class="sxs-lookup"><span data-stu-id="7e123-180">Conditional evaluation: `(?(`*expression*`)`*yes*`|`*no*`)` and `(?(`*name*`)`*yes*`|`*no*`)`, where *expression* is a subexpression to match, *name* is the name of a capturing group, *yes* is the string to match if *expression* is matched or *name* is a valid, non-empty captured group, and *no* is the subexpression to match if *expression* is not matched or *name* is not a valid, non-empty captured group.</span></span> <span data-ttu-id="7e123-181">Esse recurso permite que o mecanismo pesquise usando mais de um padrão alternativo, dependendo do resultado de uma correspondência de subexpressão anterior ou do resultado de uma asserção de largura zero.</span><span class="sxs-lookup"><span data-stu-id="7e123-181">This feature allows the engine to search by using more than one alternate pattern, depending on the result of a previous subexpression match or the result of a zero-width assertion.</span></span> <span data-ttu-id="7e123-182">Isso possibilita uma forma mais potente de referência inversa que permite, por exemplo, corresponder a uma subexpressão com base no fato de uma subexpressão anterior ser correspondente.</span><span class="sxs-lookup"><span data-stu-id="7e123-182">This allows a more powerful form of backreference that permits, for example, matching a subexpression based on whether a previous subexpression was matched.</span></span> <span data-ttu-id="7e123-183">A expressão regular no exemplo a seguir corresponde a parágrafos que são destinados a uso público e interno.</span><span class="sxs-lookup"><span data-stu-id="7e123-183">The regular expression in the following example matches paragraphs that are intended for both public and internal use.</span></span> <span data-ttu-id="7e123-184">Os parágrafos destinados apenas a uso interno começam com uma marca `<PRIVATE>`.</span><span class="sxs-lookup"><span data-stu-id="7e123-184">Paragraphs intended only for internal use begin with a `<PRIVATE>` tag.</span></span> <span data-ttu-id="7e123-185">O padrão de expressão regular `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` usa avaliação condicional para atribuir o conteúdo de parágrafos destinados a uso público e interno a grupos de captura separados.</span><span class="sxs-lookup"><span data-stu-id="7e123-185">The regular expression pattern `^(?<Pvt>\<PRIVATE\>\s)?(?(Pvt)((\w+\p{P}?\s)+)|((\w+\p{P}?\s)+))\r?$` uses conditional evaluation to assign the contents of paragraphs intended for public and for internal use to separate capturing groups.</span></span> <span data-ttu-id="7e123-186">Esses parágrafos podem ser tratados de maneiras diferentes.</span><span class="sxs-lookup"><span data-stu-id="7e123-186">These paragraphs can then be handled differently.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/conditional1.cs#4)]
     [!code-vb[Conceptual.RegularExpressions.Design#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/conditional1.vb#4)]

     <span data-ttu-id="7e123-187">O padrão de expressão regular é definido como mostra a tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7e123-187">The regular expression pattern is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7e123-188">Padrão</span><span class="sxs-lookup"><span data-stu-id="7e123-188">Pattern</span></span>|<span data-ttu-id="7e123-189">Descrição</span><span class="sxs-lookup"><span data-stu-id="7e123-189">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="7e123-190">Começar a correspondência no início de uma linha.</span><span class="sxs-lookup"><span data-stu-id="7e123-190">Begin the match at the beginning of a line.</span></span>|
    |`(?<Pvt>\<PRIVATE\>\s)?`|<span data-ttu-id="7e123-191">Corresponder a zero ou uma ocorrência da cadeia de caracteres `<PRIVATE>` seguida para um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7e123-191">Match zero or one occurrence of the string `<PRIVATE>` followed by a white-space character.</span></span> <span data-ttu-id="7e123-192">Atribuir a correspondência a um grupo de captura chamado `Pvt`.</span><span class="sxs-lookup"><span data-stu-id="7e123-192">Assign the match to a capturing group named `Pvt`.</span></span>|
    |`(?(Pvt)((\w+\p{P}?\s)+)`|<span data-ttu-id="7e123-193">Se o grupo de captura `Pvt` existir, corresponder a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por zero ou um separador de pontuação, seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7e123-193">If the `Pvt` capturing group exists, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="7e123-194">Atribuir a subcadeia de caracteres ao primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7e123-194">Assign the substring to the first capturing group.</span></span>|
    |<code>&#124;((\w+\p{P}?\s)+))</code>|<span data-ttu-id="7e123-195">Se o grupo de captura `Pvt` não existir, corresponder a uma ou mais ocorrências de um ou mais caracteres de palavra seguidos por zero ou um separador de pontuação, seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="7e123-195">If the `Pvt` capturing group does not exist, match one or more occurrences of one or more word characters followed by zero or one punctuation separator followed by a white-space character.</span></span> <span data-ttu-id="7e123-196">Atribuir a subcadeia de caracteres ao terceiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7e123-196">Assign the substring to the third capturing group.</span></span>|
    |`\r?$`|<span data-ttu-id="7e123-197">Corresponder ao final de uma linha ou ao final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7e123-197">Match the end of a line or the end of the string.</span></span>|

     <span data-ttu-id="7e123-198">Para obter mais informações sobre a avaliação condicional, consulte [Constructos de alternância](alternation-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-198">For more information about conditional evaluation, see [Alternation Constructs](alternation-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7e123-199">Definições de grupo de `(?<` *balanceamento:* `-` *name2* `>` *subexpressão* nome2property `)` .</span><span class="sxs-lookup"><span data-stu-id="7e123-199">Balancing group definitions: `(?<`*name1*`-`*name2*`>` *subexpression*`)`.</span></span> <span data-ttu-id="7e123-200">Esse recurso permite que o mecanismo de expressões regulares controle constructos aninhados, como parênteses ou colchetes de abertura e fechamento.</span><span class="sxs-lookup"><span data-stu-id="7e123-200">This feature allows the regular expression engine to keep track of nested constructs such as parentheses or opening and closing brackets.</span></span> <span data-ttu-id="7e123-201">Para ver um exemplo, consulte [Constructos de agrupamento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-201">For an example, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7e123-202">Grupos atômicos: `(?>` *subexpressão* `)` .</span><span class="sxs-lookup"><span data-stu-id="7e123-202">Atomic groups: `(?>`*subexpression*`)`.</span></span> <span data-ttu-id="7e123-203">Esse recurso permite que o mecanismo de retrocesso assegure que uma subexpressão corresponda apenas à primeira correspondência encontrada para ela, como se a expressão estivesse sendo executada independentemente da expressão que a contém.</span><span class="sxs-lookup"><span data-stu-id="7e123-203">This feature allows the backtracking engine to guarantee that a subexpression matches only the first match found for that subexpression, as if the expression were running independent of its containing expression.</span></span> <span data-ttu-id="7e123-204">Se você não usar esse constructo, as pesquisas de retrocesso de expressões maiores poderão alterar o comportamento de uma subexpressão.</span><span class="sxs-lookup"><span data-stu-id="7e123-204">If you do not use this construct, backtracking searches from the larger expression can change the behavior of a subexpression.</span></span> <span data-ttu-id="7e123-205">Por exemplo, a expressão regular `(a+)\w` corresponde a um ou mais caracteres "a", juntamente com um caractere de palavra que segue a sequência de caracteres "a" e atribui a sequência de caracteres "a" para o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="7e123-205">For example, the regular expression `(a+)\w` matches one or more "a" characters, along with a word character that follows the sequence of "a" characters, and assigns the sequence of "a" characters to the first capturing group.</span></span> <span data-ttu-id="7e123-206">No entanto, se o caractere final da cadeia de caracteres de entrada também for um "a", ele será correspondido pelo `\w` elemento Language e não será incluído no grupo capturado.</span><span class="sxs-lookup"><span data-stu-id="7e123-206">However, if the final character of the input string is also an "a", it is matched by the `\w` language element and is not included in the captured group.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking2.cs#7)]
     [!code-vb[Conceptual.RegularExpressions.Design#7](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking2.vb#7)]

     <span data-ttu-id="7e123-207">A expressão regular `((?>a+))\w` impede esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="7e123-207">The regular expression `((?>a+))\w` prevents this behavior.</span></span> <span data-ttu-id="7e123-208">Como todos os caracteres “a” consecutivos são correspondidos sem retrocesso, o primeiro grupo de captura inclui todos os caracteres “a” consecutivos.</span><span class="sxs-lookup"><span data-stu-id="7e123-208">Because all consecutive "a" characters are matched without backtracking, the first capturing group includes all consecutive "a" characters.</span></span> <span data-ttu-id="7e123-209">Se os caracteres “a” não forem seguidos por pelo menos um caractere diferente de “a”, a correspondência falhará.</span><span class="sxs-lookup"><span data-stu-id="7e123-209">If the "a" characters are not followed by at least one more character other than "a", the match fails.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/nonbacktracking1.cs#8)]
     [!code-vb[Conceptual.RegularExpressions.Design#8](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/nonbacktracking1.vb#8)]

     <span data-ttu-id="7e123-210">Para obter mais informações sobre grupos atômicos, consulte [agrupando construções](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-210">For more information about atomic groups, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

- <span data-ttu-id="7e123-211">Correspondência da direita para a esquerda, que é especificada fornecendo a opção <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> para um construtor de classe <xref:System.Text.RegularExpressions.Regex> ou um método de correspondência de instância estática.</span><span class="sxs-lookup"><span data-stu-id="7e123-211">Right-to-left matching, which is specified by supplying the <xref:System.Text.RegularExpressions.RegexOptions.RightToLeft?displayProperty=nameWithType> option to a <xref:System.Text.RegularExpressions.Regex> class constructor or static instance matching method.</span></span> <span data-ttu-id="7e123-212">Esse recurso é útil durante a pesquisa da direita para a esquerda em vez da esquerda para direita ou nos casos em que é mais eficiente iniciar uma correspondência na parte direita do padrão em vez de à esquerda.</span><span class="sxs-lookup"><span data-stu-id="7e123-212">This feature is useful when searching from right to left instead of from left to right, or in cases where it is more efficient to begin a match at the right part of the pattern instead of the left.</span></span> <span data-ttu-id="7e123-213">Como mostra o exemplo a seguir, o uso da correspondência da direita para esquerda pode alterar o comportamento de quantificadores Greedy.</span><span class="sxs-lookup"><span data-stu-id="7e123-213">As the following example illustrates, using right-to-left matching can change the behavior of greedy quantifiers.</span></span> <span data-ttu-id="7e123-214">O exemplo realiza duas pesquisas por uma frase que termina em número.</span><span class="sxs-lookup"><span data-stu-id="7e123-214">The example conducts two searches for a sentence that ends in a number.</span></span> <span data-ttu-id="7e123-215">A pesquisa da esquerda para a direita que usa o quantificador Greedy `+` corresponde a um dos seis dígitos na frase, enquanto a pesquisa da direita para a esquerda corresponde a todos os seis dígitos.</span><span class="sxs-lookup"><span data-stu-id="7e123-215">The left-to-right search that uses the greedy quantifier `+` matches one of the six digits in the sentence, whereas the right-to-left search matches all six digits.</span></span> <span data-ttu-id="7e123-216">Para obter uma descrição do padrão de expressão regular, consulte o exemplo que ilustra quantificadores lentos anteriormente nesta seção.</span><span class="sxs-lookup"><span data-stu-id="7e123-216">For a description of the regular expression pattern, see the example that illustrates lazy quantifiers earlier in this section.</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/rtl1.cs#6)]
     [!code-vb[Conceptual.RegularExpressions.Design#6](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/rtl1.vb#6)]

     <span data-ttu-id="7e123-217">Para obter mais informações sobre correspondência da direita para a esquerda, consulte [Opções de expressão regular](regular-expression-options.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-217">For more information about right-to-left matching, see [Regular Expression Options](regular-expression-options.md).</span></span>

- <span data-ttu-id="7e123-218">Lookbehind positivo e negativo: `(?<=` *subexpressão* `)` para lookbehind positivo e `(?<!` *subexpressão* `)` para lookbehind negativa.</span><span class="sxs-lookup"><span data-stu-id="7e123-218">Positive and negative lookbehind: `(?<=`*subexpression*`)` for positive lookbehind, and `(?<!`*subexpression*`)` for negative lookbehind.</span></span> <span data-ttu-id="7e123-219">Esse recurso é semelhante ao lookahead, que é discutido neste tópico.</span><span class="sxs-lookup"><span data-stu-id="7e123-219">This feature is similar to lookahead, which is discussed earlier in this topic.</span></span> <span data-ttu-id="7e123-220">Como o mecanismo de expressões regulares possibilita uma correspondência completa da direita para a esquerda, expressões regulares permitem lookbehinds irrestritos.</span><span class="sxs-lookup"><span data-stu-id="7e123-220">Because the regular expression engine allows complete right-to-left matching, regular expressions allow unrestricted lookbehinds.</span></span> <span data-ttu-id="7e123-221">O lookbehind positivo e negativo também pode ser usado para evitar o aninhamento de quantificadores quando a subexpressão aninhada é um superconjunto de uma expressão externa.</span><span class="sxs-lookup"><span data-stu-id="7e123-221">Positive and negative lookbehind can also be used to avoid nesting quantifiers when the nested subexpression is a superset of an outer expression.</span></span> <span data-ttu-id="7e123-222">Expressões regulares com tais quantificadores aninhados geralmente oferecem um desempenho ruim.</span><span class="sxs-lookup"><span data-stu-id="7e123-222">Regular expressions with such nested quantifiers often offer poor performance.</span></span> <span data-ttu-id="7e123-223">Por exemplo, o exemplo a seguir verifica se uma cadeia de caracteres começa e termina com um caractere alfanumérico e se qualquer outro caractere na cadeia de caracteres faz parte de um subconjunto maior.</span><span class="sxs-lookup"><span data-stu-id="7e123-223">For example, the following example verifies that a string begins and ends with an alphanumeric character, and that any other character in the string is one of a larger subset.</span></span> <span data-ttu-id="7e123-224">Faz parte da expressão regular usada para validar endereços de email. Para obter mais informações, consulte [Como verificar se cadeias de caracteres estão em um formato de email válido](how-to-verify-that-strings-are-in-valid-email-format.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-224">It forms a portion of the regular expression used to validate email addresses; for more information, see [How to: Verify that Strings Are in Valid Email Format](how-to-verify-that-strings-are-in-valid-email-format.md).</span></span>

     [!code-csharp[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/csharp/VS_Snippets_CLR/conceptual.regularexpressions.design/cs/lookbehind1.cs#5)]
     [!code-vb[Conceptual.RegularExpressions.Design#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.regularexpressions.design/vb/lookbehind1.vb#5)]

     <span data-ttu-id="7e123-225">A expressão regular ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` é definida conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="7e123-225">The regular expression ``^[A-Z0-9]([-!#$%&'.*+/=?^`{}|~\w])*(?<=[A-Z0-9])$`` is defined as shown in the following table.</span></span>

    |<span data-ttu-id="7e123-226">Padrão</span><span class="sxs-lookup"><span data-stu-id="7e123-226">Pattern</span></span>|<span data-ttu-id="7e123-227">Descrição</span><span class="sxs-lookup"><span data-stu-id="7e123-227">Description</span></span>|
    |-------------|-----------------|
    |`^`|<span data-ttu-id="7e123-228">Começar a correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7e123-228">Begin the match at the beginning of the string.</span></span>|
    |`[A-Z0-9]`|<span data-ttu-id="7e123-229">Corresponder a qualquer caractere numérico ou alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="7e123-229">Match any numeric or alphanumeric character.</span></span> <span data-ttu-id="7e123-230">(A comparação não diferencia maiúsculas de minúsculas.)</span><span class="sxs-lookup"><span data-stu-id="7e123-230">(The comparison is case-insensitive.)</span></span>|
    |<code>([-!#$%&'.*+/=?^\`{}&#124;~\w])\*</code>|<span data-ttu-id="7e123-231">Coincida com zero ou mais ocorrências de qualquer caractere de palavra ou qualquer um dos seguintes caracteres:-,!, #, $,%, &, ',., \* , +,/, =,?, ^, &#96;, {,}, &#124; ou ~.</span><span class="sxs-lookup"><span data-stu-id="7e123-231">Match zero or more occurrences of any word character, or any of the following characters:  -, !, #, $, %, &, ', ., \*, +, /, =, ?, ^, &#96;, {, }, &#124;, or ~.</span></span>|
    |`(?<=[A-Z0-9])`|<span data-ttu-id="7e123-232">Olhar para o caractere anterior, que precisa ser numérico ou alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="7e123-232">Look behind to the previous character, which must be numeric or alphanumeric.</span></span> <span data-ttu-id="7e123-233">(A comparação não diferencia maiúsculas de minúsculas.)</span><span class="sxs-lookup"><span data-stu-id="7e123-233">(The comparison is case-insensitive.)</span></span>|
    |`$`|<span data-ttu-id="7e123-234">Encerrar a correspondência ao final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="7e123-234">End the match at the end of the string.</span></span>|

     <span data-ttu-id="7e123-235">Para obter mais informações sobre lookbehind positivo e negativo, consulte [Constructos de agrupamento](grouping-constructs-in-regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="7e123-235">For more information about positive and negative lookbehind, see [Grouping Constructs](grouping-constructs-in-regular-expressions.md).</span></span>

## <a name="related-articles"></a><span data-ttu-id="7e123-236">Artigos relacionados</span><span class="sxs-lookup"><span data-stu-id="7e123-236">Related articles</span></span>

|<span data-ttu-id="7e123-237">Título</span><span class="sxs-lookup"><span data-stu-id="7e123-237">Title</span></span>|<span data-ttu-id="7e123-238">Descrição</span><span class="sxs-lookup"><span data-stu-id="7e123-238">Description</span></span>|
|-----------|-----------------|
|[<span data-ttu-id="7e123-239">Retrocesso</span><span class="sxs-lookup"><span data-stu-id="7e123-239">Backtracking</span></span>](backtracking-in-regular-expressions.md)|<span data-ttu-id="7e123-240">Fornece informações sobre como o retrocesso de expressões regulares se ramifica para encontrar correspondências alternativas.</span><span class="sxs-lookup"><span data-stu-id="7e123-240">Provides information about how regular expression backtracking branches to find alternative matches.</span></span>|
|[<span data-ttu-id="7e123-241">Compilação e reutilização</span><span class="sxs-lookup"><span data-stu-id="7e123-241">Compilation and Reuse</span></span>](compilation-and-reuse-in-regular-expressions.md)|<span data-ttu-id="7e123-242">Fornece informações sobre a compilação e a reutilização de expressões regulares para aumentar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="7e123-242">Provides information about compiling and reusing regular expressions to increase performance.</span></span>|
|[<span data-ttu-id="7e123-243">Acesso thread-safe</span><span class="sxs-lookup"><span data-stu-id="7e123-243">Thread Safety</span></span>](thread-safety-in-regular-expressions.md)|<span data-ttu-id="7e123-244">Fornece informações sobre a segurança de thread de expressões regulares e explica quando você deve sincronizar o acesso a objetos de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7e123-244">Provides information about regular expression thread safety and explains when you should synchronize access to regular expression objects.</span></span>|
|[<span data-ttu-id="7e123-245">Expressões regulares do .NET</span><span class="sxs-lookup"><span data-stu-id="7e123-245">.NET Regular Expressions</span></span>](regular-expressions.md)|<span data-ttu-id="7e123-246">Fornece uma visão geral sobre o aspecto de linguagem de programação das expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="7e123-246">Provides an overview of the programming language aspect of regular expressions.</span></span>|
|[<span data-ttu-id="7e123-247">O modelo de objeto de expressão regular</span><span class="sxs-lookup"><span data-stu-id="7e123-247">The Regular Expression Object Model</span></span>](the-regular-expression-object-model.md)|<span data-ttu-id="7e123-248">Oferece informações e exemplos de código que mostram como usar as classes de expressão regular.</span><span class="sxs-lookup"><span data-stu-id="7e123-248">Provides information and code examples illustrating how to use the regular expression classes.</span></span>|
|[<span data-ttu-id="7e123-249">Linguagem de expressões regulares – referência rápida</span><span class="sxs-lookup"><span data-stu-id="7e123-249">Regular Expression Language - Quick Reference</span></span>](regular-expression-language-quick-reference.md)|<span data-ttu-id="7e123-250">Oferece informações a respeito do conjunto de caracteres, operadores e constructos que você pode usar para definir expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="7e123-250">Provides information about the set of characters, operators, and constructs that you can use to define regular expressions.</span></span>|

## <a name="reference"></a><span data-ttu-id="7e123-251">Referência</span><span class="sxs-lookup"><span data-stu-id="7e123-251">Reference</span></span>

- <xref:System.Text.RegularExpressions?displayProperty=nameWithType>
