---
title: Coleções thread-safe
description: Introdução às coleções com segurança de thread usando o namespace System. Collections. decurrent no .NET, que inclui classes de coleção com segurança de threads e escalonáveis.
ms.date: 03/30/2017
ms.technology: dotnet-standard
helpviewer_keywords:
- thread-safe collections, overview
ms.assetid: 2e7ca21f-786c-4367-96be-0cf3f3dcc6bd
ms.openlocfilehash: 27b0e887d7dcff6a6c792cf2dfab6a449f59646f
ms.sourcegitcommit: 27a15a55019f6b5f2733961738babe94aec0def3
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 09/15/2020
ms.locfileid: "90547682"
---
# <a name="thread-safe-collections"></a><span data-ttu-id="f5603-103">Coleções thread-safe</span><span class="sxs-lookup"><span data-stu-id="f5603-103">Thread-Safe Collections</span></span>
<span data-ttu-id="f5603-104">O .NET Framework 4 introduz o namespace <xref:System.Collections.Concurrent?displayProperty=nameWithType>, que inclui várias classes de coleção que são tanto thread-safe quanto escalonáveis.</span><span class="sxs-lookup"><span data-stu-id="f5603-104">The .NET Framework 4 introduces the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace, which includes several collection classes that are both thread-safe and scalable.</span></span> <span data-ttu-id="f5603-105">Vários threads podem adicionar ou remover itens dessas coleções de modo seguro e eficiente sem a necessidade de sincronização adicional no código do usuário.</span><span class="sxs-lookup"><span data-stu-id="f5603-105">Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</span></span> <span data-ttu-id="f5603-106">Ao escrever um novo código, use as classes de coleção simultâneas sempre que vários threads forem ser gravados simultaneamente nas coleções.</span><span class="sxs-lookup"><span data-stu-id="f5603-106">When you write new code, use the concurrent collection classes whenever multiple threads will write to the collection concurrently.</span></span> <span data-ttu-id="f5603-107">Se estiver lendo apenas de uma coleção compartilhada, você poderá usar as classes no namespace <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f5603-107">If you are only reading from a shared collection, then you can use the classes in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="f5603-108">É recomendável não usar as classes da coleção 1.0, a menos que você precise ter como destino o runtime do .NET Framework 1.1 ou anterior.</span><span class="sxs-lookup"><span data-stu-id="f5603-108">We recommend that you do not use 1.0 collection classes unless you are required to target the .NET Framework 1.1 or earlier runtime.</span></span>  
  
## <a name="thread-synchronization-in-the-net-framework-10-and-20-collections"></a><span data-ttu-id="f5603-109">Sincronização de thread nas coleções do .NET Framework 1.0 e 2.0</span><span class="sxs-lookup"><span data-stu-id="f5603-109">Thread Synchronization in the .NET Framework 1.0 and 2.0 Collections</span></span>  
 <span data-ttu-id="f5603-110">As coleções introduzidas no .NET Framework 1.0 são encontradas no namespace <xref:System.Collections?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f5603-110">The collections introduced in the .NET Framework 1.0 are found in the <xref:System.Collections?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="f5603-111">Essas coleções, que incluem os comumente usados <xref:System.Collections.ArrayList> e <xref:System.Collections.Hashtable>, fornecem algum acesso thread-safe por meio da propriedade `Synchronized`, que retorna um wrapper thread-safe em torno da coleção.</span><span class="sxs-lookup"><span data-stu-id="f5603-111">These collections, which include the commonly used <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>, provide some thread-safety through the `Synchronized` property, which returns a thread-safe wrapper around the collection.</span></span> <span data-ttu-id="f5603-112">O wrapper funciona bloqueando toda a coleção a cada operação de adição ou remoção.</span><span class="sxs-lookup"><span data-stu-id="f5603-112">The wrapper works by locking the entire collection on every add or remove operation.</span></span> <span data-ttu-id="f5603-113">Portanto, cada thread que está tentando acessar a coleção deve aguardar por sua vez para receber esse bloqueio.</span><span class="sxs-lookup"><span data-stu-id="f5603-113">Therefore, each thread that is attempting to access the collection must wait for its turn to take the one lock.</span></span> <span data-ttu-id="f5603-114">Isso não é escalonável e pode causar degradação significativa no desempenho para coleções grandes.</span><span class="sxs-lookup"><span data-stu-id="f5603-114">This is not scalable and can cause significant performance degradation for large collections.</span></span> <span data-ttu-id="f5603-115">Além disso, o design não é totalmente protegido contra condições de corrida.</span><span class="sxs-lookup"><span data-stu-id="f5603-115">Also, the design is not completely protected from race conditions.</span></span> <span data-ttu-id="f5603-116">Para saber mais, confira [Synchronization in Generic Collections](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer) (Sincronização em coleções genéricas).</span><span class="sxs-lookup"><span data-stu-id="f5603-116">For more information, see [Synchronization in Generic Collections](/archive/blogs/bclteam/synchronization-in-generic-collections-brian-grunkemeyer).</span></span>  
  
 <span data-ttu-id="f5603-117">As classes de coleções introduzidas no .NET Framework 2.0 são encontradas no namespace <xref:System.Collections.Generic?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f5603-117">The collection classes introduced in the .NET Framework 2.0 are found in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace.</span></span> <span data-ttu-id="f5603-118">Entre elas <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602> e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="f5603-118">These include <xref:System.Collections.Generic.List%601>, <xref:System.Collections.Generic.Dictionary%602>, and so on.</span></span> <span data-ttu-id="f5603-119">Essas classes fornecem desempenho e segurança de tipos aprimorados em comparação com as classes do .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="f5603-119">These classes provide improved type safety and performance compared to the .NET Framework 1.0 classes.</span></span> <span data-ttu-id="f5603-120">No entanto, as classes de coleção do .NET Framework 2.0 não fornecem nenhuma sincronização de thread; o código de usuário deve fornecer sincronização quando itens são adicionados ou removidos simultaneamente em vários threads.</span><span class="sxs-lookup"><span data-stu-id="f5603-120">However, the .NET Framework 2.0 collection classes do not provide any thread synchronization; user code must provide all synchronization when items are added or removed on multiple threads concurrently.</span></span>  
  
 <span data-ttu-id="f5603-121">O recomendável são as classes de coleções simultâneas no .NET Framework 4, pois elas fornecem não apenas a segurança de tipos das classes de coleção do .NET Framework 2.0, mas também acesso thread-safe mais eficiente e completo do que o fornecido pelas coleções do .NET Framework 1.0.</span><span class="sxs-lookup"><span data-stu-id="f5603-121">We recommend the concurrent collections classes in the .NET Framework 4 because they provide not only the type safety of the .NET Framework 2.0 collection classes, but also more efficient and more complete thread safety than the .NET Framework 1.0 collections provide.</span></span>  
  
## <a name="fine-grained-locking-and-lock-free-mechanisms"></a><span data-ttu-id="f5603-122">Bloqueio refinado e mecanismos sem bloqueio</span><span class="sxs-lookup"><span data-stu-id="f5603-122">Fine-Grained Locking and Lock-Free Mechanisms</span></span>  
 <span data-ttu-id="f5603-123">Alguns dos tipos de coleção simultâneos usam mecanismos de sincronização leves como <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim> e <xref:System.Threading.CountdownEvent>, que são novos no .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="f5603-123">Some of the concurrent collection types use lightweight synchronization mechanisms such as <xref:System.Threading.SpinLock>, <xref:System.Threading.SpinWait>, <xref:System.Threading.SemaphoreSlim>, and <xref:System.Threading.CountdownEvent>, which are new in the .NET Framework 4.</span></span> <span data-ttu-id="f5603-124">Esses tipos de sincronização geralmente usam *giro ocupado* por breves períodos antes de colocarem o thread em um verdadeiro estado de espera.</span><span class="sxs-lookup"><span data-stu-id="f5603-124">These synchronization types typically use *busy spinning* for brief periods before they put the thread into a true Wait state.</span></span> <span data-ttu-id="f5603-125">Quando espera-se que os tempos de espera sejam muito curtos, girar é muito menos dispendioso em termos de recursos computacionais do que esperar, o que envolve uma transição de kernel que utiliza muitos recursos.</span><span class="sxs-lookup"><span data-stu-id="f5603-125">When wait times are expected to be very short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</span></span> <span data-ttu-id="f5603-126">Para classes de coleção que usam o giro, essa eficiência significa que vários threads podem adicionar e remover itens em uma taxa muito alta.</span><span class="sxs-lookup"><span data-stu-id="f5603-126">For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a very high rate.</span></span> <span data-ttu-id="f5603-127">Para saber mais sobre rotação versus bloqueio, confira [SpinLock](../../threading/spinlock.md) e [SpinWait](../../threading/spinwait.md).</span><span class="sxs-lookup"><span data-stu-id="f5603-127">For more information about spinning vs. blocking, see [SpinLock](../../threading/spinlock.md) and [SpinWait](../../threading/spinwait.md).</span></span>  
  
 <span data-ttu-id="f5603-128">As classes <xref:System.Collections.Concurrent.ConcurrentQueue%601> e <xref:System.Collections.Concurrent.ConcurrentStack%601> não usam bloqueios.</span><span class="sxs-lookup"><span data-stu-id="f5603-128">The <xref:System.Collections.Concurrent.ConcurrentQueue%601> and <xref:System.Collections.Concurrent.ConcurrentStack%601> classes do not use locks at all.</span></span> <span data-ttu-id="f5603-129">Em vez disso, elas usam operações do <xref:System.Threading.Interlocked> para obter acesso thread-safe.</span><span class="sxs-lookup"><span data-stu-id="f5603-129">Instead, they rely on <xref:System.Threading.Interlocked> operations to achieve thread-safety.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f5603-130">Considerando que as classes de coleções simultâneas dão suporte a <xref:System.Collections.ICollection>, elas fornecem implementações para as propriedades <xref:System.Collections.ICollection.IsSynchronized%2A> e <xref:System.Collections.ICollection.SyncRoot%2A>, embora essas propriedades sejam irrelevantes.</span><span class="sxs-lookup"><span data-stu-id="f5603-130">Because the concurrent collections classes support <xref:System.Collections.ICollection>, they provide implementations for the <xref:System.Collections.ICollection.IsSynchronized%2A> and <xref:System.Collections.ICollection.SyncRoot%2A> properties, even though these properties are irrelevant.</span></span> <span data-ttu-id="f5603-131">`IsSynchronized` sempre retorna `false` e `SyncRoot` é sempre `null` (`Nothing` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="f5603-131">`IsSynchronized` always returns `false` and `SyncRoot` is always `null` (`Nothing` in Visual Basic).</span></span>  
  
 <span data-ttu-id="f5603-132">A tabela a seguir lista os tipos de coleção no namespace <xref:System.Collections.Concurrent?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f5603-132">The following table lists the collection types in the <xref:System.Collections.Concurrent?displayProperty=nameWithType> namespace.</span></span>  
  
|<span data-ttu-id="f5603-133">Tipo</span><span class="sxs-lookup"><span data-stu-id="f5603-133">Type</span></span>|<span data-ttu-id="f5603-134">Description</span><span class="sxs-lookup"><span data-stu-id="f5603-134">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Collections.Concurrent.BlockingCollection%601>|<span data-ttu-id="f5603-135">Fornece funcionalidade de delimitação e bloqueio de qualquer tipo que implemente <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="f5603-135">Provides bounding and blocking functionality for any type that implements <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span></span> <span data-ttu-id="f5603-136">Para obter mais informações, veja [Visão geral de BlockingCollection](blockingcollection-overview.md).</span><span class="sxs-lookup"><span data-stu-id="f5603-136">For more information, see [BlockingCollection Overview](blockingcollection-overview.md).</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentDictionary%602>|<span data-ttu-id="f5603-137">Implementação thread-safe de um dicionário de pares chave-valor.</span><span class="sxs-lookup"><span data-stu-id="f5603-137">Thread-safe implementation of a dictionary of key-value pairs.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentQueue%601>|<span data-ttu-id="f5603-138">Implementação thread-safe de uma fila PEPS (primeiro a entrar, primeiro a sair).</span><span class="sxs-lookup"><span data-stu-id="f5603-138">Thread-safe implementation of a FIFO (first-in, first-out) queue.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentStack%601>|<span data-ttu-id="f5603-139">Implementação thread-safe de uma fila LIFO (último a entrar, primeiro a sair).</span><span class="sxs-lookup"><span data-stu-id="f5603-139">Thread-safe implementation of a LIFO (last-in, first-out) stack.</span></span>|  
|<xref:System.Collections.Concurrent.ConcurrentBag%601>|<span data-ttu-id="f5603-140">Implementação thread-safe de uma coleção não ordenada de elementos.</span><span class="sxs-lookup"><span data-stu-id="f5603-140">Thread-safe implementation of an unordered collection of elements.</span></span>|  
|<xref:System.Collections.Concurrent.IProducerConsumerCollection%601>|<span data-ttu-id="f5603-141">A interface que um tipo deve implementar para uso em um `BlockingCollection`.</span><span class="sxs-lookup"><span data-stu-id="f5603-141">The interface that a type must implement to be used in a `BlockingCollection`.</span></span>|  
  
## <a name="related-topics"></a><span data-ttu-id="f5603-142">Tópicos relacionados</span><span class="sxs-lookup"><span data-stu-id="f5603-142">Related Topics</span></span>  
  
|<span data-ttu-id="f5603-143">Título</span><span class="sxs-lookup"><span data-stu-id="f5603-143">Title</span></span>|<span data-ttu-id="f5603-144">Descrição</span><span class="sxs-lookup"><span data-stu-id="f5603-144">Description</span></span>|  
|-----------|-----------------|  
|[<span data-ttu-id="f5603-145">Visão geral de BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="f5603-145">BlockingCollection Overview</span></span>](blockingcollection-overview.md)|<span data-ttu-id="f5603-146">Este tópico descreve a funcionalidade fornecida pelo tipo <xref:System.Collections.Concurrent.BlockingCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="f5603-146">Describes the functionality provided by the <xref:System.Collections.Concurrent.BlockingCollection%601> type.</span></span>|  
|[<span data-ttu-id="f5603-147">Como: Adicionar e remover itens de um ConcurrentDictionary</span><span class="sxs-lookup"><span data-stu-id="f5603-147">How to: Add and Remove Items from a ConcurrentDictionary</span></span>](how-to-add-and-remove-items.md)|<span data-ttu-id="f5603-148">Descreve como adicionar e remover elementos de um <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span><span class="sxs-lookup"><span data-stu-id="f5603-148">Describes how to add and remove elements from a <xref:System.Collections.Concurrent.ConcurrentDictionary%602></span></span>|  
|[<span data-ttu-id="f5603-149">Como: Adicionar e remover itens individualmente de uma BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="f5603-149">How to: Add and Take Items Individually from a BlockingCollection</span></span>](how-to-add-and-take-items.md)|<span data-ttu-id="f5603-150">Descreve como adicionar e recuperar itens de uma coleta de bloqueio sem usar o enumerador de somente leitura.</span><span class="sxs-lookup"><span data-stu-id="f5603-150">Describes how to add and retrieve items from a blocking collection without using the read-only enumerator.</span></span>|  
|[<span data-ttu-id="f5603-151">Como: Adicionar a funcionalidade de delimitação e bloqueio a uma coleção</span><span class="sxs-lookup"><span data-stu-id="f5603-151">How to: Add Bounding and Blocking Functionality to a Collection</span></span>](how-to-add-bounding-and-blocking.md)|<span data-ttu-id="f5603-152">Descreve como usar qualquer classe de coleção como o mecanismo de armazenamento subjacente para uma coleção <xref:System.Collections.Concurrent.IProducerConsumerCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="f5603-152">Describes how to use any collection class as the underlying storage mechanism for an <xref:System.Collections.Concurrent.IProducerConsumerCollection%601> collection.</span></span>|  
|[<span data-ttu-id="f5603-153">Como: Usar ForEach para remover itens de uma BlockingCollection</span><span class="sxs-lookup"><span data-stu-id="f5603-153">How to: Use ForEach to Remove Items in a BlockingCollection</span></span>](how-to-use-foreach-to-remove.md)|<span data-ttu-id="f5603-154">Descreve como usar `foreach` (`For Each` no Visual Basic) para remover todos os itens em uma coleção de bloqueios.</span><span class="sxs-lookup"><span data-stu-id="f5603-154">Describes how to use `foreach`, (`For Each` in Visual Basic) to remove all items in a blocking collection.</span></span>|  
|[<span data-ttu-id="f5603-155">Como: Usar matrizes de coleções de bloqueio em um pipeline</span><span class="sxs-lookup"><span data-stu-id="f5603-155">How to: Use Arrays of Blocking Collections in a Pipeline</span></span>](how-to-use-arrays-of-blockingcollections.md)|<span data-ttu-id="f5603-156">Descreve como usar várias coleções de bloqueio ao mesmo tempo para implementar um pipeline.</span><span class="sxs-lookup"><span data-stu-id="f5603-156">Describes how to use multiple blocking collections at the same time to implement a pipeline.</span></span>|  
|[<span data-ttu-id="f5603-157">Como: Criar um pool de objetos, usando um ConcurrentBag</span><span class="sxs-lookup"><span data-stu-id="f5603-157">How to: Create an Object Pool by Using a ConcurrentBag</span></span>](how-to-create-an-object-pool.md)|<span data-ttu-id="f5603-158">Mostra como usar um recipiente simultâneo para melhorar o desempenho em cenários nos quais, em vez de criar novos objetos continuamente, você pode reutilizá-los.</span><span class="sxs-lookup"><span data-stu-id="f5603-158">Shows how to use a concurrent bag to improve performance in scenarios where you can reuse objects instead of continually creating new ones.</span></span>|  
  
## <a name="reference"></a><span data-ttu-id="f5603-159">Referência</span><span class="sxs-lookup"><span data-stu-id="f5603-159">Reference</span></span>  
 <xref:System.Collections.Concurrent?displayProperty=nameWithType>
