---
title: Covariância e contravariância em genéricos
ms.date: 03/30/2017
ms.technology: dotnet-standard
dev_langs:
- csharp
- vb
helpviewer_keywords:
- generics, covariance and contravariance
- generics, variance
- covariance and contravariance in generics
- generic type parameters
ms.assetid: 2678dc63-c7f9-4590-9ddc-0a4df684d42e
author: mairaw
ms.author: mairaw
ms.openlocfilehash: ee8cc1b677ad6f6c2718c155edbba632df38dbd3
ms.sourcegitcommit: f348c84443380a1959294cdf12babcb804cfa987
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 11/12/2019
ms.locfileid: "73974691"
---
# <a name="covariance-and-contravariance-in-generics"></a><span data-ttu-id="fbe59-102">Covariância e contravariância em genéricos</span><span class="sxs-lookup"><span data-stu-id="fbe59-102">Covariance and Contravariance in Generics</span></span>
<span data-ttu-id="fbe59-103">Covariância e contravariância são termos que se referem à capacidade de usar um tipo mais derivado (mais específico) ou um tipo menos derivado (menos específico) do que o especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="fbe59-103">Covariance and contravariance are terms that refer to the ability to use a more derived type (more specific) or a less derived type (less specific) than originally specified.</span></span> <span data-ttu-id="fbe59-104">Os parâmetros de tipo genéricos oferecem suporte a covariância e contravariância para fornecer maior flexibilidade na atribuição e no uso de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="fbe59-104">Generic type parameters support covariance and contravariance to provide greater flexibility in assigning and using generic types.</span></span> <span data-ttu-id="fbe59-105">Quando você se refere a um sistema de tipos, a covariância, contravariância e invariância possuem as definições a seguir.</span><span class="sxs-lookup"><span data-stu-id="fbe59-105">When you are referring to a type system, covariance, contravariance, and invariance have the following definitions.</span></span> <span data-ttu-id="fbe59-106">Os exemplos assumem uma classe base chamada `Base` e uma classe derivada chamada `Derived`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-106">The examples assume a base class named `Base` and a derived class named `Derived`.</span></span>  
  
- `Covariance`  
  
     <span data-ttu-id="fbe59-107">Permite usar um tipo mais derivado que o especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="fbe59-107">Enables you to use a more derived type than originally specified.</span></span>  
  
     <span data-ttu-id="fbe59-108">Você pode atribuir uma instância de `IEnumerable<Derived>` (`IEnumerable(Of Derived)` no Visual Basic) a uma variável do tipo `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-108">You can assign an instance of `IEnumerable<Derived>` (`IEnumerable(Of Derived)` in Visual Basic) to a variable of type `IEnumerable<Base>`.</span></span>  
  
- `Contravariance`  
  
     <span data-ttu-id="fbe59-109">Permite a você usar um tipo mais genérico (menos derivado) do que aquele especificado originalmente.</span><span class="sxs-lookup"><span data-stu-id="fbe59-109">Enables you to use a more generic (less derived) type than originally specified.</span></span>  
  
     <span data-ttu-id="fbe59-110">Você pode atribuir uma instância de `Action<Base>` (`Action(Of Base)` no Visual Basic) a uma variável do tipo `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-110">You can assign an instance of `Action<Base>` (`Action(Of Base)` in Visual Basic) to a variable of type `Action<Derived>`.</span></span>  
  
- `Invariance`  
  
     <span data-ttu-id="fbe59-111">Significa que você pode usar apenas o tipo especificado originalmente; assim, um parâmetro de tipo genérico invariante não é covariante nem contravariante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-111">Means that you can use only the type originally specified; so an invariant generic type parameter is neither covariant nor contravariant.</span></span>  
  
     <span data-ttu-id="fbe59-112">Você não pode atribuir uma instância de `List<Base>` (`List(Of Base)` no Visual Basic) a uma variável do tipo `List<Derived>` ou vice-versa.</span><span class="sxs-lookup"><span data-stu-id="fbe59-112">You cannot assign an instance of `List<Base>` (`List(Of Base)` in Visual Basic) to a variable of type `List<Derived>` or vice versa.</span></span>  
  
 <span data-ttu-id="fbe59-113">Os parâmetros de tipo covariantes permitem fazer atribuições muito semelhantes ao [Polimorfismo](../../csharp/programming-guide/classes-and-structs/polymorphism.md) comum, conforme mostrado no código a seguir.</span><span class="sxs-lookup"><span data-stu-id="fbe59-113">Covariant type parameters enable you to make assignments that look much like ordinary [Polymorphism](../../csharp/programming-guide/classes-and-structs/polymorphism.md), as shown in the following code.</span></span>  
  
 [!code-csharp[CoContraSimpleIEnum#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleienum/cs/example.cs#1)]
 [!code-vb[CoContraSimpleIEnum#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleienum/vb/example.vb#1)]  
  
 <span data-ttu-id="fbe59-114">A classe <xref:System.Collections.Generic.List%601> implementa a interface <xref:System.Collections.Generic.IEnumerable%601>. Assim, `List<Derived>` (`List(Of Derived)` no Visual Basic) implementa `IEnumerable<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-114">The <xref:System.Collections.Generic.List%601> class implements the <xref:System.Collections.Generic.IEnumerable%601> interface, so `List<Derived>` (`List(Of Derived)` in Visual Basic) implements `IEnumerable<Derived>`.</span></span> <span data-ttu-id="fbe59-115">O parâmetro de tipo covariante faz o resto.</span><span class="sxs-lookup"><span data-stu-id="fbe59-115">The covariant type parameter does the rest.</span></span>  
  
 <span data-ttu-id="fbe59-116">A contravariância, por outro lado, parece não ser intuitiva.</span><span class="sxs-lookup"><span data-stu-id="fbe59-116">Contravariance, on the other hand, seems counterintuitive.</span></span> <span data-ttu-id="fbe59-117">O exemplo a seguir cria um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) e, em seguida, atribuir o delegado a uma variável do tipo `Action<Derived>`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-117">The following example creates a delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic), and then assigns that delegate to a variable of type `Action<Derived>`.</span></span>  
  
 [!code-csharp[CoContraSimpleAction#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontrasimpleaction/cs/example.cs#1)]
 [!code-vb[CoContraSimpleAction#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontrasimpleaction/vb/example.vb#1)]  
  
 <span data-ttu-id="fbe59-118">Isso parece ser um retrocesso, mas é esse código de tipo seguro que compila e executa.</span><span class="sxs-lookup"><span data-stu-id="fbe59-118">This seems backward, but it is type-safe code that compiles and runs.</span></span> <span data-ttu-id="fbe59-119">A expressão lambda corresponde ao delegado ao qual ela é atribuída. Assim, ela define um método que recebe um parâmetro do tipo `Base` e não tem nenhum valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="fbe59-119">The lambda expression matches the delegate it is assigned to, so it defines a method that takes one parameter of type `Base` and that has no return value.</span></span> <span data-ttu-id="fbe59-120">O delegado resultante pode ser atribuído a uma variável do tipo `Action<Derived>` porque o parâmetro de tipo `T` do delegado <xref:System.Action%601> é contravariante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-120">The resulting delegate can be assigned to a variable of type `Action<Derived>` because the type parameter `T` of the <xref:System.Action%601> delegate is contravariant.</span></span> <span data-ttu-id="fbe59-121">O código é de tipo seguro porque `T` especifica um tipo de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="fbe59-121">The code is type-safe because `T` specifies a parameter type.</span></span> <span data-ttu-id="fbe59-122">Quando o delegado do tipo `Action<Base>` é invocado como se fosse um delegado do tipo `Action<Derived>`, seu argumento deve ser do tipo `Derived`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-122">When the delegate of type `Action<Base>` is invoked as if it were a delegate of type `Action<Derived>`, its argument must be of type `Derived`.</span></span> <span data-ttu-id="fbe59-123">Este argumento sempre pode ser passado ao método subjacente com segurança porque o parâmetro do método é do tipo `Base`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-123">This argument can always be passed safely to the underlying method, because the method's parameter is of type `Base`.</span></span>  
  
 <span data-ttu-id="fbe59-124">Geralmente, um parâmetro de tipo de covariante pode ser usado como o tipo de retorno de um delegado, e os parâmetros de tipo contravariant podem ser usados como tipos de parâmetro.</span><span class="sxs-lookup"><span data-stu-id="fbe59-124">In general, a covariant type parameter can be used as the return type of a delegate, and contravariant type parameters can be used as parameter types.</span></span> <span data-ttu-id="fbe59-125">Para uma interface, os parâmetros de tipo covariantes podem ser usados como os tipos de retorno dos métodos da interface, e os parâmetros de tipo contravariantes podem ser usados como os tipos de parâmetro dos métodos da interface.</span><span class="sxs-lookup"><span data-stu-id="fbe59-125">For an interface, covariant type parameters can be used as the return types of the interface's methods, and contravariant type parameters can be used as the parameter types of the interface's methods.</span></span>  
  
 <span data-ttu-id="fbe59-126">A covariância e a contravariância são referidas coletivamente como *variância*.</span><span class="sxs-lookup"><span data-stu-id="fbe59-126">Covariance and contravariance are collectively referred to as *variance*.</span></span> <span data-ttu-id="fbe59-127">Um parâmetro de tipo genérico que não é covariante ou contravariante é referido como *invariante*.</span><span class="sxs-lookup"><span data-stu-id="fbe59-127">A generic type parameter that is not marked covariant or contravariant is referred to as *invariant*.</span></span> <span data-ttu-id="fbe59-128">Um breve resumo de fatos sobre variância em Common Language Runtime:</span><span class="sxs-lookup"><span data-stu-id="fbe59-128">A brief summary of facts about variance in the common language runtime:</span></span>  
  
- <span data-ttu-id="fbe59-129">No .NET Framework 4, os parâmetros de tipo variantes são restringidos à interface genérica e tipos de delegados genéricos.</span><span class="sxs-lookup"><span data-stu-id="fbe59-129">In the .NET Framework 4, variant type parameters are restricted to generic interface and generic delegate types.</span></span>  
  
- <span data-ttu-id="fbe59-130">Uma interface genérica ou um tipo delegado genérico podem ter parâmetros de tipo covariantes e contravariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-130">A generic interface or generic delegate type can have both covariant and contravariant type parameters.</span></span>  
  
- <span data-ttu-id="fbe59-131">A variância aplica-se apenas para referenciar tipos; se você especificar um tipo de valor para um parâmetro de tipo variante, esse parâmetro de tipo será invariante para o tipo construído resultante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-131">Variance applies only to reference types; if you specify a value type for a variant type parameter, that type parameter is invariant for the resulting constructed type.</span></span>  
  
- <span data-ttu-id="fbe59-132">A variância não se aplica à combinação de delegado.</span><span class="sxs-lookup"><span data-stu-id="fbe59-132">Variance does not apply to delegate combination.</span></span> <span data-ttu-id="fbe59-133">Ou seja, considerando dois delegados de tipos `Action<Derived>` e `Action<Base>` (`Action(Of Derived)` e `Action(Of Base)` no Visual Basic), você não pode combinar o segundo delegado com o primeiro, ainda que o resultado seja de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="fbe59-133">That is, given two delegates of types `Action<Derived>` and `Action<Base>` (`Action(Of Derived)` and `Action(Of Base)` in Visual Basic), you cannot combine the second delegate with the first although the result would be type safe.</span></span> <span data-ttu-id="fbe59-134">A variância permite que o segundo delegado seja atribuído a uma variável do tipo `Action<Derived>`, mas os delegados podem ser combinados somente quando seus tipos são exatamente iguais.</span><span class="sxs-lookup"><span data-stu-id="fbe59-134">Variance allows the second delegate to be assigned to a variable of type `Action<Derived>`, but delegates can combine only if their types match exactly.</span></span>

<a name="InterfaceCovariantTypeParameters"></a>
## <a name="generic-interfaces-with-covariant-type-parameters"></a><span data-ttu-id="fbe59-135">Interfaces genéricas com parâmetros de tipo covariantes</span><span class="sxs-lookup"><span data-stu-id="fbe59-135">Generic Interfaces with Covariant Type Parameters</span></span>  
 <span data-ttu-id="fbe59-136">Do .NET Framework 4 em diante, várias interfaces genéricas têm parâmetros de tipo covariantes, por exemplo: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601> e <xref:System.Linq.IGrouping%602>.</span><span class="sxs-lookup"><span data-stu-id="fbe59-136">Starting with the .NET Framework 4, several generic interfaces have covariant type parameters; for example: <xref:System.Collections.Generic.IEnumerable%601>, <xref:System.Collections.Generic.IEnumerator%601>, <xref:System.Linq.IQueryable%601>, and <xref:System.Linq.IGrouping%602>.</span></span> <span data-ttu-id="fbe59-137">Todos os parâmetros de tipo dessas interfaces são covariantes, de forma que os parâmetros de tipo são usados apenas para os tipos de retorno dos membros.</span><span class="sxs-lookup"><span data-stu-id="fbe59-137">All the type parameters of these interfaces are covariant, so the type parameters are used only for the return types of the members.</span></span>  
  
 <span data-ttu-id="fbe59-138">O exemplo a seguir ilustra parâmetros de tipo covariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-138">The following example illustrates covariant type parameters.</span></span> <span data-ttu-id="fbe59-139">O exemplo define dois tipos: `Base` tem um método estático chamado `PrintBases` que usa um `IEnumerable<Base>` (`IEnumerable(Of Base)` no Visual Basic) e imprime os elementos.</span><span class="sxs-lookup"><span data-stu-id="fbe59-139">The example defines two types: `Base` has a static method named `PrintBases` that takes an `IEnumerable<Base>` (`IEnumerable(Of Base)` in Visual Basic) and prints the elements.</span></span> <span data-ttu-id="fbe59-140">`Derived` herda de `Base`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-140">`Derived` inherits from `Base`.</span></span> <span data-ttu-id="fbe59-141">O exemplo cria um `List<Derived>` vazio (`List(Of Derived)` no Visual Basic) e demonstra que esse tipo pode ser passado a `PrintBases` e atribuído a uma variável do tipo `IEnumerable<Base>` sem converter.</span><span class="sxs-lookup"><span data-stu-id="fbe59-141">The example creates an empty `List<Derived>` (`List(Of Derived)` in Visual Basic) and demonstrates that this type can be passed to `PrintBases` and assigned to a variable of type `IEnumerable<Base>` without casting.</span></span> <span data-ttu-id="fbe59-142"><xref:System.Collections.Generic.List%601> implementa <xref:System.Collections.Generic.IEnumerable%601>, o qual tem um único parâmetro de tipo covariante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-142"><xref:System.Collections.Generic.List%601> implements <xref:System.Collections.Generic.IEnumerable%601>, which has a single covariant type parameter.</span></span> <span data-ttu-id="fbe59-143">O parâmetro de tipo covariante é a razão pela qual uma instância de `IEnumerable<Derived>` pode ser usada em vez de `IEnumerable<Base>`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-143">The covariant type parameter is the reason why an instance of `IEnumerable<Derived>` can be used instead of `IEnumerable<Base>`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici/vb/example.vb#1)]  
  
## <a name="generic-interfaces-with-contravariant-generic-type-parameters"></a><span data-ttu-id="fbe59-144">Interfaces genéricas com parâmetros de tipo genéricos contravariantes</span><span class="sxs-lookup"><span data-stu-id="fbe59-144">Generic Interfaces with Contravariant Generic Type Parameters</span></span>  
 <span data-ttu-id="fbe59-145">Do .NET Framework 4 em diante, várias interfaces genéricas têm parâmetros de tipo contravariantes, por exemplo: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601> e <xref:System.Collections.Generic.IEqualityComparer%601>.</span><span class="sxs-lookup"><span data-stu-id="fbe59-145">Starting with the .NET Framework 4, several generic interfaces have contravariant type parameters; for example: <xref:System.Collections.Generic.IComparer%601>, <xref:System.IComparable%601>, and <xref:System.Collections.Generic.IEqualityComparer%601>.</span></span> <span data-ttu-id="fbe59-146">Essas interfaces possuem apenas parâmetros de tipo contravariantes. Assim, os parâmetros de tipo são usados apenas como parâmetros de tipo nos membros das interfaces.</span><span class="sxs-lookup"><span data-stu-id="fbe59-146">These interfaces have only contravariant type parameters, so the type parameters are used only as parameter types in the members of the interfaces.</span></span>  
  
 <span data-ttu-id="fbe59-147">O exemplo a seguir ilustra parâmetros de tipo contravariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-147">The following example illustrates contravariant type parameters.</span></span> <span data-ttu-id="fbe59-148">O exemplo define uma classe abstrata (`MustInherit` no Visual Basic) `Shape` com uma propriedade `Area`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-148">The example defines an abstract (`MustInherit` in Visual Basic) `Shape` class with an `Area` property.</span></span> <span data-ttu-id="fbe59-149">O exemplo também define uma classe `ShapeAreaComparer` que implementa `IComparer<Shape>` (`IComparer(Of Shape)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="fbe59-149">The example also defines a `ShapeAreaComparer` class that implements `IComparer<Shape>` (`IComparer(Of Shape)` in Visual Basic).</span></span> <span data-ttu-id="fbe59-150">A implementação do método <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> baseia-se no valor da propriedade `Area`, portanto `ShapeAreaComparer` pode ser usado para classificar objetos `Shape` por área.</span><span class="sxs-lookup"><span data-stu-id="fbe59-150">The implementation of the <xref:System.Collections.Generic.IComparer%601.Compare%2A?displayProperty=nameWithType> method is based on the value of the `Area` property, so `ShapeAreaComparer` can be used to sort `Shape` objects by area.</span></span>  
  
 <span data-ttu-id="fbe59-151">A classe `Circle` herda `Shape` e substitui `Area`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-151">The `Circle` class inherits `Shape` and overrides `Area`.</span></span> <span data-ttu-id="fbe59-152">O exemplo cria um <xref:System.Collections.Generic.SortedSet%601> de objetos `Circle` usando um construtor que usa `IComparer<Circle>` (`IComparer(Of Circle)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="fbe59-152">The example creates a <xref:System.Collections.Generic.SortedSet%601> of `Circle` objects, using a constructor that takes an `IComparer<Circle>` (`IComparer(Of Circle)` in Visual Basic).</span></span> <span data-ttu-id="fbe59-153">Porém, em vez de passar um `IComparer<Circle>`, o exemplo passa um objeto `ShapeAreaComparer` que implementa `IComparer<Shape>`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-153">However, instead of passing an `IComparer<Circle>`, the example passes a `ShapeAreaComparer` object, which implements `IComparer<Shape>`.</span></span> <span data-ttu-id="fbe59-154">O exemplo pode passar um comparador de um tipo derivado (`Shape`) quando um código chama um comparador de um tipo mais derivado (`Circle`) porque o parâmetro de tipo da interface genérica <xref:System.Collections.Generic.IComparer%601> é contravariante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-154">The example can pass a comparer of a less derived type (`Shape`) when the code calls for a comparer of a more derived type (`Circle`), because the type parameter of the <xref:System.Collections.Generic.IComparer%601> generic interface is contravariant.</span></span>  
  
 <span data-ttu-id="fbe59-155">Quando um novo objeto `Circle` é adicionado a `SortedSet<Circle>`, o método `IComparer<Shape>.Compare` (método `IComparer(Of Shape).Compare` no Visual Basic) do objeto `ShapeAreaComparer` é chamado sempre que um novo elemento é comparado a um elemento existente.</span><span class="sxs-lookup"><span data-stu-id="fbe59-155">When a new `Circle` object is added to the `SortedSet<Circle>`, the `IComparer<Shape>.Compare` method (`IComparer(Of Shape).Compare` method in Visual Basic) of the `ShapeAreaComparer` object is called each time the new element is compared to an existing element.</span></span> <span data-ttu-id="fbe59-156">O tipo de parâmetro do método (`Shape`) é menos derivado que o tipo que está sendo passado (`Circle`). Assim, a chamada é de tipo seguro.</span><span class="sxs-lookup"><span data-stu-id="fbe59-156">The parameter type of the method (`Shape`) is less derived than the type that is being passed (`Circle`), so the call is type safe.</span></span> <span data-ttu-id="fbe59-157">A contravariância permite que `ShapeAreaComparer` classifique uma coleção de um único tipo, bem como uma coleção mista de tipos, que deriva de `Shape`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-157">Contravariance enables `ShapeAreaComparer` to sort a collection of any single type, as well as a mixed collection of types, that derive from `Shape`.</span></span>  
  
 [!code-csharp[CoContravarianceInClrGenericI2#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravarianceinclrgenerici2/cs/example.cs#1)]
 [!code-vb[CoContravarianceInClrGenericI2#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravarianceinclrgenerici2/vb/example.vb#1)]  

## <a name="generic-delegates-with-variant-type-parameters"></a><span data-ttu-id="fbe59-158">Delegados genéricos com parâmetros de tipo variantes</span><span class="sxs-lookup"><span data-stu-id="fbe59-158">Generic Delegates with Variant Type Parameters</span></span>  
 <span data-ttu-id="fbe59-159">No .NET Framework 4, os delegados genéricos `Func`, tais como <xref:System.Func%602>, têm tipos de retorno covariantes e tipos de parâmetro contravariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-159">In the .NET Framework 4, the `Func` generic delegates, such as <xref:System.Func%602>, have covariant return types and contravariant parameter types.</span></span> <span data-ttu-id="fbe59-160">Os delegados genéricos `Action`, como <xref:System.Action%602>, possuem tipos de parâmetros contravariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-160">The `Action` generic delegates, such as <xref:System.Action%602>, have contravariant parameter types.</span></span> <span data-ttu-id="fbe59-161">Isso significa que os delegados podem ser atribuídos a variáveis que possuem tipos de parâmetro mais derivados e (no caso dos delegados genéricos `Func`) menos tipos de retorno derivados.</span><span class="sxs-lookup"><span data-stu-id="fbe59-161">This means that the delegates can be assigned to variables that have more derived parameter types and (in the case of the `Func` generic delegates) less derived return types.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fbe59-162">O último parâmetro de tipo genérico dos delegados genéricos `Func` especifica o tipo do valor de retorno na assinatura do delegado.</span><span class="sxs-lookup"><span data-stu-id="fbe59-162">The last generic type parameter of the `Func` generic delegates specifies the type of the return value in the delegate signature.</span></span> <span data-ttu-id="fbe59-163">É covariante (palavra-chave `out`), enquanto os outros parâmetros de tipo genéricos são contravariantes (palavra-chave `in`).</span><span class="sxs-lookup"><span data-stu-id="fbe59-163">It is covariant (`out` keyword), whereas the other generic type parameters are contravariant (`in` keyword).</span></span>  
  
 <span data-ttu-id="fbe59-164">O código a seguir ilustra isso.</span><span class="sxs-lookup"><span data-stu-id="fbe59-164">The following code illustrates this.</span></span> <span data-ttu-id="fbe59-165">O primeiro trecho de código define uma classe chamada `Base`, uma classe chamada `Derived` que herda `Base` e outra classe com um método `static` (`Shared` no Visual Basic) chamado `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-165">The first piece of code defines a class named `Base`, a class named `Derived` that inherits `Base`, and another class with a `static` method (`Shared` in Visual Basic) named `MyMethod`.</span></span> <span data-ttu-id="fbe59-166">O método usa uma instância de `Base` e retorna uma instância de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-166">The method takes an instance of `Base` and returns an instance of `Derived`.</span></span> <span data-ttu-id="fbe59-167">(Se o argumento for uma instância de `Derived`, `MyMethod` o retornará; se o argumento for uma instância de `Base`, `MyMethod` retornará uma nova instância de `Derived`.) No `Main()`, o exemplo cria uma instância de `Func<Base, Derived>` (`Func(Of Base, Derived)` em Visual Basic) que representa `MyMethod`e a armazena na variável `f1`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-167">(If the argument is an instance of `Derived`, `MyMethod` returns it; if the argument is an instance of `Base`, `MyMethod` returns a new instance of `Derived`.) In `Main()`, the example creates an instance of `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic) that represents `MyMethod`, and stores it in the variable `f1`.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#2](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#2)]
 [!code-vb[CoContravarianceDelegates#2](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#2)]  
  
 <span data-ttu-id="fbe59-168">O segundo trecho de código a seguir mostra que o delegado pode ser atribuído a uma variável do tipo `Func<Base, Base>` (`Func(Of Base, Base)` no Visual Basic) porque o tipo de retorno é covariante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-168">The second piece of code shows that the delegate can be assigned to a variable of type `Func<Base, Base>` (`Func(Of Base, Base)` in Visual Basic), because the return type is covariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#3](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#3)]
 [!code-vb[CoContravarianceDelegates#3](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#3)]  
  
 <span data-ttu-id="fbe59-169">O terceiro trecho de código a seguir mostra que o delegado pode ser atribuído a uma variável do tipo `Func<Derived, Derived>` (`Func(Of Derived, Derived)` no Visual Basic) porque o tipo de parâmetro é contravariante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-169">The third piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Derived>` (`Func(Of Derived, Derived)` in Visual Basic), because the parameter type is contravariant.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#4](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#4)]
 [!code-vb[CoContravarianceDelegates#4](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#4)]  
  
 <span data-ttu-id="fbe59-170">O trecho final de código mostra que o delegado pode ser atribuído a uma variável de tipo `Func<Derived, Base>` (`Func(Of Derived, Base)` no Visual Basic), combinando os efeitos do tipo de parâmetro contravariante e do tipo de retorno covariante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-170">The final piece of code shows that the delegate can be assigned to a variable of type `Func<Derived, Base>` (`Func(Of Derived, Base)` in Visual Basic), combining the effects of the contravariant parameter type and the covariant return type.</span></span>  
  
 [!code-csharp[CoContravarianceDelegates#5](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegates/cs/example.cs#5)]
 [!code-vb[CoContravarianceDelegates#5](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegates/vb/example.vb#5)]  
  
### <a name="variance-in-generic-and-non-generic-delegates"></a><span data-ttu-id="fbe59-171">Variação em delegados genéricos e não genéricos</span><span class="sxs-lookup"><span data-stu-id="fbe59-171">Variance in Generic and Non-Generic Delegates</span></span>  
 <span data-ttu-id="fbe59-172">No código anterior, a assinatura de `MyMethod` corresponde exatamente à assinatura do delegado genérico construído: `Func<Base, Derived>` (`Func(Of Base, Derived)` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="fbe59-172">In the preceding code, the signature of `MyMethod` exactly matches the signature of the constructed generic delegate: `Func<Base, Derived>` (`Func(Of Base, Derived)` in Visual Basic).</span></span> <span data-ttu-id="fbe59-173">O exemplo mostra que esse delegado genérico pode ser armazenado em variáveis ou parâmetros do método que têm tipos de parâmetro mais derivados e tipos de retorno menos derivados, desde que todos os tipos de delegados sejam construídos do tipo de delegado genérico <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="fbe59-173">The example shows that this generic delegate can be stored in variables or method parameters that have more derived parameter types and less derived return types, as long as all the delegate types are constructed from the generic delegate type <xref:System.Func%602>.</span></span>  
  
 <span data-ttu-id="fbe59-174">Este é um aspecto importante.</span><span class="sxs-lookup"><span data-stu-id="fbe59-174">This is an important point.</span></span> <span data-ttu-id="fbe59-175">Os efeitos da covariância e da contravariância nos parâmetros de tipo de delegados genéricos são semelhantes aos efeitos da covariância e da contravariância na associação comum de delegação (confira [Variância em delegados (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) e [Variância em delegados (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span><span class="sxs-lookup"><span data-stu-id="fbe59-175">The effects of covariance and contravariance in the type parameters of generic delegates are similar to the effects of covariance and contravariance in ordinary delegate binding (see [Variance in Delegates (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md) and [Variance in Delegates (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)).</span></span> <span data-ttu-id="fbe59-176">No entanto, a variância na associação de delegados funciona com todos os tipos de delegados, e não apenas com tipos de delegados genéricos com parâmetros de tipo variantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-176">However, variance in delegate binding works with all delegate types, not just with generic delegate types that have variant type parameters.</span></span> <span data-ttu-id="fbe59-177">Além disso, a variância na associação de delegados possibilita a um método a ser associado a qualquer delegado que tenha os tipos de parâmetro mais restritivos e um tipo de retorno menos restritivo, enquanto que a atribuição de delegados genéricos só funciona quando ambos os tipos de delegados são construídos da mesma definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="fbe59-177">Furthermore, variance in delegate binding enables a method to be bound to any delegate that has more restrictive parameter types and a less restrictive return type, whereas the assignment of generic delegates works only if both delegate types are constructed from the same generic type definition.</span></span>  
  
 <span data-ttu-id="fbe59-178">O exemplo a seguir mostra os efeitos combinados da variância na associação de delegados e a variância em parâmetros de tipo genéricos.</span><span class="sxs-lookup"><span data-stu-id="fbe59-178">The following example shows the combined effects of variance in delegate binding and variance in generic type parameters.</span></span> <span data-ttu-id="fbe59-179">O exemplo define uma hierarquia de tipo que inclui três tipos, do menos derivado (`Type1`) para o mais derivado (`Type3`).</span><span class="sxs-lookup"><span data-stu-id="fbe59-179">The example defines a type hierarchy that includes three types, from least derived (`Type1`) to most derived (`Type3`).</span></span> <span data-ttu-id="fbe59-180">A variância na associação comum de delegados é usada para associar um método a um tipo de parâmetro `Type1` e um tipo de retorno `Type3` a um representante genérico com um tipo de parâmetro `Type2` e um tipo de retorno `Type2`.</span><span class="sxs-lookup"><span data-stu-id="fbe59-180">Variance in ordinary delegate binding is used to bind a method with a parameter type of `Type1` and a return type of `Type3` to a generic delegate with a parameter type of `Type2` and a return type of `Type2`.</span></span> <span data-ttu-id="fbe59-181">O delegado genérico resultante é então atribuído a outra variável cujo tipo de delegado genérico possui um parâmetro de tipo `Type3` e tipo de retorno `Type1`, usando a covariância e a contravariância de parâmetros de tipo genéricos.</span><span class="sxs-lookup"><span data-stu-id="fbe59-181">The resulting generic delegate is then assigned to another variable whose generic delegate type has a parameter of type `Type3` and a return type of `Type1`, using the covariance and contravariance of generic type parameters.</span></span> <span data-ttu-id="fbe59-182">A segunda atribuição requer que o tipo de variável e o tipo de delegado sejam construídos a partir da mesma definição de tipo genérico, nesse caso, <xref:System.Func%602>.</span><span class="sxs-lookup"><span data-stu-id="fbe59-182">The second assignment requires both the variable type and the delegate type to be constructed from the same generic type definition, in this case, <xref:System.Func%602>.</span></span>  
  
 [!code-csharp[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/csharp/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/cs/example.cs#1)]
 [!code-vb[CoContravarianceDelegatesGenRelaxed#1](../../../samples/snippets/visualbasic/VS_Snippets_CLR/cocontravariancedelegatesgenrelaxed/vb/example.vb#1)]  

## <a name="defining-variant-generic-interfaces-and-delegates"></a><span data-ttu-id="fbe59-183">Definindo interfaces e delegados genéricos variantes</span><span class="sxs-lookup"><span data-stu-id="fbe59-183">Defining Variant Generic Interfaces and Delegates</span></span>
 <span data-ttu-id="fbe59-184">Do .NET Framework 4 em diante, o Visual Basic e o C# têm palavras-chave que permitem marcar os parâmetros de tipo genéricos de interfaces e delegados como covariantes ou contravariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-184">Starting with the .NET Framework 4, Visual Basic and C# have keywords that enable you to mark the generic type parameters of interfaces and delegates as covariant or contravariant.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fbe59-185">A partir do .NET Framework 2.0, o Common Language Runtime oferece suporte a anotações de variância em parâmetros de tipo genéricos.</span><span class="sxs-lookup"><span data-stu-id="fbe59-185">Starting with the .NET Framework version 2.0, the common language runtime supports variance annotations on generic type parameters.</span></span> <span data-ttu-id="fbe59-186">Antes do .NET Framework 4, a única maneira de definir uma classe genérica com essas anotações é usar a linguagem intermediária da Microsoft (MSIL), seja compilando a classe com [Ilasm.exe (Assembler de IL)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) ou emitindo-a em um assembly dinâmico.</span><span class="sxs-lookup"><span data-stu-id="fbe59-186">Prior to the .NET Framework 4, the only way to define a generic class that has these annotations is to use Microsoft intermediate language (MSIL), either by compiling the class with [Ilasm.exe (IL Assembler)](../../../docs/framework/tools/ilasm-exe-il-assembler.md) or by emitting it in a dynamic assembly.</span></span>  
  
 <span data-ttu-id="fbe59-187">Um parâmetro de tipo de covariante é marcado com a palavra-chave `out` (palavra-chave `Out` no Visual Basic, `+` para o [Assembler de MSIL](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="fbe59-187">A covariant type parameter is marked with the `out` keyword (`Out` keyword in Visual Basic, `+` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="fbe59-188">Você pode usar um parâmetro de tipo covariante como o valor de retorno de um método que pertence a uma interface ou como o tipo de retorno de um delegado.</span><span class="sxs-lookup"><span data-stu-id="fbe59-188">You can use a covariant type parameter as the return value of a method that belongs to an interface, or as the return type of a delegate.</span></span> <span data-ttu-id="fbe59-189">Você não pode usar um parâmetro de tipo covariante como uma restrição de tipo genérico para métodos de interface.</span><span class="sxs-lookup"><span data-stu-id="fbe59-189">You cannot use a covariant type parameter as a generic type constraint for interface methods.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="fbe59-190">Se um método de uma interface tem um parâmetro que é um tipo de delegado genérico, um parâmetro de tipo covariante do tipo da interface pode ser usado para especificar um parâmetro de tipo contravariante do tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="fbe59-190">If a method of an interface has a parameter that is a generic delegate type, a covariant type parameter of the interface type can be used to specify a contravariant type parameter of the delegate type.</span></span>  
  
 <span data-ttu-id="fbe59-191">Um parâmetro de tipo covariante é marcado com a palavra-chave `in` (palavra-chave `In` no Visual Basic, `-` para o [Assembler de MSIL](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span><span class="sxs-lookup"><span data-stu-id="fbe59-191">A contravariant type parameter is marked with the `in` keyword (`In` keyword in Visual Basic, `-` for the [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md)).</span></span> <span data-ttu-id="fbe59-192">Você pode usar um parâmetro de tipo contravariante como o tipo de um parâmetro de um método que pertence a uma interface ou como o tipo de um parâmetro de um delegado.</span><span class="sxs-lookup"><span data-stu-id="fbe59-192">You can use a contravariant type parameter as the type of a parameter of a method that belongs to an interface, or as the type of a parameter of a delegate.</span></span> <span data-ttu-id="fbe59-193">Você pode usar um parâmetro de tipo contravariante como uma restrição de tipo genérico para um método de interface.</span><span class="sxs-lookup"><span data-stu-id="fbe59-193">You can use a contravariant type parameter as a generic type constraint for an interface method.</span></span>  
  
 <span data-ttu-id="fbe59-194">Somente tipos de interfaces e tipos de delegados podem ter parâmetros de tipo variantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-194">Only interface types and delegate types can have variant type parameters.</span></span> <span data-ttu-id="fbe59-195">Um tipo de delegado ou interface pode ter parâmetros de tipo covariantes e contravariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-195">An interface or delegate type can have both covariant and contravariant type parameters.</span></span>  
  
 <span data-ttu-id="fbe59-196">O Visual Basic e o C# e não permitem que você viole as regras de uso de parâmetros de tipo covariantes e contravariantes nem adicionar anotações de covariância e de contravariância aos parâmetros de tipo de tipos que não sejam interfaces e delegados.</span><span class="sxs-lookup"><span data-stu-id="fbe59-196">Visual Basic and C# do not allow you to violate the rules for using covariant and contravariant type parameters, or to add covariance and contravariance annotations to the type parameters of types other than interfaces and delegates.</span></span> <span data-ttu-id="fbe59-197">O [Assembler de MSIL](../../../docs/framework/tools/ilasm-exe-il-assembler.md) não executa essas verificações, mas uma <xref:System.TypeLoadException> é gerada quando você tenta carregar um tipo que viola as regras.</span><span class="sxs-lookup"><span data-stu-id="fbe59-197">The [MSIL Assembler](../../../docs/framework/tools/ilasm-exe-il-assembler.md) does not perform such checks, but a <xref:System.TypeLoadException> is thrown if you try to load a type that violates the rules.</span></span>  
  
 <span data-ttu-id="fbe59-198">Para obter mais informações e códigos de exemplo, confira [Variação em interfaces genéricas (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) e [Variação em interfaces genéricas (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span><span class="sxs-lookup"><span data-stu-id="fbe59-198">For information and example code, see [Variance in Generic Interfaces (C#)](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md) and [Variance in Generic Interfaces (Visual Basic)](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces.md).</span></span>  

## <a name="list-of-variant-generic-interface-and-delegate-types"></a><span data-ttu-id="fbe59-199">Lista de tipos de interfaces e delegados genéricos variantes</span><span class="sxs-lookup"><span data-stu-id="fbe59-199">List of Variant Generic Interface and Delegate Types</span></span>
 <span data-ttu-id="fbe59-200">No .NET Framework 4, os tipos de interface e de delegado a seguir têm parâmetros de tipo covariantes e/ou contravariantes.</span><span class="sxs-lookup"><span data-stu-id="fbe59-200">In the .NET Framework 4, the following interface and delegate types have covariant and/or contravariant type parameters.</span></span>  
  
|<span data-ttu-id="fbe59-201">Digite</span><span class="sxs-lookup"><span data-stu-id="fbe59-201">Type</span></span>|<span data-ttu-id="fbe59-202">Parâmetros de tipo covariantes</span><span class="sxs-lookup"><span data-stu-id="fbe59-202">Covariant type parameters</span></span>|<span data-ttu-id="fbe59-203">Parâmetros de tipo contravariantes</span><span class="sxs-lookup"><span data-stu-id="fbe59-203">Contravariant type parameters</span></span>|  
|----------|-------------------------------|-----------------------------------|  
|<span data-ttu-id="fbe59-204"><xref:System.Action%601> para <xref:System.Action%6016></span><span class="sxs-lookup"><span data-stu-id="fbe59-204"><xref:System.Action%601> to <xref:System.Action%6016></span></span>||<span data-ttu-id="fbe59-205">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-205">Yes</span></span>|  
|<xref:System.Comparison%601>||<span data-ttu-id="fbe59-206">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-206">Yes</span></span>|  
|<xref:System.Converter%602>|<span data-ttu-id="fbe59-207">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-207">Yes</span></span>|<span data-ttu-id="fbe59-208">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-208">Yes</span></span>|  
|<xref:System.Func%601>|<span data-ttu-id="fbe59-209">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-209">Yes</span></span>||  
|<span data-ttu-id="fbe59-210"><xref:System.Func%602> para <xref:System.Func%6017></span><span class="sxs-lookup"><span data-stu-id="fbe59-210"><xref:System.Func%602> to <xref:System.Func%6017></span></span>|<span data-ttu-id="fbe59-211">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-211">Yes</span></span>|<span data-ttu-id="fbe59-212">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-212">Yes</span></span>|  
|<xref:System.IComparable%601>||<span data-ttu-id="fbe59-213">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-213">Yes</span></span>|  
|<xref:System.Predicate%601>||<span data-ttu-id="fbe59-214">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-214">Yes</span></span>|  
|<xref:System.Collections.Generic.IComparer%601>||<span data-ttu-id="fbe59-215">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-215">Yes</span></span>|  
|<xref:System.Collections.Generic.IEnumerable%601>|<span data-ttu-id="fbe59-216">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-216">Yes</span></span>||  
|<xref:System.Collections.Generic.IEnumerator%601>|<span data-ttu-id="fbe59-217">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-217">Yes</span></span>||  
|<xref:System.Collections.Generic.IEqualityComparer%601>||<span data-ttu-id="fbe59-218">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-218">Yes</span></span>|  
|<xref:System.Linq.IGrouping%602>|<span data-ttu-id="fbe59-219">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-219">Yes</span></span>||  
|<xref:System.Linq.IOrderedEnumerable%601>|<span data-ttu-id="fbe59-220">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-220">Yes</span></span>||  
|<xref:System.Linq.IOrderedQueryable%601>|<span data-ttu-id="fbe59-221">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-221">Yes</span></span>||  
|<xref:System.Linq.IQueryable%601>|<span data-ttu-id="fbe59-222">Sim</span><span class="sxs-lookup"><span data-stu-id="fbe59-222">Yes</span></span>||  
  
## <a name="see-also"></a><span data-ttu-id="fbe59-223">Consulte também</span><span class="sxs-lookup"><span data-stu-id="fbe59-223">See also</span></span>

- [<span data-ttu-id="fbe59-224">Covariância e contravariância (C#)</span><span class="sxs-lookup"><span data-stu-id="fbe59-224">Covariance and Contravariance (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="fbe59-225">Covariância e contravariância (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="fbe59-225">Covariance and Contravariance (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/index.md)
- [<span data-ttu-id="fbe59-226">Variação em delegados (C#)</span><span class="sxs-lookup"><span data-stu-id="fbe59-226">Variance in Delegates (C#)</span></span>](../../csharp/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
- [<span data-ttu-id="fbe59-227">Variação em delegados (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="fbe59-227">Variance in Delegates (Visual Basic)</span></span>](../../visual-basic/programming-guide/concepts/covariance-contravariance/variance-in-delegates.md)
