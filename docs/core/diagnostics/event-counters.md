---
title: EventCounters no .NET Core
description: Neste artigo, você aprenderá o que é o EventCounters, como implementá-los e como consumi-los.
ms.date: 08/07/2020
ms.openlocfilehash: be273776b888f13893fc694a111093cca1fa8a5e
ms.sourcegitcommit: b59237ca4ec763969a0dd775a3f8f39f8c59fe24
ms.translationtype: MT
ms.contentlocale: pt-BR
ms.lasthandoff: 10/12/2020
ms.locfileid: "91955311"
---
# <a name="eventcounters-in-net-core"></a><span data-ttu-id="970ab-103">EventCounters no .NET Core</span><span class="sxs-lookup"><span data-stu-id="970ab-103">EventCounters in .NET Core</span></span>

<span data-ttu-id="970ab-104">**Este artigo aplica-se a: ✔️** SDK do .net Core 3,0 e versões posteriores</span><span class="sxs-lookup"><span data-stu-id="970ab-104">**This article applies to: ✔️** .NET Core 3.0 SDK and later versions</span></span>

<span data-ttu-id="970ab-105">EventCounters são APIs do .NET Core usadas para coleta de métrica de desempenho leve, de plataforma cruzada e quase em tempo real.</span><span class="sxs-lookup"><span data-stu-id="970ab-105">EventCounters are .NET Core APIs used for lightweight, cross-platform, and near real-time performance metric collection.</span></span> <span data-ttu-id="970ab-106">EventCounters foram adicionados como uma alternativa de plataforma cruzada aos "contadores de desempenho" do .NET Framework no Windows.</span><span class="sxs-lookup"><span data-stu-id="970ab-106">EventCounters were added as a cross-platform alternative to the "performance counters" of the .NET Framework on Windows.</span></span> <span data-ttu-id="970ab-107">Neste artigo, você aprenderá o que são os EventCounters, como implementá-los e como consumi-los.</span><span class="sxs-lookup"><span data-stu-id="970ab-107">In this article you'll learn what EventCounters are, how to implement them, and how to consume them.</span></span>

<span data-ttu-id="970ab-108">O tempo de execução do .NET Core e algumas bibliotecas .NET publicam informações básicas de diagnóstico usando EventCounters a partir do .NET Core 3,0.</span><span class="sxs-lookup"><span data-stu-id="970ab-108">The .NET Core runtime and a few .NET libraries publish basic diagnostics information using EventCounters starting in .NET Core 3.0.</span></span> <span data-ttu-id="970ab-109">Além dos EventCounters que são fornecidos pelo tempo de execução do .NET, você pode optar por implementar seu próprio EventCounters.</span><span class="sxs-lookup"><span data-stu-id="970ab-109">Apart from the EventCounters that are provided by the .NET runtime, you may choose to implement your own EventCounters.</span></span> <span data-ttu-id="970ab-110">EventCounters pode ser usado para controlar várias métricas.</span><span class="sxs-lookup"><span data-stu-id="970ab-110">EventCounters can be used to track various metrics.</span></span>

<span data-ttu-id="970ab-111">EventCounters em tempo real como parte de um <xref:System.Diagnostics.Tracing.EventSource> e são automaticamente enviados para ferramentas de ouvinte regularmente.</span><span class="sxs-lookup"><span data-stu-id="970ab-111">EventCounters live as a part of an <xref:System.Diagnostics.Tracing.EventSource>, and are automatically pushed to listener tools on a regular basis.</span></span> <span data-ttu-id="970ab-112">Assim como todos os outros eventos em um <xref:System.Diagnostics.Tracing.EventSource> , eles podem ser consumidos tanto no processo quanto fora do processo por meio de <xref:System.Diagnostics.Tracing.EventListener> e EventPipe.</span><span class="sxs-lookup"><span data-stu-id="970ab-112">Like all other events on an <xref:System.Diagnostics.Tracing.EventSource>, they can be consumed both in-proc and out-of-proc via <xref:System.Diagnostics.Tracing.EventListener> and EventPipe.</span></span> <span data-ttu-id="970ab-113">Este artigo se concentra nos recursos de plataforma cruzada do EventCounters e exclui intencionalmente o PerfView e o ETW (rastreamento de eventos para Windows) – embora ambos possam ser usados com o EventCounters.</span><span class="sxs-lookup"><span data-stu-id="970ab-113">This article focuses on the cross-platform capabilities of EventCounters, and intentionally excludes PerfView and ETW (Event Tracing for Windows) - although both can be used with EventCounters.</span></span>

![Imagem do diagrama EventCounters no proc e fora do processo](media/event-counters.svg)

[!INCLUDE [available-counters](includes/available-counters.md)]

## <a name="eventcounter-api-overview"></a><span data-ttu-id="970ab-115">Visão geral da API do EventCounter</span><span class="sxs-lookup"><span data-stu-id="970ab-115">EventCounter API overview</span></span>

<span data-ttu-id="970ab-116">Há duas categorias principais de contadores.</span><span class="sxs-lookup"><span data-stu-id="970ab-116">There are two primary categories of counters.</span></span> <span data-ttu-id="970ab-117">Alguns contadores são para valores de "taxa", como o número total de exceções, o número total de GCs e o número total de solicitações.</span><span class="sxs-lookup"><span data-stu-id="970ab-117">Some counters are for "rate" values, such as total number of exceptions, total number of GCs, and total number of requests.</span></span> <span data-ttu-id="970ab-118">Outros contadores são valores de "instantâneo", como uso de heap, uso de CPU e tamanho de conjunto de trabalho.</span><span class="sxs-lookup"><span data-stu-id="970ab-118">Other counters are "snapshot" values, such as heap usage, CPU usage, and working set size.</span></span> <span data-ttu-id="970ab-119">Dentro de cada uma dessas categorias de contadores, há dois tipos de contadores que variam de acordo com o modo como eles obtêm seu valor.</span><span class="sxs-lookup"><span data-stu-id="970ab-119">Within each of these categories of counters, there are two types of counters that vary by how they get their value.</span></span> <span data-ttu-id="970ab-120">Os contadores de sondagem recuperam seu valor por meio de um retorno de chamada, e os contadores de não sondagem têm seus valores definidos diretamente na instância do contador.</span><span class="sxs-lookup"><span data-stu-id="970ab-120">Polling counters retrieve their value via a callback, and non-polling counters have their values directly set on the counter instance.</span></span>

<span data-ttu-id="970ab-121">Os contadores são representados pelas seguintes implementações:</span><span class="sxs-lookup"><span data-stu-id="970ab-121">The counters are represented by the following implementations:</span></span>

* <xref:System.Diagnostics.Tracing.EventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingEventCounter>
* <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>
* <xref:System.Diagnostics.Tracing.PollingCounter>

<span data-ttu-id="970ab-122">Um ouvinte de eventos especifica por quanto tempo os intervalos de medição são.</span><span class="sxs-lookup"><span data-stu-id="970ab-122">An event listener specifies how long measurement intervals are.</span></span> <span data-ttu-id="970ab-123">Ao final de cada intervalo, um valor é transmitido para o ouvinte para cada contador.</span><span class="sxs-lookup"><span data-stu-id="970ab-123">At the end of each interval a value is transmitted to the listener for each counter.</span></span> <span data-ttu-id="970ab-124">As implementações de um contador determinam quais APIs e cálculos são usados para produzir o valor em cada intervalo.</span><span class="sxs-lookup"><span data-stu-id="970ab-124">The implementations of a counter determine what APIs and calculations are used to produce the value each interval.</span></span>

1. <span data-ttu-id="970ab-125">O <xref:System.Diagnostics.Tracing.EventCounter> registra um conjunto de valores.</span><span class="sxs-lookup"><span data-stu-id="970ab-125">The <xref:System.Diagnostics.Tracing.EventCounter> records a set of values.</span></span> <span data-ttu-id="970ab-126">O <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> método adiciona um novo valor ao conjunto.</span><span class="sxs-lookup"><span data-stu-id="970ab-126">The <xref:System.Diagnostics.Tracing.EventCounter.WriteMetric%2A?displayProperty=nameWithType> method adds a new value to the set.</span></span> <span data-ttu-id="970ab-127">Com cada intervalo, um resumo estatístico do conjunto é calculado, como mín., máx. e média.</span><span class="sxs-lookup"><span data-stu-id="970ab-127">With each interval, a statistical summary for the set is computed, such as the min, max, and mean.</span></span> <span data-ttu-id="970ab-128">A ferramenta [dotnet-Counters](dotnet-counters.md) sempre exibirá o valor médio.</span><span class="sxs-lookup"><span data-stu-id="970ab-128">The [dotnet-counters](dotnet-counters.md) tool will always display the mean value.</span></span> <span data-ttu-id="970ab-129">O <xref:System.Diagnostics.Tracing.EventCounter> é útil para descrever um conjunto discreto de operações.</span><span class="sxs-lookup"><span data-stu-id="970ab-129">The <xref:System.Diagnostics.Tracing.EventCounter> is useful to describe a discrete set of operations.</span></span> <span data-ttu-id="970ab-130">O uso comum pode incluir o monitoramento do tamanho médio em bytes de operações de e/s recentes ou o valor monetário médio de um conjunto de transações financeiras.</span><span class="sxs-lookup"><span data-stu-id="970ab-130">Common usage may include monitoring the average size in bytes of recent IO operations, or the average monetary value of a set of financial transactions.</span></span>

1. <span data-ttu-id="970ab-131"><xref:System.Diagnostics.Tracing.IncrementingEventCounter>Registra um total acumulado para cada intervalo de tempo.</span><span class="sxs-lookup"><span data-stu-id="970ab-131">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> records a running total for each time interval.</span></span> <span data-ttu-id="970ab-132">O <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> método adiciona ao total.</span><span class="sxs-lookup"><span data-stu-id="970ab-132">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter.Increment%2A?displayProperty=nameWithType> method adds to the total.</span></span> <span data-ttu-id="970ab-133">Por exemplo, se `Increment()` for chamado três vezes durante um intervalo com valores `1` , `2` e `5` , o total acumulado de `8` será relatado como o valor do contador para esse intervalo.</span><span class="sxs-lookup"><span data-stu-id="970ab-133">For example, if `Increment()` is called three times during one interval with values `1`, `2`, and `5`, then the running total of `8` will be reported as the counter value for this interval.</span></span> <span data-ttu-id="970ab-134">A ferramenta [dotnet-Counters](dotnet-counters.md) exibirá a taxa como o total/tempo gravado.</span><span class="sxs-lookup"><span data-stu-id="970ab-134">The [dotnet-counters](dotnet-counters.md) tool will display the rate as the recorded total / time.</span></span> <span data-ttu-id="970ab-135">O <xref:System.Diagnostics.Tracing.IncrementingEventCounter> é útil para medir a frequência de ocorrência de uma ação, como o número de solicitações processadas por segundo.</span><span class="sxs-lookup"><span data-stu-id="970ab-135">The <xref:System.Diagnostics.Tracing.IncrementingEventCounter> is useful to measure how frequently an action is occurring, such as the number of requests processed per second.</span></span>

1. <span data-ttu-id="970ab-136">O <xref:System.Diagnostics.Tracing.PollingCounter> usa um retorno de chamada para determinar o valor que é relatado.</span><span class="sxs-lookup"><span data-stu-id="970ab-136">The <xref:System.Diagnostics.Tracing.PollingCounter> uses a callback to determine the value that is reported.</span></span> <span data-ttu-id="970ab-137">Com cada intervalo de tempo, a função de retorno de chamada fornecida pelo usuário é invocada e o valor de retorno é usado como o valor do contador.</span><span class="sxs-lookup"><span data-stu-id="970ab-137">With each time interval, the user provided callback function is invoked and the return value is used as the counter value.</span></span> <span data-ttu-id="970ab-138">Um <xref:System.Diagnostics.Tracing.PollingCounter> pode ser usado para consultar uma métrica de uma fonte externa, por exemplo, obter os bytes livres atuais em um disco.</span><span class="sxs-lookup"><span data-stu-id="970ab-138">A <xref:System.Diagnostics.Tracing.PollingCounter> can be used to query a metric from an external source, for example getting the current free bytes on a disk.</span></span> <span data-ttu-id="970ab-139">Ele também pode ser usado para relatar estatísticas personalizadas que podem ser computadas sob demanda por um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="970ab-139">It can also be used to report custom statistics that can be computed on demand by an application.</span></span> <span data-ttu-id="970ab-140">Os exemplos incluem relatar o 95 º percentil de latências de solicitação recentes ou a taxa atual de acertos ou de erros de um cache.</span><span class="sxs-lookup"><span data-stu-id="970ab-140">Examples include reporting the 95th percentile of recent request latencies, or the current hit or miss ratio of a cache.</span></span>

1. <span data-ttu-id="970ab-141">O <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> usa um retorno de chamada para determinar o valor de incremento relatado.</span><span class="sxs-lookup"><span data-stu-id="970ab-141">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses a callback to determine the reported increment value.</span></span> <span data-ttu-id="970ab-142">Com cada intervalo de tempo, o retorno de chamada é invocado e, em seguida, a diferença entre a invocação atual e a última invocação é o valor relatado.</span><span class="sxs-lookup"><span data-stu-id="970ab-142">With each time interval, the callback is invoked, and then the difference between the current invocation, and the last invocation is the reported value.</span></span> <span data-ttu-id="970ab-143">A ferramenta [dotnet-Counters](dotnet-counters.md) sempre exibirá a diferença como uma taxa, o valor/tempo relatado.</span><span class="sxs-lookup"><span data-stu-id="970ab-143">The [dotnet-counters](dotnet-counters.md) tool will always display the difference as a rate, the reported value / time.</span></span> <span data-ttu-id="970ab-144">Esse contador é útil quando não é viável chamar uma API em cada ocorrência, mas é possível consultar o número total de ocorrências.</span><span class="sxs-lookup"><span data-stu-id="970ab-144">This counter is useful when it isn't feasible to call an API on each occurrence, but it's possible to query the total number of occurrences.</span></span> <span data-ttu-id="970ab-145">Por exemplo, você pode relatar o número de bytes gravados em um arquivo por segundo, mesmo sem uma notificação toda vez que um byte é gravado.</span><span class="sxs-lookup"><span data-stu-id="970ab-145">For example, you could report the number of bytes written to a file per second, even without a notification each time a byte is written.</span></span>

## <a name="implement-an-eventsource"></a><span data-ttu-id="970ab-146">Implementar um EventSource</span><span class="sxs-lookup"><span data-stu-id="970ab-146">Implement an EventSource</span></span>

<span data-ttu-id="970ab-147">O código a seguir implementa um exemplo <xref:System.Diagnostics.Tracing.EventSource> exposto como o `"Sample.EventCounter.Minimal"` provedor nomeado.</span><span class="sxs-lookup"><span data-stu-id="970ab-147">The following code implements a sample <xref:System.Diagnostics.Tracing.EventSource> exposed as the named `"Sample.EventCounter.Minimal"` provider.</span></span> <span data-ttu-id="970ab-148">Essa origem contém um <xref:System.Diagnostics.Tracing.EventCounter> tempo de processamento de solicitação de representação.</span><span class="sxs-lookup"><span data-stu-id="970ab-148">This source contains an <xref:System.Diagnostics.Tracing.EventCounter> representing request processing time.</span></span> <span data-ttu-id="970ab-149">Esse contador tem um nome (ou seja, sua ID exclusiva na origem) e um nome de exibição, ambos usados por ferramentas de escuta, como [dotnet-Counter](dotnet-counters.md).</span><span class="sxs-lookup"><span data-stu-id="970ab-149">Such a counter has a name (that is, its unique ID in the source) and a display name, both used by listener tools such as [dotnet-counter](dotnet-counters.md).</span></span>

:::code language="csharp" source="snippets/EventCounters/MinimalEventCounterSource.cs":::

<span data-ttu-id="970ab-150">Você usa `dotnet-counters ps` para exibir uma lista de processos .NET que podem ser monitorados:</span><span class="sxs-lookup"><span data-stu-id="970ab-150">You use `dotnet-counters ps` to display a list of .NET processes that can be monitored:</span></span>

```console
dotnet-counters ps
   1398652 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399072 dotnet     C:\Program Files\dotnet\dotnet.exe
   1399112 dotnet     C:\Program Files\dotnet\dotnet.exe
   1401880 dotnet     C:\Program Files\dotnet\dotnet.exe
   1400180 sample-counters C:\sample-counters\bin\Debug\netcoreapp3.1\sample-counters.exe
```

<span data-ttu-id="970ab-151">Passe o <xref:System.Diagnostics.Tracing.EventSource> nome para o `counter_list` comutador para começar a monitorar seu contador:</span><span class="sxs-lookup"><span data-stu-id="970ab-151">Pass the <xref:System.Diagnostics.Tracing.EventSource> name to the `counter_list` switch to start monitoring your counter:</span></span>

```console
dotnet-counters monitor --process-id 1400180 Sample.EventCounter.Minimal
```

<span data-ttu-id="970ab-152">O exemplo a seguir mostra a saída do monitor:</span><span class="sxs-lookup"><span data-stu-id="970ab-152">The following example shows monitor output:</span></span>

```console
Press p to pause, r to resume, q to quit.
    Status: Running

[Samples-EventCounterDemos-Minimal]
    Request Processing Time (ms)                            0.445
```

<span data-ttu-id="970ab-153">Pressione <kbd>q</kbd> para interromper o comando de monitoramento.</span><span class="sxs-lookup"><span data-stu-id="970ab-153">Press <kbd>q</kbd> to stop the monitoring command.</span></span>

#### <a name="conditional-counters"></a><span data-ttu-id="970ab-154">Contadores condicionais</span><span class="sxs-lookup"><span data-stu-id="970ab-154">Conditional counters</span></span>

<span data-ttu-id="970ab-155">Ao implementar um <xref:System.Diagnostics.Tracing.EventSource> , os contadores que os contêm podem ser instanciados condicionalmente quando o <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> método é chamado com um <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> valor de `EventCommand.Enable` .</span><span class="sxs-lookup"><span data-stu-id="970ab-155">When implementing an <xref:System.Diagnostics.Tracing.EventSource>, the containing counters can be conditionally instantiated when the <xref:System.Diagnostics.Tracing.EventSource.OnEventCommand%2A?displayProperty=nameWithType> method is called with a <xref:System.Diagnostics.Tracing.EventCommandEventArgs.Command> value of `EventCommand.Enable`.</span></span> <span data-ttu-id="970ab-156">Para instanciar com segurança uma instância de contador somente se for `null` , use o [operador de atribuição de União nula](../../csharp/language-reference/operators/null-coalescing-operator.md).</span><span class="sxs-lookup"><span data-stu-id="970ab-156">To safely instantiate a counter instance only if it is `null`, use the [null-coalescing assignment operator](../../csharp/language-reference/operators/null-coalescing-operator.md).</span></span> <span data-ttu-id="970ab-157">Além disso, os métodos personalizados podem avaliar o <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> método para determinar se a origem do evento atual está habilitada ou não.</span><span class="sxs-lookup"><span data-stu-id="970ab-157">Additionally, custom methods can evaluate the <xref:System.Diagnostics.DiagnosticSource.IsEnabled%2A> method to determine whether or not the current event source is enabled.</span></span>

:::code language="csharp" source="snippets/EventCounters/ConditionalEventCounterSource.cs":::

> [!TIP]
> <span data-ttu-id="970ab-158">Os contadores condicionais são contadores que são condicionalmente instanciados, uma microotimização.</span><span class="sxs-lookup"><span data-stu-id="970ab-158">Conditional counters are counters that are conditionally instantiated, a micro-optimization.</span></span> <span data-ttu-id="970ab-159">O tempo de execução adota esse padrão para cenários em que os contadores normalmente não são usados, para economizar uma fração de um milissegundo.</span><span class="sxs-lookup"><span data-stu-id="970ab-159">The runtime adopts this pattern for scenarios where counters are normally not used, to save a fraction of a millisecond.</span></span>

### <a name="net-core-runtime-example-counters"></a><span data-ttu-id="970ab-160">Contadores de exemplo de tempo de execução do .NET Core</span><span class="sxs-lookup"><span data-stu-id="970ab-160">.NET Core runtime example counters</span></span>

<span data-ttu-id="970ab-161">Há muitas excelentes implementações de exemplo no tempo de execução do .NET Core.</span><span class="sxs-lookup"><span data-stu-id="970ab-161">There are many great example implementations in the .NET Core runtime.</span></span> <span data-ttu-id="970ab-162">Aqui está a implementação de tempo de execução para o contador que controla o tamanho do conjunto de trabalho do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="970ab-162">Here is the runtime implementation for the counter that tracks the working set size of the application.</span></span>

```csharp
var workingSetCounter = new PollingCounter(
    "working-set",
    this,
    () => (double)(Environment.WorkingSet / 1_000_000))
{
    DisplayName = "Working Set",
    DisplayUnits = "MB"
};
```

<span data-ttu-id="970ab-163">O <xref:System.Diagnostics.Tracing.PollingCounter> relata a quantidade atual de memória física mapeada para o processo (conjunto de trabalho) do aplicativo, já que ele captura uma métrica em um momento no tempo.</span><span class="sxs-lookup"><span data-stu-id="970ab-163">The <xref:System.Diagnostics.Tracing.PollingCounter> reports the current amount of physical memory mapped to the process (working set) of the app, since it captures a metric at a moment in time.</span></span> <span data-ttu-id="970ab-164">O retorno de chamada para sondar um valor é a expressão lambda fornecida, que é apenas uma chamada para a <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span><span class="sxs-lookup"><span data-stu-id="970ab-164">The callback for polling a value is the provided lambda expression, which is just a call to the <xref:System.Environment.WorkingSet?displayProperty=fullName> API.</span></span> <span data-ttu-id="970ab-165"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> e <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> são propriedades opcionais que podem ser definidas para ajudar o lado do consumidor do contador a exibir o valor mais claramente.</span><span class="sxs-lookup"><span data-stu-id="970ab-165"><xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayName> and <xref:System.Diagnostics.Tracing.DiagnosticCounter.DisplayUnits> are optional properties that can be set to help the consumer side of the counter to display the value more clearly.</span></span> <span data-ttu-id="970ab-166">Por exemplo, [dotnet-Counters](dotnet-counters.md) usa essas propriedades para exibir a versão mais amigável dos nomes dos contadores.</span><span class="sxs-lookup"><span data-stu-id="970ab-166">For example, [dotnet-counters](dotnet-counters.md) uses these properties to display the more display-friendly version of the counter names.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="970ab-167">As `DisplayName` Propriedades não estão localizadas.</span><span class="sxs-lookup"><span data-stu-id="970ab-167">The `DisplayName` properties are not localized.</span></span>

<span data-ttu-id="970ab-168">Para o <xref:System.Diagnostics.Tracing.PollingCounter> , e o <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> , nada mais precisa ser feito.</span><span class="sxs-lookup"><span data-stu-id="970ab-168">For the <xref:System.Diagnostics.Tracing.PollingCounter>, and the <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>, nothing else needs to be done.</span></span> <span data-ttu-id="970ab-169">Ambos sondam os próprios valores em um intervalo solicitado pelo consumidor.</span><span class="sxs-lookup"><span data-stu-id="970ab-169">They both poll the values themselves at an interval requested by the consumer.</span></span>

<span data-ttu-id="970ab-170">Aqui está um exemplo de um contador de tempo de execução implementado usando o <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> .</span><span class="sxs-lookup"><span data-stu-id="970ab-170">Here is an example of a runtime counter implemented using <xref:System.Diagnostics.Tracing.IncrementingPollingCounter>.</span></span>

```csharp
var monitorContentionCounter = new IncrementingPollingCounter(
    "monitor-lock-contention-count",
    this,
    () => Monitor.LockContentionCount
)
{
    DisplayName = "Monitor Lock Contention Count",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

<span data-ttu-id="970ab-171">O <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> usa a <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API para relatar o incremento da contagem total de contenções de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="970ab-171">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> uses the <xref:System.Threading.Monitor.LockContentionCount?displayProperty=nameWithType> API to report the increment of the total lock contention count.</span></span> <span data-ttu-id="970ab-172">A <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> propriedade é opcional, mas quando usada, ela pode fornecer uma dica para qual intervalo de tempo o contador é exibido melhor.</span><span class="sxs-lookup"><span data-stu-id="970ab-172">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> property is optional, but when used it can provide a hint for what time interval the counter is best displayed at.</span></span> <span data-ttu-id="970ab-173">Por exemplo, a contagem de contenções de bloqueio é melhor exibida como _contagem por segundo_, portanto, ela <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> é definida como um segundo.</span><span class="sxs-lookup"><span data-stu-id="970ab-173">For example, the lock contention count is best displayed as _count per second_, so its <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is set to one second.</span></span> <span data-ttu-id="970ab-174">A taxa de exibição pode ser ajustada para diferentes tipos de contadores de taxa.</span><span class="sxs-lookup"><span data-stu-id="970ab-174">The display rate can be adjusted for different types of rate counters.</span></span>

> [!NOTE]
> <span data-ttu-id="970ab-175">O <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> _não_ é usado por [dotnet-Counters](dotnet-counters.md), e ouvintes de eventos não são obrigados a usá-lo.</span><span class="sxs-lookup"><span data-stu-id="970ab-175">The <xref:System.Diagnostics.Tracing.IncrementingPollingCounter.DisplayRateTimeScale> is _not_ used by [dotnet-counters](dotnet-counters.md), and event listeners are not required to use it.</span></span>

<span data-ttu-id="970ab-176">Há mais implementações de contador a serem usadas como referência no repositório de [tempo de execução do .net](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) .</span><span class="sxs-lookup"><span data-stu-id="970ab-176">There are more counter implementations to use as a reference in the [.NET runtime](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Diagnostics/Tracing/RuntimeEventSource.cs) repo.</span></span>

## <a name="concurrency"></a><span data-ttu-id="970ab-177">Simultaneidade</span><span class="sxs-lookup"><span data-stu-id="970ab-177">Concurrency</span></span>

> [!TIP]
> <span data-ttu-id="970ab-178">A API EventCounters não garante a segurança do thread.</span><span class="sxs-lookup"><span data-stu-id="970ab-178">The EventCounters API does not guarantee thread safety.</span></span> <span data-ttu-id="970ab-179">Quando os delegados passados para <xref:System.Diagnostics.Tracing.PollingCounter> ou as <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instâncias são chamados por vários threads, é sua responsabilidade garantir a segurança de threads dos delegados.</span><span class="sxs-lookup"><span data-stu-id="970ab-179">When the delegates passed to <xref:System.Diagnostics.Tracing.PollingCounter> or <xref:System.Diagnostics.Tracing.IncrementingPollingCounter> instances are called by multiple threads, it's your responsibility to guarantee the delegates' thread-safety.</span></span>

<span data-ttu-id="970ab-180">Por exemplo, considere o seguinte <xref:System.Diagnostics.Tracing.EventSource> para acompanhar as solicitações.</span><span class="sxs-lookup"><span data-stu-id="970ab-180">For example, consider the following <xref:System.Diagnostics.Tracing.EventSource> to keep track of requests.</span></span>

:::code language="csharp" source="snippets/EventCounters/RequestEventSource.cs":::

<span data-ttu-id="970ab-181">O `AddRequest()` método pode ser chamado a partir de um manipulador de solicitação e o `RequestRateCounter` sonda o valor no intervalo especificado pelo consumidor do contador.</span><span class="sxs-lookup"><span data-stu-id="970ab-181">The `AddRequest()` method can be called from a request handler, and the `RequestRateCounter` polls the value at the interval specified by the consumer of the counter.</span></span> <span data-ttu-id="970ab-182">No entanto, o `AddRequest()` método pode ser chamado por vários threads de uma vez, colocando uma condição de corrida ativada `_requestCount` .</span><span class="sxs-lookup"><span data-stu-id="970ab-182">However, the `AddRequest()` method can be called by multiple threads at once, putting a race condition on `_requestCount`.</span></span> <span data-ttu-id="970ab-183">Uma maneira alternativa thread-safe de incrementar o `_requestCount` é usar <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970ab-183">A thread-safe alternative way to increment the `_requestCount` is to use <xref:System.Threading.Interlocked.Increment%2A?displayProperty=nameWithType>.</span></span>

```csharp
public void AddRequest() => Interlocked.Increment(ref _requestCount);
```

<span data-ttu-id="970ab-184">Para evitar leituras interrompidas (em arquiteturas de 32 bits) do `long` uso do `_requestCount` campo <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="970ab-184">To prevent torn reads (on 32-bit architectures) of the `long`-field `_requestCount` use <xref:System.Threading.Interlocked.Read%2A?displayProperty=nameWithType>.</span></span>

```csharp
_requestRateCounter = new IncrementingPollingCounter("request-rate", this, () => Interlocked.Read(ref _requestCount))
{
    DisplayName = "Request Rate",
    DisplayRateTimeScale = TimeSpan.FromSeconds(1)
};
```

## <a name="consume-eventcounters"></a><span data-ttu-id="970ab-185">Consumir EventCounters</span><span class="sxs-lookup"><span data-stu-id="970ab-185">Consume EventCounters</span></span>

<span data-ttu-id="970ab-186">Há duas maneiras principais de consumir EventCounters, seja no processo ou fora do processo.</span><span class="sxs-lookup"><span data-stu-id="970ab-186">There are two primary ways of consuming EventCounters, either in-proc, or out-of-proc.</span></span> <span data-ttu-id="970ab-187">O consumo de EventCounters pode ser diferenciado em três camadas de várias tecnologias consumidas.</span><span class="sxs-lookup"><span data-stu-id="970ab-187">The consumption of EventCounters can be distinguished into three layers of various consuming technologies.</span></span>

- <span data-ttu-id="970ab-188">Transportando eventos em um fluxo bruto via ETW ou EventPipe:</span><span class="sxs-lookup"><span data-stu-id="970ab-188">Transporting events in a raw stream via ETW or EventPipe:</span></span>
  - <span data-ttu-id="970ab-189">As APIs do ETW são fornecidas com o sistema operacional Windows, e o EventPipe é acessível como uma [API do .net](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console)ou o [protocolo IPC](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md)de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="970ab-189">ETW APIs come with the Windows OS, and EventPipe is accessible as a [.NET API](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/diagnostics-client-library.md#1-attaching-to-a-process-and-dumping-out-all-the-runtime-gc-events-in-real-time-to-the-console), or the diagnostic [IPC protocol](https://github.com/dotnet/diagnostics/blob/master/documentation/design-docs/ipc-protocol.md).</span></span>
- <span data-ttu-id="970ab-190">Decodificando o fluxo de eventos binários em eventos:</span><span class="sxs-lookup"><span data-stu-id="970ab-190">Decoding the binary event stream into events:</span></span>
  - <span data-ttu-id="970ab-191">A [biblioteca TraceEvent](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) lida com os formatos de fluxo ETW e EventPipe.</span><span class="sxs-lookup"><span data-stu-id="970ab-191">The [TraceEvent library](https://www.nuget.org/packages/Microsoft.Diagnostics.Tracing.TraceEvent) handles both ETW and EventPipe stream formats.</span></span>
- <span data-ttu-id="970ab-192">Ferramentas de linha de comando e GUI:</span><span class="sxs-lookup"><span data-stu-id="970ab-192">Command-line and GUI tools:</span></span>
  - <span data-ttu-id="970ab-193">Ferramentas como PerfView (ETW ou EventPipe), dotnet-Counters (somente EventPipe) e dotnet-monitor (somente EventPipe).</span><span class="sxs-lookup"><span data-stu-id="970ab-193">Tools like PerfView (ETW or EventPipe), dotnet-counters (EventPipe only), and dotnet-monitor (EventPipe only).</span></span>

### <a name="consume-out-of-proc"></a><span data-ttu-id="970ab-194">Consumir fora do processo</span><span class="sxs-lookup"><span data-stu-id="970ab-194">Consume out-of-proc</span></span>

<span data-ttu-id="970ab-195">Consumir EventCounters fora do processo é uma abordagem muito comum.</span><span class="sxs-lookup"><span data-stu-id="970ab-195">Consuming EventCounters out-of-proc is a very common approach.</span></span> <span data-ttu-id="970ab-196">Você pode usar os [contadores dotnet](dotnet-counters.md) para consumi-los em uma maneira de plataforma cruzada por meio de um EventPipe.</span><span class="sxs-lookup"><span data-stu-id="970ab-196">You can use [dotnet-counters](dotnet-counters.md) to consume them in a cross-platform manner via an EventPipe.</span></span> <span data-ttu-id="970ab-197">A `dotnet-counters` ferramenta é uma ferramenta global da CLI do dotNet de plataforma cruzada que pode ser usada para monitorar os valores do contador.</span><span class="sxs-lookup"><span data-stu-id="970ab-197">The `dotnet-counters` tool is a cross-platform dotnet CLI global tool that can be used to monitor the counter values.</span></span> <span data-ttu-id="970ab-198">Para saber como usar o `dotnet-counters` para monitorar seus contadores, consulte [dotnet-Counters](dotnet-counters.md)ou trabalhe no tutorial [medir o desempenho usando o EventCounters](event-counter-perf.md) .</span><span class="sxs-lookup"><span data-stu-id="970ab-198">To find out how to use `dotnet-counters` to monitor your counters, see [dotnet-counters](dotnet-counters.md), or work through the [Measure performance using EventCounters](event-counter-perf.md) tutorial.</span></span>

#### <a name="dotnet-trace"></a><span data-ttu-id="970ab-199">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="970ab-199">dotnet-trace</span></span>

<span data-ttu-id="970ab-200">A `dotnet-trace` ferramenta pode ser usada para consumir os dados do contador por meio de um EventPipe.</span><span class="sxs-lookup"><span data-stu-id="970ab-200">The `dotnet-trace` tool can be used to consume the counter data through an EventPipe.</span></span> <span data-ttu-id="970ab-201">Aqui está um exemplo `dotnet-trace` de uso para coletar dados do contador.</span><span class="sxs-lookup"><span data-stu-id="970ab-201">Here is an example using `dotnet-trace` to collect counter data.</span></span>

```console
dotnet-trace collect --process-id <pid> Sample.EventCounter.Minimal:0:0:EventCounterIntervalSec=1
```

<span data-ttu-id="970ab-202">Para obter mais informações sobre como coletar valores de contador ao longo do tempo, consulte a documentação do [rastreamento dotnet](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) .</span><span class="sxs-lookup"><span data-stu-id="970ab-202">For more information on how to collect counter values over time, see the [dotnet-trace](dotnet-trace.md#use-dotnet-trace-to-collect-counter-values-over-time) documentation.</span></span>

#### <a name="azure-application-insights"></a><span data-ttu-id="970ab-203">Azure Application Insights</span><span class="sxs-lookup"><span data-stu-id="970ab-203">Azure Application Insights</span></span>

<span data-ttu-id="970ab-204">O EventCounters pode ser consumido por Azure Monitor, especificamente Aplicativo Azure insights.</span><span class="sxs-lookup"><span data-stu-id="970ab-204">EventCounters can be consumed by Azure Monitor, specifically Azure Application Insights.</span></span> <span data-ttu-id="970ab-205">Os contadores podem ser adicionados e removidos, e você é livre para especificar contadores personalizados ou contadores conhecidos.</span><span class="sxs-lookup"><span data-stu-id="970ab-205">Counters can be added and removed, and you're free to specify custom counters, or well-known counters.</span></span> <span data-ttu-id="970ab-206">Para obter mais informações, consulte [Personalizando contadores a serem coletados](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span><span class="sxs-lookup"><span data-stu-id="970ab-206">For more information, see [Customizing counters to be collected](/azure/azure-monitor/app/eventcounters#customizing-counters-to-be-collected).</span></span>

#### <a name="dotnet-monitor"></a><span data-ttu-id="970ab-207">dotnet-monitor</span><span class="sxs-lookup"><span data-stu-id="970ab-207">dotnet-monitor</span></span>

<span data-ttu-id="970ab-208">A `dotnet-monitor` ferramenta é uma ferramenta experimental que torna mais fácil obter acesso a informações de diagnóstico em um processo do .net.</span><span class="sxs-lookup"><span data-stu-id="970ab-208">The `dotnet-monitor` tool is an experimental tool that makes it easier to get access to diagnostics information in a .NET process.</span></span> <span data-ttu-id="970ab-209">A ferramenta serve como um superconjunto de todas as ferramentas de diagnóstico.</span><span class="sxs-lookup"><span data-stu-id="970ab-209">The tool serves as a superset of all diagnostics tools.</span></span> <span data-ttu-id="970ab-210">Além dos rastreamentos, ele pode monitorar as métricas, coletar despejos de memória e coletar despejos de GC.</span><span class="sxs-lookup"><span data-stu-id="970ab-210">In addition to traces, it can monitor metrics, collect memory dumps, and collect GC dumps.</span></span> <span data-ttu-id="970ab-211">Ele é distribuído como uma ferramenta CLI e uma imagem do Docker.</span><span class="sxs-lookup"><span data-stu-id="970ab-211">It's distributed as both a CLI tool and a docker image.</span></span> <span data-ttu-id="970ab-212">Ele expõe uma API REST e a coleção de artefatos de diagnóstico ocorre por meio de chamadas REST.</span><span class="sxs-lookup"><span data-stu-id="970ab-212">It exposes a REST API, and the collection of diagnostic artifacts occurs through REST calls.</span></span>

<span data-ttu-id="970ab-213">Para obter mais informações, consulte [Introducing dotnet-monitor, uma ferramenta experimental](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span><span class="sxs-lookup"><span data-stu-id="970ab-213">For more information, see [Introducing dotnet-monitor, an experimental tool](https://devblogs.microsoft.com/dotnet/introducing-dotnet-monitor).</span></span>

### <a name="consume-in-proc"></a><span data-ttu-id="970ab-214">Consumir no processo</span><span class="sxs-lookup"><span data-stu-id="970ab-214">Consume in-proc</span></span>

<span data-ttu-id="970ab-215">Você pode consumir os valores do contador por meio da <xref:System.Diagnostics.Tracing.EventListener> API.</span><span class="sxs-lookup"><span data-stu-id="970ab-215">You can consume the counter values via the <xref:System.Diagnostics.Tracing.EventListener> API.</span></span> <span data-ttu-id="970ab-216">Um <xref:System.Diagnostics.Tracing.EventListener> é uma maneira no processo de consumir todos os eventos gravados por todas as instâncias de um <xref:System.Diagnostics.Tracing.EventSource> em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="970ab-216">An <xref:System.Diagnostics.Tracing.EventListener> is an in-proc way of consuming any events written by all instances of an <xref:System.Diagnostics.Tracing.EventSource> in your application.</span></span> <span data-ttu-id="970ab-217">Para obter mais informações sobre como usar a `EventListener` API, consulte <xref:System.Diagnostics.Tracing.EventListener> .</span><span class="sxs-lookup"><span data-stu-id="970ab-217">For more information on how to use the `EventListener` API, see <xref:System.Diagnostics.Tracing.EventListener>.</span></span>

<span data-ttu-id="970ab-218">Primeiro, o <xref:System.Diagnostics.Tracing.EventSource> que produz o valor do contador precisa ser habilitado.</span><span class="sxs-lookup"><span data-stu-id="970ab-218">First, the <xref:System.Diagnostics.Tracing.EventSource> that produces the counter value needs to be enabled.</span></span> <span data-ttu-id="970ab-219">Substitua o <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> método para obter uma notificação quando um <xref:System.Diagnostics.Tracing.EventSource> for criado e, se esse for o correto <xref:System.Diagnostics.Tracing.EventSource> com seu EventCounters, você poderá chamá <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> -lo.</span><span class="sxs-lookup"><span data-stu-id="970ab-219">Override the <xref:System.Diagnostics.Tracing.EventListener.OnEventSourceCreated%2A?displayProperty=nameWithType> method to get a notification when an <xref:System.Diagnostics.Tracing.EventSource> is created, and if this is the correct <xref:System.Diagnostics.Tracing.EventSource> with your EventCounters, then you can call <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A?displayProperty=nameWithType> on it.</span></span> <span data-ttu-id="970ab-220">Aqui está um exemplo de substituição:</span><span class="sxs-lookup"><span data-stu-id="970ab-220">Here is an example override:</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs" range="16-27":::

#### <a name="sample-code"></a><span data-ttu-id="970ab-221">Código de exemplo</span><span class="sxs-lookup"><span data-stu-id="970ab-221">Sample code</span></span>

<span data-ttu-id="970ab-222">Aqui está uma classe de exemplo <xref:System.Diagnostics.Tracing.EventListener> que imprime todos os nomes de contadores e valores de tempo de execução do .NET <xref:System.Diagnostics.Tracing.EventSource> , para publicar seus contadores internos ( `System.Runtime` ) em algum intervalo.</span><span class="sxs-lookup"><span data-stu-id="970ab-222">Here is a sample <xref:System.Diagnostics.Tracing.EventListener> class that prints out all the counter names and values from the .NET runtime's <xref:System.Diagnostics.Tracing.EventSource>, for publishing its internal counters (`System.Runtime`) at some interval.</span></span>

:::code language="csharp" source="snippets/EventCounters/SimpleEventListener.cs":::

<span data-ttu-id="970ab-223">Como mostrado acima, você _deve_ verificar se o `"EventCounterIntervalSec"` argumento está definido no `filterPayload` argumento ao chamar <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A> .</span><span class="sxs-lookup"><span data-stu-id="970ab-223">As shown above, you _must_ make sure the `"EventCounterIntervalSec"` argument is set in the `filterPayload` argument when calling <xref:System.Diagnostics.Tracing.EventListener.EnableEvents%2A>.</span></span> <span data-ttu-id="970ab-224">Caso contrário, os contadores não poderão liberar valores, já que ele não sabe em qual intervalo ele deve ser liberado.</span><span class="sxs-lookup"><span data-stu-id="970ab-224">Otherwise the counters will not be able to flush out values since it doesn't know at which interval it should be getting flushed out.</span></span>

## <a name="see-also"></a><span data-ttu-id="970ab-225">Veja também</span><span class="sxs-lookup"><span data-stu-id="970ab-225">See also</span></span>

- [<span data-ttu-id="970ab-226">dotnet-counters</span><span class="sxs-lookup"><span data-stu-id="970ab-226">dotnet-counters</span></span>](dotnet-counters.md)
- [<span data-ttu-id="970ab-227">dotnet-trace</span><span class="sxs-lookup"><span data-stu-id="970ab-227">dotnet-trace</span></span>](dotnet-trace.md)
- <xref:System.Diagnostics.Tracing.EventCounter>
- <xref:System.Diagnostics.Tracing.EventListener>
- <xref:System.Diagnostics.Tracing.EventSource>
