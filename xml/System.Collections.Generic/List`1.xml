<Type Name="List&lt;T&gt;" FullName="System.Collections.Generic.List&lt;T&gt;">
  <TypeSignature Language="C#" Value="public class List&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IList&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.IReadOnlyList&lt;T&gt;, System.Collections.IList" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit List`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IList`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyList`1&lt;!T&gt;, class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.List`1" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyList&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_CollectionDebugView`1))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">O tipo dos elementos na lista.</typeparam>
    <summary>Representa uma lista fortemente tipada de objetos que podem ser acessados por índice. Fornece métodos para pesquisar, classificar e manipular listas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs#cf7f4095e4de7646). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 O <xref:System.Collections.Generic.List%601> classe é o equivalente genérico de <xref:System.Collections.ArrayList> classe. Ele implementa o <xref:System.Collections.Generic.IList%601> interface genérica usando uma matriz cujo tamanho é aumentado dinamicamente conforme necessário.  
  
 Você pode adicionar itens a um <xref:System.Collections.Generic.List%601> usando o <xref:System.Collections.Generic.List%601.Add%2A> ou <xref:System.Collections.Generic.List%601.AddRange%2A> métodos.  
  
 O <xref:System.Collections.Generic.List%601> classe usa uma comparação de igualdade e um comparador de classificação.  
  
-   Métodos como <xref:System.Collections.Generic.List%601.Contains%2A>, <xref:System.Collections.Generic.List%601.IndexOf%2A>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A>, e <xref:System.Collections.Generic.Dictionary%602.Remove%2A> usar um comparador de igualdade para os elementos da lista. O comparador de igualdade padrão para o tipo `T` é determinado como segue. Se tipo `T` implementa o <xref:System.IEquatable%601> interface genérica e, em seguida, o comparador de igualdade é o <xref:System.IEquatable%601.Equals%28%600%29> método da interface; caso contrário, o comparador de igualdade padrão é <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.  
  
-   Métodos como <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> usar um comparador de classificação para os elementos da lista. O comparador padrão para o tipo `T` é determinado como segue.  Se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e, em seguida, o comparador padrão será o <xref:System.IComparable%601.CompareTo%28%600%29> método da interface; caso contrário, se tipo `T` implementa não genérica <xref:System.IComparable> de interface, então o comparador padrão será o <xref:System.IComparable.CompareTo%28System.Object%29> método da interface. Se tipo `T` implementa nenhuma interface, em seguida, não há nenhum comparador padrão e um delegado de comparação ou comparação deve ser fornecido explicitamente.  
  
 O <xref:System.Collections.Generic.List%601> não é garantida a ser classificada.  Você deve classificar o <xref:System.Collections.Generic.List%601> antes de executar operações (como <xref:System.Collections.Generic.List%601.BinarySearch%2A>) que exigem o <xref:System.Collections.Generic.List%601> a ser classificada.  
  
 Elementos nesta coleção podem ser acessados usando um índice de inteiro.  Índices nesta coleção são baseadas em zero.  
  
 Para grandes <xref:System.Collections.Generic.List%601> objetos, você pode aumentar a capacidade máxima para 2 bilhões de elementos em um sistema de 64 bits definindo o `enabled` atributo do elemento de configuração para `true` no ambiente de tempo de execução.  
  
 <xref:System.Collections.Generic.List%601>aceita `null` como um valor válido para a referência de tipos e permite que os elementos duplicados.  
  
 Para obter uma versão imutável o <xref:System.Collections.Generic.List%601> de classe, consulte <xref:System.Collections.Immutable.ImmutableList%601>.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Ao decidir se deve usar o <xref:System.Collections.Generic.List%601> ou <xref:System.Collections.ArrayList> classe, ambos com funcionalidade semelhante, lembre-se de que o <xref:System.Collections.Generic.List%601> classe melhor na maioria dos casos e é do tipo seguro. Se um tipo de referência for usado para o tipo `T` do <xref:System.Collections.Generic.List%601> classe, o comportamento das duas classes é idêntico. No entanto, se um tipo de valor é usado para o tipo `T`, você precisa considerar os problemas de conversão boxing e implementação.  
  
 Se um tipo de valor é usado para o tipo `T`, o compilador gera uma implementação de <xref:System.Collections.Generic.List%601> classe especificamente para esse tipo de valor. Isso significa que um elemento de lista de um <xref:System.Collections.Generic.List%601> objeto não tem que ser boxed antes que o elemento pode ser usado, e depois de aproximadamente 500 elementos da lista são criados a memória salva não conversão boxing elementos da lista é maior que a memória usada para gerar a implementação da classe.  
  
 Verifique se o tipo de valor usado para o tipo `T` implementa o <xref:System.IEquatable%601> interface genérica. Se não, os métodos como <xref:System.Collections.Generic.List%601.Contains%2A> deve chamar o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, que caixas o elemento de lista afetados. Se o tipo de valor implementa o <xref:System.IComparable> interface e você possuir o código-fonte, também implemente o <xref:System.IComparable%601> interface genérica para impedir que o <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> métodos de conversão boxing elementos da lista. Se você não possui o código-fonte, passar um <xref:System.Collections.Generic.IComparer%601> o objeto para o <xref:System.Collections.Generic.List%601.BinarySearch%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> métodos  
  
 É vantajoso usar a implementação de um tipo específico do <xref:System.Collections.Generic.List%601> classe em vez de usar o <xref:System.Collections.ArrayList> classe ou gravar uma coleção fortemente tipada de wrapper por conta própria. O motivo é sua implementação deve fazer o que o .NET Framework faz para você já, e o common language runtime pode compartilhar código Microsoft intermediate language e metadados, que não é de sua implementação.  
  
## <a name="f-considerations"></a>Considerações de F #  
 O <xref:System.Collections.Generic.List%601> classe é usada com pouca frequência em código F #.  Em vez disso, [lista](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d), que são listas imutáveis, vinculados individualmente, são geralmente preferido. Uma lista de F # fornece uma série de imutável, ordenada de valores e tem suporte para uso em desenvolvimento de estilo funcional. Quando usado de F #, a <xref:System.Collections.Generic.List%601> classe costuma ser referenciada pelo [ResizeArray\<' t >](https://msdn.microsoft.com/library/ee353447.aspx) abreviação para evitar conflitos com F # lista de nomes de tipo  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra várias propriedades e métodos para o <xref:System.Collections.Generic.List%601> classe genérica do tipo cadeia de caracteres. (Para obter um exemplo de um <xref:System.Collections.Generic.List%601> de tipos complexos, consulte o <xref:System.Collections.Generic.List%601.Contains%2A> método.)  
  
 O construtor padrão é usado para criar uma lista de cadeias de caracteres com a capacidade padrão. O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida e, em seguida, o <xref:System.Collections.Generic.List%601.Add%2A> método é usado para adicionar vários itens. Os itens são listados e o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente, juntamente com o <xref:System.Collections.Generic.List%601.Count%2A> propriedade, para mostrar que a capacidade foi aumentada conforme necessário.  
  
 O <xref:System.Collections.Generic.List%601.Contains%2A> método é usado para testar a presença de um item na lista, o <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir um novo item no meio da lista e o conteúdo da lista é exibido novamente.  
  
 O padrão <xref:System.Collections.Generic.List%601.Item%2A> propriedade (indexador em c#) é usada para recuperar um item, o <xref:System.Collections.Generic.List%601.Remove%2A> método é usado para remover a primeira instância do item duplicado adicionada anteriormente e o conteúdo é exibido novamente. O <xref:System.Collections.Generic.List%601.Remove%2A> método sempre remove a primeira instância que encontrar.  
  
 O <xref:System.Collections.Generic.List%601.TrimExcess%2A> método é usado para reduzir a capacidade de corresponder à contagem e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas. Se a capacidade não utilizada tivesse sido menos de 10% da capacidade total, a lista seria não foram redimensionada.  
  
 Por fim, o <xref:System.Collections.Generic.List%601.Clear%2A> método é usado para remover todos os itens da lista e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.  
  
 É seguro executar várias operações de leitura em um <see cref="T:System.Collections.Generic.List`1" />, mas os problemas podem ocorrer se a coleção é modificada enquanto está sendo lido. Para garantir a segurança do thread, bloquear a coleção durante uma leitura ou operação de gravação. Para habilitar uma coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua sincronização. Para coleções com sincronização interna, consulte as classes de <see cref="N:System.Collections.Concurrent" /> namespace. Para obter uma alternativa inerentemente thread-safe, consulte o <see cref="T:System.Collections.Immutable.ImmutableList`1" /> classe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.List`1" /> que está vazia e tem a capacidade inicial padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Generic.List%601> é o número de elementos que o <xref:System.Collections.Generic.List%601> pode conter. Como os elementos são adicionados a um <xref:System.Collections.Generic.List%601>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.  
  
 Se o tamanho da coleção pode ser previsto, usando o <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> construtor e especificando a capacidade inicial elimina a necessidade de executar várias operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Generic.List%601>.  
  
 A capacidade pode ser diminuída chamando o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou definindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade explicitamente. Reduzir a capacidade realoca a memória e copia todos os elementos de <xref:System.Collections.Generic.List%601>.  
  
 Este construtor é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o construtor padrão da <xref:System.Collections.Generic.List%601> classe genérica. O construtor padrão cria uma lista com a capacidade padrão, conforme demonstrado exibindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade.  
  
 O exemplo adiciona, insere e remove itens, mostrando como a capacidade muda à medida que esses métodos são usados.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">A coleção cujos elementos são copiados para a nova lista.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.List`1" />, que contém os elementos copiados da coleção especificada e tem capacidade suficiente para acomodar o número de elementos copiados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são copiados para o <xref:System.Collections.Generic.List%601> na mesma ordem em que são lidas pelo enumerador da coleção.  
  
 Este construtor é um O (*n*) operação, onde * n * é o número de elementos em `collection`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.%23ctor%2A> construtor e vários métodos para o <xref:System.Collections.Generic.List%601> classe que atuam em intervalos. Uma matriz de cadeias de caracteres é criada e transferida ao construtor, preencher a lista com os elementos da matriz. O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade, em seguida, é exibida para mostrar que a capacidade inicial é exatamente o que é necessário para manter os elementos de entrada.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public List (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">O número de elementos que a nova lista pode armazenar inicialmente.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Generic.List`1" /> que está vazia e tem a capacidade inicial especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Generic.List%601> é o número de elementos que o <xref:System.Collections.Generic.List%601> pode conter. Como os elementos são adicionados a um <xref:System.Collections.Generic.List%601>, a capacidade é aumentada automaticamente conforme necessário ao realocar a matriz interna.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Generic.List%601>.  
  
 A capacidade pode ser diminuída chamando o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou definindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade explicitamente. Reduzir a capacidade realoca a memória e copia todos os elementos de <xref:System.Collections.Generic.List%601>.  
  
 Este construtor é um O (*n*) operação, onde * n * é `capacity`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29> construtor. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres com uma capacidade de 4 é criado, porque o tamanho máximo da lista é conhecido por ser exatamente 4. A lista é preenchida com quatro cadeias de caracteres e uma cópia somente leitura é criada usando o <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Add(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser adicionado ao final do <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Adiciona um objeto ao final do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>aceita `null` como um valor válido para a referência de tipos e permite que os elementos duplicados.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> já for igual a <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando matriz interna, e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> é menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, esse método é uma operação de (1). Se a capacidade precisa ser aumentado para acomodar o novo elemento, esse método se torna um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra várias propriedades e métodos para o <xref:System.Collections.Generic.List%601> classe genérica, incluindo o <xref:System.Collections.Generic.List%601.Add%2A> método. O construtor padrão é usado para criar uma lista de cadeias de caracteres com uma capacidade de 0. O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida e, em seguida, o <xref:System.Collections.Generic.List%601.Add%2A> método é usado para adicionar vários itens. Os itens são listados e o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente, juntamente com o <xref:System.Collections.Generic.List%601.Count%2A> propriedade, para mostrar que a capacidade foi aumentada conforme necessário.  
  
 Outras propriedades e métodos são usados para pesquisar, inserir e remover os elementos da lista e, finalmente, para limpar a lista.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">A coleção cujos elementos devem ser adicionados ao final do <see cref="T:System.Collections.Generic.List`1" />. A coleção em si não pode ser <see langword="null" />, mas pode conter elementos que são <see langword="null" />, se tipo <c>T</c> é um tipo de referência.</param>
        <summary>Adiciona os elementos da coleção especificada ao final do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos elementos na coleção é preservada no <xref:System.Collections.Generic.List%601>.  
  
 Se o novo <xref:System.Collections.Generic.List%601.Count%2A> (atual <xref:System.Collections.Generic.List%601.Count%2A> mais o tamanho da coleção) será maior <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando a matriz interna para acomodar os novos elementos, e os elementos existentes são copiados para a nova matriz antes que os novos elementos são adicionados.  
  
 Se o <xref:System.Collections.Generic.List%601> pode acomodar os novos elementos sem aumentar o <xref:System.Collections.Generic.List%601.Capacity%2A>, esse método é um O (*n*) operação, onde * n * é o número de elementos a serem adicionados. Se a capacidade precisa ser aumentado para acomodar os novos elementos, esse método se torna um O (*n* + *m*) operação, onde * n * é o número de elementos a serem adicionados e *m* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.AddRange%2A> método e vários outros métodos do <xref:System.Collections.Generic.List%601> classe que atuam em intervalos. Uma matriz de cadeias de caracteres é criada e transferida ao construtor, preencher a lista com os elementos da matriz. O <xref:System.Collections.Generic.List%601.AddRange%2A> método é chamado, com a lista como seu argumento. O resultado é que os elementos atuais da lista são adicionados ao final da lista, duplicar todos os elementos.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsReadOnly">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!T&gt; AsReadOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.AsReadOnly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> somente leitura para a coleção atual.</summary>
        <returns>Um objeto que atua como um wrapper somente leitura em torno do <see cref="T:System.Collections.Generic.List`1" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para impedir que todas as modificações de <xref:System.Collections.Generic.List%601> de objeto, expô-la apenas por esse wrapper. Um <xref:System.Collections.ObjectModel.ReadOnlyCollection%601> objeto não expor os métodos que modificam a coleção. No entanto, se forem feitas alterações em subjacente <xref:System.Collections.Generic.List%601> do objeto, a coleção somente leitura reflete as alterações.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres com uma capacidade de 4 é criado, porque o tamanho máximo da lista é conhecido por ser exatamente 4. A lista é preenchida com quatro cadeias de caracteres e o <xref:System.Collections.Generic.List%601.AsReadOnly%2A> método é usado para obter somente leitura <xref:System.Collections.Generic.IList%601> implementação de interface genérica que encapsula a lista original.  
  
 Um elemento da lista original é definido para "Coelophysis" usando o <xref:System.Collections.Generic.List%601.Item%2A> propriedade (indexador em c#) e o conteúdo da lista somente leitura é exibidas novamente para demonstrar que é apenas um wrapper para a lista original.  
  
 [!code-cpp[List\`1_AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_AsReadOnly/cpp/source.cpp#1)]
 [!code-csharp[List\`1_AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_AsReadOnly/cs/source.cs#1)]
 [!code-vb[List\`1_AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_AsReadOnly/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Pesquisa todo o <see cref="T:System.Collections.Generic.List`1" /> classificado para um elemento usando o comparador padrão e retorna o índice baseado em zero do elemento.</summary>
        <returns>O índice baseado em zero da <paramref name="item" /> no <see cref="T:System.Collections.Generic.List`1" /> classificado, se <paramref name="item" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="item" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> para tipo `T` para determinar a ordem dos elementos da lista. O <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verificações de propriedade se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Collections.Generic.List%601> já devem ser classificados de acordo com a implementação de comparador; caso contrário, o resultado é incorreto.  
  
 Comparando `null` com qualquer referência de tipo é permitido e não gerará uma exceção ao usar o <xref:System.IComparable%601> interface genérica. Durante a classificação, `null` é considerado menor que qualquer outro objeto.  
  
 Se o <xref:System.Collections.Generic.List%601> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.  
  
 Caso o <xref:System.Collections.Generic.List%601> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento que é maior do que o valor de pesquisa. Ao inserir o valor para o <xref:System.Collections.Generic.List%601>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.  
  
 Esse método é um O (log * n *) operação, onde * n * é o número de elementos do intervalo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga do método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, em nenhuma ordem específica. A lista é exibida, classificada e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga do método é usada para procurar por duas cadeias de caracteres que não estão na lista, e o <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inseri-los. O valor de retorno de <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> método for negativo em cada caso, porque as cadeias de caracteres não estão na lista. Levando o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) disso produz número negativo o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa e inserção neste local preserva a classificação ordem. A segunda cadeia de caracteres de pesquisa é maior que qualquer elemento na lista, portanto, é a posição de inserção no final da lista.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(!T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Pesquisa um elemento em todo o <see cref="T:System.Collections.Generic.List`1" /> classificado usando o comparador especificado e retorna o índice baseado em zero do elemento.</summary>
        <returns>O índice baseado em zero da <paramref name="item" /> no <see cref="T:System.Collections.Generic.List`1" /> classificado, se <paramref name="item" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="item" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação personaliza como os elementos são comparados. Por exemplo, você pode usar um <xref:System.Collections.CaseInsensitiveComparer> instância como o comparador para executar pesquisas de cadeia de caracteres de maiusculas e minúsculas.  
  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança <xref:System.InvalidOperationException>.  
  
 O <xref:System.Collections.Generic.List%601> já devem ser classificados de acordo com a implementação de comparador; caso contrário, o resultado é incorreto.  
  
 Comparando `null` com qualquer referência de tipo é permitido e não gerará uma exceção ao usar o <xref:System.IComparable%601> interface genérica. Durante a classificação, `null` é considerado menor que qualquer outro objeto.  
  
 Se o <xref:System.Collections.Generic.List%601> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.  
  
 Caso o <xref:System.Collections.Generic.List%601> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento que é maior do que o valor de pesquisa. Ao inserir o valor para o <xref:System.Collections.Generic.List%601>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.  
  
 Esse método é um O (log * n *) operação, onde * n * é o número de elementos do intervalo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método.  
  
 O exemplo define um comparador alternativo para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que não null. Segundo, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais longa é considerada maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, em nenhuma ordem específica. A lista é exibida, classificado usando o comparador alternativo e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar várias cadeias de caracteres que não estão na lista, usamos o comparador alternativo. O <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir as cadeias de caracteres. Esses dois métodos estão localizados na função nomeada `SearchAndInsert`, junto com o código para levar o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado por <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e usá-lo como um índice para Inserir nova cadeia de caracteres.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public int BinarySearch (int index, int count, T item, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 BinarySearch(int32 index, int32 count, !T item, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.BinarySearch(System.Int32,System.Int32,`0,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero inicial do intervalo a ser pesquisado.</param>
        <param name="count">O tamanho do intervalo a ser procurado.</param>
        <param name="item">O objeto a ser localizado. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="comparer">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Pesquisa um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> classificado para encontrar um elemento que usa o comparador especificado e retorna o índice baseado em zero do elemento.</summary>
        <returns>O índice baseado em zero da <paramref name="item" /> no <see cref="T:System.Collections.Generic.List`1" /> classificado, se <paramref name="item" /> for encontrado; caso contrário, um número negativo que é o complemento bit a bit do índice do próximo elemento maior que <paramref name="item" />, ou, se não houver nenhum elemento maior, o complemento bit a bit de <see cref="P:System.Collections.Generic.List`1.Count" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação personaliza como os elementos são comparados. Por exemplo, você pode usar um <xref:System.Collections.CaseInsensitiveComparer> instância como o comparador para executar pesquisas de cadeia de caracteres de maiusculas e minúsculas.  
  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança <xref:System.InvalidOperationException>.  
  
 O <xref:System.Collections.Generic.List%601> já devem ser classificados de acordo com a implementação de comparador; caso contrário, o resultado é incorreto.  
  
 Comparando `null` com qualquer referência de tipo é permitido e não gerará uma exceção ao usar o <xref:System.IComparable%601> interface genérica. Durante a classificação, `null` é considerado menor que qualquer outro objeto.  
  
 Se o <xref:System.Collections.Generic.List%601> contém mais de um elemento com o mesmo valor, o método retornará somente uma das ocorrências e pode retornar qualquer uma das ocorrências, não necessariamente o primeiro deles.  
  
 Caso o <xref:System.Collections.Generic.List%601> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar a operação de complemento bit a bit (~) para esse número inteiro negativo para obter o índice do primeiro elemento que é maior do que o valor de pesquisa. Ao inserir o valor para o <xref:System.Collections.Generic.List%601>, esse índice deve ser usado como o ponto de inserção para manter a ordem de classificação.  
  
 Esse método é um O (log * n *) operação, onde * n * é o número de elementos do intervalo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método.  
  
 O exemplo define um comparador alternativo para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que não null. Segundo, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais longa é considerada maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com os nomes de cinco dinossauros herbivorous e três dinossauros carnivorous. Em cada um dos dois grupos, os nomes não estão em qualquer ordem de classificação específico. A lista é exibida, o intervalo de herbivores é classificado usando o comparador alternativo e a lista é exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar somente o intervalo de herbivores "Brachiosaurus". A cadeia de caracteres não for encontrada e o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado pelo <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> método é usado como um índice para inserir a nova cadeia de caracteres.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <see cref="T:System.Collections.Generic.List`1" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número total de elementos que a estrutura de dados interna pode manter sem redimensionamento.</summary>
        <value>O número de elementos que <see cref="T:System.Collections.Generic.List`1" /> pode conter antes que o redimensionamento seja necessário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>é o número de elementos que o <xref:System.Collections.Generic.List%601> pode armazenar antes de redimensionamento é necessário, enquanto <xref:System.Collections.Generic.List%601.Count%2A> é o número de elementos que estão realmente no <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>sempre é maior que ou igual a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> excede <xref:System.Collections.Generic.List%601.Capacity%2A> durante a adição de elementos, a capacidade é aumentada, automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.  
  
 Se a capacidade é significativamente maior do que a contagem de e para reduzir a memória usada pelo <xref:System.Collections.Generic.List%601>, você pode diminuir a capacidade chamando o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou definindo o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade explicitamente um valor inferior. Quando o valor de <xref:System.Collections.Generic.List%601.Capacity%2A> é definido explicitamente, a matriz interna também seja realocada para acomodar a capacidade especificada e todos os elementos são copiados.  
  
 Recuperar o valor dessa propriedade é uma operação de (1); configuração da propriedade é um O (*n*) operação, onde * n * é a nova capacidade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como verificar a capacidade e a contagem de um <xref:System.Collections.Generic.List%601> que contém um objeto de negócios simples e ilustra o uso de <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para remover uma capacidade extra.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 A exemplo a seguir mostra o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade em vários pontos da vida útil de uma lista. O construtor padrão é usado para criar uma lista de cadeias de caracteres com uma capacidade de 0 e o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida para demonstrar isso. Após o <xref:System.Collections.Generic.List%601.Add%2A> método foi usado para adicionar vários itens, os itens são listados e, em seguida, o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente, juntamente com o <xref:System.Collections.Generic.List%601.Count%2A> propriedade, para mostrar que a capacidade foi aumentada conforme necessário.  
  
 O <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade é exibida novamente após o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método é usado para reduzir a capacidade de corresponder à contagem. Por fim, o <xref:System.Collections.Generic.List%601.Clear%2A> método é usado para remover todos os itens da lista e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas novamente.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <see cref="P:System.Collections.Generic.List`1.Capacity" /> é definido como um valor menor que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente disponível no sistema.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os elementos do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Count%2A>é definido como 0, e referências a outros objetos de elementos da coleção também são liberadas.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>permanece inalterado. Para redefinir a capacidade do <xref:System.Collections.Generic.List%601>, chamar o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método ou conjunto de <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade diretamente. Reduzir a capacidade realoca a memória e copia todos os elementos de <xref:System.Collections.Generic.List%601>. Cortar vazio <xref:System.Collections.Generic.List%601> define a capacidade do <xref:System.Collections.Generic.List%601> à capacidade padrão.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Clear%2A> método e várias outras propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica. O <xref:System.Collections.Generic.List%601.Clear%2A> método é usado no final do programa, para remover todos os itens da lista e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Contains(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Determina se um elemento está no <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> for encontrado no <see cref="T:System.Collections.Generic.List`1" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina igualdade usando o comparador de igualdade padrão, conforme definido pela implementação do objeto do <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método para `T` (o tipo de valores na lista).  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> métodos em um <xref:System.Collections.Generic.List%601> que contém um objeto de negócios simples que implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 O exemplo a seguir contém uma lista de objetos complexos do tipo `Cube`. O `Cube` classe implementa o <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método para que os dois cubos são considerados iguais se suas dimensões forem iguais. Neste exemplo, o <xref:System.Collections.Generic.List%601.Contains%2A> método retorna `true`, pois um cubo com as dimensões especificadas já está na coleção.  
  
 [!code-csharp[System.Collections.Generic.List.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.contains/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.contains/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TOutput&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;TOutput&gt; ConvertAll&lt;TOutput&gt; (Converter&lt;T,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!!TOutput&gt; ConvertAll&lt;TOutput&gt;(class System.Converter`2&lt;!T, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ConvertAll``1(System.Converter{`0,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TOutput&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="converter" Type="System.Converter&lt;T,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOutput">O tipo dos elementos da matriz de destino.</typeparam>
        <param name="converter">Um delegado <see cref="T:System.Converter`2" /> que converte cada elemento de um tipo em outro tipo.</param>
        <summary>Converte os elementos no <see cref="T:System.Collections.Generic.List`1" /> atual para outro tipo e retorna uma lista contendo os elementos convertidos.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1" /> do tipo de destino que contém os elementos convertidos do <see cref="T:System.Collections.Generic.List`1" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Converter%602> é um delegado para um método que converte um objeto para o tipo de destino.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Converter%602> delegado e os elementos convertidos são salvos na nova <xref:System.Collections.Generic.List%601>.  
  
 Atual <xref:System.Collections.Generic.List%601> permanece inalterado.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define um método chamado `PointFToPoint` que converte um <xref:System.Drawing.PointF> estrutura para um <xref:System.Drawing.Point> estrutura. O exemplo cria um <xref:System.Collections.Generic.List%601> de <xref:System.Drawing.PointF> estruturas, cria um `Converter\<PointF, Point>` delegar (`Converter(Of PointF, Point)` no Visual Basic) para representar o `PointFToPoint` método e passa o delegado para o < xref:System.Collections.Generic.List `1.ConvertAll``1*> method. The <xref:System.Collections.Generic.List`1.ConvertAll''1* > método passa cada elemento da lista de entrada para o `PointFToPoint` método e coloca os elementos convertidos em uma nova lista de <xref:System.Drawing.Point> estruturas. Ambas as listas são exibidas.  
  
 [!code-cpp[List\`1_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[List\`1_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_ConvertAll/cs/source.cs#1)]
 [!code-vb[List\`1_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="converter" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <summary>Copia todo o <see cref="T:System.Collections.Generic.List`1" /> em uma matriz unidimensional compatível, a partir do início da matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar os elementos.  
  
 Os elementos são copiados para o <xref:System.Array> na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com 5 cadeias de caracteres. Uma matriz de cadeia de caracteres vazia de 15 elementos é criada e o <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz a partir do primeiro elemento da matriz. O <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga do método é usada para copiar todos os elementos da lista para o início da matriz em 6 de índice de matriz (deixar vazio de índice 5). Por fim, o <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para copiar 3 elementos na lista, começando com o índice 2, para o início da matriz na matriz de índice 12 (deixar vazio 11 índice). O conteúdo da matriz é exibido.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de elementos no <see cref="T:System.Collections.Generic.List`1" /> de origem é maior que o número de elementos que o <paramref name="array" /> de destino pode conter.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(`0[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="arrayIndex">O índice de base zero em <c>matriz</c> no qual a cópia começa.</param>
        <summary>Copia todo o <see cref="T:System.Collections.Generic.List`1" /> para uma matriz unidimensional compatível, iniciando no índice especificado da matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar os elementos.  
  
 Os elementos são copiados para o <xref:System.Array> na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com 5 cadeias de caracteres. Uma matriz de cadeia de caracteres vazia de 15 elementos é criada e o <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz a partir do primeiro elemento da matriz. O <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga do método é usada para copiar todos os elementos da lista para o início da matriz em 6 de índice de matriz (deixar vazio de índice 5). Por fim, o <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para copiar 3 elementos na lista, começando com o índice 2, para o início da matriz na matriz de índice 12 (deixar vazio 11 índice). O conteúdo da matriz é exibido.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">O número de elementos na origem <see cref="T:System.Collections.Generic.List`1" /> é maior do que o espaço disponível de <paramref name="arrayIndex" /> até o final do <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int index, T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 index, !T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.CopyTo(System.Int32,`0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero no <see cref="T:System.Collections.Generic.List`1" /> de origem em que a cópia começa.</param>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Generic.List`1" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="arrayIndex">O índice de base zero em <c>matriz</c> no qual a cópia começa.</param>
        <param name="count">O número de elementos a serem copiados.</param>
        <summary>Copia um intervalo de elementos do <see cref="T:System.Collections.Generic.List`1" /> para uma matriz unidimensional compatível, começando pelo índice especificado da matriz de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método usa <xref:System.Array.Copy%2A?displayProperty=nameWithType> para copiar os elementos.  
  
 Os elementos são copiados para o <xref:System.Array> na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) operação, onde * n * é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.CopyTo%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com 5 cadeias de caracteres. Uma matriz de cadeia de caracteres vazia de 15 elementos é criada e o <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%29> sobrecarga do método é usada para copiar todos os elementos da lista para a matriz a partir do primeiro elemento da matriz. O <xref:System.Collections.Generic.List%601.CopyTo%28%600%5B%5D%2CSystem.Int32%29> sobrecarga do método é usada para copiar todos os elementos da lista para o início da matriz em 6 de índice de matriz (deixar vazio de índice 5). Por fim, o <xref:System.Collections.Generic.List%601.CopyTo%28System.Int32%2C%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para copiar 3 elementos na lista, começando com o índice 2, para o início da matriz na matriz de índice 12 (deixar vazio 11 índice). O conteúdo da matriz é exibido.  
  
 [!code-cpp[List\`1_CopyTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_CopyTo/cpp/source.cpp#1)]
 [!code-csharp[List\`1_CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_CopyTo/cs/source.cs#1)]
 [!code-vb[List\`1_CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_CopyTo/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="arrayIndex" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> é igual a ou maior que o <see cref="P:System.Collections.Generic.List`1.Count" /> do <see cref="T:System.Collections.Generic.List`1" /> de origem.  
  
 -ou-  
  
 O número de elementos de <paramref name="index" /> até o final do <see cref="T:System.Collections.Generic.List`1" /> de origem é maior que o espaço disponível do <paramref name="arrayIndex" /> até o final do <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos contidos no <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <value>O número de elementos contidos no <see cref="T:System.Collections.Generic.List`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601.Capacity%2A>é o número de elementos que o <xref:System.Collections.Generic.List%601> pode armazenar antes de redimensionamento é necessário. <xref:System.Collections.Generic.List%601.Count%2A>é o número de elementos que estão realmente no <xref:System.Collections.Generic.List%601>.  
  
 <xref:System.Collections.Generic.List%601.Capacity%2A>sempre é maior que ou igual a <xref:System.Collections.Generic.List%601.Count%2A>. Se <xref:System.Collections.Generic.List%601.Count%2A> excede <xref:System.Collections.Generic.List%601.Capacity%2A> durante a adição de elementos, a capacidade é aumentada, automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como verificar a capacidade e a contagem de um <xref:System.Collections.Generic.List%601> que contém um objeto de negócios simples e ilustra o uso de <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para remover uma capacidade extra.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 O exemplo a seguir mostra o valor de <xref:System.Collections.Generic.List%601.Count%2A> propriedade em vários pontos da vida útil de uma lista. Depois que a lista foi criada e preenchida e seus elementos exibidos, o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas. Essas propriedades são exibidas novamente após o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método foi chamado e novamente após o conteúdo da lista é limpos.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public bool Exists (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Exists(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Exists(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Determina se o <see cref="T:System.Collections.Generic.List`1" /> contém elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>
          <see langword="true" /> se o <see cref="T:System.Collections.Generic.List`1" /> contiver um ou mais elementos que correspondem às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegado e o processamento é interrompido quando uma correspondência for encontrada.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Contains%2A> e <xref:System.Collections.Generic.List%601.Exists%2A> métodos em um <xref:System.Collections.Generic.List%601> que contém um objeto de negócios simples que implementa <xref:System.IEquatable%601.Equals%2A>.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Exists%2A> método e vários outros métodos que usam o <xref:System.Predicate%601> delegado genérico.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, que contém nomes de dinossauro 8, dois deles (em posições 1 e 5) terminam com "saurus". O exemplo também define um método de predicado de pesquisa denominado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booleano um valor que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> métodos são usados para a lista de pesquisa com o método de predicado de pesquisa e, em seguida, o <xref:System.Collections.Generic.List%601.RemoveAll%2A> método é usado para remover todas as entradas que terminam com "saurus".  
  
 Por fim, o <xref:System.Collections.Generic.List%601.Exists%2A> método é chamado. Ele percorre a lista desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida e o método retorna `true` se o `EndsWithSaurus` método retorna `true` para qualquer elemento. O <xref:System.Collections.Generic.List%601.Exists%2A> método retorna `false` porque todos os elementos foram removidos.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public T Find (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T Find(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Find(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O primeiro elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegado, avançando <xref:System.Collections.Generic.List%601>, começando com o primeiro elemento e terminando com o último elemento.  O processamento será interrompido quando uma correspondência for encontrada.  
  
> [!IMPORTANT]
>  Ao procurar uma lista que contém os tipos de valor, verifique se que o valor padrão para o tipo não satisfaz o predicado de pesquisa. Caso contrário, não é possível distinguir entre um elemento de lista que acontece com o valor padrão para o tipo e um valor padrão indicando que nenhuma correspondência foi encontrada. Se o valor padrão satisfaz o predicado de pesquisa, use o <xref:System.Collections.Generic.List%601.FindIndex%2A> método em vez disso.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Find%2A> método em um <xref:System.Collections.Generic.List%601> que contém um objeto complexo simple.  
  
 [!code-csharp[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.ContainsExists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.containsexists/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados a [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ para XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos de localização.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cujo `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último registro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAll">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; FindAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; FindAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindAll(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Recupera todos os elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1" /> que contém todos os elementos que correspondem às condições definidas pelo predicado especificado, se encontrados; caso contrário, um <see cref="T:System.Collections.Generic.List`1" /> vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegado e os elementos que correspondem às condições são salvos no retornado <xref:System.Collections.Generic.List%601>.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados a [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ para XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos de localização.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cujo `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último registro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado forward iniciando no primeiro elemento e terminando no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegate. O representante tem a assinatura:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Employee` classe com dois campos, `Name` e `Id`. Ele também define um `EmployeeSearch` classe com um único método, `StartsWith`, que indica se o `Employee.Name` campo começa com uma subcadeia de caracteres especificada que é fornecida para o `EmployeeSearch` construtor da classe. Observe a assinatura do método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde à assinatura do delegado que pode ser passado para o <xref:System.Collections.Generic.List%601.FindIndex%2A> método. O exemplo cria um `List<Employee>` de objeto, adiciona um número de `Employee` objetos a ele e, em seguida, chama o <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método duas vezes para pesquisar toda a coleção, na primeira vez para o primeiro `Employee` do objeto cuja `Name` campo começa com "J" e a segunda vez para a primeira `Employee` do objeto cuja `Name` campo começa com "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex2.cs#2)]
 [!code-vb[System.Collections.Generic.List.FindIndex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que se estende do índice especificado ao último elemento.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado forward começando em `startIndex` e terminando no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegate. O representante tem a assinatura:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é o número de elementos do `startIndex` ao final do <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Employee` classe com dois campos, `Name` e `Id`. Ele também define um `EmployeeSearch` classe com um único método, `StartsWith`, que indica se o `Employee.Name` campo começa com uma subcadeia de caracteres especificada que é fornecida para o `EmployeeSearch` construtor da classe. Observe a assinatura do método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde à assinatura do delegado que pode ser passado para o <xref:System.Collections.Generic.List%601.FindIndex%2A> método. O exemplo cria um `List<Employee>` de objeto, adiciona um número de `Employee` objetos a ele e, em seguida, chama o <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método duas vezes para pesquisar a coleção começando com o membro quinto (ou seja, o membro no índice 4). Na primeira vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "J"; pela segunda vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex3.cs#3)]
 [!code-vb[System.Collections.Generic.List.FindIndex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex">
      <MemberSignature Language="C#" Value="public int FindIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que coincida com as condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos na <see cref="T:System.Collections.Generic.List`1" /> que começa no índice especificado e contém o número de elementos especificado.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado forward começando em `startIndex` e final em `startIndex` mais `count` menos 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegate. O representante tem a assinatura:  
  
```csharp  
public bool methodName(T obj)  
```  
  
```vb  
Public Function methodName(obj As T) As Boolean  
```  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é `count`.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Employee` classe com dois campos, `Name` e `Id`. Ele também define um `EmployeeSearch` classe com um único método, `StartsWith`, que indica se o `Employee.Name` campo começa com uma subcadeia de caracteres especificada que é fornecida para o `EmployeeSearch` construtor da classe. Observe a assinatura do método  
  
```csharp  
public bool StartsWith(Employee e)  
```  
  
```vb  
Public Function StartsWith(e As Employee) As Boolean  
```  
  
 corresponde à assinatura do delegado que pode ser passado para o <xref:System.Collections.Generic.List%601.FindIndex%2A> método. O exemplo cria um `List<Employee>` de objeto, adiciona um número de `Employee` objetos a ele e, em seguida, chama o <xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29> método duas vezes para pesquisar toda a coleção (ou seja, os membros do índice 0 para índice <xref:System.Collections.Generic.List%601.Count%2A> - 1). Na primeira vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "J"; pela segunda vez, ele procura a primeira `Employee` do objeto cuja `Name` campo começa com "Ju".  
  
 [!code-csharp[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/cs/FindIndex1.cs#1)]
 [!code-vb[System.Collections.Generic.List.FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Collections.Generic.List.FindIndex/vb/FindIndex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLast">
      <MemberSignature Language="C#" Value="public T FindLast (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T FindLast(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLast(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O último elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegado, mover para trás no <xref:System.Collections.Generic.List%601>, começando com o último elemento e terminando com o primeiro elemento.  O processamento será interrompido quando uma correspondência for encontrada.  
  
> [!IMPORTANT]
>  Ao procurar uma lista que contém os tipos de valor, verifique se que o valor padrão para o tipo não satisfaz o predicado de pesquisa. Caso contrário, não é possível distinguir entre um elemento de lista que acontece com o valor padrão para o tipo e um valor padrão indicando que nenhuma correspondência foi encontrada. Se o valor padrão satisfaz o predicado de pesquisa, use o <xref:System.Collections.Generic.List%601.FindLastIndex%2A> método em vez disso.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados a [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ para XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos de localização.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cujo `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último registro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência em toda a <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegate.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados a [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ para XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos de localização.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cujo `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último registro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegate.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é o número de elementos desde o início do <xref:System.Collections.Generic.List%601> para `startIndex`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex">
      <MemberSignature Language="C#" Value="public int FindLastIndex (int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 FindLastIndex(int32 startIndex, int32 count, class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.FindLastIndex(System.Int32,System.Int32,System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa por um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência no intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada começando com versões anteriores em `startIndex` e final em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegate.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra os métodos de localização para o <xref:System.Collections.Generic.List%601> classe. O exemplo para o <xref:System.Collections.Generic.List%601> classe contém `book` objetos da classe `Book`, usando os dados a [arquivo XML de exemplo: livros (LINQ to XML)](http://msdn.microsoft.com/library/94252daf-6097-4625-afc2-0eb778958d4f). O `FillList` usa o método no exemplo [LINQ para XML](http://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13) para analisar os valores do XML para valores de propriedade do `book` objetos.  
  
 A tabela a seguir descreve os exemplos fornecidos para os métodos de localização.  
  
|Método|Exemplo|  
|------------|-------------|  
|<xref:System.Collections.Generic.List%601.Find%28System.Predicate%7B%600%7D%29>|Localiza um catálogo usando uma ID de `IDToFind` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindAll%28System.Predicate%7B%600%7D%29>|Localizar todos os livros que cujo `Genre` propriedade é "Computador" usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLast%28System.Predicate%7B%600%7D%29>|Localiza o último registro na coleção que tem uma data de publicação antes de 2001, usando o `PubBefore2001` delegado de predicado.<br /><br /> O exemplo c# usa um delegado anônimo.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Predicate%7B%600%7D%29>|Localiza o índice do último registro computador usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do primeiro registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
|<xref:System.Collections.Generic.List%601.FindLastIndex%28System.Int32%2CSystem.Int32%2CSystem.Predicate%7B%600%7D%29>|Localiza o índice do último registro de computador na segunda metade da coleção, usando o `FindComputer` delegado de predicado.|  
  
 [!code-csharp[List\`1_Find_Methods#1](~/samples/snippets/csharp/VS_Snippets_CLR/list`1_find_methods/cs/program.cs#1)]
 [!code-vb[List\`1_Find_Methods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/list`1_find_methods/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach">
      <MemberSignature Language="C#" Value="public void ForEach (Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ForEach(class System.Action`1&lt;!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ForEach(System.Action{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="action">O delegado <see cref="T:System.Action`1" /> a ser executado em cada elemento do <see cref="T:System.Collections.Generic.List`1" />.</param>
        <summary>Executa a ação especificada em cada elemento do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Action%601> um delegado para um método que executa uma ação no objeto passado para ele.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Action%601> delegate.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Modificar a coleção subjacente no corpo do <xref:System.Action%601> delegado não tem suporte e causa um comportamento indefinido.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Action%601> delegado para imprimir o conteúdo de um <xref:System.Collections.Generic.List%601> objeto. Neste exemplo o `Print` método é usado para exibir o conteúdo da lista para o console.  
  
> [!NOTE]
>  Além de exibir o conteúdo usando o `Print` método, o exemplo c# demonstra o uso de exibir os resultados para o console.  
  
 [!code-csharp[System.Action_PrintExample#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Action_PrintExample/cs/action.cs#01)]
 [!code-vb[System.Action_PrintExample#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Action_PrintExample/vb/action.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="action" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um elemento na coleção foi modificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.List`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera por meio do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1.Enumerator" /> para o <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. Nesta posição, o <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propriedade está definida. Por isso, você deve chamar o método <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.Generic.List%601.Enumerator.Current%2A>.  
  
 O <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> propriedade retorna o mesmo objeto até <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> é chamado. <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> define <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> está indefinido. Não é possível definir <xref:System.Collections.Generic.List%601.Enumerator.Current%2A> como o primeiro elemento da coleção novamente; você deve criar uma nova instância de enumerador em vez disso.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.  
  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRange">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.List&lt;T&gt; GetRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.List`1&lt;!T&gt; GetRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.GetRange(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice <see cref="T:System.Collections.Generic.List`1" /> baseado em zero no qual é iniciado o intervalo.</param>
        <param name="count">O número de elementos no intervalo.</param>
        <summary>Cria uma cópia superficial de um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> de origem.</summary>
        <returns>Uma cópia superficial de um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma cópia superficial de uma coleção de tipos de referência ou um subconjunto da coleção, contém somente as referências para os elementos da coleção. Os objetos em si não são copiados. As referências na nova lista apontam para os mesmos objetos as referências da lista original.  
  
 Uma cópia superficial de uma coleção de tipos de valor ou um subconjunto da coleção, contém os elementos da coleção. No entanto, se os elementos da coleção contém referências a outros objetos, esses objetos não são copiados. As referências de elementos da nova coleção apontam para os mesmos objetos as referências de elementos da coleção original.  
  
 Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.  
  
 Esse método é um O (*n*) operação, onde * n * é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.GetRange%2A> método e outros métodos para o <xref:System.Collections.Generic.List%601> classe que atuam em intervalos. No final do exemplo, o <xref:System.Collections.Generic.List%601.GetRange%2A> método é usado para obter três itens na lista, começando com o local do índice 2. O <xref:System.Collections.Generic.List%601.ToArray%2A> método é chamado em resultante <xref:System.Collections.Generic.List%601>, criando uma matriz de três elementos. Os elementos da matriz são exibidos.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido de elementos no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da primeira ocorrência dentro de todo o <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="item" /> em todo o <see cref="T:System.Collections.Generic.List`1" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado forward iniciando no primeiro elemento e terminando no último elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, com uma entrada que aparece duas vezes no local de índice 0 e o local de índice 5. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga do método de pesquisa a lista desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o lista começando com o local de índice 3 e continua até o fim da lista e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma lista vazia.</param>
        <summary>Procura o objeto especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> que se estende do índice especificado para o último elemento.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="item" /> dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que se estende do <paramref name="index" /> ao último elemento, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado forward começando em `index` e terminando no último elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é o número de elementos do `index` ao final do <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, com uma entrada que aparece duas vezes no local de índice 0 e o local de índice 5. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga do método de pesquisa a lista desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o lista começando com o local de índice 3 e continua até o fim da lista e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.IndexOf(`0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma lista vazia.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da primeira ocorrência em um intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que começa no índice especificado e contém o número de elementos especificado.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="item" /> no intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que começa em <paramref name="index" /> e contém o número de elementos <paramref name="count" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado forward começando em `index` e final em `index` mais `count` menos 1, se `count` for maior que 0.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.IndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, com uma entrada que aparece duas vezes no local de índice 0 e o local de índice 5. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%29> sobrecarga do método de pesquisa a lista desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o lista começando com o local de índice 3 e continua até o fim da lista e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Collections.Generic.List%601.IndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[List\`1_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_IndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public void Insert (int index, T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Insert(int32 index, !T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Insert(System.Int32,`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="index">O índice de base zero no qual <c>item</c> devem ser inseridos.</param>
        <param name="item">O objeto a ser inserido. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Insere um elemento no <see cref="T:System.Collections.Generic.List`1" />, no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>aceita `null` como um valor válido para a referência de tipos e permite que os elementos duplicados.  
  
 Se <xref:System.Collections.Generic.List%601.Count%2A> já for igual a <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando matriz interna, e os elementos existentes são copiados para a nova matriz antes de adicionar o novo elemento.  
  
 Se `index` é igual a <xref:System.Collections.Generic.List%601.Count%2A>, `item` é adicionada ao final da <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Insert%2A> método, juntamente com várias propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica. Depois que a lista é criada, os elementos são adicionados. O <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir um item no meio da lista. O item inserido é uma duplicata, que é removida posteriormente usando o <xref:System.Collections.Generic.List%601.Remove%2A> método.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="index" /> é maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertRange">
      <MemberSignature Language="C#" Value="public void InsertRange (int index, System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertRange(int32 index, class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">O índice baseado em zero no qual os novos elementos devem ser inseridos.</param>
        <param name="collection">A coleção cujos elementos devem ser inseridos no <see cref="T:System.Collections.Generic.List`1" />. A coleção em si não pode ser <see langword="null" />, mas pode conter elementos que são <see langword="null" />, se tipo <c>T</c> é um tipo de referência.</param>
        <summary>Insere os elementos de uma coleção no <see cref="T:System.Collections.Generic.List`1" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>aceita `null` como um valor válido para a referência de tipos e permite que os elementos duplicados.  
  
 Se o novo <xref:System.Collections.Generic.List%601.Count%2A> (atual <xref:System.Collections.Generic.List%601.Count%2A> mais o tamanho da coleção) será maior <xref:System.Collections.Generic.List%601.Capacity%2A>, a capacidade do <xref:System.Collections.Generic.List%601> é aumentado, automaticamente realocando a matriz interna para acomodar os novos elementos, e os elementos existentes são copiados para a nova matriz antes que os novos elementos são adicionados.  
  
 Se `index` é igual a <xref:System.Collections.Generic.List%601.Count%2A>, os elementos são adicionados ao final da <xref:System.Collections.Generic.List%601>.  
  
 A ordem dos elementos na coleção é preservada no <xref:System.Collections.Generic.List%601>.  
  
 Esse método é um O (*n* + *m*) operação, onde * n * é o número de elementos a serem adicionados e *m* é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra <xref:System.Collections.Generic.List%601.InsertRange%2A> método e vários outros métodos do <xref:System.Collections.Generic.List%601> classe que atuam em intervalos. Depois que a lista foi criada e preenchida com os nomes dos vários tranquilo destruidores de fábrica dinossauros, o <xref:System.Collections.Generic.List%601.InsertRange%2A> método é usado para inserir uma matriz de três dinossauros um Feroz comer a parte mais importante na lista, começando no local de índice 3.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="collection" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="index" /> é maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice com base em zero do elemento a ser obtido ou definido.</param>
        <summary>Obtém ou define o elemento no índice especificado.</summary>
        <value>O elemento no índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Generic.List%601>aceita `null` como um valor válido para a referência de tipos e permite que os elementos duplicados.  
  
 Esta propriedade fornece a capacidade de acessar um elemento específico na coleção usando a seguinte sintaxe: `myCollection[index]`.  
  
 Recuperar o valor dessa propriedade é uma operação de (1); definindo a propriedade também é uma operação de (1).  
  
   
  
## Examples  
 O exemplo nesta seção demonstra o <xref:System.Collections.Generic.List%601.Item%2A> propriedade (indexador em c#) e várias outras propriedades e métodos do <xref:System.Collections.Generic.List%601> classe genérica. Depois que a lista foi criada e preenchida usando o <xref:System.Collections.Generic.List%601.Add%2A> método, um elemento é recuperado e exibido usando o <xref:System.Collections.Generic.List%601.Item%2A> propriedade. (Para obter um exemplo que usa o <xref:System.Collections.Generic.List%601.Item%2A> propriedade para definir o valor de um elemento da lista, consulte <xref:System.Collections.Generic.List%601.AsReadOnly%2A>.)  
  
> [!NOTE]
>  Visual Basic, c# e C++ todos têm sintaxe para acessar o <xref:System.Collections.Generic.List%601.Item%2A> propriedade sem usar seu nome. Em vez disso, a variável que contém o <xref:System.Collections.Generic.List%601> é usado como se fosse uma matriz.  
  
 A linguagem c# usa a palavra-chave para definir os indexadores em vez de implementar o <xref:System.Collections.Generic.List%601.Item%2A> propriedade. Visual Basic implementa <xref:System.Collections.Generic.List%601.Item%2A> como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.  
  
 [!code-csharp[List`1_Class#2](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#2)]
 [!code-vb[List`1_Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#2)]  
[!code-csharp[List`1_Class#3](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#3)]
[!code-vb[List`1_Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="index" /> é igual a ou maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da última ocorrência dentro de todo o <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="item" /> em todo o <see cref="T:System.Collections.Generic.List`1" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, com uma entrada que aparece duas vezes no local de índice 0 e o local de índice 5. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga do método de pesquisa a lista inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a lista de versões anteriores, começando com o local de índice 3 e continuando até o início da lista, para que ele localiza a primeira ocorrência da cadeia de caracteres na lista. Por fim, o <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa inversa.</param>
        <summary>Procura o objeto especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="item" /> dentro do intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> que se estende do primeiro elemento a <paramref name="index" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada começando com versões anteriores em `index` e terminando no primeiro elemento.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é o número de elementos desde o início do <xref:System.Collections.Generic.List%601> para `index`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, com uma entrada que aparece duas vezes no local de índice 0 e o local de índice 5. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga do método de pesquisa a lista inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a lista de versões anteriores, começando com o local de índice 3 e continuando até o início da lista, para que ele localiza a primeira ocorrência da cadeia de caracteres na lista. Por fim, o <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (T item, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(!T item, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.LastIndexOf(`0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <param name="index">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos de <see cref="T:System.Collections.Generic.List`1" /> que contém o número especificado de elementos e termina no índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="item" /> dentro do intervalo de elementos no <see cref="T:System.Collections.Generic.List`1" /> que contém <paramref name="count" /> número de elementos e termina no <paramref name="index" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Generic.List%601> é pesquisada começando com versões anteriores em `index` e final em `index` menos `count` mais 1, se `count` for maior que 0.  
  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas do <xref:System.Collections.Generic.List%601.LastIndexOf%2A> método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, com uma entrada que aparece duas vezes no local de índice 0 e o local de índice 5. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%29> sobrecarga do método de pesquisa a lista inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a lista de versões anteriores, começando com o local de índice 3 e continuando até o início da lista, para que ele localiza a primeira ocorrência da cadeia de caracteres na lista. Por fim, o <xref:System.Collections.Generic.List%601.LastIndexOf%28%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de 4 entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[List\`1_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[List\`1_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_LastIndexOf/cs/source.cs#1)]
 [!code-vb[List\`1_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Collections.Generic.List`1" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não especificam uma seção válida no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Remove(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a remover do <see cref="T:System.Collections.Generic.List`1" />. O valor pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> for removido com êxito; caso contrário, <see langword="false" />.  Esse método também retornará <see langword="false" /> se <paramref name="item" /> não tiver sido encontrado no <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `T` implementa o <xref:System.IEquatable%601> interface genérica, o comparador de igualdade é o <xref:System.IEquatable%601.Equals%2A> método da interface; caso contrário, o comparador de igualdade padrão é <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra <xref:System.Collections.Generic.List%601.Remove%2A> método. Várias propriedades e métodos para o <xref:System.Collections.Generic.List%601> classe genérica são usados para adicionar, insert e a lista de pesquisa. Depois que essas operações, a lista contém uma duplicata. O <xref:System.Collections.Generic.List%601.Remove%2A> método é usado para remover a primeira instância do item duplicado e o conteúdo é exibido. O <xref:System.Collections.Generic.List%601.Remove%2A> método sempre remove a primeira instância que encontrar.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public int RemoveAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem removidos.</param>
        <summary>Remove todos os elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>O número de elementos removidos de <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegado e os elementos que correspondem às condições são removidos do <xref:System.Collections.Generic.List%601>.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.RemoveAll%2A> método e vários outros métodos que usam o <xref:System.Predicate%601> delegado genérico.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, que contém nomes de dinossauro 8, dois deles (em posições 1 e 5) terminam com "saurus". O exemplo também define um método de predicado de pesquisa denominado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booleano um valor que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Collections.Generic.List%601.Find%2A>, <xref:System.Collections.Generic.List%601.FindLast%2A>, e <xref:System.Collections.Generic.List%601.FindAll%2A> métodos são usados para a lista de pesquisa com o método de predicado de pesquisa.  
  
 O <xref:System.Collections.Generic.List%601.RemoveAll%2A> método é usado para remover todas as entradas que terminam com "saurus". Ele percorre a lista desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. O elemento seja removido se a `EndsWithSaurus` método retornará `true`.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferir o representante correto do contexto e criá-lo automaticamente.  
  
 Por fim, o <xref:System.Collections.Generic.List%601.Exists%2A> método verifica se não há nenhum cadeias de caracteres na lista que terminam com "saurus".  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveAt">
      <MemberSignature Language="C#" Value="public void RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice de base zero do elemento a ser removido.</param>
        <summary>Remove o elemento no índice especificado do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Collections.Generic.List%601.RemoveAt%2A> para remover um item, os itens restantes na lista são renumerados para substituir o item removido. Por exemplo, se você remover o item no índice 3, o item no índice 4 é movido para a posição de 3. Além disso, o número de itens na lista (conforme representado pelo <xref:System.Collections.Generic.List%601.Count%2A> propriedade) é reduzida em 1.  
  
 Esse método é um O (*n*) operação, onde * n * é (<xref:System.Collections.Generic.List%601.Count%2A> - `index`).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar, remover e inserir um objeto de negócios simples em um <xref:System.Collections.Generic.List%601>.  
  
 [!code-csharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/cs/program.cs#1)]
 [!code-fsharp[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/fs/addremoveinsert.fs#1)]
 [!code-vb[System.Collections.Generic.List.AddRemoveInsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.addremoveinsert/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="index" /> é igual a ou maior que <see cref="P:System.Collections.Generic.List`1.Count" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveRange">
      <MemberSignature Language="C#" Value="public void RemoveRange (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveRange(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice inicial baseado em zero do intervalo de elementos a serem removidos.</param>
        <param name="count">O número de elementos a serem removidos.</param>
        <summary>Remove um intervalo de elementos do <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os itens serão removidos e todos os elementos a seguir no <xref:System.Collections.Generic.List%601> ter seus índices reduzidas `count`.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.RemoveRange%2A> método e vários outros métodos do <xref:System.Collections.Generic.List%601> classe que atuam em intervalos. Depois que a lista foi criada e modificada, o <xref:System.Collections.Generic.List%601.RemoveRange%2A> método é usado para remover os dois elementos da lista, começando no local do índice 2.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido de elementos no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inverte a ordem dos elementos em todo o <see cref="T:System.Collections.Generic.List`1" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para inverter a ordem dos elementos.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra as duas sobrecargas do <xref:System.Collections.Generic.List%601.Reverse%2A> método. O exemplo cria um <xref:System.Collections.Generic.List%601> de cadeias de caracteres e adiciona seis cadeias de caracteres. O <xref:System.Collections.Generic.List%601.Reverse> sobrecarga do método usada para reverter a lista e, em seguida, o <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> sobrecarga do método usada para reverter o meio da lista, começando com o elemento 1 e abrangendo quatro elementos.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public void Reverse (int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Reverse(int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Reverse(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice inicial baseado em zero do intervalo a ser revertido.</param>
        <param name="count">O número de elementos no intervalo a serem revertidos.</param>
        <summary>Inverte a ordem dos elementos no intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa <xref:System.Array.Reverse%2A?displayProperty=nameWithType> para inverter a ordem dos elementos.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra as duas sobrecargas do <xref:System.Collections.Generic.List%601.Reverse%2A> método. O exemplo cria um <xref:System.Collections.Generic.List%601> de cadeias de caracteres e adiciona seis cadeias de caracteres. O <xref:System.Collections.Generic.List%601.Reverse> sobrecarga do método usada para reverter a lista e, em seguida, o <xref:System.Collections.Generic.List%601.Reverse%28System.Int32%2CSystem.Int32%29> sobrecarga do método usada para reverter o meio da lista, começando com o elemento 1 e abrangendo quatro elementos.  
  
 [!code-cpp[List\`1_Reverse#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Reverse/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Reverse/cs/source.cs#1)]
 [!code-vb[List\`1_Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Reverse/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido de elementos no <see cref="T:System.Collections.Generic.List`1" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Classifica os elementos no <see cref="T:System.Collections.Generic.List`1" /> ou parte dele.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="overloaded-method-syntax"></a>Sintaxe de método sobrecarregada  
 O <xref:System.Collections.Generic.List%601.Sort%2A> métodos permitem que você classifique com o comparador padrão para o tipo de objeto na lista ou especifique um método de classificação do cliente.  
  
 [Lista\<T >. Sort](xref:System.Collections.Generic.List`1.Sort*) classifica os elementos em toda a lista usando o comparador padrão do tipo de objeto são mantidos na lista.  
  
 [Lista\<T >. Classificação M (comparação\<T > comparação)](xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29) classifica os elementos em toda a lista usando o comparador especificado.  
  
 [Lista\<T >. Classificar (IComparer\<T > comparador)](xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29) classifica os elementos na lista de inteiros usando especificado <xref:System.Comparison%601?displayProperty=nameWithType>.  
  
 [Lista\<T >. Classificar (índice de Int32, contagem de Int32 IComparer\<T > comparador)](xref:System.Collections.Generic.List%601.Sort%28System.Int32,System.Int32,System.Collections.Generic.IComparer%7B%600%7D%29) classifica os elementos em um intervalo de elementos na lista usando o comparador especificado.  
  
## <a name="parameters"></a>Parâmetros  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`comparison`|<xref:System.Comparison%601>|O método delegado para uso na comparação entre elementos|  
|comparador|<xref:System.Collections.Generic.IComparer%601>|O <xref:System.Collections.Generic.IComparer%601> implementação para usar ao comparar os elementos, ou null para usar o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default>.|  
|`index`|<xref:System.Int32>|O índice inicial baseado em zero do intervalo a ser classificado.|  
|`count`|<xref:System.Int32>|O tamanho do intervalo a ser classificado.|  
  
## <a name="exceptions"></a>Exceções  
  
|Exceção|Condição|  
|---------------|---------------|  
|<xref:System.InvalidOperationException>|`comparer`não foi especificado ou `null`e o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> não é possível encontrar a implementação do <xref:System.IComparable%601?displayProperty=nameWithType> interface genérica ou <xref:System.IComparable?displayProperty=nameWithType> interface para o tipo T.|  
|<xref:System.ArgumentNullException>|`comparison` é `null`.|  
|<xref:System.ArgumentException>|A implementação de `comparison` ou `comparer` causou um erro durante a classificação. Por exemplo, `comparison` não pode retornar 0 ao comparar um item com ele próprio.<br /><br /> -ou-<br /><br /> `index` e `count` não especificam um intervalo válido no <xref:System.Collections.Generic.List%601>.|  
|<xref:System.ArgumentOutOfRangeException>|`index`é menor que 0 ou `count` é menor que 0.|  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Classifica os elementos em todo o <see cref="T:System.Collections.Generic.List`1" /> usando o comparador padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> para tipo `T` para determinar a ordem dos elementos da lista. O <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verificações de propriedade se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 Esse método usa o <xref:System.Array.Sort%2A?displayProperty=nameWithType> método, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um algoritmo de classificação de inserção.  
  
-   Se o número de partições exceder 2 log * n *, onde * n * é o intervalo da matriz de entrada, ele usa um algoritmo de Heapsort.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (* n * log * n *) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n*<sup>2</sup>) operação.  
  
   
  
## Examples  
 O exemplo a seguir adiciona alguns nomes para um `List<String>` objeto, exibe a lista em ordem não classificado, chama o <xref:System.Collections.Generic.List%601.Sort%2A> método e, em seguida, exibe a lista classificada.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/Sort1.cs#2)]
 [!code-vb[System.Collections.Generic.List.Sort#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/Sort1.vb#2)]  
  
 O código a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort> e <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecargas de método em um objeto de negócios simples. Chamando o <xref:System.Collections.Generic.List%601.Sort> método resulta no uso do comparador padrão para o tipo de parte e o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> método é implementado usando um método anônimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga do método. Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, em nenhuma ordem específica. A lista é exibida, classificada e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%29> sobrecarga do método é usada para procurar por duas cadeias de caracteres que não estão na lista, e o <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inseri-los. O valor de retorno de <xref:System.Collections.Generic.List%601.BinarySearch%2A> método for negativo em cada caso, porque as cadeias de caracteres não estão na lista. Levando o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) disso produz número negativo o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa e inserção neste local preserva a classificação ordem. A segunda cadeia de caracteres de pesquisa é maior que qualquer elemento na lista, portanto, é a posição de inserção no final da lista.  
  
 [!code-cpp[List\`1_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearch/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não consegue encontrar uma implementação da interface genérica <see cref="T:System.IComparable`1" /> ou a interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Classifica os elementos em todo o <see cref="T:System.Collections.Generic.List`1" /> usando o comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são classificados usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 Esse método usa o <xref:System.Array.Sort%2A?displayProperty=nameWithType> método, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um algoritmo de classificação de inserção.  
  
-   Se o número de partições exceder 2 log * n *, onde * n * é o intervalo da matriz de entrada, ele usa um algoritmo de Heapsort.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (* n * log * n *) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n*<sup>2</sup>) operação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método.  
  
 O exemplo define um comparador alternativo para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que não null. Segundo, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais longa é considerada maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, em nenhuma ordem específica. A lista é exibida, classificado usando o comparador alternativo e exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar várias cadeias de caracteres que não estão na lista, usamos o comparador alternativo. O <xref:System.Collections.Generic.List%601.Insert%2A> método é usado para inserir as cadeias de caracteres. Esses dois métodos estão localizados na função nomeada `SearchAndInsert`, junto com o código para levar o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado por <xref:System.Collections.Generic.List%601.BinarySearch%28%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> e usá-lo como um índice para Inserir nova cadeia de caracteres.  
  
 [!code-cpp[List\`1_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não pode encontrar a implementação da interface genérica <see cref="T:System.IComparable`1" /> ou da interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(class System.Comparison`1&lt;!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Comparison{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparison">O <see cref="T:System.Comparison`1" /> a ser usado na comparação de elementos.</param>
        <summary>Classifica os elementos em todo o <see cref="T:System.Collections.Generic.List`1" /> usando o <see cref="T:System.Comparison`1" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparison` for fornecido, os elementos de <xref:System.Collections.Generic.List%601> são classificados usando o método representado pelo delegado.  
  
 Se `comparison` é `null`, uma <xref:System.ArgumentNullException> é gerada.  
  
 Esse método usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um algoritmo de classificação de inserção  
  
-   Se o número de partições exceder 2 log * n *, onde * n * é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (* n * log * n *) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n*<sup>2</sup>) operação.  
  
   
  
## Examples  
 O código a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%2A> e <xref:System.Collections.Generic.List%601.Sort%2A> sobrecargas de método em um objeto de negócios simples. Chamando o <xref:System.Collections.Generic.List%601.Sort%2A> método resulta no uso do comparador padrão para o tipo de parte e o <xref:System.Collections.Generic.List%601.Sort%2A> método é implementado usando um método anônimo.  
  
 [!code-csharp[System.Collections.Generic.List.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.sort/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.sort/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecarga do método.  
  
 O exemplo define um método alternativo de comparação para cadeias de caracteres, denominado `CompareDinosByLength`. Esse método funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que não null. Segundo, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais longa é considerada maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, em nenhuma ordem específica. A lista também inclui uma cadeia de caracteres vazia e uma referência nula. A lista é exibida, classificados usando um <xref:System.Comparison%601> delegado genérico que representa o `CompareDinosByLength` método e exibida novamente.  
  
 [!code-cpp[List\`1_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortComparison/cs/source.cs#1)]
 [!code-vb[List\`1_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="comparison" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparison" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparison" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort (int index, int count, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort(int32 index, int32 count, class System.Collections.Generic.IComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.Sort(System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="index">O índice inicial baseado em zero do intervalo a ser classificado.</param>
        <param name="count">O tamanho do intervalo a ser classificado.</param>
        <param name="comparer">A implementação <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" />.</param>
        <summary>Classifica os elementos em um intervalo de elementos em <see cref="T:System.Collections.Generic.List`1" /> usando o comparador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` for fornecido, os elementos do <xref:System.Collections.Generic.List%601> são classificados usando especificado <xref:System.Collections.Generic.IComparer%601> implementação.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable%601> interface genérica e usa essa implementação, se disponível.  Caso contrário, <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> verifica se tipo `T` implementa o <xref:System.IComparable> interface.  Se tipo `T` não implementa a interface <xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType> lança um <xref:System.InvalidOperationException>.  
  
 Esse método usa <xref:System.Array.Sort%2A?displayProperty=nameWithType>, que se aplica a classificação introspectiva da seguinte maneira:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um algoritmo de classificação de inserção  
  
-   Se o número de partições exceder 2 log * n *, onde * n * é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um algoritmo Quicksort.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Em média, esse método é um O (* n * log * n *) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>; no pior caso é um O (*n*<sup>2</sup>) operação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga de método e o <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método.  
  
 O exemplo define um comparador alternativo para cadeias de caracteres chamado DinoCompare, que implementa o `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. O comparador funciona da seguinte maneira: primeiro, os termos de comparação são testados para `null`, e uma referência nula é tratada como menor que não null. Segundo, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais longa é considerada maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criada e preenchida com os nomes de cinco dinossauros herbivorous e três dinossauros carnivorous. Em cada um dos dois grupos, os nomes não estão em qualquer ordem de classificação específico. A lista é exibida, o intervalo de herbivores é classificado usando o comparador alternativo e a lista é exibida novamente.  
  
 O <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> sobrecarga do método é usada para pesquisar somente o intervalo de herbivores "Brachiosaurus". A cadeia de caracteres não for encontrada e o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor` -1 no Visual Basic) do número negativo retornado pelo <xref:System.Collections.Generic.List%601.BinarySearch%28System.Int32%2CSystem.Int32%2C%600%2CSystem.Collections.Generic.IComparer%7B%600%7D%29> método é usado como um índice para inserir a nova cadeia de caracteres.  
  
 [!code-cpp[List\`1_SortSearchComparerRange#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cpp/source.cpp#1)]
 [!code-csharp[List\`1_SortSearchComparerRange#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_SortSearchComparerRange/cs/source.cs#1)]
 [!code-vb[List\`1_SortSearchComparerRange#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_SortSearchComparerRange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="count" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="count" /> não especificam um intervalo válido no <see cref="T:System.Collections.Generic.List`1" />.  
  
 -ou-  
  
 A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, e o comparador padrão <see cref="P:System.Collections.Generic.Comparer`1.Default" /> não pode encontrar a implementação da interface genérica <see cref="T:System.IComparable`1" /> ou da interface <see cref="T:System.IComparable" /> para o tipo <paramref name="T" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Collections.Generic.ICollection`1" /> é somente leitura.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Collections.Generic.ICollection`1" /> for somente leitura; caso contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção que seja somente leitura não permite a adição, a remoção ou a modificação de elementos após a coleção ser criada.  
  
 Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera em uma coleção.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerator`1" /> que pode ser usado para iterar pela coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. Nesta posição, o <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriedade está definida. Por isso, você deve chamar o método <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.  
  
 O <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propriedade retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> é chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.Generic.IEnumerator%601.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> está indefinido. Não é possível definir <xref:System.Collections.Generic.IEnumerator%601.Current%2A> como o primeiro elemento da coleção novamente; você deve criar uma nova instância de enumerador em vez disso.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.  
  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.CopyTo">
      <MemberSignature Language="C#" Value="void ICollection.CopyTo (Array array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.ICollection.CopyTo(class System.Array array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.ICollection" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="arrayIndex">O índice de base zero em <c>matriz</c> no qual a cópia começa.</param>
        <summary>Copia os elementos do <see cref="T:System.Collections.ICollection" /> para um <see cref="T:System.Array" />, começando em um determinado índice <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Se o tipo da fonte de <xref:System.Collections.ICollection> não pode ser convertido automaticamente para o tipo de destino `array`, as implementações não genéricas de <xref:System.Collections.ICollection.CopyTo%2A?displayProperty=nameWithType> gerar <xref:System.InvalidCastException>, enquanto as implementações genéricas lançam <xref:System.ArgumentException>.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="arrayIndex" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> é multidimensional.  
  
 -ou-  
  
 O <paramref name="array" /> não tem indexação baseada em zero.  
  
 -ou-  
  
 O número de elementos na origem <see cref="T:System.Collections.ICollection" /> é maior do que o espaço disponível de <paramref name="arrayIndex" /> até o final do <paramref name="array" /> de destino.  
  
 -ou-  
  
 O tipo do <see cref="T:System.Collections.ICollection" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Collections.ICollection" /> é sincronizado (thread-safe).</summary>
        <value>
          <see langword="true" /> caso o acesso ao <see cref="T:System.Collections.ICollection" /> seja sincronizado (thread-safe); do contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  Em casos raros em que a enumeração afirma com acessos de gravação, você pode bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Retorna um objeto que pode ser usado para sincronizar o acesso a <xref:System.Collections.ICollection>. A sincronização é eficaz somente se todos os threads bloquear este objeto antes de acessar a coleção.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />.</summary>
        <value>Um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.ICollection" />.  Na implementação padrão da <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna a instância atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.  
  
 <xref:System.Collections.ICollection.SyncRoot%2A>Retorna um objeto que pode ser usado para sincronizar o acesso a <xref:System.Collections.ICollection>. A sincronização é eficaz somente se todos os threads bloquear este objeto antes de acessar a coleção. O código a seguir mostra o uso do <xref:System.Collections.ICollection.SyncRoot%2A> propriedade para c#, C++ e Visual Basic.  
  
```csharp  
ICollection ic = ...;  
lock (ic.SyncRoot)   
{  
    // Access the collection.  
}  
```  
  
```vb  
Dim ic As ICollection = ...  
SyncLock ic.SyncRoot  
    ' Access the collection.  
End SyncLock  
```  
  
```cpp#  
ICollection^ ic = ...;  
try   
{  
    Monitor::Enter(ic->SyncRoot);  
    // Access the collection.  
}  
finally   
{  
    Monitor::Exit(ic->SyncRoot);  
}  
```  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera em uma coleção.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> que pode ser usado para iterar pela coleção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.  Nesta posição, o <xref:System.Collections.IEnumerator.Current%2A> propriedade está definida. Por isso, você deve chamar o método <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 O <xref:System.Collections.IEnumerator.Current%2A> propriedade retorna o mesmo objeto até que o <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> é chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.  
  
 As implementações padrão de coleções no namespace <xref:System.Collections.Generic?displayProperty=nameWithType> não são sincronizadas.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Add(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O <see cref="T:System.Object" /> para adicionar ao <see cref="T:System.Collections.IList" />.</param>
        <summary>Adiciona um item ao <see cref="T:System.Collections.IList" />.</summary>
        <returns>A posição na qual o novo elemento foi inserido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Collections.Generic.List%601.Count%2A> é menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, esse método é uma operação de (1). Se a capacidade precisa ser aumentado para acomodar o novo elemento, esse método se torna um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O <see cref="T:System.Object" /> a ser localizado no <see cref="T:System.Collections.IList" />.</param>
        <summary>Determinará se o <see cref="T:System.Collections.IList" /> contiver um valor específico.</summary>
        <returns>
          <see langword="true" /> se <paramref name="item" /> for encontrado no <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#IndexOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a ser localizado no <see cref="T:System.Collections.IList" />.</param>
        <summary>Determina o índice de um item específico em <see cref="T:System.Collections.IList" />.</summary>
        <returns>O índice de <paramref name="item" /> se encontrado na lista; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">O índice de base zero no qual <c>item</c> devem ser inseridos.</param>
        <param name="item">O objeto a ser inserido no <see cref="T:System.Collections.IList" />.</param>
        <summary>Insere um item na <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `index` é igual ao número de itens no <xref:System.Collections.IList>, em seguida, `item` é acrescentado ao final.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">
          O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Collections.IList" /> tiver um valor fixo; caso contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção com um tamanho fixo não permite a adição ou a remoção de elementos após a coleção ser criada, mas permite a modificação de elementos existentes.  
  
 Uma coleção com um tamanho fixo é simplesmente uma coleção com um wrapper que impede a adição e a remoção de elementos; por isso, caso as alterações sejam feitas na coleção subjacente, inclusive a adição ou a remoção de elementos, a coleção de tamanho fixo reflete essas alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Collections.IList" /> é somente leitura.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Collections.IList" /> for somente leitura; caso contrário, <see langword="false" />.  Na implementação padrão de <see cref="T:System.Collections.Generic.List`1" />, essa propriedade sempre retorna <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma coleção que seja somente leitura não permite a adição, a remoção ou a modificação de elementos após a coleção ser criada.  
  
 Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.List`1.System#Collections#IList#Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice com base em zero do elemento a ser obtido ou definido.</param>
        <summary>Obtém ou define o elemento no índice especificado.</summary>
        <value>O elemento no índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A linguagem c# usa o [isso](~/docs/csharp/language-reference/keywords/this.md) palavra-chave para definir os indexadores em vez de implementar o <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> propriedade. Visual Basic implementa <xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A> como uma propriedade padrão, que fornece a mesma funcionalidade de indexação.  
  
 Recuperar o valor dessa propriedade é uma operação de (1); definindo a propriedade também é uma operação de (1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.ArgumentException">A propriedade é definida e <paramref name="value" /> é de um tipo que não é atribuível ao <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.System#Collections#IList#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">O objeto a remover do <see cref="T:System.Collections.IList" />.</param>
        <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade usando o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=nameWithType> para `T`, o tipo de valores na lista.  
  
 Esse método executa uma pesquisa linear; Portanto, esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          O <paramref name="item" /> é de um tipo que não é atribuível à <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.ToArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia os elementos do <see cref="T:System.Collections.Generic.List`1" /> em uma nova matriz.</summary>
        <returns>Uma matriz que contém cópias dos elementos do <see cref="T:System.Collections.Generic.List`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são copiados usando <xref:System.Array.Copy%2A?displayProperty=nameWithType>, que é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.ToArray%2A> método e outros métodos para o <xref:System.Collections.Generic.List%601> classe que atuam em intervalos. No final do exemplo, o <xref:System.Collections.Generic.List%601.GetRange%2A> método é usado para obter três itens na lista, começando com o local do índice 2. O <xref:System.Collections.Generic.List%601.ToArray%2A> método é chamado em resultante <xref:System.Collections.Generic.List%601>, criando uma matriz de três elementos. Os elementos da matriz são exibidos.  
  
 [!code-cpp[List\`1_Ranges#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Ranges/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Ranges#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Ranges/cs/source.cs#1)]
 [!code-vb[List\`1_Ranges#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Ranges/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrimExcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define a capacidade para o número real de elementos de <see cref="T:System.Collections.Generic.List`1" />, se esse número for menor que um valor limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para minimizar a memória da coleção sobrecarga se nenhum elemento novo será adicionado à coleção. O custo de realocar e copiar uma grande <xref:System.Collections.Generic.List%601> pode ser considerável, no entanto, para que o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método não fará nada se a lista estiver em mais de 90% da capacidade. Isso evita a incorrer em um custo de realocação grande para um ganho relativamente pequeno.  
  
> [!NOTE]
>  O limite atual de 90 por cento pode mudar em versões futuras.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
 Para redefinir um <xref:System.Collections.Generic.List%601> para seu estado inicial, chame o <xref:System.Collections.Generic.List%601.Clear%2A> método antes de chamar o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método. Cortar vazio <xref:System.Collections.Generic.List%601> define a capacidade do <xref:System.Collections.Generic.List%601> à capacidade padrão.  
  
 A capacidade também pode ser definida usando o <xref:System.Collections.Generic.List%601.Capacity%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como verificar a capacidade e a contagem de um <xref:System.Collections.Generic.List%601> que contém um objeto de negócios simples e ilustra o uso de <xref:System.Collections.Generic.List%601.TrimExcess%2A> método para remover uma capacidade extra.  
  
 [!code-csharp[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/cs/program.cs#1)]
 [!code-vb[System.Collections.Generic.List.CapacityCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.collections.generic.list.capacitycount/vb/module1.vb#1)]  
  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método. Várias propriedades e métodos para o <xref:System.Collections.Generic.List%601> classe são usados para adicionar, inserir e remover itens de uma lista de cadeias de caracteres. Em seguida, o <xref:System.Collections.Generic.List%601.TrimExcess%2A> método é usado para reduzir a capacidade de corresponder à contagem e o <xref:System.Collections.Generic.List%601.Capacity%2A> e <xref:System.Collections.Generic.List%601.Count%2A> propriedades são exibidas. Se a capacidade não utilizada tivesse sido menos de 10% da capacidade total, a lista seria não foram redimensionada. Por fim, o conteúdo da lista é desmarcado.  
  
 [!code-cpp[List\`1_Class#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_Class/cpp/source.cpp#1)]
 [!code-csharp[List\`1_Class#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_Class/cs/source.cs#1)]
 [!code-fsharp[List\`1_Class#1](~/samples/snippets/fsharp/VS_Snippets_CLR/List`1_Class/fs/listclass.fs#1)]
 [!code-vb[List\`1_Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_Class/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll">
      <MemberSignature Language="C#" Value="public bool TrueForAll (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrueForAll(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.List`1.TrueForAll(System.Predicate{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">O delegado <see cref="T:System.Predicate`1" /> que define as condições a serem verificadas nos elementos.</param>
        <summary>Determina se cada elemento do <see cref="T:System.Collections.Generic.List`1" /> corresponde às condições definidas pelo predicado especificado.</summary>
        <returns>
          <see langword="true" /> se cada elemento do <see cref="T:System.Collections.Generic.List`1" /> corresponder às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />. Se a lista não tiver elementos, o valor retornado será <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos da atual <xref:System.Collections.Generic.List%601> individualmente são passados para o <xref:System.Predicate%601> delegado e o processamento é interrompido quando o delegado retorna `false` para qualquer elemento. Os elementos são processados em ordem, e todas as chamadas são feitas em um único thread.  
  
 Esse método é um O (*n*) operação, onde * n * é <xref:System.Collections.Generic.List%601.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Collections.Generic.List%601.TrueForAll%2A> método e vários outros métodos que usam <xref:System.Predicate%601> delegado genérico.  
  
 Um <xref:System.Collections.Generic.List%601> de cadeias de caracteres é criado, que contém nomes de dinossauro 8, dois deles (em posições 1 e 5) terminam com "saurus". O exemplo também define um método de predicado de pesquisa denominado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booleano um valor que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Collections.Generic.List%601.TrueForAll%2A> método percorre a lista desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` método retornará `false`.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 [!code-cpp[List\`1_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/List`1_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[List\`1_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/List`1_FindEtAl/cs/source.cs#1)]
 [!code-vb[List\`1_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/List`1_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
