<Type Name="XmlMessageFormatter" FullName="System.Messaging.XmlMessageFormatter">
  <TypeSignature Language="C#" Value="public class XmlMessageFormatter : ICloneable, System.Messaging.IMessageFormatter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlMessageFormatter extends System.Object implements class System.ICloneable, class System.Messaging.IMessageFormatter" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.XmlMessageFormatter" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Messaging.IMessageFormatter</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Serializa e desserializa objetos para ou do corpo de uma mensagem, usando o formato XML baseado na definição de esquema XSD.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.XmlMessageFormatter> é o formatador padrão que uma instância de <xref:System.Messaging.MessageQueue> usa para serializar mensagens gravadas na fila. Quando você cria uma instância de <xref:System.Messaging.MessageQueue>, uma instância do <xref:System.Messaging.XmlMessageFormatter> é criado e associado a <xref:System.Messaging.MessageQueue>. Você pode especificar um formatador diferente criá-lo no seu código e atribuindo-a para o <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade do seu <xref:System.Messaging.MessageQueue>.  
  
 Padrão de uma fila <xref:System.Messaging.XmlMessageFormatter> instância pode ser usada para gravar na fila, mas ele não pode ser usado para ler da fila até que você definir o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriedade no formatador. Você pode definir um ou ambos os valores na instância de formatador padrão, ou você pode criar uma nova instância do formatador e defina os valores automaticamente, passando-os como argumentos em apropriada <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> construtor.  
  
 Ao especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> em vez de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, a existência de tipo é verificada em tempo de compilação em vez de hora de leitura, reduzindo a possibilidade de erro. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>requer que cada entrada totalmente qualificados, especificando seu nome de assembly. Além disso, ao trabalhar com várias versões simultâneas, o número de versão deve ser anexado ao nome de tipo do destino.  
  
 O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informam ao formatador que esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar de acordo com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Somente uma das duas propriedades precisa ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual propriedade a ser usada é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos de matriz para qualquer uma das propriedades, uma exceção será lançada quando a mensagem é lida.  
  
 O <xref:System.Messaging.XmlMessageFormatter> é um componente crucial do menos rígida de mensagens baseadas em XML. A utilitário XSD.exe usa que o formato XML é usado para gerar o esquema XML, como quando você usa o utilitário para serializar uma classe usada por seu aplicativo. A classe deve ter um construtor padrão.  
  
 O formato é usado novamente no processo de reverter quando o utilitário gera uma classe com base no esquema distribuir para descrever os dados de classe. O uso do utilitário e o esquema XML gera permite que você evite redistributing.dll arquivos toda vez que você recompilar uma classe após a implementação de sua classe ter sido alterado. Como o esquema não for alterado no cliente ou servidor, outras alterações em ambos os lados não afetará os outros.  
  
   
  
## Examples  
 O exemplo de código a seguir inclui três partes de código: um componente de servidor, uma classe order e código do cliente. A classe de ordem pode ser usada pelo utilitário XSD.exe para gerar o esquema que o servidor as reconheça em mensagens de entrada. O esquema é um arquivo XML formatado que descreve a forma"" da classe. Esse esquema, em seguida, pode ser usado no lado do cliente para gerar uma classe de ordem específicas do cliente que compartilha o mesmo esquema de classe de servidor.  
  
 O exemplo de código a seguir representa um componente de servidor que recebe pedidos por meio de uma fila de mensagens. O corpo da mensagem deve ser um objeto de ordem cuja esquema coincide com a classe de Order.cs abaixo. O processo de servidor ou aplicativo desserializa a ordem.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source.cpp#1)]
 [!code-csharp[Classic XmlMessageFormatter Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source.cs#1)]
 [!code-vb[Classic XmlMessageFormatter Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir representa a classe de ordem que fornece um esquema para que o aplicativo no servidor recebe e desserializa objetos ordem.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic XmlMessageFormatter Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source2.cs#2)]
 [!code-vb[Classic XmlMessageFormatter Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source2.vb#2)]  
  
 Qualquer aplicativo cliente que interage com o aplicativo no servidor deve enviar mensagens para o servidor por serializar informações em uma classe definida localmente de ordem no corpo da mensagem. A classe definida localmente de ordem deve ter o mesmo esquema que a classe de servidor definido ordem na qual o aplicativo no servidor tentarão desserializar o corpo da mensagem. O utilitário XSD.exe permite que o Gerenciador do aplicativo no servidor de criar e distribuir o esquema que o cliente deve usar para serializar mensagens enviadas para o servidor.  
  
 Quando o Gerenciador do aplicativo cliente recebe o esquema para a classe de ordem, o utilitário de XSD.exe será usado novamente para gerar uma classe de ordem específicas do cliente do esquema. Essa classe é usada no exemplo de código cliente abaixo, a classe de ordem do servidor não é (o utilitário XSD.exe faz com que a classe de esquema gerado ter o mesmo nome que a classe original). Essa nova classe de ordem é usado para serializar a ordem em que o corpo da mensagem.  
  
 O exemplo de código a seguir é o lado do cliente de processamento, usado para serializar um pedido e enviar as informações associadas com a ordem em uma fila. O código associa informações de Item, a quantidade e o endereço de elementos do esquema que foram gerados para a classe Order.cs pelo utilitário XSD.exe. Um pedido for enviado para a fila de pedidos no computador local.  
  
 [!code-cpp[Classic XmlMessageFormatter Example#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CPP/source3.cpp#3)]
 [!code-csharp[Classic XmlMessageFormatter Example#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/CS/source3.cs#3)]
 [!code-vb[Classic XmlMessageFormatter Example#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic XmlMessageFormatter Example/VB/source3.vb#3)]  
  
 Depois que o esquema é gerado da classe de ordem no servidor, você pode modificar a classe. A menos que as alterações de esquema, você não precisa redistribuir o esquema. Depois de distributed o esquema e gerado de uma classe de ordem do lado do cliente, essa classe de cliente também pode ser modificada independentemente da classe de ordem do servidor, desde que o próprio esquema não é modificado. As duas classes tornam-se menos rígidas.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância do <see cref="T:System.Messaging.XmlMessageFormatter" /> conjunto de tipos de classe sem destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de construtor é usada com mais frequência durante a gravação da fila, como tipos de destino não são necessários durante a gravação.  
  
 Para ler uma mensagem de uma fila usando uma instância de <xref:System.Messaging.XmlMessageFormatter> criado usando este construtor, você deve definir o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades para o formatador Saiba quais tipos de tentativa de desserializar.  
  
 Quando você cria um novo <xref:System.Messaging.MessageQueue>, um padrão <xref:System.Messaging.XmlMessageFormatter> instância é criada, sem o conjunto de tipos de destino. Assim como acontece com um formatador criado usando este construtor, você deve definir tipos de destino para essa instância de formatador se você quiser ler da fila.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (string[] targetTypeNames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string[] targetTypeNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.String[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypeNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="targetTypeNames">Uma matriz do tipo <see cref="T:System.String" /> que especifica o conjunto dos possíveis tipos que serão desserializados pelo formatador da mensagem fornecida. Esses valores devem ser totalmente qualificados, por exemplo, “MyNamespace.MyOrders, MyOrdersAssemblyName”.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.XmlMessageFormatter" />, definindo os tipos de destino passados como uma matriz de valores de cadeia de caracteres (totalmente qualificados).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os construtores com parâmetros de tipo de destino são usados com mais frequência durante a leitura da fila. Ao escrever, não é necessário especificar os tipos de destino.  
  
 Esta sobrecarga do <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> conjuntos de construtor o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> propriedade para os valores da matriz passado por meio de `targetTypeNames` parâmetro. Definir essa propriedade permite um <xref:System.Messaging.MessageQueue> usando esse <xref:System.Messaging.XmlMessageFormatter> instância para ler as mensagens que contêm objetos de tipos.  
  
 Tanto o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informam ao formatador que esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar de acordo com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Somente uma das duas propriedades precisa ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual usar é específico para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos de matriz para qualquer uma das propriedades, uma exceção será lançada em tempo de leitura.  
  
   
  
## Examples  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="targetTypeNames" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlMessageFormatter (Type[] targetTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Type[] targetTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.#ctor(System.Type[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="targetTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="targetTypes">Uma matriz do tipo <see cref="T:System.Type" /> que especifica o conjunto dos possíveis tipos que serão desserializados pelo formatador da mensagem fornecida.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Messaging.XmlMessageFormatter" /> classe, definindo tipos de destino transmitidos como uma matriz de tipos de objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os construtores com parâmetros de tipo de destino são usados com mais frequência durante a leitura da fila. Ao escrever, não é necessário especificar os tipos de destino.  
  
 Esta sobrecarga do <xref:System.Messaging.XmlMessageFormatter.%23ctor%2A> conjuntos de construtor o <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedade para os valores da matriz passado por meio de `targetTypes` parâmetro. Definir essa propriedade permite um <xref:System.Messaging.MessageQueue> usando esse <xref:System.Messaging.XmlMessageFormatter> instância para ler mensagens que contém objetos dos tipos dados.  
  
 Tanto o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informam ao formatador que esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar de acordo com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Somente uma das duas propriedades precisa ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual usar é específico para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos de matriz para qualquer uma das propriedades, uma exceção será lançada em tempo de leitura.  
  
 Ao especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> em vez de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, a existência de tipo é verificada em tempo de compilação em vez de hora de leitura, reduzindo a possibilidade de erro. <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>requer que cada entrada totalmente qualificados, especificando seu nome de assembly. Além disso, ao trabalhar com várias versões simultâneas, o número de versão deve ser anexado ao nome de tipo do destino.  
  
 Ao usar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, você pode adicionar cada objeto (por exemplo, `MyClass`) à lista de forma demonstrada pelo código c# a seguir.  
  
```  
TargetTypes = new Type[]{typeof(MyClass)}  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="targetTypes" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanRead(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.CanRead(System.Messaging.Message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">O <see cref="T:System.Messaging.Message" /> para inspecionar.</param>
        <summary>Determina se o formatador pode desserializar a mensagem.</summary>
        <returns>
          <see langword="true" />Se o formatador XML pode desserializar a mensagem. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> é chamado, o formatador tenta determinar se o conteúdo da mensagem é algo pode desserializar. O formatador só pode desserializar a mensagem se o tipo no corpo da mensagem tem o mesmo esquema como um dos tipos na matriz representada pelo <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades. <xref:System.Messaging.XmlMessageFormatter.CanRead%2A>Retorna `false` nas duas seguintes circunstâncias:  
  
-   A mensagem não foi formatada usando o <xref:System.Messaging.XmlMessageFormatter>.  
  
-   O esquema do corpo da mensagem não está entre aqueles listados em ambos os <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedade.  
  
 O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informam ao formatador que tipos de objetos deve ser capaz de desserializar. Se qualquer tipo está ausente na lista, ainda não foi encontrado dentro da mensagem, <xref:System.Messaging.XmlMessageFormatter.CanRead%2A> retorna `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nem o <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nem <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> propriedade foi definida.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="message" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma instância do <see cref="T:System.Messaging.XmlMessageFormatter" /> classe cuja leitura/gravação (os conjuntos de tipos de destino) de propriedades são os mesmos atual <see cref="T:System.Messaging.XmlMessageFormatter" /> instância.</summary>
        <returns>Um objeto cujas propriedades são idênticas desse <see cref="T:System.Messaging.XmlMessageFormatter" /> instância, mas cujos metadados não especifique-o para ser uma instância da classe de formatador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma cópia do formatador e inicializa a todas as suas propriedades para os valores deste <xref:System.Messaging.XmlMessageFormatter> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public object Read (System.Messaging.Message message);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Read(class System.Messaging.Message message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Read(System.Messaging.Message)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
      </Parameters>
      <Docs>
        <param name="message">O <see cref="T:System.Messaging.Message" />, em formato XML, a ser desserializado.</param>
        <summary>Lê o conteúdo da mensagem determinada e cria um objeto que contém a mensagem desserializada.</summary>
        <returns>A mensagem desserializada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informam ao formatador que esquemas para tentar corresponder ao desserializar uma mensagem. Uma dessas propriedades deve ser definida antes da mensagem pode ser desserializada.  
  
 A instância serializada no corpo da mensagem deve estar de acordo com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Os tipos de destino não precisam ser especificado para gravar na fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nem o <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> nem <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> propriedade foi definida.  
  
 -ou-  
  
 A instância serializada no corpo da mensagem não é compatível com qualquer um dos esquemas representados pelos tipos de no <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> e <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> propriedades.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="message" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TargetTypeNames">
      <MemberSignature Language="C#" Value="public string[] TargetTypeNames { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] TargetTypeNames" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypeNames")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica o conjunto dos possíveis tipos que serão desserializados pelo formatador da mensagem fornecida.</summary>
        <value>Uma matriz do tipo <see cref="T:System.String" /> que especifica os tipos de objetos a ser desserializado do corpo da mensagem ao ler a mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informam ao formatador que esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar de acordo com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Somente uma das duas propriedades precisa ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual propriedade a ser usada é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos de matriz para qualquer uma das propriedades, uma exceção será lançada quando a mensagem é lida.  
  
 <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>requer que cada entrada totalmente qualificados, especificando seu nome de assembly. Além disso, ao trabalhar com várias versões simultâneas, o número de versão deve ser anexado ao nome de tipo do destino.  
  
 Os tipos de destino somente são necessárias durante a leitura da fila. O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades não precisam ser configurado para gravar na fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A propriedade <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypeNames" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TargetTypes">
      <MemberSignature Language="C#" Value="public Type[] TargetTypes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] TargetTypes" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.XmlMessageFormatter.TargetTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("XmlMsgTargetTypes")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica o conjunto dos possíveis tipos que serão desserializados pelo formatador da mensagem fornecida.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Type" /> que especifica os tipos de objetos a ser desserializado do corpo da mensagem ao ler a mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tanto o <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades informam ao formatador que esquemas para tentar corresponder ao desserializar uma mensagem. Isso permite que o formatador interpretar o corpo da mensagem.  
  
 A instância serializada no corpo da mensagem deve estar de acordo com um dos esquemas representados na matriz de tipo. Quando você ler a mensagem usando o <xref:System.Messaging.MessageQueue.Receive%2A> método, o método cria um objeto do tipo que corresponde ao esquema identificado e lê o corpo da mensagem para ele.  
  
 Somente uma das duas propriedades precisa ser definida durante a leitura da fila, mas você pode definir ambos. O conjunto de tipos é o conjunto combinado de duas propriedades. A decisão de qual propriedade a ser usada é específica para seu aplicativo. Se o corpo da mensagem contém um tipo cujo esquema não corresponde a nenhum dos tipos de matriz para qualquer uma das propriedades, uma exceção será lançada quando a mensagem é lida.  
  
 Os tipos de destino somente são necessárias durante a leitura da fila. O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> e <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedades não precisam ser configurado para gravar na fila.  
  
 Ao especificar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> em vez de <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A>, a existência de tipo é verificada em tempo de compilação em vez de hora de leitura, reduzindo a possibilidade de erro.  
  
 Ao usar <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A>, você pode adicionar cada objeto (por exemplo, `MyClass`) à lista de forma demonstrada pelo código do c# `TargetTypes = new Type[]{typeof(MyClass), typeof (MyOtherClass)};`.  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A propriedade <see cref="P:System.Messaging.XmlMessageFormatter.TargetTypes" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (System.Messaging.Message message, object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(class System.Messaging.Message message, object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.XmlMessageFormatter.Write(System.Messaging.Message,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.Messaging.Message" />
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="message">O <see cref="T:System.Messaging.Message" /> cujo <see cref="P:System.Messaging.Message.Body" /> propriedade conterá o objeto serializado.</param>
        <param name="obj">O <see cref="T:System.Object" /> a ser serializado no corpo da mensagem.</param>
        <summary>Serializa um objeto no corpo da mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os tipos de destino não precisam ser especificados para gravar na fila como eles devem ser durante a leitura. O <xref:System.Messaging.XmlMessageFormatter.TargetTypeNames%2A> ou <xref:System.Messaging.XmlMessageFormatter.TargetTypes%2A> propriedade é usada pelo formatador apenas ao desserializar uma mensagem.  
  
 O <xref:System.Messaging.XmlMessageFormatter> usa o <xref:System.Xml.Serialization.XmlSerializer> classe, que define o que pode ser serializado. Somente campos públicos e as propriedades públicas podem ser serializadas. Estruturas, estruturas com matrizes e matrizes de estruturas são todos serializável, desde que eles não usam o estilo de codificação com o protocolo SOAP.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="message" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="obj" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
