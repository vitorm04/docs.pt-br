<Type Name="MessageQueue" FullName="System.Messaging.MessageQueue">
  <TypeSignature Language="C#" Value="public class MessageQueue : System.ComponentModel.Component, System.Collections.IEnumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageQueue extends System.ComponentModel.Component implements class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageQueue" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("ReceiveCompleted")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.Messaging.MessageQueueInstaller))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageQueueConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece acesso a uma fila de um servidor do Enfileiramento de Mensagens.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tecnologia de enfileiramento de mensagens permite que os aplicativos executados em momentos diferentes para se comunicar por redes heterogêneas e sistemas podem estar temporariamente offline. Aplicativos enviam, receber, ou inspecionar (ler sem remover) mensagens das filas. O Message Queuing é um componente opcional do [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] e Windows NT e deve ser instalado separadamente.  
  
 O <xref:System.Messaging.MessageQueue> classe é um wrapper em torno de enfileiramento de mensagens. Há várias versões do enfileiramento de mensagens e usando o <xref:System.Messaging.MessageQueue> classe pode resultar em comportamento um pouco diferente, dependendo do sistema operacional você está usando. Para obter informações sobre os recursos específicos de cada versão do enfileiramento de mensagens, consulte o tópico "O que há de novo no serviço de enfileiramento" no SDK da plataforma no MSDN.  
  
 O <xref:System.Messaging.MessageQueue> classe fornece uma referência a uma fila do serviço de enfileiramento de mensagens. Você pode especificar um caminho no <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor para se conectar a um recurso existente, ou você pode criar uma nova fila no servidor. Antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, você deve associar a nova instância do <xref:System.Messaging.MessageQueue> classe com uma fila existente. Nesse ponto, você pode manipular as propriedades de fila como <xref:System.Messaging.MessageQueue.Category%2A> e <xref:System.Messaging.MessageQueue.Label%2A>.  
  
 <xref:System.Messaging.MessageQueue>dá suporte a dois tipos de recuperação de mensagens: síncronas e assíncronas. Métodos síncronos, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, fazer com que o thread de processo de um intervalo de tempo especificado para uma nova mensagem chegar na fila de espera. Os métodos assíncronos, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A>, permitir que as tarefas do aplicativo principal continuar em um thread separado, até que uma mensagem chega na fila. Esses métodos funcionam com objetos de retorno de chamada e do estado para transmitir informações entre threads.  
  
 Quando você cria uma nova instância do <xref:System.Messaging.MessageQueue> classe, você não está criando uma nova fila do serviço de enfileiramento de mensagens. Em vez disso, você pode usar o <xref:System.Messaging.MessageQueue.Create%28System.String%29>, <xref:System.Messaging.MessageQueue.Delete%28System.String%29>, e <xref:System.Messaging.MessageQueue.Purge%2A> métodos para gerenciar as filas no servidor.  
  
 Ao contrário de <xref:System.Messaging.MessageQueue.Purge%2A>, <xref:System.Messaging.MessageQueue.Create%28System.String%29> e <xref:System.Messaging.MessageQueue.Delete%28System.String%29> são `static` membros, portanto você pode chamá-las sem criar uma nova instância do <xref:System.Messaging.MessageQueue> classe.  
  
 Você pode definir o <xref:System.Messaging.MessageQueue> do objeto <xref:System.Messaging.MessageQueue.Path%2A> propriedade com um dos três nomes: o nome amigável, o <xref:System.Messaging.MessageQueue.FormatName%2A>, ou o <xref:System.Messaging.MessageQueue.Label%2A>. O nome amigável, que é definido como a fila <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades, é <xref:System.Messaging.MessageQueue.MachineName%2A> \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para uma fila pública, e <xref:System.Messaging.MessageQueue.MachineName%2A> \\ `Private$` \\ <xref:System.Messaging.MessageQueue.QueueName%2A> para uma fila particular. O <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade permite o acesso offline para filas de mensagens. Por fim, você pode usar a fila <xref:System.Messaging.MessageQueue.Label%2A> propriedade para definir a fila <xref:System.Messaging.MessageQueue.Path%2A>.  
  
 Para obter uma lista de valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>, consulte o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor.  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 O exemplo de código a seguir envia uma mensagem para uma fila e recebe uma mensagem de uma fila, usando uma classe específica de aplicativo chamada `Order`.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Somente o <see cref="M:System.Messaging.MessageQueue.GetAllMessages" /> método é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />. Depois que o construtor padrão inicializa a nova instância, você deve definir a propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> da instância antes de usar a instância.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma nova instância do <xref:System.Messaging.MessageQueue> classe imediatamente não estiver associado a uma fila no servidor de enfileiramento de mensagens. Antes de usar essa instância, você deve ser conectar a uma fila existente do serviço de enfileiramento de mensagens, definindo o <xref:System.Messaging.MessageQueue.Path%2A> propriedade. Como alternativa, você pode definir o <xref:System.Messaging.MessageQueue> referência para o <xref:System.Messaging.MessageQueue.Create%28System.String%29> valor de retorno do método, criando uma nova fila do serviço de enfileiramento de mensagens.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe. Todos os valores de filtro estão definidos como `true`.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue>.  
  
 [!code-csharp[MessageQueue#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" /> que referencia a fila de Enfileiramento de Mensagens no caminho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja associar o novo <xref:System.Messaging.MessageQueue> instância para uma determinada fila Enfileiramento de mensagens, para o qual você sabe o caminho, nome de formato ou rótulo. Se você deseja conceder acesso exclusivo para o primeiro aplicativo que faz referência a fila, você deve definir o <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriedade `true` ou use o construtor que passa um parâmetro de restrição de acesso de leitura.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens. Para criar uma nova fila no enfileiramento de mensagens, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe do `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila, conforme mostrado na tabela a seguir.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:`[ *nome do formato* ]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Rotular|`Label:`[ *label* ]|`Label:`TheLabel|  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, não a sintaxe do nome do caminho para o construtor. Caso contrário, uma exceção é lançada porque o controlador de domínio primário não está disponível para resolver o caminho para o nome de formato.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>. Esses valores se baseiam nas propriedades da fila do serviço de enfileiramento de mensagens com o caminho especificado pelo `path` parâmetro.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se a configuração de nível de privacidade do enfileiramento de mensagens da fila é "Body"; Caso contrário, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|O valor da propriedade de nome de computador do enfileiramento de mensagens da fila.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|`false`|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se a configuração de diário do objeto enfileiramento de mensagens está habilitada; Caso contrário, `false`.|  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não é válida, possivelmente porque não foi definida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> para conceder acesso de leitura exclusivo ao primeiro aplicativo que acessar a fila; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" /> que referencia a fila do serviço de enfileiramento de mensagens no caminho especificado e com a restrição de acesso de leitura especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja associar o novo <xref:System.Messaging.MessageQueue> para uma determinada fila Enfileiramento de mensagens, para o qual você sabe o caminho, nome de formato ou rótulo. Se você deseja conceder acesso exclusivo para o primeiro aplicativo que faz referência a fila, defina o `sharedModeDenyReceive` parâmetro `true`. Caso contrário, defina `sharedModeDenyReceive` para `false` ou use o construtor que tem apenas um `path` parâmetro.  
  
 Configuração `sharedModeDenyReceive` para `true` afeta todos os objetos que acessam o enfileiramento de mensagens, incluindo outros aplicativos. Os efeitos do parâmetro não estão restritos a esse aplicativo.  
  
 O <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor cria uma nova instância do <xref:System.Messaging.MessageQueue> classe; ele não cria uma nova fila do serviço de enfileiramento de mensagens. Para criar uma nova fila no enfileiramento de mensagens, use <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe do `path` parâmetro depende do tipo de fila.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Como alternativa, você pode usar o nome de formato ou rótulo de uma fila do serviço de enfileiramento de mensagens para descrever o caminho da fila.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:`[ *nome do formato* ]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112<br /><br /> `FormatName:DIRECT=SPX:` `NetworkNumber`; `HostNumber`\\`QueueName`<br /><br /> `FormatName:DIRECT=TCP:` `IPAddress`\\`QueueName`<br /><br /> `FormatName:DIRECT=OS:` `MachineName`\\`QueueName`|  
|Rotular|`Label:`[ *label* ]|`Label:`TheLabel|  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, em vez da sintaxe de nome amigável. Caso contrário, uma exceção é lançada porque o controlador de domínio primário (no qual o Active Directory reside) não está disponível para resolver o caminho para o nome de formato.  
  
 Se um <xref:System.Messaging.MessageQueue> abre uma fila com o `sharedModeDenyReceive` parâmetro definido como `true`, qualquer <xref:System.Messaging.MessageQueue> que gera de tenta ler da fila subsequentemente uma <xref:System.Messaging.MessageQueueException> devido a uma violação de compartilhamento. Um <xref:System.Messaging.MessageQueueException> também é gerada se um <xref:System.Messaging.MessageQueue> tenta acessar a fila em modo exclusivo, enquanto outras <xref:System.Messaging.MessageQueue> já tem acesso de não-exclusivo para a fila.  
  
 A tabela a seguir mostra os valores de propriedade inicial para uma instância do <xref:System.Messaging.MessageQueue>. Esses valores se baseiam nas propriedades da fila de enfileiramento de mensagens, com o caminho especificado pelo `path` parâmetro.  
  
|Propriedade|Valor inicial|  
|--------------|-------------------|  
|<xref:System.Messaging.MessageQueue.Authenticate%2A>|`false`.|  
|<xref:System.Messaging.MessageQueue.BasePriority%2A>|0.|  
|<xref:System.Messaging.MessageQueue.Category%2A>|<xref:System.Guid.Empty>.|  
|<xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.DefaultPropertiesToSend> classe.|  
|<xref:System.Messaging.MessageQueue.EncryptionRequired%2A>|`true`, se a configuração de nível de privacidade do enfileiramento de mensagens da fila é "Body"; Caso contrário, `false`.|  
|<xref:System.Messaging.MessageQueue.Formatter%2A>|<xref:System.Messaging.XmlMessageFormatter>.|  
|<xref:System.Messaging.MessageQueue.Label%2A>|<xref:System.String.Empty>.|  
|<xref:System.Messaging.MessageQueue.MachineName%2A>|O valor da propriedade de nome de computador do enfileiramento de mensagens da fila.|  
|<xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>|<xref:System.Messaging.MessageQueue.InfiniteQueueSize>.|  
|<xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A>|Os valores definidos pelo construtor padrão da <xref:System.Messaging.MessagePropertyFilter> classe.|  
|<xref:System.Messaging.MessageQueue.Path%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.QueueName%2A>|<xref:System.String.Empty>, se não for definido pelo construtor.|  
|<xref:System.Messaging.MessageQueue.DenySharedReceive%2A>|O valor de `sharedModeDenyReceive` parâmetro.|  
|<xref:System.Messaging.MessageQueue.UseJournalQueue%2A>|`true`, se a configuração de diário do objeto enfileiramento de mensagens está habilitada; Caso contrário, `false`.|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue> com acesso exclusivo, define seu caminho e envia uma mensagem à fila.  
  
 [!code-cpp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CPP/mqctor_denysharedreceive.cpp#1)]
 [!code-csharp[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/CS/mqctor_denysharedreceive.cs#1)]
 [!code-vb[MessageQueue.ctor_PathSharedModeDenyReceive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ctor_PathSharedModeDenyReceive/VB/mqctor_denysharedreceive.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não é válida, possivelmente porque não foi definida.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="accessMode">Um dos valores de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> para conceder acesso de leitura exclusivo ao primeiro aplicativo que acessar a fila; caso contrário, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" />para criar e usar um cache de conexão; Caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir cria um novo <xref:System.Messaging.MessageQueue> com acesso de leitura exclusivo e conexão em cache habilitada.  
  
 [!code-cpp[MessageQueue4#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue4/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue4#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue4/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MessageQueue (string path, bool sharedModeDenyReceive, bool enableCache, System.Messaging.QueueAccessMode accessMode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool sharedModeDenyReceive, bool enableCache, valuetype System.Messaging.QueueAccessMode accessMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.#ctor(System.String,System.Boolean,System.Boolean,System.Messaging.QueueAccessMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="sharedModeDenyReceive" Type="System.Boolean" />
        <Parameter Name="enableCache" Type="System.Boolean" />
        <Parameter Name="accessMode" Type="System.Messaging.QueueAccessMode" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />, que pode ser “.” no computador local.</param>
        <param name="sharedModeDenyReceive">
          <see langword="true" /> para conceder acesso de leitura exclusivo ao primeiro aplicativo que acessar a fila; caso contrário, <see langword="false" />.</param>
        <param name="enableCache">
          <see langword="true" />para criar e usar um cache de conexão; Caso contrário, <see langword="false" />.</param>
        <param name="accessMode">Um dos valores de <see cref="T:System.Messaging.QueueAccessMode" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AccessMode">
      <MemberSignature Language="C#" Value="public System.Messaging.QueueAccessMode AccessMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.QueueAccessMode AccessMode" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.AccessMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.QueueAccessMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica o modo de acesso da fila.</summary>
        <value>Um dos valores de <see cref="T:System.Messaging.QueueAccessMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O modo de acesso padrão para uma fila é `QueueAccessMode.SendAndReceive`, a menos que você especifique o contrário ao chamar o construtor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Authenticate">
      <MemberSignature Language="C#" Value="public bool Authenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Authenticate" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Authenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Authenticate")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a fila aceita apenas mensagens autenticadas.</summary>
        <value>
          <see langword="true" /> se a fila aceita apenas mensagens autenticadas; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Autenticação de mensagem fornece uma maneira para garantir a integridade da mensagem e verificar que enviou a mensagem. Para solicitar a autenticação, o aplicativo de envio define o nível de autenticação da mensagem.  
  
 Quando você define <xref:System.Messaging.MessageQueue.Authenticate%2A> para `true`, você está restringindo acesso à fila no servidor, não apenas a esta <xref:System.Messaging.MessageQueue> instância. Todos os clientes que trabalham com a mesma fila do serviço de enfileiramento de mensagens serão afetados.  
  
 Uma fila que aceita apenas mensagens autenticadas rejeitará uma mensagem não autenticada. Para solicitar a notificação de rejeição de mensagem, um aplicativo de envio pode definir o <xref:System.Messaging.Message.AcknowledgeType%2A> propriedade da mensagem. Como não existe nenhuma outra indicação de rejeição de mensagem, o aplicativo de envio pode perder a mensagem, a menos que você solicita que ele seja enviada para a fila de mensagens mortas.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Authenticate%2A> propriedade.  
  
 [!code-csharp[MessageQueue#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public short BasePriority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_BasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a prioridade base que enfileiramento de mensagens usa para rotear mensagens de uma fila pública pela rede.</summary>
        <value>A prioridade base única para todas as mensagens enviadas à fila (pública). O padrão é zero (0).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Prioridade básica de uma fila de mensagens Especifica como uma mensagem voltados à fila é tratada como trafegam através da rede. Você pode definir o <xref:System.Messaging.MessageQueue.BasePriority%2A> propriedade confere uma prioridade maior ou menor para todas as mensagens enviadas para a fila especificada daqueles enviados para outras filas. A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 Uma fila de mensagens <xref:System.Messaging.MessageQueue.BasePriority%2A> não está relacionado ao <xref:System.Messaging.Message.Priority%2A> propriedade de uma mensagem, que especifica a ordem na qual uma mensagem de entrada é colocada na fila.  
  
 <xref:System.Messaging.MessageQueue.BasePriority%2A>aplica-se somente para as filas públicas cujo caminho especificado usando o nome de formato. A prioridade base de uma fila particular é sempre zero (0).  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.BasePriority%2A> propriedade.  
  
 [!code-csharp[MessageQueue#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A prioridade base foi definida como um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia uma operação de espiada assíncrona que não tem um tempo limite. A operação não é concluída até que uma mensagem se torna disponível na fila.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> quando uma mensagem se torna disponível na fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, criar um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A>inicia uma operação assíncrona peek; o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando o resultado usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação assíncrona inspecionar na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o exemplo exibe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação assíncrona de pico.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <summary>Inicia uma operação assíncrona de pico que tem um tempo limite especificado. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, criar um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A>inicia uma operação assíncrona peek; o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando o resultado usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginPeek%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lançará uma exceção.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação assíncrona de pico, usando o caminho da fila ". \myQueue". Ele cria um manipulador de eventos, `MyPeekCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A>é chamado com um tempo limite de um minuto para iniciar a operação assíncrona de pico. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado ou o tempo limite expirar, a mensagem é recuperada, se houver, e seu corpo é gravado para a tela. Em seguida, <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado novamente para iniciar uma nova operação de pico assíncrona com o tempo limite da mesma.  
  
 [!code-cpp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CPP/mqbeginpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/CS/mqbeginpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_timeout/VB/mqbeginpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <summary>Inicia uma operação assíncrona de pico que tem um tempo limite especificado e um objeto de estado especificado, que fornece informações associadas ao longo do tempo de vida da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginPeek%2A> para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Use essa sobrecarga para associar informações com a operação que será preservada ao longo do tempo de vida da operação. O manipulador de eventos pode acessar essas informações examinando o <xref:System.IAsyncResult.AsyncState%2A> propriedade o <xref:System.IAsyncResult> que está associado com a operação.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginPeek%2A>, criar um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginPeek%2A>inicia uma operação assíncrona peek; o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.PeekCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> ou recuperando o resultado usando o <xref:System.Messaging.PeekCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite e um objeto de estado. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.PeekCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lançará uma exceção.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir. Para ilustrar esse cenário, consulte a seção de exemplo.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação assíncrona de pico, usando o caminho da fila ". \myQueue". Ele cria um manipulador de eventos, `MyPeekCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos. <xref:System.Messaging.MessageQueue.BeginPeek%2A>é chamado, com um tempo limite de um minuto. Cada chamada para <xref:System.Messaging.MessageQueue.BeginPeek%2A> tem um inteiro exclusivo associado que identifica a operação específica. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado ou o tempo limite expirou, a mensagem, se houver, foi recuperada e seu corpo e o identificador de inteiro de operação específico são gravados na tela. Em seguida, <xref:System.Messaging.MessageQueue.BeginPeek%2A> é chamado novamente para iniciar uma nova operação de pico assíncrona com o mesmo limite e o número inteiro associado da operação acabou de concluir.  
  
 [!code-cpp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CPP/mqbeginpeek_timeoutstateobject.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/CS/mqbeginpeek_timeoutstateobject.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_TimeSpanStateObject#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_TimeSpanStateObject/VB/mqbeginpeek_timeoutstateobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que receberá a notificação da conclusão da operação assíncrona.</param>
        <summary>Inicia uma operação assíncrona de pico que tem um tempo limite especificado e um objeto de estado especificado, que fornece informações associadas ao longo do tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.PeekCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>também é gerado se já existir uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma operação assíncrona de pico. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: um valor de tempo limite de dez segundos; um inteiro exclusivo que identifica a mensagem específica; e uma nova instância da <xref:System.AsyncCallback> que identifica o manipulador de eventos, `MyPeekCompleted`. Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o manipulador de eventos exibe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginPeek#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginPeek/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginPeek#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginPeek/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginPeek">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginPeek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginPeek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginPeek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="action">Um dos valores de <see cref="T:System.Messaging.PeekAction" />. Indica se a mensagem atual ou a próxima na fila de mensagens deve ser espiada.</param>
        <param name="state">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que recebe a notificação de conclusão de operação assíncrona.</param>
        <summary>Inicia uma operação assíncrona de pico que tem um tempo limite especificado e que usa um cursor específico, uma ação de pico especificado e um objeto de estado especificado. O objeto de estado fornece informações associadas ao longo do tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado. O <xref:System.Messaging.MessageQueue.PeekCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginPeek%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.PeekCompleted>também é gerado se já existir uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.BeginPeek%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginPeek%2A> é assíncrona, você pode chamá-lo para inspecionar a fila sem bloquear o thread atual de execução. Para inspecionar sincronamente a fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>Retorna um <xref:System.IAsyncResult> que identifica a operação assíncrona iniciada pelo método. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, use o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor diferente de <see langword="PeekAction.Current" /> ou <see langword="PeekAction.Next" /> foi especificado para o parâmetro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia uma operação de recebimento assíncrona que não tem um tempo limite. A operação não é concluída até que uma mensagem se torna disponível na fila.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> quando uma mensagem foi removida da fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A>inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir encadeia solicitações assíncronas. Ele assume que há uma fila no computador local chamado "myQueue". O `Main` função inicia a operação assíncrona que é manipulada pelo `MyReceiveCompleted` rotina. `MyReceiveCompleted`processa a mensagem atual e inicia um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 O exemplo de código a seguir enfileira solicitações assíncronas. A chamada para <xref:System.Messaging.MessageQueue.BeginReceive%2A> usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> em seu valor de retorno. O `Main` rotina aguarda até que todas as operações assíncronas sejam concluídas antes de sair.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_wh.cpp#2)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_wh.cs#2)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_wh.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <summary>Inicia uma operação de recebimento assíncrona que tem um tempo limite especificado. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A>inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o evento de conclusão é gerado, mas será lançada uma exceção ao chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lançará uma exceção.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O exemplo de código cria um manipulador de eventos, `MyReceiveCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> representante do manipulador de eventos. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%29>, passando um valor de tempo limite de dez segundos. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginReceive1#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive1/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive1#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive1/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente porque ele representa um número negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <summary>Inicia uma operação de recebimento assíncrona que tem um tempo limite e um objeto de estado especificados, que fornece informações associadas durante o tempo de vida da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processamento assíncrono, você usa <xref:System.Messaging.MessageQueue.BeginReceive%2A> para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> eventos quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Use essa sobrecarga para associar informações com a operação que será preservada ao longo do tempo de vida da operação. O manipulador de eventos pode detectar essa informação examinando o <xref:System.IAsyncResult.AsyncState%2A> propriedade o <xref:System.IAsyncResult> que está associado com a operação.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A>inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 Essa sobrecarga Especifica um tempo limite e um objeto de estado. Se o intervalo especificado pelo `timeout` parâmetro expira, esse componente gera o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento. Como não existe nenhuma mensagem, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lançará uma exceção.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O exemplo de código cria um manipulador de eventos, `MyReceiveCompleted`e anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> representante do manipulador de eventos. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%29>, passando um valor de tempo limite de dez segundos e um inteiro exclusivo que identifica essa mensagem específica. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginReceive2#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive2/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive2#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive2/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, object stateObject, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, object stateObject, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="stateObject" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="stateObject">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que receberá a notificação da conclusão da operação assíncrona.</param>
        <summary>Inicia uma operação de recebimento assíncrona que tem um tempo limite e um objeto de estado especificados, que fornece informações associadas durante o tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.ReceiveCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A>inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, você usa o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma assíncrona operação de recebimento. O envia de exemplo de código uma mensagem para uma fila de mensagens local, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%28System.TimeSpan%2CSystem.Object%2CSystem.AsyncCallback%29>, passando: um valor de tempo limite de dez segundos; um inteiro exclusivo que identifica a mensagem específica; e uma nova instância da <xref:System.AsyncCallback> que identifica o manipulador de eventos, `MyReceiveCompleted`. Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o manipulador de eventos recebe a mensagem e grava o corpo da mensagem e o identificador inteiro da mensagem para a tela.  
  
 [!code-cpp[MessageQueueBeginReceive3#0](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueueBeginReceive3/cpp/class1.cpp#0)]
 [!code-csharp[MessageQueueBeginReceive3#0](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueueBeginReceive3/CS/class1.cs#0)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (TimeSpan timeout, System.Messaging.Cursor cursor, object state, AsyncCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, object state, class System.AsyncCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.BeginReceive(System.TimeSpan,System.Messaging.Cursor,System.Object,System.AsyncCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o intervalo de tempo para aguardar uma mensagem se tornar disponível.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="state">Um objeto de estado, especificado pelo aplicativo, que contém informações associadas à operação assíncrona.</param>
        <param name="callback">O <see cref="T:System.AsyncCallback" /> que recebe a notificação de conclusão de operação assíncrona.</param>
        <summary>Inicia uma recepção assíncrona operação que tem um tempo limite especificado e usa um cursor especificado e um objeto de estado especificado. O objeto de estado fornece informações associadas ao longo do tempo de vida da operação. Essa sobrecarga recebe uma notificação, por meio de um retorno de chamada, da identidade do manipulador de eventos da operação. A operação não é concluída até que uma mensagem se torna disponível na fila ou que ocorra o tempo limite.</summary>
        <returns>O <see cref="T:System.IAsyncResult" /> que identifica a solicitação assíncrona postada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa essa sobrecarga, o retorno de chamada especificado no parâmetro de retorno de chamada é invocado diretamente quando uma mensagem se torna disponível na fila ou quando o intervalo de tempo especificado tiver expirado; o <xref:System.Messaging.MessageQueue.ReceiveCompleted> não é gerado. As outras sobrecargas de <xref:System.Messaging.MessageQueue.BeginReceive%2A> contam com este componente para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento.  
  
 <xref:System.Messaging.MessageQueue.ReceiveCompleted>também é gerado se já existir uma mensagem na fila.  
  
 Para usar <xref:System.Messaging.MessageQueue.BeginReceive%2A>, crie um manipulador de eventos que processa os resultados da operação assíncrona e associá-lo com o delegado do evento. <xref:System.Messaging.MessageQueue.BeginReceive%2A>inicia uma assíncrona recebe operação. o <xref:System.Messaging.MessageQueue> é notificado por meio do aumento do <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento, quando uma mensagem chega na fila. O <xref:System.Messaging.MessageQueue> pode acessar a mensagem chamando <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> ou recuperar o resultado usando o <xref:System.Messaging.ReceiveCompletedEventArgs>.  
  
 O <xref:System.Messaging.MessageQueue.BeginReceive%2A> método retorna imediatamente, mas não é possível concluir a operação assíncrona até que o manipulador de eventos é chamado.  
  
 Porque <xref:System.Messaging.MessageQueue.BeginReceive%2A> é assíncrona, você pode chamá-lo para receber uma mensagem da fila sem bloquear o thread atual de execução. Para modo síncrono receber uma mensagem, use o <xref:System.Messaging.MessageQueue.Receive%2A> método.  
  
 Quando uma operação assíncrona for concluída, você pode chamar <xref:System.Messaging.MessageQueue.BeginPeek%2A> ou <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente no manipulador de eventos para manter receber notificações.  
  
 O <xref:System.IAsyncResult> que <xref:System.Messaging.MessageQueue.BeginReceive%2A> retorna identifica a operação assíncrona que o método foi iniciado. Você pode usar isso <xref:System.IAsyncResult> durante o tempo de vida da operação, embora você geralmente não usá-lo até <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> é chamado. No entanto, se você iniciar várias operações assíncronas, você pode colocar seus <xref:System.IAsyncResult> valores em uma matriz e especificar se deseja esperar que todas as operações ou qualquer operação seja concluída. Nesse caso, use o <xref:System.IAsyncResult.AsyncWaitHandle%2A> propriedade o <xref:System.IAsyncResult> para identificar a operação concluída.  
  
 O objeto de estado associa informações de estado com a operação. Por exemplo, se você chamar <xref:System.Messaging.MessageQueue.BeginReceive%2A> várias vezes para iniciar várias operações, você pode identificar cada operação por meio de um objeto de estado separado que você definir.  
  
 Você também pode usar o objeto de estado para transmitir informações entre os threads de processo. Se um thread é iniciado, mas o retorno de chamada está em um thread diferente em um cenário assíncrono, o objeto de estado é empacotado e passado novamente juntamente com informações do evento.  
  
 Não use a chamada assíncrona <xref:System.Messaging.MessageQueue.BeginReceive%2A> com transações. Se você quiser executar uma operação assíncrona transacional, chame <xref:System.Messaging.MessageQueue.BeginPeek%2A>e colocar a transação e (síncrono) <xref:System.Messaging.MessageQueue.Receive%2A> método no manipulador de eventos que você criar para a operação de pico. O manipulador de eventos pode conter funcionalidade, como mostra o código c# a seguir.  
  
```csharp  
myMessageQueue.BeginTransaction();  
 myMessageQueue.Receive();  
 myMessageQueue.CommitTransaction();  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanRead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Messaging.MessageQueue" /> pode ser lido.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Messaging.MessageQueue" /> existe e o aplicativo pode lê-lo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanRead%2A>Indica se o aplicativo é capaz de inspecionar ou receber mensagens da fila. Se <xref:System.Messaging.MessageQueue.CanRead%2A> é `true`, o <xref:System.Messaging.MessageQueue> pode receber ou inspecionar mensagens da fila. Caso contrário, ele não pode.  
  
 <xref:System.Messaging.MessageQueue.CanRead%2A>é `false` se uma fila já está aberta com acesso de leitura exclusivo (ou se ele está aberto com acesso não-exclusivo e isso <xref:System.Messaging.MessageQueue> solicita acesso exclusivo), ou se o aplicativo não tem direitos suficientes para acessá-lo. Se seu aplicativo tentar ler de uma fila quando <xref:System.Messaging.MessageQueue.CanRead%2A> é `false`, o acesso foi negado.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CanRead%2A> propriedade.  
  
 [!code-csharp[MessageQueue#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CanWrite")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Messaging.MessageQueue" /> pode ser gravado.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Messaging.MessageQueue" /> existe e o aplicativo pode gravar nela; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>Indica se o aplicativo é capaz de enviar mensagens à fila. Se <xref:System.Messaging.MessageQueue.CanWrite%2A> é `true`, o <xref:System.Messaging.MessageQueue> pode enviar mensagens à fila. Caso contrário, ele não pode.  
  
 <xref:System.Messaging.MessageQueue.CanWrite%2A>é `false` se uma fila já está aberta com acesso de gravação exclusivo (ou se ele está aberto com acesso não-exclusivo e isso <xref:System.Messaging.MessageQueue> solicita acesso exclusivo), ou se o aplicativo não tem direitos suficientes para acessá-lo. Se seu aplicativo tentar gravar em uma fila quando <xref:System.Messaging.MessageQueue.CanWrite%2A> é `false`, o acesso foi negado.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CanWrite%2A> propriedade.  
  
 [!code-csharp[MessageQueue#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Category">
      <MemberSignature Language="C#" Value="public Guid Category { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Category" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Category" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Category")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a categoria da fila.</summary>
        <value>Um <see cref="T:System.Guid" /> que representa a categoria de fila (enfileiramento tipo identificador), que permite que os aplicativos categorizem suas filas. O padrão é <see langword="Guid.empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A categoria de fila permite que um aplicativo categorizem suas filas. Por exemplo, você pode colocar todas as filas de cobrança em uma categoria e todas as filas de pedido em outro.  
  
 O <xref:System.Messaging.MessageQueue.Category%2A> propriedade fornece acesso para a propriedade de ID do tipo de serviço de enfileiramento de mensagem (que é leitura/gravação), acessíveis por meio de **propriedades da fila de** caixa de diálogo no Console de gerenciamento do computador. Você pode definir uma nova categoria. Embora você possa usar <xref:System.Guid.NewGuid%2A> para criar um valor de categoria é exclusivo em todas as <xref:System.Guid> valores, essa ação é desnecessária. O valor da categoria deve ser distinto somente de outras categorias, não de todos os outros <xref:System.Guid> valores. Por exemplo, você pode atribuir {00000000-0000-0000-0000-000000000001} como o <xref:System.Messaging.MessageQueue.Category%2A> para um conjunto de filas e {00000000-0000-0000-0000-000000000002} como a <xref:System.Messaging.MessageQueue.Category%2A> para outro conjunto.  
  
 Não é necessário definir o <xref:System.Messaging.MessageQueue.Category%2A>. O valor pode ser `null`.  
  
 A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Category%2A> propriedade.  
  
 [!code-csharp[MessageQueue#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A categoria de fila foi definida como um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClearConnectionCache">
      <MemberSignature Language="C#" Value="public static void ClearConnectionCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ClearConnectionCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ClearConnectionCache" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o cache de conexão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, os nomes de formato armazenados no cache são removidos e identificadores abertos e armazenados em cache são fechados.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir chama <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>.  
  
 [!code-csharp[MessageQueue#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos alocados pelo <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Close%2A>libera todos os recursos associados com um <xref:System.Messaging.MessageQueue>, incluindo recursos compartilhados se apropriado. O sistema novamente adquire estes recursos automaticamente se eles ainda estão disponíveis, por exemplo quando você chamar o <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método, como o código c# a seguir.  
  
```csharp  
myMessageQueue.Send("Text 1.");  
myMessageQueue.Close();  
myMessageQueue.Send("Text 2."); //Resources are re-acquired.  
```  
  
 Quando você chama <xref:System.Messaging.MessageQueue.Close%2A>, todos os <xref:System.Messaging.MessageQueue> propriedades que acessem diretamente a fila do serviço de enfileiramento de mensagens estão limpo. O <xref:System.Messaging.MessageQueue.Path%2A>, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>, <xref:System.Messaging.MessageQueue.Formatter%2A>, e <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> todas permanecem como estavam.  
  
 <xref:System.Messaging.MessageQueue.Close%2A>nem sempre Libere a leitura e gravação identificadores em uma fila, porque eles podem ser compartilhados. Você pode executar qualquer uma das etapas a seguir para garantir que <xref:System.Messaging.MessageQueue.Close%2A> libera os identificadores de leitura e gravação a uma fila:  
  
-   Criar o <xref:System.Messaging.MessageQueue> com acesso exclusivo. Para fazer isso, chame o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%29> ou <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> construtor e defina o `sharedModeDenyReceive` parâmetro `true`.  
  
-   Criar o <xref:System.Messaging.MessageQueue> com conexão caching desabilitado. Para fazer isso, chame o <xref:System.Messaging.MessageQueue.%23ctor%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> construtor e defina o `enableConnectionCache` parâmetro `false`.  
  
-   Desabilite o cache de conexão. Para fazer isso, defina o <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriedade `false`.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Close%2A> para uma fila antes de excluir a fila no servidor de enfileiramento de mensagens. Caso contrário, as mensagens enviadas para a fila podem gerar exceções ou aparecem na fila de mensagens mortas.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir fecha uma fila do serviço de enfileiramento de mensagens.  
  
 [!code-cpp[MessageQueue.Close#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Close/CPP/mqclose.cpp#1)]
 [!code-csharp[MessageQueue.Close#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Close/CS/mqclose.cs#1)]
 [!code-vb[MessageQueue.Close#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Close/VB/mqclose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho da fila a ser criado.</param>
        <summary>Cria uma fila não transacional do serviço de enfileiramento de mensagens no caminho especificado.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueue" /> que representa a nova fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar uma fila de enfileiramento de mensagens não transacionais.  
  
 Para criar uma nova instância do <xref:System.Messaging.MessageQueue> classe em seu aplicativo e associá-lo a uma fila existente, use o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor. Para criar uma nova fila no enfileiramento de mensagens, chame <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe para a `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para o computador local. Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir cria filas públicas e privadas. Envia uma mensagem para filas selecionadas.  
  
 [!code-cpp[MessageQueue.Create_path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_path/CPP/mqcreate.cpp#1)]
 [!code-csharp[MessageQueue.Create_path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_path/CS/mqcreate.cs#1)]
 [!code-vb[MessageQueue.Create_path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_path/VB/mqcreate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Já existe uma fila no caminho especificado.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue Create (string path, bool transactional);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue Create(string path, bool transactional) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Create(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="transactional" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O caminho da fila a ser criado.</param>
        <param name="transactional">
          <see langword="true" /> para criar uma fila transacional; <see langword="false" /> para criar uma fila não transacional.</param>
        <summary>Cria uma fila transacional ou não transacional do Enfileiramento de Mensagens no caminho especificado.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueue" /> que representa a nova fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa sobrecarga para criar uma fila transacional no enfileiramento de mensagens. Você pode criar uma fila não transacional, definindo o `transactional` parâmetro `false` ou chamando a outra sobrecarga do <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 Para criar uma nova instância do <xref:System.Messaging.MessageQueue> classe em seu aplicativo e associá-lo a uma fila existente, use o <xref:System.Messaging.MessageQueue.%23ctor%2A> construtor. Para criar uma nova fila no enfileiramento de mensagens, chame <xref:System.Messaging.MessageQueue.Create%28System.String%29>.  
  
 A sintaxe para a `path` parâmetro depende do tipo de fila-referências, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Use "." para o computador local. Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir cria filas transacionais públicas e privadas. Envia uma mensagem para filas selecionadas.  
  
 [!code-cpp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CPP/mqcreate_transactional.cpp#1)]
 [!code-csharp[MessageQueue.Create_PathTransactional#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/CS/mqcreate_transactional.cs#1)]
 [!code-vb[MessageQueue.Create_PathTransactional#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Create_PathTransactional/VB/mqcreate_transactional.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Já existe uma fila no caminho especificado.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCursor">
      <MemberSignature Language="C#" Value="public System.Messaging.Cursor CreateCursor ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Cursor CreateCursor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.CreateCursor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Cursor</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo <see cref="T:System.Messaging.Cursor" /> para a fila de mensagens atual.</summary>
        <returns>Um novo <see cref="T:System.Messaging.Cursor" /> para a fila de mensagens atual. Esse cursor é usado para manter um local específico na fila durante a leitura de mensagens da fila.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTime">
      <MemberSignature Language="C#" Value="public DateTime CreateTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime CreateTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.CreateTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_CreateTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a hora e a data em que a fila foi criada no enfileiramento de mensagens.</summary>
        <value>Um <see cref="T:System.DateTime" /> que representa a data e hora em que a fila foi criada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.CreateTime%2A>refere-se à fila no servidor de enfileiramento de mensagens, não o <xref:System.Messaging.MessageQueue> instância.  
  
 Se a fila existe, esta propriedade representa a hora em que a fila foi criada, ajustados à hora local do servidor no qual a fila existe.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.CreateTime%2A> propriedade.  
  
 [!code-csharp[MessageQueue#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultPropertiesToSend">
      <MemberSignature Language="C#" Value="public System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.DefaultPropertiesToSend DefaultPropertiesToSend" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DefaultPropertiesToSend" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DefaultPropertiesToSend")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.DefaultPropertiesToSend</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define os valores da propriedade da mensagem a serem usados por padrão quando o aplicativo envia mensagens para a fila.</summary>
        <value>Um <see cref="T:System.Messaging.DefaultPropertiesToSend" /> que contém os valores da propriedade da mensagem Enfileiramento de Mensagens usados quando o aplicativo envia objetos diferentes de instâncias <see cref="T:System.Messaging.Message" /> para a fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você envia qualquer objeto que não é do tipo <xref:System.Messaging.Message> na fila, o <xref:System.Messaging.MessageQueue> insere o objeto em uma mensagem do serviço de enfileiramento de mensagens. Nesse momento, o <xref:System.Messaging.MessageQueue> aplica-se a mensagem os valores de propriedade que você especificar o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade. Por outro lado, se você enviar um <xref:System.Messaging.Message> para a fila, essas propriedades já foram especificadas para a instância em si, portanto <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> é ignorado para o <xref:System.Messaging.Message>.  
  
 Embora você defina as propriedades por meio de <xref:System.Messaging.MessageQueue> objeto, o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> se refere às propriedades das mensagens que são enviadas à fila, e não a própria fila.  
  
 Os valores padrão para as propriedades são mostrados na tabela a seguir.  
  
|Propriedade|Valor padrão|  
|--------------|-------------------|  
|<xref:System.Messaging.DefaultPropertiesToSend.AcknowledgeType%2A>|`AcknowledgeType.None`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AdministrationQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.AppSpecific%2A>|Zero (0)|  
|<xref:System.Messaging.DefaultPropertiesToSend.AttachSenderId%2A>|`true`|  
|<xref:System.Messaging.DefaultPropertiesToSend.EncryptionAlgorithm%2A>|`EncryptionAlgorithm.RC2`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Extension%2A>|Uma matriz de bytes de comprimento zero|  
|<xref:System.Messaging.DefaultPropertiesToSend.HashAlgorithm%2A>|`HashAlgorithm.MD5`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Label%2A>|Cadeia de caracteres vazia ("")|  
|<xref:System.Messaging.DefaultPropertiesToSend.Priority%2A>|`MessagePriority.Normal`|  
|<xref:System.Messaging.DefaultPropertiesToSend.Recoverable%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.ResponseQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToBeReceived%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TimeToReachQueue%2A>|`Message.InfiniteTimeout`|  
|<xref:System.Messaging.DefaultPropertiesToSend.TransactionStatusQueue%2A>|`null`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.DefaultPropertiesToSend.UseTracing%2A>|`false`|  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir usa a prioridade de uma mensagem para determinar as propriedades padrão para enviar a mensagem.  
  
 [!code-cpp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CPP/mqdefaultpropertiestosend.cpp#1)]
 [!code-csharp[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/CS/mqdefaultpropertiestosend.cs#1)]
 [!code-vb[MessageQueue.DefaultPropertiesToSend#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.DefaultPropertiesToSend/VB/mqdefaultpropertiestosend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Não foi possível definir as propriedades padrão para a fila, possivelmente porque uma das propriedades não é válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O local da fila a ser excluída.</param>
        <summary>Exclui uma fila em um servidor de Enfileiramento de Mensagens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sintaxe para a `path` parâmetro depende do tipo de fila.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
  
 Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila.  
  
|Referência|Sintaxe|  
|---------------|------------|  
|Nome do formato|FormatName: [ *nome do formato* ]|  
|Rotular|Rótulo: [ *rótulo* ]|  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exclui uma fila do enfileiramento de mensagens, se ele existir.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A sintaxe do parâmetro <paramref name="path" /> não é válida.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="DenySharedReceive">
      <MemberSignature Language="C#" Value="public bool DenySharedReceive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DenySharedReceive" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.DenySharedReceive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_DenySharedReceive")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se este <see cref="T:System.Messaging.MessageQueue" /> tem acesso exclusivo para receber mensagens da fila do serviço de enfileiramento de mensagens.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Messaging.MessageQueue" /> tem direitos exclusivos para receber mensagens da fila; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.DenySharedReceive%2A>Especifica o modo compartilhado da fila referenciada por este <xref:System.Messaging.MessageQueue>. Definir <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> para `true` para indicar que somente este <xref:System.Messaging.MessageQueue> devem ter acesso ao inspecionar ou receber mensagens da fila com especificado <xref:System.Messaging.MessageQueue.Path%2A>. Se houver outro <xref:System.Messaging.MessageQueue> ou outro aplicativo está associado com o mesmo recurso de fila, essa instância ou aplicativo não será capaz de inspecionar ou receber mensagens, mas ainda pode enviá-los.  
  
 Se <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> é `false`, a fila está disponível para vários aplicativos para enviar, inspecionar ou receber mensagens.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.DenySharedReceive%2A> propriedade.  
  
 [!code-csharp[MessageQueue#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Descarta os recursos (exceto a memória) usados pelo <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> quando tiver terminado de usar o <xref:System.Messaging.MessageQueue>. O <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> método deixa o <xref:System.Messaging.MessageQueue> em um estado inutilizável. Depois de chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29>, você deve liberar todas as referências para o <xref:System.Messaging.MessageQueue> para a memória estava ocupando pode ser recuperada pela coleta de lixo.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Dispose%28System.Boolean%29> antes de liberar sua última referência para o <xref:System.Messaging.MessageQueue>. Caso contrário, os recursos de <xref:System.Messaging.MessageQueue> está usando não será liberada até que as chamadas de coleta de lixo a <xref:System.Messaging.MessageQueue> destruidor do objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableConnectionCache">
      <MemberSignature Language="C#" Value="public static bool EnableConnectionCache { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool EnableConnectionCache" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EnableConnectionCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se um cache de conexões será mantido pelo aplicativo.</summary>
        <value>
          <see langword="true" />para criar e usar um cache de conexão; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um cache de conexão é uma lista de referências a estruturas que contêm a leitura ou gravação identificadores para filas. Quando <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> é `true`, o <xref:System.Messaging.MessageQueue> usa identificadores do cache de cada vez que você chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, <xref:System.Messaging.MessageQueue.Peek%2A>, ou <xref:System.Messaging.MessageQueue.Receive%2A>, em vez de identificadores abertos de novo. Isso pode melhorar o desempenho. Usar um cache de conexão também protege o <xref:System.Messaging.MessageQueue> de alterações na topologia da rede.  
  
 Se você criar uma nova conexão a uma fila quando o cache de conexão está cheio, o <xref:System.Messaging.MessageQueue> substitui a estrutura menos acessada recentemente com a nova conexão. Você pode limpar o cache inteiramente chamando <xref:System.Messaging.MessageQueue.ClearConnectionCache%2A>, por exemplo, se os nomes de formato de filas que você está trabalhando com foram alterados para que o anterior de leitura e gravação identificadores não são mais válidos.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.EnableConnectionCache%2A> propriedade.  
  
 [!code-csharp[MessageQueue#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncryptionRequired">
      <MemberSignature Language="C#" Value="public System.Messaging.EncryptionRequired EncryptionRequired { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Messaging.EncryptionRequired EncryptionRequired" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.EncryptionRequired" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_EncryptionRequired")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.EncryptionRequired</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a fila aceita apenas não-particular (não criptografado) mensagens.</summary>
        <value>Um dos valores de <see cref="T:System.Messaging.EncryptionRequired" />. O padrão é <see langword="None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você especificar que a criptografia é necessária para as mensagens enviadas para uma fila, somente os corpos de mensagens são criptografados. Os outros membros (por exemplo, o <xref:System.Messaging.Message.Label%2A> e <xref:System.Messaging.Message.SenderId%2A> propriedades) não pode ser criptografada.  
  
 A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 Criptografar uma mensagem faz com que a mensagem privada. Você pode especificar o requisito de criptografia da fila seja `None`, `Body`, ou `Optional` definindo o <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriedade adequadamente. O <xref:System.Messaging.Message.UseEncryption%2A> configuração da mensagem deve corresponder ao requisito de criptografia da fila. Se a mensagem não está criptografada, mas a fila especifica `Body`, ou se a mensagem for criptografada, mas a fila especifica `None`, a mensagem será rejeitada pela fila. Se o aplicativo de envio solicita uma mensagem de confirmação negativa nesse caso, o enfileiramento de mensagens indica rejeição da mensagem para o aplicativo de envio. Se o <xref:System.Messaging.Message.UseDeadLetterQueue%2A> é de propriedade `true`, uma mensagem de falha de criptografia é enviada para a fila de mensagens mortas. Caso contrário, a mensagem será perdida.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.EncryptionRequired%2A> propriedade.  
  
 [!code-csharp[MessageQueue#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndPeek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndPeek (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndPeek(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndPeek(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O <see cref="T:System.IAsyncResult" /> que identifica a operação de espiada assíncrona a concluir e da qual recuperar um resultado final.</param>
        <summary>Conclui a operação de espiada assíncrona especificada.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> associado com a operação assíncrona concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> conclui a operação foi iniciada pelo <xref:System.Messaging.MessageQueue.BeginPeek%2A> chamar. Para fazer isso, <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> exibe a mensagem.  
  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>pode especificar um tempo limite, o que faz com que o <xref:System.Messaging.MessageQueue.PeekCompleted> evento a ser gerado se o tempo limite ocorre antes que será exibida uma mensagem na fila. Quando um tempo limite ocorre sem uma mensagem que chega na fila, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29> lança uma exceção.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>é usado para ler a mensagem que causou o <xref:System.Messaging.MessageQueue.PeekCompleted> evento ser gerado.  
  
 Se você quiser continuar a assincronamente inspecionar mensagens, você pode chamar novamente <xref:System.Messaging.MessageQueue.BeginPeek%2A> depois de chamar <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação assíncrona inspecionar na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o exemplo exibe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação assíncrona de pico.  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="asyncResult" /> não é válida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message EndReceive (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message EndReceive(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">O <see cref="T:System.IAsyncResult" /> que identifica a operação de recebimento assíncrono a concluir e da qual recuperar o resultado final.</param>
        <summary>Conclui a operação de recebimento assíncrono especificada.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> associado com a operação assíncrona concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> conclui a operação foi iniciada pelo <xref:System.Messaging.MessageQueue.BeginReceive%2A> chamar. Para fazer isso, <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> recebe a mensagem.  
  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>pode especificar um tempo limite, o que faz com que o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento a ser gerado se o tempo limite ocorre antes que será exibida uma mensagem na fila. Quando um tempo limite ocorre sem uma mensagem que chega na fila, uma chamada subsequente para <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29> lança uma exceção.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>é usado para ler (remover da fila) a mensagem que causou o <xref:System.Messaging.MessageQueue.ReceiveCompleted> evento ser gerado.  
  
 Se você quiser continuar a mensagens de forma assíncrona, você pode chamar novamente <xref:System.Messaging.MessageQueue.BeginReceive%2A> depois de chamar <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir encadeia solicitações assíncronas. Ele assume que há uma fila no computador local chamado "myQueue". O `Main` função inicia a operação assíncrona que é manipulada pelo `MyReceiveCompleted` rotina. `MyReceiveCompleted`processa a mensagem atual e inicia um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CPP/mqbeginreceive_noparms_mre.cpp#1)]
 [!code-csharp[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/CS/mqbeginreceive_noparms_mre.cs#1)]
 [!code-vb[MessageQueue.BeginReceive_noparms_combined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginReceive_noparms_combined/VB/mqbeginreceive_noparms_mre.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="asyncResult" /> não é válida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">A localização da fila a ser encontrada.</param>
        <summary>Determina se existe uma fila de Enfileiramento de Mensagens no caminho especificado.</summary>
        <returns>
          <see langword="true" /> se existir uma fila com o caminho especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método determina se existe uma fila do serviço de enfileiramento de mensagens em um caminho especificado. Nenhum método existe para determinar se existe uma fila com um nome de formato especificado. Para obter mais informações sobre a sintaxe de nome de formato e outras formas de sintaxe de caminho, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.)  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>é uma operação cara. Usá-lo somente quando é necessário no aplicativo.  
  
> [!NOTE]
>  O <xref:System.Messaging.MessageQueue.Exists%28System.String%29> método não oferece suporte a <xref:System.Messaging.MessageQueue.FormatName%2A> prefixo.  
  
 A sintaxe para a `path` parâmetro depende do tipo de fila, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
  
 <xref:System.Messaging.MessageQueue.Exists%28System.String%29>não pode ser chamado para verificar a existência de uma fila particular remota.  
  
 Para obter a sintaxe mais, consulte o <xref:System.Messaging.MessageQueue.Path%2A> propriedade.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila.  
  
|Referência|Sintaxe|  
|---------------|------------|  
|Rotular|Rótulo: [ `label` ]|  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir verifica se uma fila do serviço de enfileiramento de mensagens existe e, em seguida, exclui-lo.  
  
 [!code-cpp[MessageQueue.ExistsDelete#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CPP/mqexistsdelete.cpp#1)]
 [!code-csharp[MessageQueue.ExistsDelete#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ExistsDelete/CS/mqexistsdelete.cs#1)]
 [!code-vb[MessageQueue.ExistsDelete#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ExistsDelete/VB/mqexistsdelete.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A sintaxe <paramref name="path" /> não é válida.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Um erro ao acessar um método de Enfileiramento de Mensagens.  
  
 -ou-  
  
 O método <see cref="M:System.Messaging.MessageQueue.Exists(System.String)" /> está sendo chamado em uma fila particular remota</exception>
        <exception cref="T:System.InvalidOperationException">O aplicativo usou a sintaxe de nome de formato ao verificar a existência da fila.</exception>
      </Docs>
    </Member>
    <Member MemberName="FormatName">
      <MemberSignature Language="C#" Value="public string FormatName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FormatName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.FormatName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_FormatName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome de fila exclusivo que o Enfileiramento de Mensagens gerou no momento da criação da fila.</summary>
        <value>O nome da fila, que é exclusivo na rede.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade contém o nome do formato da fila. O Message Queuing usa o nome de formato para identificar qual fila para abrir e como acessá-la. Ao contrário da maioria das características da fila, o nome de formato não é uma propriedade de fila do enfileiramento de aplicativos, portanto você não pode acessá-lo por meio da ferramenta de gerenciamento do serviço de enfileiramento de mensagens. O nome de formato é simplesmente um nome exclusivo para a fila, que o enfileiramento de mensagens gera quando ele cria a fila ou que o aplicativo gera mais tarde.  
  
 Se você especificar um caminho usando a sintaxe de nome de caminho (como `myComputer\myQueue`) em vez de usar a sintaxe de nome de formato ao ler ou gravar na fila, o controlador de domínio primário (que usa o Active Directory) converte o <xref:System.Messaging.MessageQueue.Path%2A> em associado <xref:System.Messaging.MessageQueue.FormatName%2A> antes de acessar a fila. Se seu aplicativo estiver trabalhando offline, você deve usar a sintaxe de nome de formato; Caso contrário, o controlador de domínio primário não estará disponível para executar a conversão de caminho.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.FormatName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">O <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definido.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Formatter">
      <MemberSignature Language="C#" Value="public System.Messaging.IMessageFormatter Formatter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.IMessageFormatter Formatter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Formatter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Messaging.Design.MessageFormatterConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Formatter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.IMessageFormatter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o formatador usado para serializar ou desserializar um objeto do corpo de uma mensagem lida ou gravada na fila.</summary>
        <value>O <see cref="T:System.Messaging.IMessageFormatter" /> que produz um fluxo a ser gravado ou lido do corpo da mensagem. O padrão é <see cref="T:System.Messaging.XmlMessageFormatter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade contém uma instância de um objeto formatador, que transforma mensagens quando o aplicativo lê ou grava na fila.  
  
 Quando o aplicativo envia a mensagem para a fila, o formatador serializa o objeto em um fluxo e o insere no corpo da mensagem. Ao ler de uma fila, o formatador desserializa os dados da mensagem para o <xref:System.Messaging.Message.Body%2A> propriedade de um <xref:System.Messaging.Message>.  
  
 O <xref:System.Messaging.XmlMessageFormatter> é flexível, portanto, não é necessário ter o mesmo objeto de tipo no remetente e destinatário, ao usar esse formato. O <xref:System.Messaging.ActiveXMessageFormatter> e <xref:System.Messaging.BinaryMessageFormatter> serializar os dados em representação binária. O <xref:System.Messaging.ActiveXMessageFormatter> é usado ao enviar ou receber componentes COM.  
  
 <xref:System.Messaging.BinaryMessageFormatter>e <xref:System.Messaging.ActiveXMessageFormatter> fornecer a taxa de transferência mais rápida que o <xref:System.Messaging.XmlMessageFormatter>. O <xref:System.Messaging.ActiveXMessageFormatter> permite a interoperabilidade com aplicativos de enfileiramento de mensagens do Visual Basic 6.0.  
  
 Quando o aplicativo envia mensagens na fila, o <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> só se aplica a essas mensagens que usam as propriedades de mensagem padrão, <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>. Se você enviar um <xref:System.Messaging.Message> para a fila, enfileiramento de mensagens usa o formatador definido no <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade para serializar o corpo em vez disso.  
  
 O <xref:System.Messaging.MessageQueue> classe sempre usará um <xref:System.Messaging.Message> para receber ou espiar uma mensagem da fila. A mensagem é desserializada usando o <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.BinaryMessageFormatter>.  
  
 [!code-cpp[MessagingBinaryFormatter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessagingBinaryFormatter/CPP/message_binaryformatter.cpp#1)]
 [!code-csharp[MessagingBinaryFormatter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessagingBinaryFormatter/CS/message_binaryformatter.cs#1)]
 [!code-vb[MessagingBinaryFormatter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessagingBinaryFormatter/VB/message_binaryformatter.vb#1)]  
  
 O exemplo de código a seguir demonstra a formatação de um corpo de mensagem usando <xref:System.Messaging.XmlMessageFormatter>.  
  
 [!code-cpp[Message.Body#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Body/CPP/message_sendreceive.cpp#1)]
 [!code-csharp[Message.Body#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Body/CS/message_sendreceive.cs#1)]
 [!code-vb[Message.Body#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Body/VB/message_sendreceive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAllMessages">
      <MemberSignature Language="C#" Value="public System.Messaging.Message[] GetAllMessages ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message[] GetAllMessages() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetAllMessages" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna todas as mensagens na fila.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Messaging.Message" /> que representa todas as mensagens na fila, na mesma ordem em que são exibidas na fila do serviço de Enfileiramento de Mensagens.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>Retorna um instantâneo estático do mensagens na fila, os links não dinâmicos para essas mensagens. Portanto, você não pode usar a matriz para modificar as mensagens na fila. Se você quiser interação dinâmica, em tempo real com a fila (como a capacidade de excluir mensagens), chame o <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> método, que retorna uma lista dinâmica de mensagens na fila.  
  
 Porque <xref:System.Messaging.MessageQueue.GetAllMessages%2A> retorna uma cópia das mensagens na fila no momento em que o método foi chamado, a matriz não reflete as novas mensagens que chegam na fila ou mensagens que são removidas da fila.  
  
 <xref:System.Messaging.MessageQueue.GetAllMessages%2A>recupera apenas as propriedades não filtradas pelo <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.GetAllMessages%2A>.  
  
 [!code-cpp[MessageQueue2#21](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#21)]
 [!code-csharp[MessageQueue2#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Enumera as mensagens em uma fila. O <see cref="M:System.Messaging.MessageQueue.GetEnumerator" /> foi preterido. Em vez disso, <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> deve ser usado.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> que fornece uma conexão dinâmica para as mensagens na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.GetEnumerator%2A>.  
  
 [!code-cpp[MessageQueue2#22](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#22)]
 [!code-csharp[MessageQueue2#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMachineId">
      <MemberSignature Language="C#" Value="public static Guid GetMachineId (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Guid GetMachineId(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMachineId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O nome do computador que contém a fila, sem as duas barras invertidas anteriores (\\\\).</param>
        <summary>Obtém o identificador do computador no qual a fila referenciada por este <see cref="T:System.Messaging.MessageQueue" /> está localizado.</summary>
        <returns>Um <see cref="T:System.Guid" /> que representa um identificador exclusivo para o computador no qual a fila está localizada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o identificador do computador para dois propósitos, entre outros: para ler o diário do computador e configurar certificados de segurança. No entanto, você não pode chamar <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29> para um computador remoto quando você estiver trabalhando offline, porque o aplicativo deve ter acesso ao serviço de diretório no controlador de domínio.  
  
 O identificador do computador (ou o identificador de máquina) é um <xref:System.Guid> que o enfileiramento de mensagens cria quando um computador é adicionado à empresa. O Message Queuing combina o identificador do computador com o `Machine` e `Journal` palavras-chave para criar o nome do formato do diário do computador, que tem a sintaxe `Machine=<computeridentifier>;Journal`. O diário do computador, que também é conhecido como a fila de diário, é uma fila do sistema que armazena cópias das gerados pelo aplicativo de mensagens quando o <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> é de propriedade `true`.  
  
 Essa sintaxe para o diário é válido somente ao construir o nome do formato da fila. A sintaxe de nome de caminho é `MachineName` \\ `Journal$`.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir chama <xref:System.Messaging.MessageQueue.GetMachineId%28System.String%29>.  
  
 [!code-csharp[MessageQueue#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">O identificador do computador não pôde ser recuperado, possivelmente porque o serviço de diretório não está disponível. Por exemplo, se você estiver trabalhando offline.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um objeto enumerador para todas as mensagens na fila. O <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" /> foi preterido. Em vez disso, <see cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" /> deve ser usado.</summary>
        <returns>O <see cref="T:System.Messaging.MessageEnumerator" /> mantém as mensagens que estão contidas na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A>cria uma lista dinâmica de todas as mensagens em uma fila. Você pode remover da fila a mensagem na posição atual do enumerador chamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para o <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> retorna.  
  
 Como o cursor é associado com a lista dinâmica de mensagens na fila, a enumeração reflete qualquer modificação que você fizer as mensagens na fila, se a mensagem está além da posição atual do cursor. Por exemplo, o enumerador pode acessar automaticamente uma mensagem de prioridade mais baixa colocado além da posição atual do cursor, mas não uma mensagem de prioridade mais alta inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageEnumerator.Reset%2A> para o <xref:System.Messaging.MessageEnumerator>.  
  
 A ordem das mensagens na enumeração reflete a ordem na fila, para que mensagens de prioridade mais alta serão exibido antes que os de prioridade mais baixa.  
  
 Se você quiser um instantâneo estático das mensagens em fila em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Esse método retorna uma matriz de <xref:System.Messaging.Message> objetos que representam as mensagens no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém uma lista dinâmica de mensagens em uma fila e contagens de todas as mensagens com o <xref:System.Messaging.Message.Priority%2A> propriedade definida como <xref:System.Messaging.MessagePriority?displayProperty=nameWithType>.  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageEnumerator2">
      <MemberSignature Language="C#" Value="public System.Messaging.MessageEnumerator GetMessageEnumerator2 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.MessageEnumerator GetMessageEnumerator2() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um objeto enumerador para todas as mensagens na fila.</summary>
        <returns>O <see cref="T:System.Messaging.MessageEnumerator" /> mantém as mensagens que estão contidas na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>cria uma lista dinâmica de todas as mensagens em uma fila. Você pode remover da fila a mensagem na posição atual do enumerador chamando <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> para o <xref:System.Messaging.MessageEnumerator> que <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A> retorna.  
  
 Como o cursor é associado com a lista dinâmica de mensagens na fila, a enumeração reflete qualquer modificação que você fizer as mensagens na fila, se a mensagem está além da posição atual do cursor. Por exemplo, o enumerador pode acessar automaticamente uma mensagem de prioridade mais baixa colocado além da posição atual do cursor, mas não uma mensagem de prioridade mais alta inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageEnumerator.Reset%2A> para o <xref:System.Messaging.MessageEnumerator>.  
  
 A ordem das mensagens na enumeração reflete a ordem na fila, para que mensagens de prioridade mais alta serão exibido antes que os de prioridade mais baixa.  
  
 Se você quiser um instantâneo estático das mensagens em fila em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetAllMessages%2A>. Esse método retorna uma matriz de <xref:System.Messaging.Message> objetos que representam as mensagens no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece a semântica de cursor somente de avanço para enumerar todas as filas públicas na rede.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueueEnumerator" /> que fornece uma lista dinâmica de todas as filas de mensagens pública na rede.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> retorna uma enumeração de todas as filas públicas que estão em uma rede.  
  
 Porque o cursor está associado uma lista dinâmica, a enumeração reflete as modificações feitas a uma lista de fila para filas excluído ou adicionado além da posição atual do cursor. Adições ou exclusões de filas localizadas antes da posição atual do cursor não são refletidas. Por exemplo, o enumerador automaticamente pode acessar uma fila acrescentado além da posição do cursor, mas não uma inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para o <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Não há nenhuma ordem definida de filas em uma rede. Um enumerador não ordene-as, por exemplo, computador, rótulo, status público ou privado ou quaisquer outros critérios acessíveis.  
  
 Se você quiser um instantâneo estático de filas da rede em vez de uma conexão dinâmica a eles, chame <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada um desses dois métodos retorna uma matriz de <xref:System.Messaging.MessageQueue> objetos que representam as filas no momento em que o método foi chamado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir itera todas as filas de mensagens na rede e examina o caminho para cada fila. Finalmente, ele exibe o número de filas públicas na rede.  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CPP/mqgetmessagequeueenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/CS/mqgetmessagequeueenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_noparms/VB/mqgetmessagequeueenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMessageQueueEnumerator">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueueEnumerator GetMessageQueueEnumerator(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetMessageQueueEnumerator(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Um <see cref="T:System.Messaging.MessageQueueCriteria" /> que contém os critérios usados para filtrar as filas de mensagens disponíveis.</param>
        <summary>Fornece a semântica de cursor somente de avanço para enumerar todas as filas públicas na rede que atendem aos critérios especificados.</summary>
        <returns>Um <see cref="T:System.Messaging.MessageQueueEnumerator" /> que fornece uma lista dinâmica de filas de mensagens pública na rede que satisfaça as restrições especificadas pelo <paramref name="criteria" /> parâmetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta sobrecarga do <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A> retorna uma lista de todas as filas públicas na rede que atendem a critérios definidos nos critérios de aplicativo. Você pode especificar os critérios para incluir, por exemplo, fila hora de criação ou modificação, nome do computador, rótulo, categoria ou qualquer combinação desses elementos.  
  
 Porque o cursor está associado uma lista dinâmica, a enumeração reflete as modificações feitas para uma fila que ocorre além da posição atual do cursor. Alterações em filas localizadas antes da posição atual do cursor não são refletidas. Por exemplo, o enumerador automaticamente pode acessar uma fila acrescentado além da posição do cursor, mas não uma inseridos antes de posição. No entanto, você pode redefinir a enumeração, assim, movendo o cursor volta para o início da lista, chamando <xref:System.Messaging.MessageQueueEnumerator.Reset%2A> para o <xref:System.Messaging.MessageQueueEnumerator>.  
  
 Não há nenhuma ordem definida de filas em uma rede. Um enumerador não ordene-as, por exemplo, computador, rótulo, status público ou privado ou quaisquer outros critérios acessíveis.  
  
 Se você quiser um instantâneo estático de filas da rede em vez de uma conexão dinâmica a eles, especifique os critérios para <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> ou chame <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>. Cada um desses dois métodos retorna uma matriz de <xref:System.Messaging.MessageQueue> objetos que representam as filas no momento em que o método foi chamado. Chamando <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29> fornece os mesmos resultados que chamar <xref:System.Messaging.MessageQueue.GetPublicQueues%2A> com os critérios de filtragem de <xref:System.Messaging.MessageQueue.Category%2A>, <xref:System.Messaging.MessageQueue.Label%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>, respectivamente.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir itera por meio de filas de mensagens e exibe o caminho de cada fila que foi criada no último dia e que existe no computador "MyComputer".  
  
 [!code-cpp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CPP/mqgetmessagequeueenumerator_criteria.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/CS/mqgetmessagequeueenumerator_criteria.cs#1)]
 [!code-vb[MessageQueue.GetMessageQueueEnumerator_criteria#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageQueueEnumerator_criteria/VB/mqgetmessagequeueenumerator_criteria.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPrivateQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPrivateQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPrivateQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPrivateQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O computador do qual recuperar as filas privativas.</param>
        <summary>Recupera todas as filas privativas no computador especificado.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Messaging.MessageQueue" /> que referenciam as filas privativas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.GetPrivateQueuesByMachine%28System.String%29>recupera um instantâneo estático de filas em um computador especificado.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="machineName" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera todas as filas públicas na rede.</summary>
        <returns>Uma matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que fazem referência as filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga se você quiser uma lista completa de todas as filas públicas na rede. Se você deseja restringir a lista por certos critérios, como <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, ou a hora da última modificação use outra sobrecarga desse método. (Como alternativa, você pode usar <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, ou <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>.)  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueues">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueues (System.Messaging.MessageQueueCriteria criteria);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueues(class System.Messaging.MessageQueueCriteria criteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueues(System.Messaging.MessageQueueCriteria)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="criteria" Type="System.Messaging.MessageQueueCriteria" />
      </Parameters>
      <Docs>
        <param name="criteria">Um <see cref="T:System.Messaging.MessageQueueCriteria" /> que contém os critérios usados para filtrar as filas.</param>
        <summary>Recupera todas as filas públicas na rede que atendem aos critérios especificados.</summary>
        <returns>Uma matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que fazem referência as filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você deseja filtrar todas as filas públicas na rede pelo rótulo, categoria ou nome do computador, o <xref:System.Messaging.MessageQueue> classe contém métodos específicos que fornecem essa funcionalidade (<xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>, <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>, e <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>, respectivamente). Use essa sobrecarga para obter uma lista de todas as filas públicas na rede que atendam a mais de um desses critérios (por exemplo, se você deseja especificar um rótulo e uma categoria). Você também pode filtrar por critérios de mensagem diferente de <xref:System.Messaging.MessageQueue.Label%2A>, <xref:System.Messaging.MessageQueue.Category%2A>, e <xref:System.Messaging.MessageQueue.MachineName%2A>. Por exemplo, você deve usar essa sobrecarga para filtrar por hora da última modificação da fila. Basta criar uma nova instância do <xref:System.Messaging.MessageQueueCriteria> classe, defina as propriedades adequadas na instância e passe a instância como o `criteria` parâmetro.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueues%2A>recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByCategory">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByCategory (Guid category);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByCategory(valuetype System.Guid category) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByCategory(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="category" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="category">Um <see cref="T:System.Guid" /> que agrupa o conjunto de filas a serem recuperados.</param>
        <summary>Recupera todas as filas públicas na rede que pertencem à categoria especificada.</summary>
        <returns>Uma matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que fazem referência as filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por categoria. O <xref:System.Messaging.MessageQueue.Category%2A> propriedade fornece acesso para o Message Queuing tipo propriedade ID (que é leitura/gravação) de uma determinada fila. Embora você possa usar <xref:System.Guid.NewGuid%2A> para criar um valor de categoria é exclusivo em todas as <xref:System.Guid> valores, não é necessário. O valor da categoria deve ser distinto somente de outras categorias, não de todos os outros <xref:System.Guid> valores. Por exemplo, você pode atribuir {00000000-0000-0000-0000-000000000001} como o <xref:System.Messaging.MessageQueue.Category%2A> para um conjunto de filas e {00000000-0000-0000-0000-000000000002} como a <xref:System.Messaging.MessageQueue.Category%2A> para outro conjunto.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByCategory%28System.Guid%29>recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar a categoria como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByLabel">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByLabel (string label);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByLabel(string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByLabel(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="label">Um rótulo que agrupa o conjunto de filas a serem recuperados.</param>
        <summary>Recupera todas as filas públicas na rede que contêm o rótulo especificado.</summary>
        <returns>Uma matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que fazem referência as filas públicas recuperadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por rótulo.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByLabel%28System.String%29>recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar o rótulo como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPublicQueuesByMachine">
      <MemberSignature Language="C#" Value="public static System.Messaging.MessageQueue[] GetPublicQueuesByMachine (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.MessageQueue[] GetPublicQueuesByMachine(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetPublicQueuesByMachine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.MessageQueue[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O nome do computador que contém o conjunto de filas públicas a serem recuperados.</param>
        <summary>Recupera todas as filas públicas que residem no computador especificado.</summary>
        <returns>Uma matriz de <see cref="T:System.Messaging.MessageQueue" /> objetos que fazem referência as filas públicas no computador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para filtrar as filas públicas por computador.  
  
 <xref:System.Messaging.MessageQueue.GetPublicQueuesByMachine%28System.String%29>recupera um instantâneo estático das filas. Para interagir com uma lista dinâmica de filas, use <xref:System.Messaging.MessageQueue.GetMessageQueueEnumerator%2A>. Você pode especificar o nome do computador como parte do <xref:System.Messaging.MessageQueueCriteria> passar para o método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Não|  
|Computador local e o nome de formato direto|Não|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir recupera a lista de filas.  
  
 [!code-cpp[MessageQueue.GetQueueLists#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CPP/mqgetqueuelists.cpp#1)]
 [!code-csharp[MessageQueue.GetQueueLists#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetQueueLists/CS/mqgetqueuelists.cs#1)]
 [!code-vb[MessageQueue.GetQueueLists#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetQueueLists/VB/mqgetqueuelists.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="machineName" /> parâmetro tem sintaxe incorreta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSecurityContext">
      <MemberSignature Language="C#" Value="public static System.Messaging.SecurityContext GetSecurityContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Messaging.SecurityContext GetSecurityContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.GetSecurityContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.SecurityContext</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera o contexto de segurança MSMQ associa o usuário atual (identidade de thread) no momento desta chamada.</summary>
        <returns>Um <see cref="T:System.Messaging.SecurityContext" /> objeto que contém o contexto de segurança.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public Guid Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid Id" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_GuidId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador exclusivo de enfileiramento de mensagens da fila.</summary>
        <value>Um <see cref="P:System.Messaging.MessageQueue.Id" /> que representa o identificador da mensagem gerado pelo aplicativo do serviço de enfileiramento de mensagens.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Conjuntos de enfileiramento de mensagens a <xref:System.Messaging.MessageQueue.Id%2A> propriedade quando ele cria a fila. Essa propriedade só está disponível para filas públicas.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Id%2A> propriedade.  
  
 [!code-csharp[MessageQueue#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="InfiniteQueueSize">
      <MemberSignature Language="C#" Value="public static readonly long InfiniteQueueSize;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly int64 InfiniteQueueSize" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteQueueSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que nenhuma restrição de tamanho existe para uma fila.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse membro é frequentemente usado ao definir <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> ou <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Messaging.MessageQueue.InfiniteQueueSize> membro.  
  
 [!code-csharp[MessageQueue#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InfiniteTimeout">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan InfiniteTimeout;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan InfiniteTimeout" />
      <MemberSignature Language="DocId" Value="F:System.Messaging.MessageQueue.InfiniteTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que nenhum tempo limite existe para os métodos que inspecionar ou recebem mensagens.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue>dá suporte a dois tipos de recuperação de mensagens: síncronas e assíncronas. Métodos síncronos, <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.Receive%2A>, fazer com que o thread de processo de um intervalo de tempo especificado para uma nova mensagem chegar na fila de espera. Se o intervalo de tempo especificado for <xref:System.Messaging.MessageQueue.InfiniteTimeout>, o thread de processo permanecerá bloqueado até que uma nova mensagem está disponível. Por outro lado, <xref:System.Messaging.MessageQueue.BeginPeek%2A> e <xref:System.Messaging.MessageQueue.BeginReceive%2A> (os métodos assíncronos), permitir que as tarefas de aplicativo principal continuar em um thread separado, até que uma mensagem chega na fila.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Messaging.MessageQueue.InfiniteTimeout> membro.  
  
 [!code-csharp[MessageQueue#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Label">
      <MemberSignature Language="C#" Value="public string Label { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Label" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Label" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Label")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a descrição da fila.</summary>
        <value>O rótulo para a fila de mensagens. O padrão é uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comprimento máximo de um rótulo de fila de mensagens é 124 caracteres.  
  
 O <xref:System.Messaging.MessageQueue.Label%2A> propriedade precisa ser exclusivo em todas as filas. No entanto, se várias filas compartilham o mesmo <xref:System.Messaging.MessageQueue.Label%2A>, você não pode usar o <xref:System.Messaging.MessageQueue.Send%28System.Object%29> método para difundir uma mensagem a todos eles. Se você usar a sintaxe do rótulo para o <xref:System.Messaging.MessageQueue.Path%2A> propriedade ao enviar a mensagem, uma exceção será lançada se o <xref:System.Messaging.MessageQueue.Label%2A> não é exclusivo.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Label%2A> propriedade.  
  
 [!code-csharp[MessageQueue#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O rótulo foi definido como um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastModifyTime">
      <MemberSignature Language="C#" Value="public DateTime LastModifyTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime LastModifyTime" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.LastModifyTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_LastModifyTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a última vez em que as propriedades de uma fila foram modificadas.</summary>
        <value>Um <see cref="T:System.DateTime" /> que indica quando as propriedades de fila foram modificadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A hora da última modificação inclui quando a fila foi criada e qualquer <xref:System.Messaging.MessageQueue> propriedade que modifica o enfileiramento de mensagens, como <xref:System.Messaging.MessageQueue.BasePriority%2A>. O valor de <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade representa a hora do sistema do computador local.  
  
 Você deve chamar <xref:System.Messaging.MessageQueue.Refresh%2A> antes de obter o <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade; caso contrário, a hora da modificação associado a esta <xref:System.Messaging.MessageQueue> podem não ser atuais.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade.  
  
 [!code-csharp[MessageQueue#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do computador em que a fila do serviço de enfileiramento de mensagens está localizada.</summary>
        <value>O nome do computador no qual a fila está localizada. O padrão do serviço de enfileiramento de mensagens é “.”, o computador local.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MachineName%2A> é um componente integrante da sintaxe do nome amigável da fila de <xref:System.Messaging.MessageQueue.Path%2A>. A tabela a seguir mostra a sintaxe que você deve usar para uma fila de um tipo especificado quando você deseja identificar o caminho da fila usando seu nome amigável.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para o computador local ao especificar o <xref:System.Messaging.MessageQueue.MachineName%2A>. Somente o nome do computador é reconhecido para esta propriedade, por exemplo, `Server0`. O <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade não dá suporte para o formato do endereço IP.  
  
 Se você definir o <xref:System.Messaging.MessageQueue.Path%2A> em termos do <xref:System.Messaging.MessageQueue.MachineName%2A>, o aplicativo gera uma exceção ao trabalhar offline porque o controlador de domínio é necessário para a conversão de caminho. Portanto, você deve usar o <xref:System.Messaging.MessageQueue.FormatName%2A> para o <xref:System.Messaging.MessageQueue.Path%2A> sintaxe ao trabalhar offline.  
  
 O <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades relacionadas. Alterando o <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade faz com que o <xref:System.Messaging.MessageQueue.Path%2A> propriedade a ser alterada. É criado a partir do novo <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A>. Alterando o <xref:System.Messaging.MessageQueue.Path%2A> (por exemplo, para usar a sintaxe de nome de formato) redefine o <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades para referir-se a nova fila. Se o <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade estiver vazia, o <xref:System.Messaging.MessageQueue.Path%2A> está definido para a fila de diário do computador que você especificar.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome do computador não é válido, possivelmente porque a sintaxe está incorreta.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumJournalSize">
      <MemberSignature Language="C#" Value="public long MaximumJournalSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumJournalSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumJournalSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumJournalSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho máximo da fila de diário.</summary>
        <value>O tamanho máximo, em quilobytes, da fila de diário. O padrão do Enfileiramento de Mensagens especifica que não há limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>fornece acesso para o limite de armazenamento do diário de enfileiramento de mensagens. Ele é relevante somente quando <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> é `true`. A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração  
  
 Se você armazenar mensagens em uma fila de mensagens mortas ou diário, você deve limpar periodicamente a fila para remover as mensagens que não são mais necessários. Contagem de mensagens em uma fila para a cota de mensagens para o computador em que a fila reside. (O administrador define a cota do computador).  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A> propriedade.  
  
 [!code-csharp[MessageQueue#21](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho da fila de diário máximo foi definido para um valor inválido.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumQueueSize">
      <MemberSignature Language="C#" Value="public long MaximumQueueSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MaximumQueueSize" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MaximumQueueSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MaximumQueueSize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho máximo da fila.</summary>
        <value>O tamanho máximo, em quilobytes, da fila. O padrão do Enfileiramento de Mensagens especifica que não há limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> fornece acesso ao limite de armazenamento de mensagem enfileiramento de mensagens, que é separado da cota de mensagens do computador que o administrador define. Para obter mais informações sobre a cota de mensagens, consulte <xref:System.Messaging.MessageQueue.MaximumJournalSize%2A>.  
  
 A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração  
  
 Se for feita uma tentativa de exceder o tamanho máximo da fila ou a cota de mensagens do computador, as mensagens podem ser perdidas. Quando a cota da fila for atingida, o enfileiramento de mensagens notifica a fila de administração do aplicativo de envio para indicar que a fila está cheia, retornando uma mensagem de confirmação negativa. O Message Queuing continuará a enviar confirmações negativas, até que o tamanho total das mensagens na fila fique abaixo do limite.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.MaximumQueueSize%2A> propriedade.  
  
 [!code-csharp[MessageQueue#22](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho máximo da fila contém um valor negativo.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="MessageReadPropertyFilter">
      <MemberSignature Language="C#" Value="public System.Messaging.MessagePropertyFilter MessageReadPropertyFilter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.MessagePropertyFilter MessageReadPropertyFilter" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MessageReadPropertyFilter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MessageReadPropertyFilter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.MessagePropertyFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o filtro de propriedade para receber ou espiar mensagens.</summary>
        <value>O <see cref="T:System.Messaging.MessagePropertyFilter" /> usado pela fila para filtrar o conjunto de propriedades que ela recebe ou espia para cada mensagem.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse filtro é um conjunto de valores booleanos, restringindo as propriedades de mensagem que o <xref:System.Messaging.MessageQueue> recebe ou exibe. Quando o <xref:System.Messaging.MessageQueue> recebe ou exibe uma mensagem da fila do servidor, ele recupera apenas as propriedades para o qual o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> valor é `true`.  
  
 A seguir mostra os valores de propriedade inicial para o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> propriedade. Essas configurações são idênticas à chamada <xref:System.Messaging.MessagePropertyFilter.SetDefaults%2A> em um <xref:System.Messaging.MessagePropertyFilter>.  
  
|Propriedade|Valor padrão|  
|--------------|-------------------|  
|<xref:System.Messaging.MessagePropertyFilter.Acknowledgment%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AcknowledgeType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AdministrationQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AppSpecific%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ArrivedTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.AttachSenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Authenticated%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderName%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.AuthenticationProviderType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Body%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.ConnectorType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.CorrelationId%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultBodySize%2A>|1024 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultExtensionSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DefaultLabelSize%2A>|255 bytes|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DestinationSymmetricKey%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.DigitalSignature%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.EncryptionAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Extension%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.HashAlgorithm%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Id%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.IsFirstInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.IsLastInTransaction%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Label%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.MessageType%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Priority%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.Recoverable%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.ResponseQueue%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderCertificate%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SenderVersion%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.SentTime%2A>|`true`|  
|<xref:System.Messaging.MessagePropertyFilter.SourceMachine%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToBeReceived%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TimeToReachQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionId%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.TransactionStatusQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseAuthentication%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseDeadLetterQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseEncryption%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseJournalQueue%2A>|`false`|  
|<xref:System.Messaging.MessagePropertyFilter.UseTracing%2A>|`false`|  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Messaging.MessageQueue.MessageReadPropertyFilter%2A> para restringir as propriedades da mensagem recebidas.  
  
 [!code-cpp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CPP/mqmessagereadpropertyfilter.cpp#1)]
 [!code-csharp[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/CS/mqmessagereadpropertyfilter.cs#1)]
 [!code-vb[MessageQueue.MessageReadPropertyFilter#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.MessageReadPropertyFilter/VB/mqmessagereadpropertyfilter.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O filtro é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastAddress">
      <MemberSignature Language="C#" Value="public string MulticastAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MulticastAddress" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.MulticastAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_MulticastAddress")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Introduzido no MSMQ 3.0. Obtém ou define o endereço multicast associado à fila.</summary>
        <value>Um <see cref="T:System.String" /> que contém um endereço multicast válido (no formato mostrado abaixo) ou <see langword="null" />, que indica que a fila não está associada a um endereço multicast.  
  
```  
&lt;address&gt;:&lt;port&gt;  
```</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propriedade é usada para associar a um endereço de multicast que pode ser usado ao enviar mensagens de uma fila não transacional. Você não pode associar uma fila transacional com um endereço de multicast. Quando o aplicativo de envio envia mensagens para um endereço de difusão seletiva, enfileiramento de mensagens envia uma cópia da mensagem para cada fila associada a esse endereço.  
  
 Multicast IP endereços devem estar no intervalo de classe D de 224.0.0.0 a 239.255.255.255, que corresponde à configuração os quatro primeiros bits de ordem superior como iguais a 1110. No entanto, somente determinados intervalos de endereços nesse intervalo são não reservado e disponível para enviar mensagens de multicast. Para obter a lista mais recente de endereços multicast reservados, consulte o [endereços Multicast do número autoridade IANA (Internet Assigned) da Internet](http://go.microsoft.com/fwlink/?linkid=3859) página da Web. Não há nenhuma restrição sobre o número da porta.  
  
 Se vários computadores de origem estão enviando mensagens de multicast e desejar que uma fila específica para receber mensagens de um único computador de origem, cada computador de origem deve enviar mensagens para uma combinação diferente de número de porta e endereço IP.  
  
 Para desassociar uma fila de um endereço de multicast, defina o <xref:System.Messaging.MessageQueue.MulticastAddress%2A> propriedade como uma cadeia de caracteres de comprimento zero. Não defina-a como `null`, pois isso resultará em um <xref:System.ArgumentNullException>.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Path">
      <MemberSignature Language="C#" Value="public string Path { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Path" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Path" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Messaging.Design.QueuePathEditor", "System.Drawing.Design.UITypeEditor, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Path")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o caminho da fila. Definir o <see cref="P:System.Messaging.MessageQueue.Path" /> faz com que o <see cref="T:System.Messaging.MessageQueue" /> aponte para uma nova fila.</summary>
        <value>A fila que é referenciada pelo <see cref="T:System.Messaging.MessageQueue" />. O padrão depende do construtor <see cref="M:System.Messaging.MessageQueue.#ctor" /> usado, ele é <see langword="null" /> ou especificado pelo parâmetro <paramref name="path" /> do construtor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sintaxe para a <xref:System.Messaging.MessageQueue.Path%2A> propriedade depende do tipo de fila-pontos a, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
|Fila de diário do computador|`MachineName`\\`Journal$`|  
|Fila de mensagens mortas da máquina|`MachineName`\\`Deadletter$`|  
|Fila de mensagens mortas transacional do computador|`MachineName`\\`XactDeadletter$`|  
  
 Use "." para representar o computador local.  
  
 O <xref:System.Messaging.MessageQueue.MachineName%2A>, <xref:System.Messaging.MessageQueue.Path%2A>, e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades relacionadas. Alterando o <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade faz com que o <xref:System.Messaging.MessageQueue.Path%2A> propriedade a ser alterada. É criado a partir do novo <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A>. Alterando o <xref:System.Messaging.MessageQueue.Path%2A> (por exemplo, para usar a sintaxe de nome de formato) redefine o <xref:System.Messaging.MessageQueue.MachineName%2A> e <xref:System.Messaging.MessageQueue.QueueName%2A> propriedades para referir-se a nova fila.  
  
 Como alternativa, você pode usar o <xref:System.Messaging.MessageQueue.FormatName%2A> ou <xref:System.Messaging.MessageQueue.Label%2A> para descrever o caminho da fila, conforme mostrado na tabela a seguir.  
  
|Referência|Sintaxe|Exemplo|  
|---------------|------------|-------------|  
|Nome do formato|`FormatName:`[ *nome do formato* ]|`FormatName:Public=`5A5F7535-AE9A-41d4-935C-845C2AFF7112|  
|Rotular|`Label:`[ *label* ]|`Label:`TheLabel|  
  
 Se você usar a sintaxe do rótulo para o <xref:System.Messaging.MessageQueue.Path%2A> propriedade ao enviar a mensagem, uma exceção será lançada se o <xref:System.Messaging.MessageQueue.Label%2A> não é exclusivo.  
  
 Para trabalhar offline, você deve usar a sintaxe de nome de formato, em vez da sintaxe de nome amigável da primeira tabela. Caso contrário, uma exceção é lançada porque o controlador de domínio primário (no qual o Active Directory reside) não está disponível para resolver o caminho para o nome de formato.  
  
 Definir um novo caminho fecha a fila de mensagens e libera todos os identificadores.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Sim|  
  
> [!NOTE]
>  No modo de grupo de trabalho, você pode usar somente as filas particulares. Especifique o caminho usando a sintaxe de fila particular `MachineName` \\ `Private$` \\ `QueueName`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria novos <xref:System.Messaging.MessageQueue> objetos usando vários tipos de sintaxe de nome de caminho. Em cada caso, ele envia uma mensagem para a fila cujo caminho é definido no construtor.  
  
 [!code-cpp[MessageQueue.Path#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Path/CPP/mqpath.cpp#1)]
 [!code-csharp[MessageQueue.Path#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Path/CS/mqpath.cs#1)]
 [!code-vb[MessageQueue.Path#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Path/VB/mqpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho não é válido, possivelmente porque a sintaxe não é válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna sem remover (espia) a primeira mensagem na fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />. O método <see cref="M:System.Messaging.MessageQueue.Peek" /> é síncrono. Portanto, ele bloqueia o thread atual até que uma mensagem se torne disponível.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> que representa a primeira mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga espiar uma fila ou aguarde até que existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove a primeira mensagem da fila. Portanto, repetidas chamadas para <xref:System.Messaging.MessageQueue.Peek%2A> retornar a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove a primeira mensagem da fila. Repetidas chamadas para <xref:System.Messaging.MessageQueue.Receive%2A>, portanto, retornar mensagens diferentes.  
  
 O Message Queuing ordena as mensagens na fila de acordo com a hora de chegada e prioridade. Uma mensagem mais recente é colocada antes mais antiga somente se ele for de uma prioridade mais alta.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga não especifica um tempo limite, o aplicativo pode aguardar indefinidamente. Se você precisar continuar sem aguardar o processamento de aplicativo, use o assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método. Como alternativa, você pode especificar um tempo limite para uma mensagem para chegar na fila usando a sobrecarga do <xref:System.Messaging.MessageQueue.Peek%2A> que especifica um tempo limite.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 Os exemplos a seguir usam o <xref:System.Messaging.MessageQueue.Peek%2A> método em uma fila.  
  
 No primeiro exemplo, o aplicativo aguarda uma mensagem se torna disponível na fila. Observe que o primeiro exemplo não acessa a mensagem que chega; ele simplesmente pausa até que uma mensagem chega de processamento. Se uma mensagem já existe na fila, ela retornará imediatamente.  
  
 No segundo exemplo, uma mensagem que contém um aplicativo definido `Order` classe é enviada para a fila e, em seguida, inspecionada da fila.  
  
 [!code-cpp[MessageQueue.Peek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CPP/mqpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Peek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_noparms/CS/mqpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.Peek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_noparms/VB/mqpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo máximo de espera para que a fila contenha uma mensagem.</param>
        <summary>Retorna sem remover (espia) a primeira mensagem na fila referenciada por este <see cref="T:System.Messaging.MessageQueue" />. O método <see cref="M:System.Messaging.MessageQueue.Peek" /> é síncrono e, portanto, bloqueia o thread atual até que uma mensagem fique disponível ou o tempo limite especificado seja atingido.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> que representa a primeira mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga espiar uma fila ou aguardar um período especificado de tempo até que existe uma mensagem na fila. O método retorna imediatamente se já existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove a primeira mensagem da fila. Portanto, repetidas chamadas para <xref:System.Messaging.MessageQueue.Peek%2A> retornar a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove a primeira mensagem da fila. Repetidas chamadas para <xref:System.Messaging.MessageQueue.Receive%2A>, portanto, retornar mensagens diferentes.  
  
 O Message Queuing ordena as mensagens na fila de acordo com a hora de chegada e prioridade. Uma mensagem mais recente é colocada antes mais antiga somente se ele for de uma prioridade mais alta.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado até que o período especificado de tempo ou indefinidamente se você indicou <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se você precisar continuar sem aguardar o processamento de aplicativo, use o assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Messaging.MessageQueue.Peek%2A> método com um tempo limite de zero para verificar se a fila está vazia.  
  
 [!code-cpp[MessageQueue.Peek_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CPP/mqpeek_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Peek_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Peek_timeout/CS/mqpeek_timeout.cs#1)]
 [!code-vb[MessageQueue.Peek_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Peek_timeout/VB/mqpeek_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Peek (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.PeekAction action);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Peek(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.PeekAction action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Peek(System.TimeSpan,System.Messaging.Cursor,System.Messaging.PeekAction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="action" Type="System.Messaging.PeekAction" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo máximo de espera para que a fila contenha uma mensagem.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="action">Um dos valores de <see cref="T:System.Messaging.PeekAction" />. Indica se a mensagem atual ou a próxima na fila de mensagens deve ser espiada.</param>
        <summary>Retorna sem remover (espia) a mensagem atual ou a próxima na fila usando o cursor especificado. O método <see cref="M:System.Messaging.MessageQueue.Peek" /> é síncrono e, portanto, bloqueia o thread atual até que uma mensagem fique disponível ou o tempo limite especificado seja atingido.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> que representa uma mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga espiar uma fila ou aguardar um período especificado de tempo até que existe uma mensagem na fila. O método retorna imediatamente se já existe uma mensagem na fila.  
  
 O <xref:System.Messaging.MessageQueue.Peek%2A> método lê, mas não remove uma mensagem da fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método, por outro lado, lê e remove uma mensagem da fila.  
  
 Use <xref:System.Messaging.MessageQueue.Peek%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread está bloqueado até o período especificado de tempo ou indefinidamente se você indicou <xref:System.Messaging.MessageQueue.InfiniteTimeout>. Se você precisar continuar sem aguardar o processamento de aplicativo, use o assíncrona <xref:System.Messaging.MessageQueue.BeginPeek%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor diferente de <see langword="PeekAction.Current" /> ou <see langword="PeekAction.Next" /> foi especificado para o parâmetro <paramref name="action" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> é inválido. Provavelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a espiar.</param>
        <summary>Exibe a mensagem que corresponde ao identificador de correlação especificado e imediatamente gerará uma exceção se nenhuma mensagem com o identificador de correlação especificado existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você inspecionar mensagens em uma fila. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila. Ele solicita uma confirmação positiva especificamente quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a espiar.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Exibe a mensagem que corresponde ao identificador de correlação determinado e aguarda até que uma mensagem com o identificador de correlação especificado está disponível na fila, ou o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro e nenhuma nova mensagem chega na fila de dentro do período especificado o `timeout` parâmetro, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você inspecionar mensagens em uma fila. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#5](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#5)]
 [!code-csharp[MessageQueue2#5](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou antes do tempo limite expirou.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a espiar.</param>
        <summary>Espia a mensagem cujo identificador de mensagem corresponde ao parâmetro <paramref name="id" />.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ler sem remover da fila, uma mensagem que tem um identificador de mensagem conhecidos. O identificador de uma mensagem é exclusivo em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Essa sobrecarga lança uma exceção se a fila não contém a mensagem no momento.  
  
 Dois métodos adicionais permitem a você inspecionar mensagens em uma fila: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> retorna uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#6](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#6)]
 [!code-csharp[MessageQueue2#6](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não existe nenhuma mensagem com <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a espiar.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Espia a mensagem cujo identificador de mensagem corresponde ao parâmetro <paramref name="id" />. Aguarda até que a mensagem é exibida na fila ou um tempo limite ocorre.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> ler sem remover da fila, uma mensagem que tem um identificador de mensagem conhecidos. O identificador de uma mensagem é exclusivo em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Essa sobrecarga lança uma exceção se a fila não contém a mensagem no momento e uma nova mensagem chegou antes do tempo limite ocorre.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 Dois métodos adicionais permitem a você inspecionar mensagens em uma fila: <xref:System.Messaging.MessageQueue.Peek%2A> e <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. O <xref:System.Messaging.MessageQueue.Peek%2A> método retorna a primeira mensagem na fila; <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> retorna uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.PeekById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#7](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#7)]
 [!code-csharp[MessageQueue2#7](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.InvalidOperationException">A mensagem com especificado <paramref name="id" /> não existe na fila e não chegou antes do período especificado pelo <paramref name="timeout" /> parâmetro expirou.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> da mensagem para inspecionar.</param>
        <summary>Introduzido no MSMQ 3.0. Exibe a mensagem que corresponde ao identificador de pesquisa especificado de uma fila não transacional.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.LookupId" /> corresponde ao parâmetro <paramref name="lookupId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos sem removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador de pesquisa especificado e remova-a da fila, use o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message PeekByLookupId (System.Messaging.MessageLookupAction action, long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message PeekByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.PeekByLookupId(System.Messaging.MessageLookupAction,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="action">Uma da <see cref="T:System.Messaging.MessageLookupAction" /> valores, especificando como a mensagem é lida na fila. Especifique um dos seguintes:  
  
 <see langword="MessageLookupAction.Current" />: Exibe a mensagem especificada pelo <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Next" />: Exibe a mensagem posterior a mensagem especificada pelo <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.Previous" />: Exibe a mensagem anterior à mensagem especificada pelo <c>lookupId</c>.  
  
 <see langword="MessageLookupAction.First" />: Exibe a primeira mensagem na fila. O <c>lookupId</c> parâmetro deve ser definido como 0.  
  
 <see langword="MessageLookupAction.Last" />: Exibe a última mensagem na fila. O <c>lookupId</c> parâmetro deve ser definido como 0.</param>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> de mensagem para inspecionar ou 0. 0 é usado para acessar a primeira ou última mensagem na fila.</param>
        <summary>Introduzido no MSMQ 3.0. Exibe uma mensagem específica da fila. A mensagem pode ser especificada por um identificador de pesquisa ou por sua posição no início ou no final da fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> especificado pelo <paramref name="action" /> e <paramref name="lookupId" /> parâmetros passados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos sem removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador especificado e removê-la da fila, use o <xref:System.Messaging.MessageQueue.ReceiveByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="action" /> não é um dos membros do <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="PeekCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.PeekCompletedEventHandler PeekCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.PeekCompletedEventHandler PeekCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.PeekCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_PeekCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.PeekCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma mensagem é lida sem ser removida da fila. Este é o resultado da operação assíncrona, <see cref="M:System.Messaging.MessageQueue.BeginPeek" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginPeek%2A>é usada no processamento assíncrono para gerar o <xref:System.Messaging.MessageQueue.PeekCompleted> quando uma mensagem fica disponível na fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.EndPeek%28System.IAsyncResult%29>é usado para concluir a operação iniciada por uma chamada para <xref:System.Messaging.MessageQueue.BeginPeek%2A> e inspecionar mensagem quando o <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado.  
  
 Quando você cria um <xref:System.Messaging.PeekCompletedEventHandler> delegado, você identificar o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do representante ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, a menos que você remova o representante. Para obter mais informações sobre delegados de manipulador de eventos, consulte [NIB: eventos e delegados](http://msdn.microsoft.com/en-us/d98fd58b-fa4f-4598-8378-addf4355a115).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyPeekCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.PeekCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginPeek%2A> para iniciar uma operação assíncrona inspecionar na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.PeekCompleted> é gerado, o exemplo exibe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginPeek%2A> novamente para iniciar uma nova operação assíncrona de pico  
  
 [!code-cpp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CPP/mqbeginpeek_noparms.cpp#1)]
 [!code-csharp[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/CS/mqbeginpeek_noparms.cs#1)]
 [!code-vb[MessageQueue.BeginPeek_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.BeginPeek_noparms/VB/mqbeginpeek_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="public void Purge ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Purge() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Purge" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui todas as mensagens contidas na fila.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Limpar a fila faz com que o enfileiramento de mensagens definir o sinalizador de modificação de fila, que afeta o <xref:System.Messaging.MessageQueue.LastModifyTime%2A> propriedade. As mensagens são limpos da fila são perdidas; eles não são enviados para a fila de mensagens mortas ou a fila de diário.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Purge%2A>.  
  
 [!code-cpp[MessageQueue2#29](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#29)]
 [!code-csharp[MessageQueue2#29](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="QueueName">
      <MemberSignature Language="C#" Value="public string QueueName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string QueueName" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.QueueName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_QueueName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome amigável que identifica a fila.</summary>
        <value>O nome que identifica a fila referenciada por essa <see cref="T:System.Messaging.MessageQueue" />. O valor não pode ser <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode combinar o <xref:System.Messaging.MessageQueue.QueueName%2A> com o <xref:System.Messaging.MessageQueue.MachineName%2A> para criar um amigável <xref:System.Messaging.MessageQueue.Path%2A> nome para a fila. A sintaxe para a variação do nome amigável do <xref:System.Messaging.MessageQueue.Path%2A> propriedade depende do tipo de fila, conforme mostrado na tabela a seguir.  
  
|Tipo de fila|Sintaxe|  
|----------------|------------|  
|Fila pública|`MachineName`\\`QueueName`|  
|Fila particular|`MachineName`\\`Private$`\\`QueueName`|  
|Fila de diário|`MachineName`\\`QueueName`\\`Journal$`|  
  
 Use "." para representar o computador local.  
  
 Alterando o <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade afeta o <xref:System.Messaging.MessageQueue.Path%2A> propriedade. Se você definir o <xref:System.Messaging.MessageQueue.QueueName%2A> sem definir o <xref:System.Messaging.MessageQueue.MachineName%2A> propriedade, o <xref:System.Messaging.MessageQueue.Path%2A> propriedade torna-se.\\ `QueueName`. Caso contrário, o <xref:System.Messaging.MessageQueue.Path%2A> se torna `MachineName` \\ `QueueName`.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Sim|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.QueueName%2A> propriedade.  
  
 [!code-csharp[MessageQueue#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome da fila é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadHandle">
      <MemberSignature Language="C#" Value="public IntPtr ReadHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ReadHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.ReadHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReadHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador nativo usado para ler as mensagens da fila de mensagens.</summary>
        <value>Um identificador para o objeto de fila nativo que você usa para exibir e receber mensagens da fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.ReadHandle%2A> fornece um identificador nativo do Windows para o objeto de fila de mensagem que é usado para inspecionar e receber mensagens da fila. Se você alterar o caminho da fila, o identificador é fechado e reaberto com um novo valor.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pela <see cref="T:System.Messaging.MessageQueue" />. Essa chamada é síncrona e bloqueia a execução do thread atual até que uma mensagem esteja disponível.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila ou aguarde até que haja mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila ou novo, as mensagens de alta prioridade.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga do <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recebe uma mensagem de uma fila e envia informações sobre essa mensagem para a tela.  
  
 [!code-cpp[MessageQueue.Receive_noparms#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CPP/mqreceive_noparms.cpp#1)]
 [!code-csharp[MessageQueue.Receive_noparms#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_noparms/CS/mqreceive_noparms.cs#1)]
 [!code-vb[MessageQueue.Receive_noparms#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_noparms/VB/mqreceive_noparms.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a primeira mensagem disponível na fila transacional referenciada pelo <see cref="T:System.Messaging.MessageQueue" />. Essa chamada é síncrona e bloqueia a execução do thread atual até que uma mensagem esteja disponível.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pelo `transaction` parâmetro ou aguarde até que haja mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga do <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a uma fila transacional no computador local e envia uma mensagem à fila. Em seguida, ele recebe a mensagem que contém um pedido. Se ele encontrar uma fila não transacional, ela irá gerar e exceção e reverter a transação.  
  
 [!code-cpp[MessageQueue.Receive_transaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CPP/mqreceive_transaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_transaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_transaction/CS/mqreceive_transaction.cs#1)]
 [!code-vb[MessageQueue.Receive_transaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_transaction/VB/mqreceive_transaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.  
  
 -ou-  
  
 A fila é não transacional.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pela <see cref="T:System.Messaging.MessageQueue" />. Essa chamada é síncrona e bloqueia a execução do thread atual até que uma mensagem esteja disponível.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro ou aguarde até que haja mensagens na fila.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. Como essa sobrecarga do <xref:System.Messaging.MessageQueue.Receive%2A> método Especifica um tempo limite infinito, o aplicativo pode aguardar indefinidamente. Se o processamento do aplicativo deve continuar sem esperar que a mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Receive%28System.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#9](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#9)]
 [!code-csharp[MessageQueue2#9](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pelo <see cref="T:System.Messaging.MessageQueue" /> e aguarda até que uma mensagem esteja disponível na fila ou o tempo limite expire.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem e retornar em um período de tempo especificado se não existem mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, a remoção da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila ou novo, as mensagens de alta prioridade.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir recebe uma mensagem de uma fila e envia informações sobre essa mensagem para a tela. O exemplo pausa a execução por até cinco segundos, enquanto aguarda uma mensagem para chegar na fila.  
  
 [!code-cpp[MessageQueue.Receive_timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CPP/mqreceive_timeout.cpp#1)]
 [!code-csharp[MessageQueue.Receive_timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_timeout/CS/mqreceive_timeout.cs#1)]
 [!code-vb[MessageQueue.Receive_timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_timeout/VB/mqreceive_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <summary>Recebe a mensagem atual na fila, usando um cursor especificado. Se nenhuma mensagem estiver disponível, esse método aguarda até que uma mensagem fica disponível, ou o tempo limite expirar.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens  
  
 Use essa sobrecarga para receber uma mensagem e retornar em um período de tempo especificado se não existem mensagens na fila.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a primeira mensagem disponível na fila transacional referenciada pelo <see cref="T:System.Messaging.MessageQueue" /> e aguarda até que uma mensagem está disponível na fila, ou o tempo limite expirar.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pelo `transaction` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso deste método.  
  
 [!code-cpp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CPP/mqreceive_timeouttransaction.cpp#1)]
 [!code-csharp[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/CS/mqreceive_timeouttransaction.cs#1)]
 [!code-vb[MessageQueue.Receive_TimeoutTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Receive_TimeoutTransaction/VB/mqreceive_timeouttransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
 -ou-  
  
 A fila é não transacional.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a primeira mensagem disponível na fila referenciada pela <see cref="T:System.Messaging.MessageQueue" />. Esta chamada é síncrona e aguarda até que uma mensagem esteja disponível na fila ou que o tempo limite expire.</summary>
        <returns>Uma <see cref="T:System.Messaging.Message" /> que faz referência à primeira mensagem disponível na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornará as mensagens que execute na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler a primeira mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. O <xref:System.Messaging.MessageQueue.Peek%2A> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não haveria nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread será bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso deste método.  
  
 [!code-cpp[MessageQueue2#8](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#8)]
 [!code-csharp[MessageQueue2#8](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
 - ou -  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem atual na fila, usando um cursor especificado. Se nenhuma mensagem estiver disponível, esse método aguarda até que uma mensagem fica disponível, ou o tempo limite expirar.</summary>
        <returns>Um <see cref="T:System.Messaging.Message" /> que faz referência a uma mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila transacional usando o contexto de transação interna definido pelo `transaction` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornar as mensagens que execute na fila.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida é retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler uma mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não há nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread está bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> é inválido. Provavelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
 -ou-  
  
 A fila é não transacional.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Receive (TimeSpan timeout, System.Messaging.Cursor cursor, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message Receive(valuetype System.TimeSpan timeout, class System.Messaging.Cursor cursor, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Receive(System.TimeSpan,System.Messaging.Cursor,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="cursor" Type="System.Messaging.Cursor" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="cursor">Um <see cref="T:System.Messaging.Cursor" /> que mantém uma posição específica na fila de mensagens.</param>
        <param name="transactionType">Uma da <see cref="T:System.Messaging.MessageQueueTransactionType" /> valores que descreve o tipo de contexto de transação para associar com a mensagem.</param>
        <summary>Recebe a mensagem atual na fila, usando um cursor especificado. Se nenhuma mensagem estiver disponível, esse método aguarda até que uma mensagem fica disponível, ou o tempo limite expirar.</summary>
        <returns>Um <see cref="T:System.Messaging.Message" /> que faz referência a uma mensagem na fila.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para receber uma mensagem de uma fila usando um contexto de transação definido pelo `transactionType` parâmetro e retornar em um período especificado de tempo se não existem mensagens na fila.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.MessageQueue.Receive%2A> método permite a leitura síncrona de uma mensagem, removendo-la da fila. As chamadas subsequentes para <xref:System.Messaging.MessageQueue.Receive%2A> retornar as mensagens que execute na fila.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem recebida é retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler uma mensagem em uma fila sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.Peek%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.Peek%2A>. Porque <xref:System.Messaging.MessageQueue.Peek%2A> não remove quaisquer mensagens na fila, não há nada para reverter por uma chamada para <xref:System.Messaging.MessageQueueTransaction.Abort%2A>.  
  
 Use uma chamada para <xref:System.Messaging.MessageQueue.Receive%2A> quando é aceitável para o thread atual a ser bloqueado enquanto aguarda uma mensagem para chegar na fila. O thread está bloqueado para o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro. Se o processamento do aplicativo deve continuar sem esperar por uma mensagem, considere usar o método assíncrono, <xref:System.Messaging.MessageQueue.BeginReceive%2A>.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="cursor" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> é inválido. Provavelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem não chegou à fila antes do tempo limite expirar.  
  
 - ou -  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <threadsafe>O método não é thread-safe.</threadsafe>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação determinado (de uma fila não transacional) e imediatamente gerará uma exceção se nenhuma mensagem com o identificador de correlação especificado existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila não transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada ao aplicativo.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método recupera uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia e recebe uma mensagem que contém um pedido de e para uma fila. Ele solicita uma confirmação positiva especificamente quando a mensagem original atinge ou é recuperada da fila.  
  
 [!code-cpp[Message.Acknowledgment#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Message.Acknowledgment/CPP/message_acknowledgment.cpp#1)]
 [!code-csharp[Message.Acknowledgment#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Message.Acknowledgment/CS/message_acknowledgment.cs#1)]
 [!code-vb[Message.Acknowledgment#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Message.Acknowledgment/VB/message_acknowledgment.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação determinado (de uma fila transacional) e imediatamente gerará uma exceção se nenhuma mensagem com o identificador de correlação especificado existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada para o aplicativo usando o contexto de transação interna definido pelo `transaction` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#14](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#14)]
 [!code-csharp[MessageQueue2#14](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A fila é não transacional.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação especificado e imediatamente gerará uma exceção se nenhuma mensagem com o identificador de correlação especificado existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Se nenhuma mensagem for encontrada que corresponda a `correlationID` parâmetro, uma exceção será lançada. Caso contrário, a mensagem é removida da fila e retornada para o aplicativo usando um contexto de transação definido pelo `transactionType` parâmetro.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#11](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#11)]
 [!code-csharp[MessageQueue2#11](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação fornecido (de uma fila não transacional) e aguarda até uma mensagem com o identificador de correlação especificado estar disponível na fila ou até o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila não transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Este método retorna imediatamente se a mensagem com o identificador de correlação especificado o `correlationId` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#10](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#10)]
 [!code-csharp[MessageQueue2#10](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação determinado (de uma fila transacional) e aguarda até que uma mensagem com o identificador de correlação especificado está disponível na fila, ou o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Esse método retorna imediatamente quando a mensagem com o identificador de correlação especificado pelo `correlationId` parâmetro está na fila, usando o contexto de transação interna definido pelo `transaction` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#13](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#13)]
 [!code-csharp[MessageQueue2#13](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.  
  
 -ou-  
  
 A fila é não transacional.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByCorrelationId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByCorrelationId (string correlationId, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByCorrelationId(string correlationId, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByCorrelationId(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="correlationId" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="correlationId">O <see cref="P:System.Messaging.Message.CorrelationId" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador de correlação determinado e aguarda até que uma mensagem com o identificador de correlação especificado está disponível na fila, ou o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja <see cref="P:System.Messaging.Message.CorrelationId" /> corresponde ao parâmetro <paramref name="correlationId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método examina a fila referenciada pelo <xref:System.Messaging.MessageQueue> para uma mensagem cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde especificado `correlationId` parâmetro. Este método retorna imediatamente se a mensagem com o identificador de correlação especificado o `correlationId` parâmetro está na fila, usando um contexto de transação definido pelo `transactionType` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.CorrelationId%2A> da nova mensagem para ver se ele corresponde a `correlationId` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.CorrelationId%2A> corresponde a `correlationId` parâmetro. Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 O <xref:System.Messaging.Message.CorrelationId%2A> propriedade é usada para ligar uma mensagem enviada para a fila de mensagens de resposta, relatório ou confirmação associadas.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> método é usado para recuperar uma mensagem especificando seu identificador exclusivo.  
  
 Para ler uma mensagem com um identificador de correlação especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekByCorrelationId%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#12](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#12)]
 [!code-csharp[MessageQueue2#12](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="correlationId" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="correlationId" /> especificado.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A mensagem com o <paramref name="correlationId" /> especificado não existe na fila e não chegou antes do tempo limite expirar.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <summary>Recebe a mensagem que corresponde ao identificador fornecido (de uma fila não transacional) e gera uma exceção imediatamente se nenhuma mensagem com o identificador existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29>.  
  
 [!code-cpp[MessageQueue2#16](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#16)]
 [!code-csharp[MessageQueue2#16](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador determinado (de uma fila transacional) e imediatamente gerará uma exceção se nenhuma mensagem com o identificador especificado existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila, usando o contexto de transação interna definido pelo `transaction` parâmetro. Este método lança uma exceção imediatamente a mensagem não está na fila  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#17](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#17)]
 [!code-csharp[MessageQueue2#17](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A fila é não transacional.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador específico e imediatamente gerará uma exceção se nenhuma mensagem com o identificador especificado existe atualmente na fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila. Caso contrário, a mensagem é removida da fila e retornada para o aplicativo usando um contexto de transação definido pelo `transactionType` parâmetro.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Se a mensagem com o identificador especificado está em uma fila diferente daquele que está associado a esta <xref:System.Messaging.MessageQueue> instância, a mensagem não será localizada.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#15](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#15)]
 [!code-csharp[MessageQueue2#15](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="id" /> especificado.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <summary>Recebe a mensagem que corresponde ao identificador fornecido (de uma fila não transacional) e aguarda até uma mensagem com o identificador estar disponível na fila ou tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Esse método retorna imediatamente se a mensagem com o identificador especificado o `id` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada como continuam novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%29>.  
  
 [!code-cpp[MessageQueue2#20](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#20)]
 [!code-csharp[MessageQueue2#20](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem com o <paramref name="id" /> especificado não chegou à fila antes do tempo limite expirar.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Recebe a mensagem que corresponde ao identificador determinado (de uma fila transacional) e aguarda até que uma mensagem com o identificador especificado está disponível na fila ou o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila, usando o contexto de transação interna definido pelo `transaction` parâmetro. Esse método retorna imediatamente se a mensagem com o identificador especificado o `id` parâmetro está na fila. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada como continuam novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#18](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#18)]
 [!code-csharp[MessageQueue2#18](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem com o <paramref name="id" /> especificado não chegou à fila antes do tempo limite expirar.  
  
 -ou-  
  
 A fila é não transacional.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveById">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveById (string id, TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveById(string id, valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveById(System.String,System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.Messaging.Message.Id" /> da mensagem a ser recebida.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que indica o tempo de espera até que uma nova mensagem esteja disponível para inspeção.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Recebe a mensagem que corresponde ao identificador específico e aguarda até que uma mensagem com o identificador especificado está disponível na fila ou o tempo limite expirar.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.Id" /> corresponde ao parâmetro <paramref name="id" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador conhecido e removê-la da fila. Esse método retorna imediatamente se a mensagem com o identificador especificado o `id` parâmetro está na fila, usando um contexto de transação definido pelo `transactionType` parâmetro. Caso contrário, o método aguarda por determinado período de tempo para uma nova mensagem chegue. Se uma nova mensagem não chegar antes do tempo limite expirar, uma exceção será lançada.  
  
 O `timeout` parâmetro não especifica o total de tempo para esse método de execução. Em vez disso, ele especifica o tempo de espera por uma nova mensagem chegar na fila. Cada vez que uma nova mensagem chega, este método examina o <xref:System.Messaging.Message.Id%2A> da nova mensagem para ver se ele corresponde a `id` parâmetro. Caso contrário, esse método inicia o período de tempo limite em e aguarda até que outra nova mensagem chegue. Portanto, se continuarem novas mensagens chegarem dentro do período de tempo limite, é possível para esse método continuar a executar indefinidamente, até que o período de tempo limite expira sem novas mensagens que chegam, ou até que uma mensagem chega cujo <xref:System.Messaging.Message.Id%2A> corresponde a `id` parâmetro.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 O <xref:System.Messaging.Message.Id%2A> propriedade de uma mensagem é exclusiva em toda a empresa de enfileiramento de mensagens, para que haja no máximo uma mensagem na fila que corresponde a determinado `id` parâmetro. Se a mensagem com o identificador especificado está em uma fila diferente daquele que está associado a esta <xref:System.Messaging.MessageQueue> instância, a mensagem não será localizada.  
  
 Use essa sobrecarga de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%29> quando ele é aceitável para o thread atual a ser bloqueada como continuam novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro. O thread será bloqueado pelo menos o período de tempo ou indefinidamente se você especificou o valor <xref:System.Messaging.MessageQueue.InfiniteTimeout> para o `timeout` parâmetro, ou se novas mensagens chegam na fila de dentro do período de tempo limite especificado pelo `timeout` parâmetro.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Dois outros métodos permitem que você receber mensagens de uma fila. O <xref:System.Messaging.MessageQueue.Receive%2A> método retorna a primeira mensagem na fila e o <xref:System.Messaging.MessageQueue.ReceiveByCorrelationId%28System.String%29> método é usado para recuperar uma confirmação, o relatório ou a mensagem de resposta geradas pelo aplicativo que foi criada como resultado de uma mensagem enviada para a fila.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método. O <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> método sempre retorna a primeira mensagem na fila, para que as chamadas subsequentes para o método retornarem a mesma mensagem, a menos que uma mensagem de prioridade mais alta chega na fila. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekById%28System.String%29>. Porque <xref:System.Messaging.MessageQueue.PeekById%28System.String%29> não remove quaisquer mensagens na fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ReceiveById%28System.String%2CSystem.TimeSpan%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#19](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#19)]
 [!code-csharp[MessageQueue2#19](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O valor especificado para o parâmetro <paramref name="timeout" /> não é válido, possivelmente <paramref name="timeout" /> é menor que <see cref="F:System.TimeSpan.Zero" /> ou maior que <see cref="F:System.Messaging.MessageQueue.InfiniteTimeout" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Uma mensagem com o <paramref name="id" /> especificado não chegou à fila antes do tempo limite expirar.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (long lookupId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(int64 lookupId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lookupId" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> da mensagem a ser recebida.</param>
        <summary>Introduzido no MSMQ 3.0. Recebe a mensagem que corresponde ao identificador de pesquisa especificado de uma fila não transacional.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> cuja propriedade <see cref="P:System.Messaging.Message.LookupId" /> corresponde ao parâmetro <paramref name="lookupId" /> passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e removê-la da fila. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador de pesquisa especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="action">Uma da <see cref="T:System.Messaging.MessageLookupAction" /> valores, especificando como a mensagem é lida na fila. Especifique um dos seguintes:  
  
 <see langword="MessageLookupAction.Current" />: Recebe a mensagem especificada pelo <c>lookupId</c> e as remove da fila.  
  
 <see langword="MessageLookupAction.Next" />: Recebe a mensagem seguinte à mensagem especificada pelo <c>lookupId</c> e as remove da fila.  
  
 <see langword="MessageLookupAction.Previous" />: Recebe a mensagem anterior a mensagem especificada pelo <c>lookupId</c> e as remove da fila.  
  
 <see langword="MessageLookupAction.First" />: Recebe a primeira mensagem na fila e a remove da fila. O <c>lookupId</c> parâmetro deve ser definido como 0.  
  
 <see langword="MessageLookupAction.Last" />: Recebe a última mensagem na fila e a remove da fila. O <c>lookupId</c> parâmetro deve ser definido como 0.</param>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> de mensagem para receber ou 0. 0 é usado para acessar a primeira ou última mensagem na fila.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Introduzido no MSMQ 3.0. Recebe uma mensagem específica de uma fila transacional. A mensagem pode ser especificada por um identificador de pesquisa ou por sua posição no início ou no final da fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> especificado pelo <paramref name="lookupId" /> e <paramref name="action" /> parâmetros passados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e removê-la da fila, usando um contexto de transação definido pelo `transaction` parâmetro. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Como esse método é chamado em uma fila transacional, a mensagem recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Porque <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> não remove quaisquer mensagens da fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.  
  
 -ou-  
  
 A fila é não transacional.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="action" /> não é um dos membros do <see cref="T:System.Messaging.MessageLookupAction" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveByLookupId">
      <MemberSignature Language="C#" Value="public System.Messaging.Message ReceiveByLookupId (System.Messaging.MessageLookupAction action, long lookupId, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message ReceiveByLookupId(valuetype System.Messaging.MessageLookupAction action, int64 lookupId, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ReceiveByLookupId(System.Messaging.MessageLookupAction,System.Int64,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Messaging.MessageLookupAction" />
        <Parameter Name="lookupId" Type="System.Int64" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="action">Uma da <see cref="T:System.Messaging.MessageLookupAction" /> valores, especificando como a mensagem é lida na fila. Especifique um dos seguintes:  
  
 <see langword="MessageLookupAction.Current" />: Recebe a mensagem especificada pelo <c>lookupId</c> e as remove da fila.  
  
 <see langword="MessageLookupAction.Next" />: Recebe a mensagem seguinte à mensagem especificada pelo <c>lookupId</c> e as remove da fila.  
  
 <see langword="MessageLookupAction.Previous" />: Recebe a mensagem anterior a mensagem especificada pelo <c>lookupId</c> e as remove da fila.  
  
 <see langword="MessageLookupAction.First" />: Recebe a primeira mensagem na fila e a remove da fila. O <c>lookupId</c> parâmetro deve ser definido como 0.  
  
 <see langword="MessageLookupAction.Last" />: Recebe a última mensagem na fila e a remove da fila. O <c>lookupId</c> parâmetro deve ser definido como 0.</param>
        <param name="lookupId">O <see cref="P:System.Messaging.Message.LookupId" /> de mensagem para receber ou 0. 0 é usado para acessar a primeira ou última mensagem na fila.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Introduzido no MSMQ 3.0. Recebe uma mensagem específica da fila, usando o contexto de transação especificado. A mensagem pode ser especificada por um identificador de pesquisa ou por sua posição no início ou no final da fila.</summary>
        <returns>O <see cref="T:System.Messaging.Message" /> especificado pelo <paramref name="action" /> e <paramref name="lookupId" /> parâmetros passados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para ler uma mensagem com um identificador de pesquisa conhecidos e removê-la da fila, usando um contexto de transação definido pelo `transactionType` parâmetro. Este método lança uma exceção imediatamente a mensagem não está na fila.  
  
 O <xref:System.Messaging.Message.LookupId%2A> propriedade de uma mensagem é exclusiva para a fila onde reside a mensagem, para que haja no máximo uma mensagem na fila que corresponde a determinado `lookupId` parâmetro.  
  
 Para ler uma mensagem com um identificador especificado sem removê-la da fila, use o <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> método. Não há nenhum contexto de transação associado com uma mensagem retornada por uma chamada para <xref:System.Messaging.MessageQueue.PeekByLookupId%2A>. Porque <xref:System.Messaging.MessageQueue.PeekByLookupId%2A> não remove quaisquer mensagens da fila, não haveria nada para ser revertida se a transação foi anulada.  
  
 Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para receber a mensagem. Especificar `Single` se você deseja receber a mensagem como uma única transação interna. Você pode especificar `None` se você quiser receber uma mensagem de uma fila transacional fora de um contexto de transação.  
  
 Se esse método é chamado para receber uma mensagem de uma fila transacional, a mensagem é recebida será retornada para a fila se a transação foi anulada. A mensagem não é permanentemente removida da fila até que a transação é confirmada.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">O MSMQ 3.0 não está instalado.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível localizar a mensagem com o <paramref name="lookupId" /> especificado.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="action" /> não é um dos membros do <see cref="T:System.Messaging.MessageLookupAction" />.  
  
 -ou-  
  
 O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveCompleted">
      <MemberSignature Language="C#" Value="public event System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Messaging.ReceiveCompletedEventHandler ReceiveCompleted" />
      <MemberSignature Language="DocId" Value="E:System.Messaging.MessageQueue.ReceiveCompleted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_ReceiveCompleted")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Messaging.ReceiveCompletedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando uma mensagem foi removida da fila. Esse evento é gerado pela operação assíncrona, <see cref="M:System.Messaging.MessageQueue.BeginReceive" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.BeginReceive%2A>é usada no processamento assíncrono para gerar o <xref:System.Messaging.MessageQueue.ReceiveCompleted> quando uma mensagem fica disponível na fila de eventos.  
  
 <xref:System.Messaging.MessageQueue.EndReceive%28System.IAsyncResult%29>é usado para concluir a operação iniciada por uma chamada para <xref:System.Messaging.MessageQueue.BeginReceive%2A> e inspecionar mensagem quando o <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado.  
  
 Quando você cria um <xref:System.Messaging.ReceiveCompletedEventHandler> delegado, você identificar o método que manipulará o evento. Para associar o evento com o manipulador de eventos, adicione uma instância do representante ao evento. O manipulador de eventos é chamado sempre que o evento ocorre, a menos que você remova o representante. Para obter mais informações sobre delegados de manipulador de eventos, consulte [NIB: eventos e delegados](http://msdn.microsoft.com/en-us/d98fd58b-fa4f-4598-8378-addf4355a115).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um manipulador de eventos chamado `MyReceiveCompleted`, anexa-o para o <xref:System.Messaging.MessageQueue.ReceiveCompleted> representante do manipulador de eventos e chamadas <xref:System.Messaging.MessageQueue.BeginReceive%2A> para iniciar uma recepção assíncrona a operação na fila que está localizada no caminho ". \myQueue". Quando um <xref:System.Messaging.MessageQueue.ReceiveCompleted> é gerado, o exemplo recebe a mensagem e grava seu corpo para a tela. O exemplo, em seguida, chama <xref:System.Messaging.MessageQueue.BeginReceive%2A> novamente para iniciar um novo assíncrona operação de recebimento.  
  
 [!code-cpp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CPP/mqreceivecompletedeventhandler.cpp#1)]
 [!code-csharp[MessageQueue.ReceiveCompleted#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/CS/mqreceivecompletedeventhandler.cs#1)]
 [!code-vb[MessageQueue.ReceiveCompleted#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.ReceiveCompleted/VB/mqreceivecompletedeventhandler.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Atualiza as propriedades apresentadas pelo <see cref="T:System.Messaging.MessageQueue" /> para refletir o estado atual do recurso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Messaging.MessageQueue.Refresh%2A>sincroniza as propriedades de um <xref:System.Messaging.MessageQueue> com seus recursos de servidor de enfileiramento de mensagens associado. Se qualquer propriedade, como <xref:System.Messaging.MessageQueue.Label%2A> ou <xref:System.Messaging.MessageQueue.Category%2A>, foi alterado no servidor desde a hora de <xref:System.Messaging.MessageQueue> foi criado, <xref:System.Messaging.MessageQueue.Refresh%2A> atualizações a <xref:System.Messaging.MessageQueue> com as novas informações.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Refresh%2A>.  
  
 [!code-cpp[MessageQueue2#28](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#28)]
 [!code-csharp[MessageQueue2#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetPermissions">
      <MemberSignature Language="C#" Value="public void ResetPermissions ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetPermissions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.ResetPermissions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine a lista de permissão para os valores padrão do sistema operacional. Remove qualquer permissão de fila que você tenha anexado à lista padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama <xref:System.Messaging.MessageQueue.ResetPermissions%2A>, retornar a lista de permissão para seus valores padrão. Em geral, isso concede todas as permissões do criador da fila e concede ao grupo todos os seguintes direitos:  
  
-   Obtenha as propriedades da fila.  
  
-   Obter as permissões da fila.  
  
-   Grave na fila.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.ResetPermissions%2A>.  
  
 [!code-cpp[MessageQueue2#27](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#27)]
 [!code-csharp[MessageQueue2#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <summary>Envia um objeto a uma fila não transacional referenciada por essa <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila transacional, a mensagem será enviada para a fila de mensagens mortas. Se você quiser que a mensagem seja parte de uma transação que contém outras mensagens, use uma sobrecarga que utiliza um <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> como um parâmetro.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a uma fila de mensagens e envia uma mensagem à fila.  
  
 [!code-cpp[MessageQueue.Send_obj#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_obj/CPP/mqsend_generic.cpp#1)]
 [!code-csharp[MessageQueue.Send_obj#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_obj/CS/mqsend_generic.cs#1)]
 [!code-vb[MessageQueue.Send_obj#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_obj/VB/mqsend_generic.vb#1)]  
  
 O exemplo de código a seguir envia um aplicativo definido `Order` classe para uma fila e, em seguida, recebe uma mensagem de fila.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envia um objeto para a fila transacional referenciada por este <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação interna definido pelo `transaction` parâmetro. O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila não transacional, a mensagem pode ser enviada para a fila de mensagens mortas sem lançar uma exceção.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 <xref:System.Messaging.MessageQueueTransaction>é de thread apartment com suporte, portanto, se o estado de apartment é `STA`, você não pode usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar o <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o seguinte fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir envia uma cadeia de caracteres para uma fila transacional e, em seguida, recebe uma mensagem de fila.  
  
 [!code-cpp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CPP/mqsend_objtransaction.cpp#1)]
 [!code-csharp[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/CS/mqsend_objtransaction.cs#1)]
 [!code-vb[MessageQueue.Send_ObjectTransaction#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.Send_ObjectTransaction/VB/mqsend_objtransaction.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
 -ou-  
  
 O aplicativo do serviço de enfileiramento de mensagens indicou um uso incorreto de transações.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Envia um objeto para a fila referenciada por esse <see cref="T:System.Messaging.MessageQueue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação definido pelo `transactionType` parâmetro. Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para enviar a mensagem. Especificar `Single` se você deseja enviar a mensagem como uma única transação interna. Você pode especificar `None` se você quiser enviar uma mensagem transacional para um thread não-transacional.  
  
 O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#2](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#2)]
 [!code-csharp[MessageQueue2#2](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="label">O rótulo da mensagem.</param>
        <summary>Envia um objeto para a fila não transacional referenciada por este <see cref="T:System.Messaging.MessageQueue" /> e especifica um rótulo para a mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem. O objeto que você envia para a fila pode ser uma <xref:System.Messaging.Message>, uma estrutura, um objeto de dados ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm herdar significado para enfileiramento de mensagens.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila transacional, a mensagem será enviada para a fila de mensagens mortas. Se você quiser que a mensagem seja parte de uma transação que contém outras mensagens, use uma sobrecarga que utiliza um <xref:System.Messaging.MessageQueueTransaction> ou <xref:System.Messaging.MessageQueueTransactionType> como um parâmetro.  
  
 O <xref:System.Messaging.MessageQueue.Path%2A> propriedade para este <xref:System.Messaging.MessageQueue> instância deve ser especificada antes de enviar a mensagem. Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%29>.  
  
 [!code-cpp[MessageQueue2#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#1)]
 [!code-csharp[MessageQueue2#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="label">O rótulo da mensagem.</param>
        <param name="transaction">O objeto <see cref="T:System.Messaging.MessageQueueTransaction" />.</param>
        <summary>Envia um objeto para a fila transacional referenciada por este <see cref="T:System.Messaging.MessageQueue" /> e especifica um rótulo para a mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila transacional referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação interna definido pelo `transaction` parâmetro. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem. O objeto que você envia para a fila pode ser uma <xref:System.Messaging.Message>, uma estrutura, um objeto de dados ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm herdar significado para enfileiramento de mensagens.  
  
 Se você usar essa sobrecarga para enviar uma mensagem para uma fila não transacional, a mensagem pode ser enviada para a fila de mensagens mortas sem lançar uma exceção.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade  
  
 <xref:System.Messaging.MessageQueueTransaction>é de thread apartment com suporte, portanto, se o estado de apartment é `STA`, você não pode usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar o <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o seguinte fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransaction%29>.  
  
 [!code-cpp[MessageQueue2#4](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#4)]
 [!code-csharp[MessageQueue2#4](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="transaction" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
 - ou -  
  
 O aplicativo do serviço de enfileiramento de mensagens indicou um uso incorreto de transação.  
  
 - ou -  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public void Send (object obj, string label, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Send(object obj, string label, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.Send(System.Object,System.String,System.Messaging.MessageQueueTransactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="label" Type="System.String" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser enviado à fila.</param>
        <param name="label">O rótulo da mensagem.</param>
        <param name="transactionType">Um dos valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que descreve o tipo de contexto de transação associado à mensagem.</param>
        <summary>Envia um objeto para a fila referenciada por este <see cref="T:System.Messaging.MessageQueue" /> e especifica um rótulo para a mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para enviar uma mensagem que contém o `obj` parâmetro para a fila referenciada pelo <xref:System.Messaging.MessageQueue>, usando um contexto de transação definido pelo `transactionType` parâmetro. Especifique `Automatic` para o `transactionType` parâmetro se já houver um contexto de transação externa é anexado ao thread que você deseja usar para enviar a mensagem. Especificar `Single` se você deseja enviar a mensagem como uma única transação interna. Você pode especificar `None` se você quiser enviar uma mensagem transacional para um thread não-transacional.  
  
 O objeto que você envia para a fila pode ser um <xref:System.Messaging.Message> ou qualquer objeto gerenciado. Se você enviar qualquer objeto diferente de um <xref:System.Messaging.Message>, o objeto é serializado e inserido no corpo da mensagem. Com essa sobrecarga, você pode especificar o rótulo de cadeia de caracteres que identifica a mensagem.  
  
 O rótulo da mensagem é diferente do rótulo da fila de mensagem, mas ambos são dependentes do aplicativo e não têm herdar significado para enfileiramento de mensagens.  
  
 Se você não definir a <xref:System.Messaging.MessageQueue.Formatter%2A> propriedade antes de chamar <xref:System.Messaging.MessageQueue.Send%28System.Object%29>, o formatador padrão é o <xref:System.Messaging.XmlMessageFormatter>.  
  
 O <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> propriedade se aplica a qualquer objeto diferente de um <xref:System.Messaging.Message>. Se você especificar, por exemplo, um rótulo ou uma prioridade usando o <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A> membro, esses valores se aplicam a qualquer mensagem que contém um objeto que não é do tipo <xref:System.Messaging.Message> quando o seu aplicativo a envia para a fila. Ao enviar um <xref:System.Messaging.Message>, os valores de propriedade definidos para o <xref:System.Messaging.Message> têm precedência sobre <xref:System.Messaging.MessageQueue.DefaultPropertiesToSend%2A>e a mensagem <xref:System.Messaging.Message.Formatter%2A?displayProperty=nameWithType> propriedade tem precedência sobre a fila <xref:System.Messaging.MessageQueue.Formatter%2A?displayProperty=nameWithType> propriedade.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.Send%28System.Object%2CSystem.String%2CSystem.Messaging.MessageQueueTransactionType%29>.  
  
 [!code-cpp[MessageQueue2#3](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#3)]
 [!code-csharp[MessageQueue2#3](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="label" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueTransaction">O aplicativo do serviço de enfileiramento de mensagens indicou um uso incorreto de transação.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O parâmetro <paramref name="transactionType" /> não é um dos membros do <see cref="T:System.Messaging.MessageQueueTransactionType" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">A propriedade <see cref="P:System.Messaging.MessageQueue.Path" /> não foi definida.  
  
 -ou-  
  
 Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.AccessControlList dacl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.AccessControlList dacl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.AccessControlList)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dacl" Type="System.Messaging.AccessControlList" />
      </Parameters>
      <Docs>
        <param name="dacl">Um <see cref="T:System.Messaging.AccessControlList" /> que contém uma ou mais entradas de controle de acesso que especificam os objetos de confiança e as permissões a serem concedidas.</param>
        <summary>Atribui direitos de acesso à fila com base no conteúdo de uma lista de controle de acesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar direitos por meio de uma coleção de entradas de controle de acesso para especificar informações de objeto de confiança e permissões. Isso é usado, por exemplo, para conceder permissões a vários usuários ao mesmo tempo.  
  
 O objeto de confiança especificado quando você cria o `ace` parâmetro pode ser um usuário individual, um grupo de usuários ou um computador. Se o objeto de confiança é um indivíduo, use o formato `DOMAIN` \\ `user`. Você pode especificar "." para o objeto de confiança indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Quando você cria o `dacl` parâmetro, adicione <xref:System.Messaging.AccessControlEntry> instâncias do seu <xref:System.Messaging.AccessControlList> coleção. Quando você construir cada entrada de controle de acesso, você pode especificar os direitos de acesso genérico ou padrão. Os direitos para uma fila podem ser qualquer combinação das seguintes opções:  
  
-   Excluir  
  
-   Segurança de leitura  
  
-   Segurança de gravação  
  
-   Sincronizar  
  
-   Modificar proprietário  
  
-   Ler  
  
-   Write  
  
-   Executar  
  
-   Necessária  
  
-   Todos  
  
-   Nenhum  
  
 Esses direitos são um conjunto de sinalizadores de bit que você pode combinar usando o operador OR de bit a bit.  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.AccessControlList%29>.      
  
 [!code-cpp[MessageQueue2#26](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#26)]
 [!code-csharp[MessageQueue2#26](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#26)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (System.Messaging.MessageQueueAccessControlEntry ace);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(class System.Messaging.MessageQueueAccessControlEntry ace) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.Messaging.MessageQueueAccessControlEntry)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ace" Type="System.Messaging.MessageQueueAccessControlEntry" />
      </Parameters>
      <Docs>
        <param name="ace">Um <see cref="T:System.Messaging.MessageQueueAccessControlEntry" /> que especifica um usuário, um tipo de acesso e um tipo de permissão.</param>
        <summary>Atribui direitos de acesso para a fila com base no conteúdo de uma entrada de controle de acesso.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar direitos por meio de uma entrada de controle de acesso para especificar o objeto de confiança e informações de direitos.  
  
 O objeto de confiança especificado quando você cria o `ace` parâmetro pode ser um usuário individual, um grupo de usuários ou um computador. Se o objeto de confiança é um indivíduo, use o formato `DOMAIN` \\ `user`. Você pode especificar "." para o objeto de confiança indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Os direitos para uma fila, que você especificar na `rights` parâmetro quando você construir o <xref:System.Messaging.MessageQueueAccessControlEntry>, pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 O `rights` parâmetro que você especificar no construtor para o `ace` parâmetro é um sinalizador do <xref:System.Messaging.MessageQueueAccessRights> enumeração. Representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou quando você cria o `rights` parâmetro.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.Messaging.MessageQueueAccessControlEntry%29>.  
  
 [!code-cpp[MessageQueue2#24](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#24)]
 [!code-csharp[MessageQueue2#24](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#24)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
      </Parameters>
      <Docs>
        <param name="user">O indivíduo, grupo ou computador que obtém direitos adicionais para a fila.</param>
        <param name="rights">Um <see cref="T:System.Messaging.MessageQueueAccessRights" /> que indica o conjunto de direitos para a fila de enfileiramento de mensagens atribui para a <c>usuário</c> passado.</param>
        <summary>Fornece os direitos de acesso especificados a um computador, grupo ou usuário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder direitos especificados para um usuário individual. O usuário pode ser qualquer objeto de confiança válido, o que inclui usuários individuais, grupos de usuários ou um computador. Se o usuário for um indivíduo, use o formato `DOMAIN` \\ `user` para o `user` parâmetro. Você pode especificar "." para o `user` parâmetro para indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Os direitos para uma fila, especificado no `rights` parâmetro pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 O <xref:System.Messaging.MessageQueueAccessRights> enumeração representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou para criar o `rights` parâmetro.  
  
 Com essa sobrecarga, você só pode conceder permissões; Você não pode revogar ou negar. Você deve usar uma sobrecarga diferente para conceder explicitamente qualquer <xref:System.Messaging.AccessControlEntryType> que `Allow`.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%29>.  
  
 [!code-cpp[MessageQueue2#23](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#23)]
 [!code-csharp[MessageQueue2#23](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <paramref name="user" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetPermissions">
      <MemberSignature Language="C#" Value="public void SetPermissions (string user, System.Messaging.MessageQueueAccessRights rights, System.Messaging.AccessControlEntryType entryType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPermissions(string user, valuetype System.Messaging.MessageQueueAccessRights rights, valuetype System.Messaging.AccessControlEntryType entryType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageQueue.SetPermissions(System.String,System.Messaging.MessageQueueAccessRights,System.Messaging.AccessControlEntryType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="user" Type="System.String" />
        <Parameter Name="rights" Type="System.Messaging.MessageQueueAccessRights" />
        <Parameter Name="entryType" Type="System.Messaging.AccessControlEntryType" />
      </Parameters>
      <Docs>
        <param name="user">O indivíduo, grupo ou computador que obtém direitos adicionais para a fila.</param>
        <param name="rights">Um <see cref="T:System.Messaging.MessageQueueAccessRights" /> que indica o conjunto de direitos para a fila de enfileiramento de mensagens atribui para a <c>usuário</c> passado.</param>
        <param name="entryType">Um <see cref="T:System.Messaging.AccessControlEntryType" /> que especifica se deve conceder, negar ou revogar as permissões especificadas pelo <c>direitos</c> parâmetro.</param>
        <summary>Fornece a um computador, grupo ou usuário os direitos de acesso especificados, com o tipo de controle de acesso especificado (permitir, negar, revogar ou definir).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para conceder, negar ou revogar direitos especificados para um usuário individual. O usuário pode ser qualquer objeto de confiança válido, o que inclui usuários individuais, grupos de usuários ou um computador. Se o usuário for um indivíduo, use o formato `DOMAIN` \\ `user` para o `user` parâmetro. Você pode especificar "." para o `user` parâmetro para indicar o computador local.  
  
 As permissões atribuídas a <xref:System.Messaging.MessageQueue.SetPermissions%2A> adicionar direitos à lista existente. Por padrão, o criador de uma fila pública ou privada tem controle total e o grupo de domínio todos têm permissão para obter as propriedades de fila, obter permissões e gravar na fila. Quando você chama <xref:System.Messaging.MessageQueue.SetPermissions%2A>, as informações de permissões de usuário e são anexadas à parte inferior da lista existente.  
  
 O sistema examina cada <xref:System.Messaging.AccessControlEntry> na sequência até que ocorra um dos seguintes eventos:  
  
-   Um acesso negado <xref:System.Messaging.AccessControlEntry> nega explicitamente qualquer um dos direitos de acesso solicitado a um dos objetos de confiança mencionados no token de acesso do thread.  
  
-   Um ou mais acesso permitidos <xref:System.Messaging.AccessControlEntry> itens para objetos de confiança explicitamente listados no token de acesso do thread concedem os direitos de acesso solicitado.  
  
-   Todos os <xref:System.Messaging.AccessControlEntry> itens foram verificados e há ainda pelo menos um solicitada direito de acesso que não foi explicitamente permitido, nesse caso, o acesso é negado implicitamente.  
  
 Os direitos para uma fila, especificado no `rights` parâmetro pode ser qualquer combinação das seguintes opções:  
  
-   Controle total  
  
-   Excluir mensagem  
  
-   Receber mensagem  
  
-   Inspecionar mensagem  
  
-   Receber mensagens do diário  
  
-   Obter propriedades de fila  
  
-   Definir propriedades de fila  
  
-   Obter permissões  
  
-   Conjunto de permissões  
  
-   Assumir a propriedade de fila  
  
-   Gravar a mensagem  
  
 O <xref:System.Messaging.MessageQueueAccessRights> enumeração representa um conjunto de sinalizadores de bit que você pode combinar usando o operador bit a bit ou para criar o `rights` parâmetro.  
  
 A tabela a seguir mostra se este método está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de <xref:System.Messaging.MessageQueue.SetPermissions%28System.String%2CSystem.Messaging.MessageQueueAccessRights%2CSystem.Messaging.AccessControlEntryType%29>.  
  
 [!code-cpp[MessageQueue2#25](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue2/cpp/class1.cpp#25)]
 [!code-csharp[MessageQueue2#25](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue2/CS/class1.cs#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_SynchronizingObject")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto que controla a chamada do manipulador de eventos resultantes de um <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ou <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> eventos.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISynchronizeInvoke" />, que representa o objeto que controla a chamada do manipulador de eventos resultantes de um <see cref="E:System.Messaging.MessageQueue.ReceiveCompleted" /> ou <see cref="E:System.Messaging.MessageQueue.PeekCompleted" /> eventos. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Messaging.MessageQueue.ReceiveCompleted> ou <xref:System.Messaging.MessageQueue.PeekCompleted> evento resulta de uma <xref:System.Messaging.MessageQueue.BeginReceive%2A> ou <xref:System.Messaging.MessageQueue.BeginPeek%2A> solicitar, respectivamente, para um segmento específico. Normalmente, o <xref:System.Messaging.MessageQueue.SynchronizingObject%2A> é definido quando o componente relacionado é colocado dentro de um controle ou formulário, porque esses componentes estão associados a um segmento específico.  
  
 Normalmente, o objeto de sincronização realiza marshaling de uma chamada de método em um único thread.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Transactional">
      <MemberSignature Language="C#" Value="public bool Transactional { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Transactional" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.Transactional" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_Transactional")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a fila aceita apenas as transações.</summary>
        <value>
          <see langword="true" /> se a fila aceita apenas mensagens enviadas como parte de uma transação; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mensagens transacionais refere-se a união de várias mensagens relacionadas em uma única transação. Envio de mensagens como parte de uma transação assegura que as mensagens são entregues em ordem, entregue apenas uma vez e recuperados com êxito da sua fila de destino.  
  
 Se uma fila for transacional, ele aceita apenas mensagens que são enviadas como parte de uma transação. No entanto, uma mensagem não transacional pode ser enviada ou recebida de uma fila de transação local sem explicitamente usando transacional <xref:System.Messaging.MessageQueueTransaction.Begin%2A>, <xref:System.Messaging.MessageQueueTransaction.Commit%2A>, e <xref:System.Messaging.MessageQueueTransaction.Abort%2A> sintaxe. Se uma mensagem não transacional é enviada para uma fila transacional, esse componente cria uma transação de mensagem única para ele, exceto no caso de referência a uma fila em um computador remoto usando um nome de formato direto. Nessa situação, se você não especificar um contexto de transação ao enviar uma mensagem, ela não é criada para você e a mensagem será enviada para a fila de mensagens mortas.  
  
 Se você enviar uma mensagem não transacional para uma fila transacional, você não poderá reverter a mensagem em caso de uma exceção.  
  
 <xref:System.Messaging.MessageQueueTransaction>é de thread apartment com suporte, portanto, se o estado de apartment é `STA`, você não pode usar a transação em vários threads. Visual Basic define o estado do thread principal para `STA`, portanto, você deve aplicar o <xref:System.MTAThreadAttribute> no `Main` sub-rotina. Caso contrário, o envio de uma mensagem transacional usando outro thread gerará uma exceção <xref:System.Messaging.MessageQueueException>. Aplicar o <xref:System.MTAThreadAttribute> usando o seguinte fragmento.  
  
```vb  
<System.MTAThreadAttribute>  
 public sub Main()  
```  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir exibe o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.Transactional%2A> propriedade.  
  
 [!code-csharp[MessageQueue#27](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#27)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseJournalQueue">
      <MemberSignature Language="C#" Value="public bool UseJournalQueue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseJournalQueue" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.UseJournalQueue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as mensagens recebidas são copiadas para a fila de diário.</summary>
        <value>
          <see langword="true" />Se as mensagens recebidas da fila são copiadas para a sua fila de diário; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o aplicativo do serviço de enfileiramento de mensagens cria uma nova fila de aplicativo, ele cria automaticamente uma fila de diário associado no mesmo local. A fila de diário é usada para rastrear as mensagens removidas da fila. A definição dessa propriedade modifica o enfileiramento de mensagens. Portanto, qualquer outro <xref:System.Messaging.MessageQueue> instâncias são afetadas pela alteração.  
  
 A fila de diário não controla mensagens removidas da fila porque o timer de seu tempo de recebimento expirou, nem acompanha mensagens limpas da fila usando um serviço de diretório enfileiramento de mensagens (armazenamento de informações ou do Active Directory).  
  
 Aplicativos não podem enviar mensagens para filas de diário; eles são limitados a acesso somente leitura dessas filas. Além disso, enfileiramento de mensagens nunca remove as mensagens das filas de diário. O aplicativo usando a fila deve limpar essas mensagens recebê-los ou limpar a fila.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Não|  
  
   
  
## Examples  
 O exemplo de código a seguir obtém e define o valor de uma fila de mensagens <xref:System.Messaging.MessageQueue.UseJournalQueue%2A> propriedade.  
  
 [!code-csharp[MessageQueue#28](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue/CS/class1.cs#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">Erro ao acessar um método do serviço de Enfileiramento de Mensagens.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteHandle">
      <MemberSignature Language="C#" Value="public IntPtr WriteHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int WriteHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageQueue.WriteHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Messaging.MessagingDescription("MQ_WriteHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador nativo usado para enviar mensagens para a fila de mensagens.</summary>
        <value>Um identificador para o objeto de fila nativo que você usa para enviar mensagens à fila.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Messaging.MessageQueue.WriteHandle%2A> fornece um identificador nativo do Windows para o objeto de fila de mensagem que é usado para enviar mensagens à fila. Se você alterar o caminho da fila, o identificador é fechado e reaberto com um novo valor.  
  
 A tabela a seguir mostra se essa propriedade está disponível nos vários modos de grupo de trabalho.  
  
|Modo de grupo de trabalho|Disponível|  
|--------------------|---------------|  
|Computador local|Sim|  
|Computador local e o nome de formato direto|Sim|  
|Computador remoto|Não|  
|Computador remoto e o nome de formato direto|Sim|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException">A fila de mensagens não está disponível para gravação.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
