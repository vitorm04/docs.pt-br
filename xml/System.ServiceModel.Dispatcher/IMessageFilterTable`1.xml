<Type Name="IMessageFilterTable&lt;TFilterData&gt;" FullName="System.ServiceModel.Dispatcher.IMessageFilterTable&lt;TFilterData&gt;">
  <TypeSignature Language="C#" Value="public interface IMessageFilterTable&lt;TFilterData&gt; : System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;, System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IMessageFilterTable`1&lt;TFilterData&gt; implements class System.Collections.Generic.ICollection`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.Generic.IDictionary`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.ServiceModel.Dispatcher.MessageFilter, !TFilterData&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Dispatcher.IMessageFilterTable`1" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TFilterData" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IDictionary&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.ServiceModel.Dispatcher.MessageFilter,TFilterData&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="TFilterData">O tipo de dados associados a cada filtro na tabela.</typeparam>
    <summary>Um <see langword="interface" /> que define o contrato que uma tabela de filtro deve implementar para inspecionar mensagens com critérios de consulta derivados de um ou mais filtros.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela de filtro é um componente principal do mecanismo de filtro. O principal uso do mecanismo de filtro no [!INCLUDE[indigo1](~/includes/indigo1-md.md)] é corresponder a lógica do aplicativo para mensagens, localizando todos os filtros que correspondem a uma mensagem.  
  
 Uma tabela de filtro permite que vários filtros a serem correspondidos em relação a uma única mensagem com mais eficiência do que pode ser correspondidos separadamente. Uma tabela de filtro associa dados de filtro com filtros. A tabela é uma coleção de pares chave-valor, onde a chave é o <xref:System.ServiceModel.Dispatcher.MessageFilter>, e o valor de dados de filtro associado. Dados de filtro podem ser quaisquer dados do tipo especificado no parâmetro genérico e podem ser usados para especificar quais ações a serem tomadas se uma mensagem for atendida por um filtro na tabela.  
  
 Filtrar entradas de tabela podem ser acessadas usando o <xref:System.Collections.Generic.IDictionary%602> funcionalidade que <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601> herda.  
  
 Observe que uma instância de filtro só pode ser adicionada a um determinado <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601> depois. Para adicionar várias instâncias desse filtro para a mesma tabela de filtro, use um construtor de filtro para criar instâncias adicionais.  
  
 Um filtro corresponde a uma mensagem quando a mensagem satisfaz os critérios de consulta do filtro. Há quatro métodos sobrecarregados de correspondência. Os dados retornados são os dados de filtro ou <xref:System.ServiceModel.Dispatcher.MessageFilter> objetos em si. Esses dados são retornados se várias correspondências são permitidas ou corresponder a um único. A tabela a seguir mostra essas informações para cada sobrecarga.  
  
|Nome do método|Correspondências|Dados retornados|  
|-----------------|-------------|-------------------|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A>|Simples|`FilterData`|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A>|Simples|<xref:System.ServiceModel.Dispatcher.MessageFilter>|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A>|Múltiplo|`FilterData`|  
|<xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>|Múltiplo|Objetos <xref:System.ServiceModel.Dispatcher.MessageFilter>|  
  
 Cada método contém duas sobrecargas. A diferença entre as duas sobrecargas é que um recebe um <xref:System.ServiceModel.Channels.Message> parâmetro e não é permitida para examinar o conteúdo do corpo; o outro utiliza um <xref:System.ServiceModel.Channels.MessageBuffer> parâmetro e pode examinar qualquer parte da mensagem. Se você chamar um método com o parâmetro da mensagem e a tabela de filtro contém um filtro que examina o conteúdo do corpo da mensagem, uma exceção será lançada. Se você não tiver certeza sobre os filtros em uma tabela, chame a sobrecarga que utiliza um buffer de mensagem.  
  
 Cabeçalhos de mensagem são automaticamente armazenados em buffer e podem ser inspecionados por um filtro sem ser consumido. Mas se o corpo é a serem inspecionadas por um filtro, a mensagem inteira deve ser armazenado em buffer porque um corpo de mensagem sem buffer é consumido por uma consulta e seu conteúdo é destruído.  
  
 As classes a seguir implementam <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601>:  
  
-   <xref:System.ServiceModel.Dispatcher.MessageFilterTable%601>  
  
-   <xref:System.ServiceModel.Dispatcher.XPathMessageFilterTable%601>  
  
 ]]></format>
    </remarks>
    <threadsafe>Tabelas de filtro são thread-safe em relação à correspondência de operações, mas são não thread-safe em relação a modificação. Threads que acessar uma tabela de filtro devem ser sincronizados pelo <see cref="T:System.Threading.ReaderWriterLock" /> ou bloqueio semelhante semântica. Esse bloqueio permite que várias leituras de uma tabela de filtro (por exemplo, uma operação de correspondência) sejam executados simultaneamente, mas para gravar em uma tabela de filtro (por exemplo, adicionar um filtro), um thread deve aguardar um bloqueio exclusivo.  
  
 Compilação de todos é feita quando filtros são adicionados à tabela. Se você criar uma tabela de filtro com antecedência e nunca editá-lo, o bloqueio não é necessário durante uma correspondência.</threadsafe>
  </Docs>
  <Members>
    <MemberGroup MemberName="GetMatchingFilter">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um filtro da tabela cujos critérios de consulta são atendidos por uma mensagem especificada ou em buffer de mensagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método quando um único filtro deve corresponder à mensagem e o filtro de correspondência é necessário.  
  
 Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> se o conteúdo do corpo não requer o exame. Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> se o conteúdo do corpo da mensagem pode exigir o exame.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se mais de um filtro corresponde a mensagem, um <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> deve ser gerada.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.Message message, out System.ServiceModel.Dispatcher.MessageFilter result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.Message message, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.Message,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">O <see cref="T:System.ServiceModel.Channels.Message" /> a ser testado.</param>
        <param name="result">To be added.</param>
        <summary>Retorna um valor que indica se o critério de correspondência de exatamente um filtro na tabela for atendido, a mensagem especificada e retorna o filtro em um <see langword="out" /> parâmetro.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência pelo menos um filtro na tabela é atendido pelo <paramref name="message" />; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método quando um único filtro deve corresponder à mensagem e o filtro de correspondência é necessário.  
  
 Se o corpo da mensagem deve ser inspecionado por um filtro na tabela de filtro, use o <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> versão do método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se mais de um filtro corresponde a mensagem, um <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> deve ser gerada.  
  
 Esta versão usa um <see cref="T:System.ServiceModel.Channels.Message" /> e deve lançar um <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> se tentar examinar o corpo da mensagem.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilter">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilter (System.ServiceModel.Channels.MessageBuffer buffer, out System.ServiceModel.Dispatcher.MessageFilter result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilter(class System.ServiceModel.Channels.MessageBuffer buffer, [out] class System.ServiceModel.Dispatcher.MessageFilter&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilter(System.ServiceModel.Channels.MessageBuffer,System.ServiceModel.Dispatcher.MessageFilter@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="filter" Type="System.ServiceModel.Dispatcher.MessageFilter&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="result">To be added.</param>
        <summary>Retorna um valor que indica se o critério de correspondência de exatamente um filtro na tabela é atendido de mensagem especificada ou em buffer e retorna filtrar em um <see langword="out" /> parâmetro.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência pelo menos um filtro na tabela é atendido pelo <paramref name="messageBuffer" />; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método quando um único filtro deve corresponder à mensagem em buffer, o filtro de correspondência deve ser retornado e o corpo da mensagem precisa ser inspecionado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingFilters">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona os filtros cujos critérios de consulta são atendidos por uma mensagem especificada ou em buffer de mensagem para uma coleção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use um destes métodos quando mais de um filtro deve corresponder à mensagem e os filtros de correspondência são necessários. Observe que a coleção que contém os filtros não é limpo antes que os resultados são adicionados. Isso permite que você acumular todas as correspondências entre várias tabelas de filtro em uma única coleção.  
  
 Se o corpo da mensagem deve ser inspecionado por um filtro na tabela de filtro, a mensagem de buffer e passá-lo para o <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A> método. Caso contrário, use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilters%2A>.  
  
 A correspondência <xref:System.ServiceModel.Dispatcher.MessageFilter> são armazenados no `results` parâmetro. O filtro de dados podem ser recuperados da tabela de filtro usando esses filtros como chaves com os métodos fornecidos pelo <xref:System.Collections.Generic.IDictionary%602>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="message">O <see cref="T:System.ServiceModel.Channels.Message" /> a ser testado.</param>
        <param name="results">Parâmetro de referência que armazena o <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> objetos que correspondem à <see cref="T:System.Collections.Generic.ICollection`1" /> &lt;filtro&gt;.</param>
        <summary>Retorna um valor que indica se o critério de correspondência de um filtro na tabela for atendido, a mensagem especificada e adiciona filtros de correspondência a uma coleção.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência pelo menos um filtro na tabela é atendido pelo <paramref name="message" />; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método quando houver mais de um filtro deve corresponder à mensagem, os filtros de correspondência são necessários e o corpo da mensagem não tem que ser inspecionado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Esta versão usa um <see cref="T:System.ServiceModel.Channels.Message" /> e deve lançar um <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> se tentar examinar o corpo da mensagem.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingFilters">
      <MemberSignature Language="C#" Value="public bool GetMatchingFilters (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingFilters(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;class System.ServiceModel.Dispatcher.MessageFilter&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingFilters(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{System.ServiceModel.Dispatcher.MessageFilter})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;System.ServiceModel.Dispatcher.MessageFilter&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="results">Parâmetro de referência que armazena o <see cref="T:System.ServiceModel.Dispatcher.MessageFilter" /> objetos que correspondem à <see cref="T:System.Collections.Generic.ICollection`1" /> &lt;filtro&gt;.</param>
        <summary>Retorna um valor que indica se o critério de correspondência de um filtro na tabela é atendido pela mensagem de buffer especificada e adiciona os filtros de correspondência a uma coleção.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência pelo menos um filtro na tabela é atendido pelo <paramref name="messageBuffer" />; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método quando mais de um filtro deve corresponder à mensagem em buffer, a correspondência de filtro é necessária e o corpo da mensagem pode ter que ser inspecionado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValue">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um valor que indica se o critério de correspondência de um filtro na tabela é atendido de mensagem especificada ou em buffer e retorna os dados de filtro para o filtro correspondente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use um destes métodos quando, no máximo, um filtro deve corresponder à mensagem e apenas os dados de filtro da correspondência de filtro devem ser recuperados. Esses métodos retornam um valor booleano que indica se um filtro correspondente foi encontrado e definir o `data` referência de parâmetro para os dados de filtro correspondente.  
  
 Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> se o corpo da mensagem não é inspecionado por qualquer um dos filtros na tabela de filtros.  
  
 Se o corpo da mensagem pode ser inspecionado por um filtro na tabela de filtro, a mensagem de buffer e passá-lo para o <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingFilter%2A> versão do método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se mais de um filtro corresponde a mensagem, um <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> deve ser gerada.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.Message message, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.Message message, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.Message,`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="value" Type="TFilterData&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="message">O <see cref="T:System.ServiceModel.Channels.Message" /> a ser testado.</param>
        <param name="data">To be added.</param>
        <summary>Retorna um valor que indica se o critério de correspondência de exatamente um filtro na tabela for atendido, a mensagem especificada e adiciona os dados de filtro correspondente a uma coleção.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência de exatamente um filtro na tabela é atendida pela mensagem; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método quando um único filtro deve corresponder à mensagem e apenas os dados de filtro da correspondência de filtro devem ser recuperados.  
  
 Este método espera no máximo um único filtro correspondente. Se corresponder a mais de um filtro, um <xref:System.ServiceModel.Dispatcher.MultipleFilterMatchesException> deve ser gerada.  
  
 Se o corpo da mensagem deve ser inspecionado por um filtro na tabela de filtros, do buffer de mensagem usando <xref:System.ServiceModel.Channels.Message.CreateBufferedCopy%2A> e passá-lo para o <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValue%2A> versão do método.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se mais de um filtro corresponde a mensagem, um <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> deve ser gerada.  
  
 Essa sobrecarga toma uma <see cref="T:System.ServiceModel.Channels.Message" /> e deve lançar um <see cref="T:System.ServiceModel.Dispatcher.InvalidBodyAccessException" /> se tentar examinar o corpo da mensagem.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValue">
      <MemberSignature Language="C#" Value="public bool GetMatchingValue (System.ServiceModel.Channels.MessageBuffer buffer, out TFilterData data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValue(class System.ServiceModel.Channels.MessageBuffer buffer, [out] !TFilterData&amp; data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValue(System.ServiceModel.Channels.MessageBuffer,`0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="value" Type="TFilterData&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="data">To be added.</param>
        <summary>Retorna um valor que indica se o critério de correspondência de exatamente um filtro na tabela é atendido pela mensagem de buffer especificada e adiciona os dados de filtro correspondente a uma coleção.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência de exatamente um filtro na tabela é atendida pela mensagem; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método quando um único filtro deve corresponder à mensagem em buffer, somente os dados de filtro da correspondência de filtro devem ser recuperados e o corpo da mensagem precisa ser inspecionado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Se mais de um filtro corresponde a mensagem, um <see cref="T:System.ServiceModel.Dispatcher.MultipleFilterMatchesException" /> deve ser gerada.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMatchingValues">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona os dados de filtro de filtros que correspondem a mensagem especificada ou em buffer de mensagem para uma coleção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método quando mais de um filtro para corresponder e apenas os dados de filtro correspondente são necessários. Esses métodos retornam um valor booleano que indica se os filtros correspondentes foram encontrados e colocar qualquer correspondência filtrar dados em uma coleção.  
  
 Observe que a coleção que contém os dados de filtro não é limpo antes que os resultados são adicionados. Isso permite que você acumular todas as correspondências entre várias tabelas de filtro em uma única coleção.  
  
 Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> se o conteúdo do corpo da mensagem não precisa de exame. Use <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> se o conteúdo do corpo da mensagem requer o exame.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.Message message, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.Message message, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.Message,System.Collections.Generic.ICollection{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.ServiceModel.Channels.Message" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="message">O <see cref="T:System.ServiceModel.Channels.Message" /> a ser testado.</param>
        <param name="results">Parâmetro de referência que armazena os dados de filtro de filtros de correspondência em uma coleção genérica.</param>
        <summary>Retorna um valor que indica se o critério de correspondência pelo menos um filtro na tabela for atendido, a mensagem especificada e adiciona o <paramref name="FilterData" /> de filtros de correspondência a uma coleção.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência pelo menos um filtro na tabela é atendido pelo <paramref name="message" />; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método quando um ou mais filtros devem corresponder à mensagem, apenas os dados do filtro são necessários, e o conteúdo do corpo da mensagem não devem ser inspecionado.  
  
 Os dados de filtro da correspondência <xref:System.ServiceModel.Dispatcher.MessageFilter> objetos são armazenados no `results` parâmetro.  
  
 Se o corpo da mensagem é inspecionado por um filtro na tabela de filtro, a mensagem de buffer e passá-lo para o <xref:System.ServiceModel.Dispatcher.IMessageFilterTable%601.GetMatchingValues%2A> versão do método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMatchingValues">
      <MemberSignature Language="C#" Value="public bool GetMatchingValues (System.ServiceModel.Channels.MessageBuffer buffer, System.Collections.Generic.ICollection&lt;TFilterData&gt; results);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool GetMatchingValues(class System.ServiceModel.Channels.MessageBuffer buffer, class System.Collections.Generic.ICollection`1&lt;!TFilterData&gt; results) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Dispatcher.IMessageFilterTable`1.GetMatchingValues(System.ServiceModel.Channels.MessageBuffer,System.Collections.Generic.ICollection{`0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageBuffer" Type="System.ServiceModel.Channels.MessageBuffer" />
        <Parameter Name="results" Type="System.Collections.Generic.ICollection&lt;TFilterData&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="results">Parâmetro de referência que armazena os dados de filtro da correspondência filtros em um genérico <see cref="T:System.Collections.Generic.ICollection`1" /> &lt; <c>FilterData</c>&gt;.</param>
        <summary>Retorna um valor que indica se o critério de correspondência pelo menos um filtro na tabela é atendido pela mensagem de buffer especificada e adiciona o <paramref name="FilterData" /> de filtros de correspondência a uma coleção.</summary>
        <returns>
          <see langword="true" />Se o critério de correspondência pelo menos um filtro na tabela é atendido pelo <paramref name="messageBuffer" />; <see langword="false" /> se nenhum filtro for satisfeito.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método quando um ou mais filtros são esperados para corresponder a mensagem em buffer, somente os dados do filtro são necessários, e o corpo da mensagem pode exigir inspeção.  
  
 Os dados de filtro da correspondência <xref:System.ServiceModel.Dispatcher.MessageFilter> objetos são armazenados no `results` parâmetro.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
