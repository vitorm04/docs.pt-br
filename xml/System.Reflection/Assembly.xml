<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um assembly, que é um bloco de construção autodescritivo, versátil e reutilizável de um aplicativo de common language runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Reflection.Assembly> classe carregar assemblies para explorar as partes de metadados e constituinte de assemblies, para descobrir os tipos contidos em assemblies e para criar instâncias desses tipos.  
  
 Para obter uma matriz de <xref:System.Reflection.Assembly> objetos representar os assemblies atualmente carregados em um domínio de aplicativo (por exemplo, domínio de aplicativo padrão de um projeto simple), use o <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> método.  
  
 Carregar assemblies dinamicamente, o <xref:System.Reflection.Assembly> classe fornece os seguintes métodos estáticos (`Shared` métodos no Visual Basic). Os assemblies são carregados para o domínio de aplicativo onde ocorre a operação de carregamento.  
  
-   A maneira recomendada para assemblies de carga é usar o <xref:System.AppDomain.Load%2A> método, que identifica o assembly a ser carregada pelo seu nome de exibição (por exemplo, "System, Version = 2.0.0.0, Culture = neutral, PublicKeyToken = b77a5c561934e089"). A pesquisa para o assembly segue as regras descritas [como o tempo de execução Localiza Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).  
  
-   O <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos permitem que você carregar um assembly para reflexão, mas não para execução. Por exemplo, um assembly que tem como alvo uma plataforma de 64 bits pode ser examinado pelo código que é executado em uma plataforma de 32 bits.  
  
-   O <xref:System.Reflection.Assembly.LoadFile%2A> e <xref:System.Reflection.Assembly.LoadFrom%2A> métodos são fornecidos para os cenários raros em que um assembly deve ser identificado pelo caminho.  
  
 Para obter um <xref:System.Reflection.Assembly> objeto para o assembly em execução no momento, use o <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> método.  
  
 Número de membros do <xref:System.Reflection.Assembly> classe fornecem informações sobre um assembly. Por exemplo:  
  
-   O <xref:System.Reflection.Assembly.GetName%2A> método retorna um <xref:System.Reflection.AssemblyName> objeto que fornece acesso a partes do nome de exibição do assembly.  
  
-   O <xref:System.Reflection.Assembly.GetCustomAttributes%2A> método lista os atributos aplicados ao assembly.  
  
-   O <xref:System.Reflection.Assembly.GetFiles%2A> método fornece acesso a arquivos no manifesto do assembly.  
  
-   O <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> método fornece os nomes dos recursos no manifesto do assembly.  
  
 O <xref:System.Reflection.Assembly.GetTypes%2A> método lista todos os tipos no assembly. O <xref:System.Reflection.Assembly.GetExportedTypes%2A> método lista os tipos que são visíveis para chamadores fora do assembly. O <xref:System.Reflection.Assembly.GetType%2A> método pode ser usado para pesquisar um determinado tipo no assembly. O <xref:System.Reflection.Assembly.CreateInstance%2A> método pode ser usado para procurar e criar instâncias de tipos no assembly.  
  
 Para obter mais informações sobre assemblies, consulte a seção "Aplicativo domínios e Assemblies" o [domínios de aplicativo](~/docs/framework/app-domains/application-domains.md) tópico.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como obter o assembly em execução no momento, criar uma instância de um tipo contido nesse assembly e chamar um dos métodos do tipo com associação tardia. Para essa finalidade, o exemplo de código define uma classe denominada `Example`, com um método denominado `SampleMethod`. O construtor da classe aceita um inteiro, que é usado para calcular o valor de retorno do método.  
  
 O exemplo de código também demonstra o uso do <xref:System.Reflection.Assembly.GetName%2A> método para obter um <xref:System.Reflection.AssemblyName> objeto que pode ser usado para analisar o nome completo do assembly. O exemplo exibe o número de versão do assembly, o <xref:System.Reflection.Assembly.CodeBase%2A> propriedade e o <xref:System.Reflection.Assembly.EntryPoint%2A> propriedade.  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Esta classe não pode ser herdada pelo código parcialmente confiável.</permission>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Reflection.Assembly" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado por classes derivadas durante a construção do <xref:System.Reflection.Assembly> objetos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o local do assembly como especificado originalmente, por exemplo, em um objeto <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <value>O local do assembly como especificado originalmente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter o caminho absoluto para o arquivo de manifesto-contendo carregado, use o <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> propriedade em vez disso.  
  
 Se o assembly foi carregado como uma matriz de bytes, usando uma sobrecarga de <xref:System.Reflection.Assembly.Load%2A> método que usa uma matriz de bytes, essa propriedade retorna o local do chamador do método, não o local do assembly carregado.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Reflection.Assembly.CodeBase%2A> propriedade.  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar o caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">O <see cref="P:System.Type.FullName" /> do tipo a se localizar.</param>
        <summary>Localiza o tipo especificado desse assembly e cria uma instância dele usando o ativador de sistema, usando a pesquisa que diferencia maiúsculas de minúsculas.</summary>
        <returns>Uma instância do tipo especificado criada com o construtor padrão; ou <see langword="null" /> se <paramref name="typeName" /> não foi encontrado. O tipo é resolvido usando o associador padrão, sem especificar atributos de cultura ou de ativação, e com <see cref="T:System.Reflection.BindingFlags" /> definido como <see langword="Public" /> ou <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tempo de execução não consegue encontrar `typeName` no <xref:System.Reflection.Assembly> instância, ele retorna `null` em vez de gerar uma exceção. Isso pode acontecer porque:  
  
-   Você não especificou o nome totalmente qualificado do tipo.  
  
-   Você especificou o nome de tipo totalmente qualificado, mas seu caso não coincidem no caso do tipo <xref:System.Type.FullName%2A?displayProperty=nameWithType> propriedade. Para obter uma comparação de maiusculas e minúsculas de `typeName` com o nome do tipo completo, chame o <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> de sobrecarga e especifique `true` para o `ignoreCase` argumento.  
  
-   O tipo não existe no atual <xref:System.Reflection.Assembly> instância.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Person` classe e chama o <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> método instanciá-la.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> é uma cadeia de caracteres vazia ("") ou que começa com um caractere nulo.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto de somente reflexão.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> exige um assembly dependente que não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto somente reflexão e o <paramref name="typeName" /> exige um assembly dependente que não foi pré-carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> exige um assembly dependente, mas o arquivo não é um assembly válido.  
  
 -ou-  
  
 <paramref name="typeName" /> requer um assembly dependente compilado para uma versão do tempo de execução que é posterior à versão atualmente carregada.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">O <see cref="P:System.Type.FullName" /> do tipo a se localizar.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo; caso contrário, <see langword="false" />.</param>
        <summary>Localiza o tipo especificado desse assembly e cria uma instância dele usando o ativador de sistema, com pesquisa que diferencia maiúsculas de minúsculas opcional.</summary>
        <returns>Uma instância do tipo especificado criada com o construtor padrão; ou <see langword="null" /> se <paramref name="typeName" /> não foi encontrado. O tipo é resolvido usando o associador padrão, sem especificar atributos de cultura ou de ativação, e com <see cref="T:System.Reflection.BindingFlags" /> definido como <see langword="Public" /> ou <see langword="Instance" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tempo de execução não consegue encontrar `typeName` no <xref:System.Reflection.Assembly> instância, ele retorna `null` em vez de gerar uma exceção. Isso pode acontecer porque:  
  
-   Você não especificou o nome totalmente qualificado do tipo.  
  
-   O tipo não existe no atual <xref:System.Reflection.Assembly> instância.  
  
   
  
## Examples  
 O exemplo a seguir define um `Person` classe. Depois, ele chama o <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> método instanciá-la, mas, como maiusculas e minúsculas de `typeName` argumento não coincidir com o tipo <xref:System.Type.FullName%2A> propriedade, o método retorna `null`. Quando o exemplo passa a mesma cadeia de caracteres para o <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> de sobrecarga e especifica que a comparação deve diferenciar maiusculas de minúsculas, o `Person` classe for encontrada e um `Person` objeto é instanciado com êxito.  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> é uma cadeia de caracteres vazia ("") ou que começa com um caractere nulo.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto de somente reflexão.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> exige um assembly dependente que não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto somente reflexão e o <paramref name="typeName" /> exige um assembly dependente que não foi pré-carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> exige um assembly dependente, mas o arquivo não é um assembly válido.  
  
 -ou-  
  
 <paramref name="typeName" /> requer um assembly dependente compilado para uma versão do tempo de execução que é posterior à versão atualmente carregada.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName">O <see cref="P:System.Type.FullName" /> do tipo a se localizar.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo; caso contrário, <see langword="false" />.</param>
        <param name="bindingAttr">Um bitmask que afeta a maneira pela qual a pesquisa é realizada. O valor é uma combinação dos sinalizadores de bit de <see cref="T:System.Reflection.BindingFlags" />.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumentos, invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> por meio de reflexão. Se <c>associador</c> é <see langword="null" />, o associador padrão é usado.</param>
        <param name="args">Uma matriz que contém os argumentos a serem passados ao construtor. Essa matriz de argumentos deve corresponder em número, ordem e tipo aos parâmetros do construtor a ser invocado. Se o construtor padrão for desejado, <c>args</c> deve ser uma matriz vazia ou <see langword="null" />.</param>
        <param name="culture">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos. Se isso for <see langword="null" />, será usado o <see langword="CultureInfo" /> para o thread atual. (Isso é necessário para converter um <see langword="String" /> que representa 1000 para um valor <see langword="Double" />, por exemplo, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</param>
        <param name="activationAttributes">Uma matriz de um ou mais atributos que podem participar da ativação. Normalmente, uma matriz que contém um único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica a URL necessária para ativar um objeto remoto.  Esse parâmetro está relacionado a objetos ativados pelo cliente. A ativação do cliente é uma tecnologia herdada, mantida para compatibilidade com versões anteriores, mas não é recomendada para novos desenvolvimentos. Em vez disso, os aplicativos distribuídos devem usar o Windows Communication Foundation.</param>
        <summary>Localiza o tipo especificado desse assembly e cria uma instância dele usando o ativador do sistema, com a pesquisa opcional que diferencia maiúsculas de minúsculas e com a cultura especificada, os argumentos e os atributos de associação e ativação.</summary>
        <returns>Uma instância do tipo especificado ou <see langword="null" />, se <paramref name="typeName" /> não for encontrado. Os argumentos fornecidos são usados para resolver o tipo e associar o construtor utilizado para criar a instância.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="typeName" /> é uma cadeia de caracteres vazia ("") ou que começa com um caractere nulo.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto de somente reflexão.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Nenhum construtor correspondente foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">Uma matriz de atributos de ativação não vazia é passada a um tipo que não herda de <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="typeName" /> requer um assembly dependente que não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="typeName" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto somente reflexão e o <paramref name="typeName" /> exige um assembly dependente que não foi pré-carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="typeName" /> exige um assembly dependente, mas o arquivo não é um assembly válido.  
  
 -ou-  
  
 <paramref name="typeName" /> requer um assembly dependente compilado para uma versão do tempo de execução posterior à versão carregada.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para criar uma instância de um representante. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">O nome de exibição de um assembly.</param>
        <param name="typeName">O nome completo de um tipo.</param>
        <summary>Cria o nome de tipo qualificado pelo nome para exibição do seu assembly.</summary>
        <returns>O nome completo do tipo qualificado pelo nome de exibição do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formato de cadeia de caracteres retornada é:  
  
 \<FullTypeName >, \<AssemblyDisplayName >  
  
 Consulte <xref:System.Reflection.AssemblyName> para obter uma descrição do formato do nome para exibição de um assembly.  
  
 Para acomodar as alterações em versões do common language runtime, use esse método em vez de construir o nome qualificado por conta própria.  Para obter informações sobre nomes de assembly qualificado, consulte <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção que contém os atributos personalizados deste assembly.</summary>
        <value>Uma coleção que contém os atributos personalizados deste assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção dos tipos definidos nesse assembly.</summary>
        <value>Uma coleção dos tipos definidos neste assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Assembly.DefinedTypes%2A> propriedade é comparável ao <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> método, exceto que o <xref:System.Reflection.Assembly.DefinedTypes%2A> propriedade retorna um [coleção](../Topic/IEnumerable\(T\)%20Interface.md) de <xref:System.Reflection.TypeInfo> objetos e o <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> método retorna uma matriz de <xref:System.Type> objetos.  
  
 A matriz retornada inclui tipos aninhados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o ponto de entrada desse assembly.</summary>
        <value>Um objeto que representa o ponto de entrada desse assembly. Se nenhum ponto de entrada for encontrado (por exemplo, se o assembly for uma DLL), <see langword="null" /> será retornado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">O objeto a ser comparado com essa instância.</param>
        <summary>Determina se este assembly e o objeto especificado são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="o" /> for igual a essa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Assembly.Equals%2A> método executa um teste de igualdade de referência determinar se a instância atual e `o` são iguais.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI, incluindo caracteres de escape, que representa a base de código.</summary>
        <value>Um URI com caracteres de escape.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar o caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a evidência para esse assembly.</summary>
        <value>A evidência para esse assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Evidência é o conjunto de informações que constitui a entrada para decisões de política de segurança, como quais permissões podem ser concedidas ao código.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção dos tipos públicos definidos nesse assembly visíveis fora do assembly.</summary>
        <value>Uma coleção dos tipos públicos definidos nesse assembly visíveis fora do assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome de exibição do assembly.</summary>
        <value>O nome para exibição do assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte <xref:System.Reflection.AssemblyName> para obter uma descrição do formato do nome para exibição de um assembly.  
  
> [!NOTE]
>  Escrevendo seu próprio código para analisar os nomes de exibição não é recomendado. Em vez disso, passe o nome de exibição para o <xref:System.Reflection.AssemblyName.%23ctor%2A> construtor, que analisa e preenche os campos apropriados do novo <xref:System.Reflection.AssemblyName>.  
  
 No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. No entanto, ele não está incluído na cadeia de caracteres retornada pela propriedade <xref:System.Reflection.Assembly.FullName%2A>, por motivos de compatibilidade. Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir recupera o nome para exibição do assembly em execução no momento e o nome para exibição do assembly que contém o <xref:System.Int32> tipo (`int` em c#, `Integer` no Visual Basic).  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Um objeto que representa um tipo no assembly que será retornado.</param>
        <summary>Obtém o assembly carregado no momento em que o tipo especificado é definido.</summary>
        <returns>O assembly no qual o tipo especificado é definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método é equivalente a recuperação do valor da <xref:System.Type.Assembly?displayProperty=nameWithType> propriedade. No entanto, o <xref:System.Type.Assembly?displayProperty=nameWithType> propriedade normalmente oferece desempenho superior.  
  
 Para chamar esse método, você deve ter uma <xref:System.Type> objeto, o que significa que o assembly no qual a classe é definida já deve ser carregado.  
  
   
  
## Examples  
 O exemplo a seguir recupera o assembly que contém o <xref:System.Int32> digite e exibe seu nome e o arquivo local.  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Reflection.Assembly" /> do método que invocou o método atualmente em execução.</summary>
        <returns>O objeto <see langword="Assembly" /> do método que invocou o método atualmente em execução.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o método que chama o <xref:System.Reflection.Assembly.GetCallingAssembly%2A> método é expandido embutido pelo compilador just-in-time (JIT), ou se o chamador estiver expandido embutido, o assembly que é retornado por <xref:System.Reflection.Assembly.GetCallingAssembly%2A> podem diferir inesperadamente. Por exemplo, considere os seguintes métodos e assemblies:  
  
-   Método `M1` no assembly `A1` chamadas <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
-   Método `M2` no assembly `A2` chamadas `M1`.  
  
-   Método `M3` no assembly `A3` chamadas `M2`.  
  
 Quando `M1` não é embutida, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A2`. Quando `M1` é embutida, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A3`. Da mesma forma, quando `M2` não é embutida, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A2`. Quando `M2` é embutida, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> retorna `A3`.  
  
 Esse efeito também ocorre quando `M1` é executado como uma chamada tail de `M2`, ou quando `M2` é executado como uma chamada tail de `M3`. Você pode impedir que o compilador JIT do inlining o método que chama <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, aplicando o <xref:System.Runtime.CompilerServices.MethodImplAttribute> atributo com o <xref:System.Runtime.CompilerServices.MethodImplOptions?displayProperty=nameWithType> sinalizador, mas não há nenhum mecanismo semelhante para evitar chamadas tail.  
  
   
  
## Examples  
 O exemplo a seguir obtém o assembly de chamada do método atual.  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Este argumento é ignorado para objetos do tipo <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Obtém todos os atributos personalizados para esse assembly.</summary>
        <returns>Uma matriz que contém os atributos personalizados para este assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método implementa correspondente <xref:System.Reflection.ICustomAttributeProvider> método de interface. Portanto, o `inherit` parâmetro deve ser especificado mesmo que ele será ignorado.  
  
 Um atributo pseudo indica bits dos metadados principais que devem ser definidas quando o atributo estiver presente. Ao contrário de um atributo personalizado que estende os metadados para um tipo e é salvo junto com o tipo, um atributo pseudo modifica metadados para o tipo e, em seguida, será descartado. Alguns dos bits resultantes não podem ser acessado usando APIs de reflexão existente.  
  
 A tabela a seguir resume os atributos de pseudo diferentes e os acessadores para os bits que estão disponíveis em reflexão.  
  
|Atributo pseudo|Bits de metadados|Acessador de reflexão|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nome da DLL|Nenhum acessador PInvokeMap método/global comum para atributos de método.<br /><br /> Nenhum acessador para o nome da DLL.|  
|GuidAttribute|Armazenado como um atributo personalizado real.|Acessado como um atributo personalizado real.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Vários bits.|Nenhum acessador.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags(). OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags(). OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Empacotamento de classe.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Nenhum acessador.|  
|FieldOffsetAttribute|Deslocamento de campo.|Nenhum acessador.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Nenhum acessador ou enumerador.|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">O tipo para o qual os atributos personalizados devem ser retornados.</param>
        <param name="inherit">Este argumento é ignorado para objetos do tipo <see cref="T:System.Reflection.Assembly" />.</param>
        <summary>Obtém os atributos personalizados para esse assembly conforme especificado pelo tipo.</summary>
        <returns>Uma matriz que contém os atributos personalizados para este assembly conforme especificado por <paramref name="attributeType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método implementa correspondente <xref:System.Reflection.ICustomAttributeProvider> método de interface. Portanto, o `inherit` parâmetro deve ser especificado mesmo que ele será ignorado.  
  
 Um atributo pseudo indica bits dos metadados principais que devem ser definidas quando o atributo estiver presente. Ao contrário de um atributo personalizado que estende os metadados para um tipo e é salvo junto com o tipo, um atributo pseudo modifica metadados para o tipo e, em seguida, será descartado. Alguns dos bits resultantes não podem ser acessado usando APIs de reflexão existente.  
  
 A tabela a seguir resume os atributos de pseudo diferentes e os acessadores para os bits que estão disponíveis em reflexão.  
  
|Atributo pseudo|Bits de metadados|Acessador de reflexão|  
|-----------------------|-------------------|-------------------------|  
|DllImportAttribute|CorPInvokeMap<br /><br /> Nome da DLL|Nenhum acessador PInvokeMap método/global comum para atributos de método.<br /><br /> Nenhum acessador para o nome da DLL.|  
|GuidAttribute|Armazenado como um atributo personalizado real.|Acessado como um atributo personalizado real.|  
|ComImportAttribute|CorTypeAttr.tdImport|Type.Attributes.Import|  
|SerializableAttribute|CorTypeAttr.tdSerializable|Type.Attributes.Serializable|  
|NonSerializedAttribute|CorFieldAttr.fdNotSerialized|FieldInfo.Attributes.NotSerialized|  
|MethodImplAttribute|CorMethodImpl|MethodInfo.GetMethodImplementationFlags()<br /><br /> ConstructorInfo.GetMethodImplementationFlags()|  
|MarshalAsAttribute|Vários bits.|Nenhum acessador.|  
|PreserveSigAttribute|CorMethodImpl.miOLE|MethodInfo.GetMethodImplementationFlags(). OLE<br /><br /> ConstructorInfo.GetMethodImplementationFlags(). OLE|  
|InAttribute|CorParamAttr.pdIn|ParameterInfo.Attributes.In|  
|OutAttribute|CorParamAttr.pdOut|ParameterInfo.Attributes.Out|  
|StructLayoutAttribute|CorTypeAttr.tdLayoutSequential<br /><br /> CorTypeAttr.tdExplicitLayout<br /><br /> CorTypeAttr.tdAnsiClass<br /><br /> CorTypeAttr.tdUnicodeClass<br /><br /> CorTypeAttr.tdAutoClass<br /><br /> Empacotamento de classe.|Type.Attributes.LayoutSequential<br /><br /> Type.Attributes.ExplicitLayout<br /><br /> Type.Attributes.AnsiClass<br /><br /> Type.Attributes.UnicodeClass<br /><br /> Type.Attributes.AutoClass<br /><br /> Nenhum acessador.|  
|FieldOffsetAttribute|Deslocamento de campo.|Nenhum acessador.|  
|AssemblyLoadAttribute|CorAssemblyFlags|Nenhum acessador ou enumerador.|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" /> não é um tipo de tempo de execução.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna informações sobre os atributos que foram aplicados ao <see cref="T:System.Reflection.Assembly" /> atual, expressos como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</summary>
        <returns>Uma lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representam dados sobre os atributos que foram aplicados ao assembly atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para examinar os atributos personalizados de código no contexto exclusivo de reflexão, em casos onde os atributos personalizados próprios são definidos no código que é carregado no contexto exclusivo de reflexão. Métodos como <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> e <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> não pode ser usado em tais casos, porque eles criar instâncias dos atributos. O código no contexto exclusivo de reflexão não pode ser executado. Para obter mais informações e como código, consulte o <xref:System.Reflection.CustomAttributeData> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o processo executável no domínio de aplicativo padrão. Em outros domínios de aplicativo, é o primeiro executável que foi executado por <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</summary>
        <returns>O assembly é processo executável no domínio de aplicativo padrão ou o primeiro executável que foi executado por <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />. Pode retornar <see langword="null" /> quando chamado do código não gerenciado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Assembly.GetEntryAssembly%2A> método pode retornar `null` quando um assembly gerenciado foi carregado de um aplicativo não gerenciado. Por exemplo, se um aplicativo não gerenciado cria uma instância de um componente COM escrita em c#, uma chamada para o <xref:System.Reflection.Assembly.GetEntryAssembly%2A> método do componente de c# retornará nulo, porque o ponto de entrada para o processo de código não gerenciado em vez de um assembly gerenciado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o assembly que contém o código executado no momento.</summary>
        <returns>O assembly que contém o código que está sendo executado no momento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por motivos de desempenho, você deve chamar esse método somente quando você não souber em tempo de design o assembly está em execução atualmente. A maneira recomendada para recuperar um <xref:System.Reflection.Assembly> objeto que representa o assembly atual é usar o <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriedade de um tipo encontrado no assembly, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 Para obter o assembly que contém o método que é chamado de código em execução no momento, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propriedade para obter o assembly em execução no momento com base em um tipo contido nesse assembly. Ele também chama o <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> método para mostrar que retorna um <xref:System.Reflection.Assembly> objeto que representa o mesmo assembly.  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os tipos públicos definidos nesse assembly que são visíveis fora do assembly.</summary>
        <returns>Uma matriz que representa os tipos definidos nesse assembly que são visíveis fora do assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os únicos tipos visíveis fora de um assembly são os tipos públicos e tipos públicos aninhados em outros tipos públicos.  
  
   
  
## Examples  
 O exemplo de código a seguir define um número de classes com vários níveis de acesso e chamadas <xref:System.Reflection.Assembly.GetExportedTypes%2A> para exibir os que estão visíveis fora do assembly.  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O assembly é um assembly dinâmico.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do arquivo especificado. Não inclua o caminho para o arquivo.</param>
        <summary>Obtém um <see cref="T:System.IO.FileStream" /> para o arquivo especificado na tabela de arquivo do manifesto desse assembly.</summary>
        <returns>Um fluxo que contém o arquivo especificado ou <see langword="null" /> se o arquivo não for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em ambos os arquivos de recurso públicas e privadas.  
  
 O `name` não deve incluir o caminho para o arquivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> não é um assembly válido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar o caminho e para ler o arquivo especificado. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os arquivos na tabela de arquivo de um manifesto do assembly.</summary>
        <returns>Uma matriz de fluxos que contêm os arquivos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em arquivos de recurso públicas e privadas.  
  
 Essa sobrecarga é equivalente a chamar o <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> sobrecarga e especificando `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Um arquivo não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">Um arquivo não é um assembly válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" />para incluir os módulos de recursos; Caso contrário, <see langword="false" />.</param>
        <summary>Obtém os arquivos na tabela de arquivos de um manifesto do assembly, especificar se deseja incluir os módulos de recursos.</summary>
        <returns>Uma matriz de fluxos que contêm os arquivos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em arquivos de recurso públicas e privadas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Um arquivo não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">Um arquivo não é um assembly válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém todos os módulos carregados que fazem parte desse assembly.</summary>
        <returns>Uma matriz de módulos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" />para incluir os módulos de recursos; Caso contrário, <see langword="false" />.</param>
        <summary>Obtém todos os módulos carregados que fazem parte desse assembly, especificar se deseja incluir os módulos de recursos.</summary>
        <returns>Uma matriz de módulos.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName">O nome do recurso, que diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna informações sobre como o recurso em questão foi persistido.</summary>
        <returns>Um objeto que é populado com informações sobre a topologia do recurso ou <see langword="null" />, se o recurso não for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informações sobre o recurso é retornado somente se o recurso é visível ao chamador ou o chamador tem <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="resourceName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="resourceName" /> é uma cadeia de caracteres vazia ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os nomes de todos os recursos nesse assembly.</summary>
        <returns>Uma matriz que contém os nomes de todos os recursos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o nome de cada recurso na matriz retornada por este método, da seguinte maneira:  
  
-   Você pode passar o nome do recurso para o <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> método para obter informações adicionais sobre o recurso.  
  
-   Se o nome identifica um arquivo. Resources binário, você pode remover a sua extensão de arquivo. Resources e passá-lo para o <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> construtor para instanciar o Gerenciador de recursos.  
  
-   Você pode passar o nome do recurso para o <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> método para recuperar um <xref:System.IO.Stream> objeto que você pode passar para o <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> construtor.  
  
-   Você pode passar o nome do recurso para o <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> método para recuperar um <xref:System.IO.Stream> objeto que você pode passar para o <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> construtor.  
  
 Informações sobre o recurso é retornado somente se o recurso é visível ao chamador ou o chamador tem <xref:System.Security.Permissions.ReflectionPermission>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome que diferencia maiúsculas de minúsculas do recurso de manifesto solicitado.</param>
        <summary>Carrega o recurso de manifesto especificado desse assembly.</summary>
        <returns>O recurso de manifesto; ou <see langword="null" /> se nenhum recurso foi especificado durante a compilação ou se o recurso não é visível para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um recurso de manifesto é um recurso (como um arquivo de imagem) que é inserido no assembly em tempo de compilação. Para obter mais informações sobre recursos de manifesto, consulte [Noções básicas de recursos do Microsoft .NET Framework](http://go.microsoft.com/fwlink/?LinkId=204554) na biblioteca MSDN.  
  
 Informações sobre o recurso é retornado somente se o recurso é visível ao chamador ou o chamador tem <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Este método retorna `null` se um recurso particular em outro assembly é acessado e o chamador não tem <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador.  
  
 Se o manifesto do assembly lista um arquivo de recurso, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retorna um <xref:System.IO.Stream> objeto mesmo se o arquivo de recurso não pode ser encontrado no disco no momento. Se o arquivo de recurso não for encontrado, passando resultante <xref:System.IO.Stream> o objeto para o <xref:System.Resources.ResourceReader> construtor faz com que um <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.IO.IOException" />, em vez disso.  
  
</para>
          </block>  
  
 Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> não é um assembly válido.</exception>
        <exception cref="T:System.NotImplementedException">O tamanho do recurso é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O tipo cujo namespace é usado para definir o escopo do nome de recurso de manifesto.</param>
        <param name="name">O nome que diferencia maiúsculas de minúsculas do recurso de manifesto solicitado.</param>
        <summary>Carrega o recurso de manifesto especificado, o escopo pelo namespace do tipo especificado, desse assembly.</summary>
        <returns>O recurso de manifesto; ou <see langword="null" /> se nenhum recurso foi especificado durante a compilação ou se o recurso não é visível para o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, se o nome completo especificado para `type` é "MyNameSpace.MyClasses" e `name` é "Net", este método sobrecarregar procura um recurso chamado "MyNameSpace.Net".  
  
 Um recurso de manifesto é um recurso (como um arquivo de imagem) que é inserido no assembly em tempo de compilação. Para obter mais informações sobre recursos de manifesto, consulte [Noções básicas de recursos do Microsoft .NET Framework](http://go.microsoft.com/fwlink/?LinkId=204554) na biblioteca MSDN.  
  
 Informações sobre o recurso é retornado somente se o recurso é visível ao chamador ou o chamador tem <xref:System.Security.Permissions.ReflectionPermission>.  
  
> [!NOTE]
>  Este método retorna `null` se um recurso particular em outro assembly é acessado e o chamador não tem <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador.  
  
 Se o manifesto do assembly lista um arquivo de recurso, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> retorna um <xref:System.IO.Stream> objeto mesmo se o arquivo de recurso não pode ser encontrado no disco no momento. Se o arquivo de recurso não for encontrado, passando resultante <xref:System.IO.Stream> o objeto para o <xref:System.Resources.ResourceReader> construtor faz com que um <xref:System.ArgumentException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> não é um assembly válido.</exception>
        <exception cref="T:System.NotImplementedException">O tamanho do recurso é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do módulo que está sendo solicitado.</param>
        <summary>Obtém o módulo especificado nesse assembly.</summary>
        <returns>O módulo que está sendo solicitado ou <see langword="null" />, se o módulo não tiver sido encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em nomes de arquivo.  
  
 Classes de `Reflection.Emit` namespace emitir o nome do escopo para um módulo dinâmico. O nome do escopo pode ser determinado pelo <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> propriedade. Passar o tipo de módulo a ser `Assembly.GetModule`. Por exemplo, se desejar que o módulo que contém o manifesto do assembly, passe o nome do escopo do módulo a ser `GetModule`. Caso contrário, passe o nome de arquivo do módulo. Os assemblies carregados por um do `Load` métodos que têm um parâmetro do byte [] têm apenas um módulo, e que o módulo de manifesto. Sempre busca esses módulos usando o nome do escopo.  
  
 Um tipo pode ser recuperado de um módulo específico usando <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>. Chamando `Module.GetType` no módulo que contém o manifesto não iniciará uma pesquisa de assembly inteiro. Para recuperar um tipo de um assembly, independentemente de qual módulo está em, você deve chamar <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="name" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> não é um assembly válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém todos os módulos que fazem parte desse assembly.</summary>
        <returns>Uma matriz de módulos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em arquivos de recurso públicas e privadas.  
  
> [!NOTE]
>  Módulos devem ser emitidos com extensões de nome de arquivo.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome do módulo na matriz retornada que contém o manifesto do assembly.  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O módulo a ser carregado não especifica uma extensão de nome de arquivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules">
          <see langword="true" />para incluir os módulos de recursos; Caso contrário, <see langword="false" />.</param>
        <summary>Obtém todos os módulos que fazem parte desse assembly, especificar se deseja incluir os módulos de recursos.</summary>
        <returns>Uma matriz de módulos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em arquivos de recurso públicas e privadas.  
  
> [!NOTE]
>  Módulos devem ser emitidos com extensões de nome de arquivo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um <see cref="T:System.Reflection.AssemblyName" /> para esse assembly.</summary>
        <returns>Um objeto que contém o nome de exibição totalmente analisado para esse assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar o caminho do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName">
          <see langword="true" /> para definir o <see cref="P:System.Reflection.Assembly.CodeBase" /> com o local do assembly depois que tiver sido feita uma cópia de sombra dele; <see langword="false" /> para definir <see cref="P:System.Reflection.Assembly.CodeBase" /> com o local original.</param>
        <summary>Obtém um <see cref="T:System.Reflection.AssemblyName" /> para esse assembly, definindo a base de código como especificado por <paramref name="copiedName" />.</summary>
        <returns>Um objeto que contém o nome de exibição totalmente analisado para esse assembly.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar o caminho do assembly. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O objeto a ser populado com informações de serialização.</param>
        <param name="context">O contexto de destino da serialização.</param>
        <summary>Obtém informações de serialização com todos os dados necessários para recriar uma instância desse assembly.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os objetos <see cref="T:System.Reflection.AssemblyName" /> para todos os assemblies referenciados por esse assembly.</summary>
        <returns>Uma matriz que contém os nomes de exibição totalmente analisados de todos os assemblies referenciados por esse assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriedade de um <xref:System.Reflection.AssemblyName> objeto retornado por esse método é <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> se não houver nenhum algoritmo de hash para o assembly referenciado, ou se o algoritmo de hash do assembly referenciado não é identificado pelo <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeração. Em versões anteriores do .NET Framework, o <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propriedade retornada <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> nessa situação.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a chamar o <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> método. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Reflection.Assembly> classe.  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">A cultura especificada.</param>
        <summary>Obtém o assembly satélite para a cultura especificada.</summary>
        <returns>O assembly satélite especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblies satélites contém recursos localizados, diferentes de assemblies de aplicativo principal, que contêm código executável não localizáveis e recursos para uma única cultura que servem como o padrão ou a cultura neutra.  
  
 Chame este método para usar a versão atual do assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível localizar o assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> não correspondia ao especificado.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly satélite não é um assembly válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture">A cultura especificada.</param>
        <param name="version">A versão do assembly satélite.</param>
        <summary>Obtém a versão especificada do assembly satélite para a cultura especificada.</summary>
        <returns>O assembly satélite especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblies satélites contém recursos localizados, diferentes de assemblies de aplicativo principal, que contêm código executável não localizáveis e recursos para uma única cultura que servem como o padrão ou a cultura neutra.  
  
 Chamar o <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> sobrecarga para usar a versão atual do assembly.  
  
 Se `version` é `null`, a versão do assembly atual será usada se o recurso e os assemblies principais são assinados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="culture" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">O assembly satélite com um nome de arquivo correspondente foi encontrado, mas o <see langword="CultureInfo" /> ou a versão não corresponde àquela especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível localizar o assembly.</exception>
        <exception cref="T:System.BadImageFormatException">O assembly satélite não é um assembly válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome completo do tipo.</param>
        <summary>Obtém o objeto <see cref="T:System.Type" /> com o nome especificado na instância do assembly.</summary>
        <returns>Um objeto que representa a classe especificada ou <see langword="null" /> se a classe não for encontrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa apenas a instância atual do assembly. O `name` parâmetro inclui o namespace, mas não o assembly. Para pesquisar outros assemblies para um tipo, use o <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga de método, o que pode opcionalmente incluir um nome de exibição do assembly como parte do nome do tipo.  
  
> [!NOTE]
>  Se o tipo foi encaminhado para outro conjunto, ele ainda é retornado por este método. Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
   
  
## Examples  
 O exemplo a seguir define um resumo `MeansOfTransportation` classe no `Transportation` namespace. Ele chama o <xref:System.Reflection.Assembly.GetType%28System.String%29> método para recuperar seu <xref:System.Type> objeto, chamadas de <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> método para obter uma matriz de <xref:System.Reflection.PropertyInfo> objetos que representam as propriedades do tipo e, em seguida, exibe informações sobre o tipo abstraem propriedades. Observe que a chamada para o <xref:System.Reflection.Assembly.GetType%28System.String%29> método usa o nome do tipo totalmente qualificado (ou seja, seu namespace juntamente com seu nome de tipo).  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é inválido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> exige um assembly dependente que não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.IO.IOException" />, em vez disso.  
  
</para>
          </block>
          <paramref name="name" />requer um assembly dependente que foi encontrado, mas não pôde ser carregado.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto somente reflexão e o <paramref name="name" /> exige um assembly dependente que não foi pré-carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> exige um assembly dependente, mas o arquivo não é um assembly válido.  
  
 -ou-  
  
 <paramref name="name" /> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome completo do tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</param>
        <summary>Obtém o objeto <see cref="T:System.Type" /> com o nome especificado na instância do assembly e, opcionalmente, lança uma exceção se o tipo não for encontrado.</summary>
        <returns>Um objeto que representa a classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa apenas a instância atual do assembly. O `name` parâmetro inclui o namespace, mas não o assembly. Para pesquisar outros assemblies para um tipo, use o <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga de método, o que pode opcionalmente incluir um nome de exibição do assembly como parte do nome do tipo.  
  
> [!NOTE]
>  Se o tipo foi encaminhado para outro conjunto, ele ainda é retornado por este método. Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 O `throwOnError` parâmetro afeta somente o que acontece quando o tipo não foi encontrado. Ele não afeta todas as exceções que podem ser geradas. Em particular, se o tipo é encontrado, mas não pode ser carregado, <xref:System.TypeLoadException> pode ser acionada mesmo se `throwOnError` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é inválido.  
  
 - ou -  
  
 O comprimento de <paramref name="name" /> excede 1024 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o tipo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> exige um assembly dependente que não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto somente reflexão e o <paramref name="name" /> exige um assembly dependente que não foi pré-carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> exige um assembly dependente, mas o arquivo não é um assembly válido.  
  
 -ou-  
  
 <paramref name="name" /> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome completo do tipo.</param>
        <param name="throwOnError">
          <see langword="true" /> para gerar uma exceção se não for possível encontrar o tipo; <see langword="false" /> para retornar <see langword="null" />.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas e minúsculas do nome do tipo; caso contrário, <see langword="false" />.</param>
        <summary>Obtém o objeto <see cref="T:System.Type" /> com o nome especificado na instância do assembly, com a opção de ignorar a diferença entre maiúsculas e minúsculas e de gerar uma exceção se o tipo não for encontrado.</summary>
        <returns>Um objeto que representa a classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa apenas a instância atual do assembly. O `name` parâmetro inclui o namespace, mas não o assembly. Para pesquisar outros assemblies para um tipo, use o <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga de método, o que pode opcionalmente incluir um nome de exibição do assembly como parte do nome do tipo.  
  
> [!NOTE]
>  Se o tipo foi encaminhado para outro conjunto, ele ainda é retornado por este método. Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 O `throwOnError` parâmetro afeta somente o que acontece quando o tipo não foi encontrado. Ele não afeta todas as exceções que podem ser geradas. Em particular, se o tipo é encontrado, mas não pode ser carregado, <xref:System.TypeLoadException> pode ser acionada mesmo se `throwOnError` é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é inválido.  
  
 - ou -  
  
 O comprimento de <paramref name="name" /> excede 1024 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="throwOnError" /> é <see langword="true" /> e o tipo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="name" /> exige um assembly dependente que não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="name" /> exige um assembly dependente que foi encontrado, mas que não pôde ser carregado.  
  
 -ou-  
  
 O assembly atual foi carregado no contexto somente reflexão e o <paramref name="name" /> exige um assembly dependente que não foi pré-carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="name" /> exige um assembly dependente, mas o arquivo não é um assembly válido.  
  
 -ou-  
  
 <paramref name="name" /> exige um assembly dependente que foi compilado para uma versão do tempo de execução posterior à versão carregada no momento.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os tipos definidos neste assembly.</summary>
        <returns>Uma matriz que contém todos os tipos que são definidos nesse assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A matriz retornada inclui tipos aninhados.  
  
 Se o <xref:System.Reflection.Assembly.GetTypes%2A> método for chamado em um assembly e um tipo nesse assembly é dependente de um tipo em um assembly que não tenha sido carregado (por exemplo, se ela deriva de um tipo no assembly segundo), um <xref:System.Reflection.ReflectionTypeLoadException> é gerada. Por exemplo, isso pode acontecer se o primeiro assembly foi carregado com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> ou <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos e o segundo conjunto não foi carregado. Isso também pode acontecer com assemblies carregados usando o <xref:System.Reflection.Assembly.Load%2A> e <xref:System.Reflection.Assembly.LoadFile%2A> métodos se o segundo conjunto não pode ser localizada quando o <xref:System.Reflection.Assembly.GetTypes%2A> método é chamado.  
  
> [!NOTE]
>  Se um tipo foi encaminhado para outro conjunto, ele não está incluído na matriz retornada. Para obter informações sobre o encaminhamento de tipo, consulte [encaminhamento de tipo no Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).  
  
 Para recuperar uma coleção de <xref:System.Reflection.TypeInfo> objetos em vez de uma matriz de <xref:System.Type> objetos, use o <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir exibe os parâmetros de um método em um tipo no assembly especificado.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException">O assembly contém um ou mais tipos que não podem ser carregados. A matriz retornada pela propriedade <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> dessa exceção contém um objeto <see cref="T:System.Type" /> para cada tipo que foi carregado e <see langword="null" /> para cada tipo que não pôde ser carregado, enquanto a propriedade <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> contém uma exceção para cada tipo que não pôde ser carregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o assembly foi carregado do cache de assembly global.</summary>
        <value>
          <see langword="true" />Se o assembly foi carregado do cache de assembly global; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o contexto de host com o qual o assembly foi carregado.</summary>
        <value>Um valor <see cref="T:System.Int64" /> que indica o contexto de host com o qual o assembly foi carregado, se houver.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma cadeia de caracteres que representa a versão do CLR (Common Language Runtime) salva no arquivo que contém o manifesto.</summary>
        <value>O nome da pasta da versão do CLR. Este não é um caminho completo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, o valor para o .NET Framework versão 1.1 seria v 1.1.4322. Os arquivos binários para que a versão deve ser localizados no caminho % windir%\Microsoft.NET\Framework\v1.1.4322.  
  
 Por padrão, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> está definido para a versão do CLR usado para compilar o assembly. No entanto, ele pode ter sido definido como outro valor em tempo de compilação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">O tipo do atributo a ser verificada para esse assembly.</param>
        <param name="inherit">Este argumento é ignorado para objetos deste tipo.</param>
        <summary>Indica se há ou não um atributo especificado foi aplicado ao assembly.</summary>
        <returns>
          <see langword="true" />Se o atributo foi aplicado para o assembly. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir se aplica a <xref:System.Reflection.AssemblyTitleAttribute> atributo para um assembly e, em seguida, usa <xref:System.Reflection.Assembly.IsDefined%2A> para indicar se ela foi aplicada. Ele também testa um atributo que não foi aplicado.  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />usa um tipo inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o assembly atual foi gerado dinamicamente no processo atual por meio de reflexão emite.</summary>
        <value>
          <see langword="true" />Se o assembly atual foi gerado dinamicamente no processo atual; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Assemblies dinâmicos são representados pela classe derivada <xref:System.Reflection.Emit.AssemblyBuilder>.  
  
 Quando um assembly dinâmico é salvo em disco, o assembly salvo não é dinâmico. Se o assembly salvo é carregado em outro domínio de aplicativo ou processo, o <xref:System.Reflection.Assembly.IsDynamic%2A> propriedade retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o assembly atual é carregado com confiança total.</summary>
        <value>
          <see langword="true" /> se o assembly atual for carregado com confiança total; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <summary>Carrega o assembly com uma imagem baseada em formato COFF, contendo um assembly emitido. O assembly é carregado no domínio de aplicativo do chamador.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança de que o assembly de chamada. Para carregar um assembly de uma matriz de bytes com o nível de confiança do domínio do aplicativo, use o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> sobrecarga do método. Para obter mais informações sobre o uso de evidência com sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que usam matrizes de bytes, consulte o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> sobrecarga do método.  
  
 Refletir em arquivos executáveis C++ pode lançar um <xref:System.BadImageFormatException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou `.reloc` seção do arquivo executável. Para preservar o `.reloc` endereço para o arquivo executável C++, especifique `/fixed:no` quando você está vinculando.  
  
 Observe que essa sobrecarga de método sempre cria um novo <xref:System.Reflection.Assembly> objeto com seu próprio mapeamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">O objeto que descreve o assembly a ser carregado.</param>
        <summary>Carrega um assembly de acordo com seu <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>será gerada se `assemblyRef` Especifica o nome completo do assembly e o primeiro conjunto que corresponda ao nome simple tem uma versão diferente, cultura ou token de chave pública. O carregador não continuar a investigação de outros assemblies que correspondem ao nome simple.  
  
> [!NOTE]
>  Não use um <xref:System.Reflection.AssemblyName> somente com o <xref:System.Reflection.AssemblyName.CodeBase%2A> conjunto de propriedades. O <xref:System.Reflection.AssemblyName.CodeBase%2A> propriedade não fornece todos os elementos da identidade do assembly (como nome ou versão), então o carregar não ocorrerem de acordo com regras de carga por identidade, como se esperaria do <xref:System.Reflection.Assembly.Load%2A> método. Em vez disso, o assembly for carregado usando regras de carga. Para obter informações sobre as desvantagens de usar o contexto de carga, consulte o <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> sobrecarga de método ou [práticas recomendadas para o carregamento do Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidência fornecida pelo carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada. Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.  
  
    > [!NOTE]
    >  No .NET Framework versão 1.0 e na versão 1.1 sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado. `Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada. Evidência de assembly de chamada e evidência da imagem COFF são ignorados.  
  
 Refletir em arquivos executáveis C++ pode lançar um <xref:System.BadImageFormatException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou `.reloc` seção do arquivo executável. Para preservar o `.reloc` endereço para o arquivo executável C++, especifique `/fixed:no` quando você está vinculando.  
  
> [!NOTE]
>  Se o <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriedade estiver definida, a primeira tentativa de carregar o assembly usa o nome de exibição (incluindo a versão, cultura e assim por diante, conforme retornado pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade). Se o arquivo não for encontrado, <xref:System.Reflection.AssemblyName.CodeBase%2A> é usado para pesquisar o assembly. Se o assembly for encontrado usando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome de exibição é comparado com o assembly. Se a correspondência falhar, um <xref:System.IO.FileLoadException> é gerada.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Reflection.AssemblyName> do objeto e o utiliza para carregar o `sysglobal.dll` assembly. O exemplo, em seguida, exibe o nome completo de tipos públicos do assembly.  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.IO.IOException" />, em vez disso.  
  
</para>
          </block>  
  
 Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> não é um assembly válido. -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">O formato longo do nome do assembly.</param>
        <summary>Carrega um assembly tendo o formato longo de seu nome.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formato longo de um nome de assembly consiste em seu nome simple (como "sistema" para o assembly System. dll), juntamente com sua versão, cultura, token de chave pública e, opcionalmente, sua arquitetura de processador. Ele corresponde do assembly <xref:System.Reflection.Assembly.FullName%2A> propriedade. O exemplo a seguir ilustra o uso de um nome longo para carregar o assembly System. dll para o .NET Framework 4.  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <xref:System.IO.FileLoadException>será gerada se `assemblyString` Especifica o nome completo do assembly e o primeiro conjunto que corresponda ao nome simple tem uma versão diferente, cultura ou token de chave pública. O carregador não continuar a investigação de outros assemblies que correspondem ao nome simple.  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidência fornecida pelo carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada. Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.  
  
    > [!NOTE]
    >  No .NET Framework versão 1.0 e na versão 1.1 sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado. `Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada. Evidência de assembly de chamada e evidência da imagem COFF são ignorados.  
  
 Refletir em arquivos executáveis C++ pode lançar um <xref:System.BadImageFormatException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou `.reloc` seção do arquivo executável. Para preservar o `.reloc` endereço para o arquivo executável C++, especifique `/fixed:no` quando você está vinculando.  
  
 No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, a maneira recomendada para especificar um nome de assembly é criar um <xref:System.Reflection.AssemblyName> do objeto e passá-lo para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir carrega um assembly fornecido o nome totalmente qualificado e lista todos os tipos contidos no assembly especificado. Para este exemplo de código ser executado, você deve fornecer o nome de assembly totalmente qualificado. Para obter informações sobre como obter o nome totalmente qualificado do assembly, consulte [nomes de Assembly](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> é uma cadeia de comprimento zero.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <param name="rawSymbolStore">Uma matriz de bytes que contém os bytes brutos que representam os símbolos do assembly.</param>
        <summary>Carrega o assembly com uma imagem baseada em formato COFF, contendo um assembly emitido e com a opção de incluir símbolos para o assembly. O assembly é carregado no domínio de aplicativo do chamador.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nível de confiança de um assembly carregado usando esse método é o mesmo que o nível de confiança de que o assembly de chamada. Para carregar um assembly de uma matriz de bytes com o nível de confiança do domínio do aplicativo, use o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> sobrecarga do método. Para obter mais informações sobre o uso de evidência com sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que usam matrizes de bytes, consulte o <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> sobrecarga do método.  
  
 Refletir em arquivos executáveis C++ pode lançar um <xref:System.BadImageFormatException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou `.reloc` seção do arquivo executável. Para preservar o `.reloc` endereço para o arquivo executável C++, especifique `/fixed:no` quando você está vinculando.  
  
 Observe que essa sobrecarga de método sempre cria um novo <xref:System.Reflection.Assembly> objeto com seu próprio mapeamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">O objeto que descreve o assembly a ser carregado.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <summary>Carrega um assembly de acordo com seu <see cref="T:System.Reflection.AssemblyName" />. O assembly é carregado no domínio do chamador usando a evidência fornecida.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>será gerada se `assemblyRef` Especifica o nome completo do assembly e o primeiro conjunto que corresponda ao nome simple tem uma versão diferente, cultura ou token de chave pública. O carregador não continuar a investigação de outros assemblies que correspondem ao nome simple.  
  
> [!NOTE]
>  Não use um <xref:System.Reflection.AssemblyName> somente com o <xref:System.Reflection.AssemblyName.CodeBase%2A> conjunto de propriedades. O <xref:System.Reflection.AssemblyName.CodeBase%2A> propriedade não fornece todos os elementos da identidade do assembly (como nome ou versão), então o carregar não ocorrerem de acordo com regras de carga por identidade, como se esperaria do <xref:System.Reflection.Assembly.Load%2A> método. Em vez disso, o assembly for carregado usando regras de carga. Para obter informações sobre as desvantagens de usar o contexto de carga, consulte o <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> sobrecarga de método ou [práticas recomendadas para o carregamento do Assembly](~/docs/framework/deployment/best-practices-for-assembly-loading.md).  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidência fornecida pelo carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada. Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.  
  
    > [!NOTE]
    >  No .NET Framework versão 1.0 e na versão 1.1 sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado. `Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada. Evidência de assembly de chamada e evidência da imagem COFF são ignorados.  
  
 Refletir em arquivos executáveis C++ pode lançar um <xref:System.BadImageFormatException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou `.reloc` seção do arquivo executável. Para preservar o `.reloc` endereço para o arquivo executável C++, especifique `/fixed:no` quando você está vinculando.  
  
> [!NOTE]
>  Se o <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propriedade e o <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propriedade estiver definida, a primeira tentativa de carregar o assembly usa o nome de exibição (incluindo a versão, cultura e assim por diante, conforme retornado pelo <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propriedade). Se o arquivo não for encontrado, <xref:System.Reflection.AssemblyName.CodeBase%2A> é usado para pesquisar o assembly. Se o assembly for encontrado usando <xref:System.Reflection.AssemblyName.CodeBase%2A>, o nome de exibição é comparado com o assembly. Se a correspondência falhar, um <xref:System.IO.FileLoadException> é gerada.  
  
 Se você chamar o <xref:System.Reflection.Assembly.Load%2A> método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não gerará um <xref:System.IO.FileLoadException> a igualdade e a integridade das especificações evidência diferentes não podem ser determinada. A evidência que primeiro é bem-sucedida é a evidência que será usada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyRef" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">O nome para exibição do assembly.</param>
        <param name="assemblySecurity">Evidência para carregar o assembly.</param>
        <summary>Carrega um assembly dado seu nome de exibição, carregando-o no domínio do chamador usando a evidência fornecida.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.FileLoadException>será gerada se `assemblyString` Especifica o nome completo do assembly e o primeiro conjunto que corresponda ao nome simple tem uma versão diferente, cultura ou token de chave pública. O carregador não continuar a investigação de outros assemblies que correspondem ao nome simple.  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidência fornecida pelo carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é herdado do assembly de chamada. Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.  
  
    > [!NOTE]
    >  No .NET Framework versão 1.0 e na versão 1.1 sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado. `Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada. Evidência de assembly de chamada e evidência da imagem COFF são ignorados.  
  
 Refletir em arquivos executáveis C++ pode lançar um <xref:System.BadImageFormatException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou `.reloc` seção do arquivo executável. Para preservar o `.reloc` endereço para o arquivo executável C++, especifique `/fixed:no` quando você está vinculando.  
  
 Se você chamar esse método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não gerará um <xref:System.IO.FileLoadException> a igualdade e a integridade das especificações evidência diferentes não podem ser determinada. A evidência que primeiro é bem-sucedida é a evidência que será usada.  
  
 No .NET Framework versão 2.0, a arquitetura do processador é adicionada à identidade do assembly e pode ser especificada como parte das cadeias de caracteres de nome do assembly. Por exemplo, "ProcessorArchitecture=msil". No entanto, a maneira recomendada para especificar um nome de assembly é criar um <xref:System.Reflection.AssemblyName> do objeto e passá-lo para uma sobrecarga apropriada do <xref:System.Reflection.Assembly.Load%2A> método. Consulte <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> não foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.  
  
 - ou -  
  
 Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <param name="rawSymbolStore">Uma matriz de bytes que contém os bytes brutos que representam os símbolos do assembly.</param>
        <param name="securityEvidence">Evidência para carregar o assembly.</param>
        <summary>Carrega o assembly com um formato de arquivo de objeto COFF comum-com base em imagem que contém um assembly emitido, incluindo, opcionalmente, símbolos e evidência de assembly. O assembly é carregado no domínio de aplicativo do chamador.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly é carregado no domínio do chamador usando a evidência fornecida. Os bytes brutos que representa os símbolos para o assembly também são carregados.  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.Reflection.Assembly.Load%2A> método substituir partes de evidência fornecida pelo carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é herdado do assembly de chamada. Isso se aplica ao .NET Framework versão 1.1 Service Pack 1 (SP1) e versões posteriores.  
  
    > [!NOTE]
    >  No .NET Framework versão 1.0 e na versão 1.1 sem o SP1, quando você usa um <xref:System.Reflection.Assembly.Load%2A> sobrecarga de método com um `Byte[]` parâmetro para carregar uma imagem COFF, evidência é combinado. `Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.Load%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada. Evidência de assembly de chamada e evidência da imagem COFF são ignorados.  
  
 Refletir em arquivos executáveis C++ pode lançar um <xref:System.BadImageFormatException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou `.reloc` seção do arquivo executável. Para preservar o `.reloc` endereço para o arquivo executável C++, especifique `/fixed:no` quando você está vinculando.  
  
 Se você chamar o [\], Byte\<xref:System.Reflection.Assembly.Load%2A > método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não gerará um <xref:System.IO.FileLoadException> porque o igualdade e a integridade das especificações evidência diferentes não podem ser determinados. A evidência que primeiro é bem-sucedida é a evidência que será usada.  
  
 Observe que essa sobrecarga de método sempre cria um novo <xref:System.Reflection.Assembly> objeto com seu próprio mapeamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes em com duas evidências diferentes.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> não é <see langword="null" />.  Por padrão, a política de CAS legada não está habilitada no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando ele não estiver habilitado, <paramref name="securityEvidence" /> devem ser <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de fornecer a evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <param name="rawSymbolStore">Uma matriz de bytes que contém os bytes brutos que representam os símbolos do assembly.</param>
        <param name="securityContextSource">A origem do contexto de segurança.</param>
        <summary>Carrega o assembly com uma imagem baseada no formato COFF contendo um assembly emitido, opcionalmente incluindo símbolos e especificando a fonte para o contexto de segurança. O assembly é carregado no domínio de aplicativo do chamador.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assembly é carregado no domínio de aplicativo do chamador usando a origem especificada para o contexto de segurança. Se `rawSymbolStore` foi especificado, os bytes brutos que representam os símbolos para o assembly também são carregados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="rawAssembly" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor atribuído de <paramref name="securityContextSource" /> não é um dos valores de enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho totalmente qualificado do arquivo a ser carregado.</param>
        <summary>Carrega o conteúdo de um arquivo do assembly no caminho especificado.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Reflection.Assembly.LoadFile%2A> método para carregar e examine os assemblies que têm a mesma identidade, mas estão localizados em diferentes caminhos.<xref:System.Reflection.Assembly.LoadFile%2A> não carregar arquivos em contexto de carga e não resolver dependências usando o caminho de carga, como o <xref:System.Reflection.Assembly.LoadFrom%2A> método. <xref:System.Reflection.Assembly.LoadFile%2A>é útil neste cenário limitada porque <xref:System.Reflection.Assembly.LoadFrom%2A> não pode ser usado para carregar assemblies que têm as mesmo identidades mas caminhos diferentes; ele carregará apenas os primeiros esse assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="path" /> não é um caminho absoluto.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O parâmetro <paramref name="path" /> é uma cadeia de caracteres vazia ("") ou não existe.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="path" /> foi compilada com uma versão posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path">O caminho totalmente qualificado do arquivo do assembly.</param>
        <param name="securityEvidence">Evidência para carregar o assembly.</param>
        <summary>Carrega um assembly de acordo com seu caminho, carregando o assembly no domínio do chamador usando a evidência fornecida.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Reflection.Assembly.LoadFile%2A> método para carregar e examine os assemblies que têm a mesma identidade, mas estão localizados em diferentes caminhos. <xref:System.Reflection.Assembly.LoadFile%2A>não carregar arquivos para o <xref:System.Reflection.Assembly.LoadFrom%2A> contexto e não resolver dependências usando o caminho de carga, como o <xref:System.Reflection.Assembly.LoadFrom%2A> método. <xref:System.Reflection.Assembly.LoadFile%2A>é útil neste cenário limitada porque <xref:System.Reflection.Assembly.LoadFrom%2A> não pode ser usado para carregar assemblies que têm as mesmo identidades mas caminhos diferentes; ele carregará apenas os primeiros esse assembly.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O argumento <paramref name="path" /> não é um caminho absoluto.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O parâmetro <paramref name="path" /> é uma cadeia de caracteres vazia ("") ou não existe.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="path" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="path" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> não é <see langword="null" />. Por padrão, a política de CAS legada não está habilitada no [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; quando ele não estiver habilitado, <paramref name="securityEvidence" /> devem ser <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou um diretório, e para acesso às informações no próprio caminho. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome ou o caminho do arquivo que contém o manifesto do assembly.</param>
        <summary>Carrega um assembly de acordo com o nome de arquivo ou caminho.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape. Esse método fornece caracteres de escape para todos os caracteres inválidos no URI.  
  
> [!NOTE]
>  Não há suporte para o protocolo de transferência de arquivo (FTP). Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não está carregado. Nenhuma exceção é lançada.  
  
 `assemblyFile`pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.  
  
 Módulos (assemblies) pode ser carregado em um dos três contextos, ou pode ser carregado sem contexto:  
  
-   O contexto de carregamento contém assemblies encontrados pela sondagem: no GAC, em um assembly de host armazenar se o tempo de execução está hospedado, ou no <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo. A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.  
  
-   Contexto de carga contém os assemblies para os quais o usuário forneceu um caminho que não são incluído nos diretórios pesquisados por sondagem. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.  
  
-   O contexto exclusivo de reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código nesses contextos não podem ser executados.  
  
-   Se o usuário gerado ou localizado o assembly, não é em qualquer contexto. Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especificar uma matriz de bytes que contém um assembly e para transitórios assemblies dinâmicos criados com reflexão emitir e não são salvas em disco.  
  
 Contexto de carga permite que um assembly a ser carregado de um caminho não incluído na investigação e ainda permite que as dependências no caminho a ser localizado e carregado porque as informações de caminho são mantidas pelo contexto de.  
  
 O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens. Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.  
  
-   Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará. Isso pode ocorrer quando um assembly é desserializado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com um local diferente, mas com a mesma identidade de um <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado poderá ocorrer.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.  
  
-   Se existir uma imagem nativa para `assemblyFile`, ele não é usado. O assembly não pode ser carregado como domínio neutro.  
  
-   No .NET Framework versão 1.0 e 1.1, a diretiva não será aplicada.  
  
   
  
## Examples  
 O exemplo a seguir carrega um assembly fornecido o nome de arquivo ou caminho.  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits. Consulte o tópico de exceção para obter mais informações.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.Security.SecurityException">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">O nome do assembly é maior que os caracteres MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome ou o caminho do arquivo que contém o manifesto do assembly.</param>
        <param name="securityEvidence">Evidência para carregar o assembly.</param>
        <summary>Carrega um assembly dado seu nome de arquivo ou caminho e fornecendo evidência de segurança.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape. Esse método fornece caracteres de escape para todos os caracteres inválidos no URI.  
  
> [!NOTE]
>  Não há suporte para o protocolo de transferência de arquivo (FTP). Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não está carregado. Nenhuma exceção é lançada.  
  
 `assemblyFile`pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.  
  
 Módulos (assemblies) pode ser carregado em um dos três contextos, ou pode ser carregado sem contexto:  
  
-   O contexto de carregamento contém assemblies encontrados pela sondagem: no GAC, em um assembly de host armazenar se o tempo de execução está hospedado, ou no <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo. A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.  
  
-   Contexto de carga contém os assemblies para os quais o usuário forneceu um caminho que não são incluído nos diretórios pesquisados por sondagem. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.  
  
-   O contexto exclusivo de reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código nesses contextos não podem ser executados.  
  
-   Se o usuário gerado ou localizado o assembly, não é em qualquer contexto. Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especificar uma matriz de bytes que contém um assembly e para transitórios assemblies dinâmicos criados com reflexão emitir e não são salvas em disco.  
  
 Contexto de carga permite que um assembly a ser carregado de um caminho não incluído na investigação e ainda permite que as dependências no caminho a ser localizado e carregado porque as informações de caminho são mantidas pelo contexto de.  
  
 O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens. Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.  
  
-   Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará. Isso pode ocorrer quando um assembly é desserializado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com um local diferente, mas com a mesma identidade de um <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado poderá ocorrer.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.  
  
-   Se existir uma imagem nativa para `assemblyFile`, ele não é usado. O assembly não pode ser carregado como domínio neutro.  
  
-   No .NET Framework versão 1.0 e 1.1, a diretiva não será aplicada.  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.Reflection.Assembly.LoadFrom%2A> método substituir partes de evidência fornecida pelo carregador.  
  
-   Se você chamar esse método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não gerará um <xref:System.IO.FileLoadException> a igualdade e a integridade das especificações evidência diferentes não podem ser determinada. A evidência que primeiro é bem-sucedida é a evidência que será usada.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é combinado. `Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada. Evidência de assembly de chamada e evidência da imagem COFF são ignorados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.  
  
 -ou-  
  
 O <paramref name="securityEvidence" /> não é ambíguo e é determinado como inválido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits. Consulte o tópico de exceção para obter mais informações.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.Security.SecurityException">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">O nome do assembly é maior que os caracteres MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome ou o caminho do arquivo que contém o manifesto do assembly.</param>
        <param name="hashValue">O valor do código hash calculado.</param>
        <param name="hashAlgorithm">O algoritmo de hash usado para arquivos de hash e para gerar o nome forte.</param>
        <summary>Carrega um assembly de acordo com o nome de arquivo ou caminho, valor e algoritmo de hash.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape. Esse método fornece caracteres de escape para todos os caracteres inválidos no URI.  
  
> [!NOTE]
>  Não há suporte para o protocolo de transferência de arquivo (FTP). Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não está carregado. Nenhuma exceção é lançada.  
  
 `assemblyFile`pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.  
  
 Módulos (assemblies) pode ser carregado em um dos três contextos, ou pode ser carregado sem contexto:  
  
-   O contexto de carregamento contém assemblies encontrados pela sondagem: no cache de assembly global, em um assembly de host armazenar se o tempo de execução está hospedado, ou no <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo. A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.  
  
-   Contexto de carga contém os assemblies para os quais o usuário forneceu um caminho que não está incluído no probing. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.  
  
-   O contexto exclusivo de reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código nesses contextos não podem ser executados.  
  
-   Se o usuário gerado ou localizado o assembly, não é em qualquer contexto. Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especificar uma matriz de bytes que contém um assembly e para transitórios assemblies dinâmicos criados com reflexão emitir e não são salvas em disco.  
  
 Contexto de carga permite que um assembly a ser carregado de um caminho que não está incluído no probing e ainda permite que as dependências no caminho a ser localizado e carregado porque as informações de caminho são mantidas pelo contexto de.  
  
 O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens. Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.  
  
-   Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará. Isso pode ocorrer quando um assembly é desserializado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com um local diferente, mas com a mesma identidade de um <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado poderá ocorrer.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.  
  
-   Se existir uma imagem nativa para `assemblyFile`, ele não é usado. O assembly não pode ser carregado como de domínio neutro.  
  
 O assembly é carregado com a evidência que fornece o carregador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits. Consulte o tópico de exceção para obter mais informações.  
  
 -ou-  
  
 <paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.Security.SecurityException">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">O nome do assembly é maior que os caracteres MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome ou o caminho do arquivo que contém o manifesto do assembly.</param>
        <param name="securityEvidence">Evidência para carregar o assembly.</param>
        <param name="hashValue">O valor do código hash calculado.</param>
        <param name="hashAlgorithm">O algoritmo de hash usado para arquivos de hash e para gerar o nome forte.</param>
        <summary>Carrega um assembly fornecido seu nome de arquivo ou o caminho, o evidência de segurança, o valor de hash e o algoritmo de hash.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape. Esse método fornece caracteres de escape para todos os caracteres inválidos no URI.  
  
> [!NOTE]
>  Não há suporte para o protocolo de transferência de arquivo (FTP). Se o URI fornecido para `assemblyFile` é um endereço FTP, o assembly não está carregado. Nenhuma exceção é lançada.  
  
 `assemblyFile`pode ser absoluto ou relativo para o diretório atual, e o assembly é carregado para o domínio do chamador.  
  
 Módulos (assemblies) pode ser carregado em um dos três contextos, ou pode ser carregado sem contexto:  
  
-   O contexto de carregamento contém assemblies encontrados pela sondagem: no GAC, em um assembly de host armazenar se o tempo de execução está hospedado, ou no <xref:System.AppDomainSetup.ApplicationBase%2A> e <xref:System.AppDomainSetup.PrivateBinPath%2A> do domínio do aplicativo. A maioria das sobrecargas do método <xref:System.Reflection.Assembly.Load%2A> carrega os assemblies nesse contexto.  
  
-   Contexto de carga contém os assemblies para os quais o usuário forneceu um caminho que não são incluído nos diretórios pesquisados por sondagem. <xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> e <xref:System.AppDomain.ExecuteAssembly%2A> são exemplos de métodos que carregam pelo caminho.  
  
-   O contexto exclusivo de reflexão contém assemblies carregados com o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> e <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código nesses contextos não podem ser executados.  
  
-   Se o usuário gerado ou localizado o assembly, não é em qualquer contexto. Isso se aplica aos assemblies carregados usando sobrecargas do <xref:System.Reflection.Assembly.Load%2A> método que especificar uma matriz de bytes que contém um assembly e para transitórios assemblies dinâmicos criados com reflexão emitir e não são salvas em disco.  
  
 Contexto de carga permite que um assembly a ser carregado de um caminho não incluído na investigação e ainda permite que as dependências no caminho a ser localizado e carregado porque as informações de caminho são mantidas pelo contexto de.  
  
 O <xref:System.Reflection.Assembly.LoadFrom%2A> método tem as seguintes desvantagens. Considere o uso de <xref:System.Reflection.Assembly.Load%2A> em seu lugar.  
  
-   Se um assembly com a mesma identidade já estiver carregado, <xref:System.Reflection.Assembly.LoadFrom%2A> retornará o assembly carregado, mesmo se um caminho diferente foi especificado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>e posteriormente um assembly no contexto de carga tenta carregar o mesmo assembly por nome de exibição, a tentativa de carregamento falhará. Isso pode ocorrer quando um assembly é desserializado.  
  
-   Se um assembly é carregado com <xref:System.Reflection.Assembly.LoadFrom%2A>, e o caminho de investigação inclui um assembly com um local diferente, mas com a mesma identidade de um <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, ou outro comportamento inesperado poderá ocorrer.  
  
-   <xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType> e <xref:System.Security.Permissions.FileIOPermissionAccess?displayProperty=nameWithType>, ou <xref:System.Net.WebPermission>, no caminho especificado.  
  
-   Se existir uma imagem nativa para `assemblyFile`, ele não é usado. O assembly não pode ser carregado como domínio neutro.  
  
-   No .NET Framework versão 1.0 e 1.1, a diretiva não será aplicada.  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método sem nenhum <xref:System.Security.Policy.Evidence> parâmetro, o assembly é carregado com a evidência que fornece o carregador.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um <xref:System.Security.Policy.Evidence> parâmetros, partes de evidência são mesclados. Partes de evidência fornecida como um argumento para o <xref:System.Reflection.Assembly.LoadFrom%2A> método substituir partes de evidência fornecida pelo carregador.  
  
-   Se você chamar esse método mais de uma vez no mesmo assembly, mas com uma evidência diferente especificada, o common language runtime não gerará um <xref:System.IO.FileLoadException> a igualdade e a integridade das especificações evidência diferentes não podem ser determinada. A evidência que primeiro é bem-sucedida é a evidência que será usada.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro para carregar uma objeto arquivo formato COFF imagem comum, evidência é combinado. `Zone`, `Url` e `Site` são herdadas do assembly de chamada, e `Hash` e `StrongName` são obtidos do assembly COFF.  
  
-   Quando você usa um <xref:System.Reflection.Assembly.LoadFrom%2A> método com um `Byte[]` parâmetro e <xref:System.Security.Policy.Evidence> para carregar uma imagem COFF, somente a evidência fornecida é usada. Evidência de assembly de chamada e evidência da imagem COFF são ignorados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.  
  
 -ou-  
  
 O <paramref name="securityEvidence" /> não é ambíguo e é determinado como inválido.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido; por exemplo, um assembly de 32 bits em um processo de 64 bits. Consulte o tópico de exceção para obter mais informações.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.Security.SecurityException">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">O nome do assembly é maior que os caracteres MAX_PATH.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para carregar um assembly com evidências. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">O nome do módulo. Essa cadeia de caracteres deve corresponder a um nome de arquivo no manifesto deste assembly.</param>
        <param name="rawModule">Uma matriz de bytes que é uma imagem baseada em COFF que contém módulo omitido ou um recurso.</param>
        <summary>Carrega o módulo, interno a esse assembly, com uma imagem baseada no formato COFF que contém um módulo emitido ou um arquivo de recurso.</summary>
        <returns>O módulo carregado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> ou <paramref name="rawModule" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> não coincide com uma entrada de arquivo no manifesto deste assembly.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> não é um módulo válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName">O nome do módulo. Essa cadeia de caracteres deve corresponder a um nome de arquivo no manifesto deste assembly.</param>
        <param name="rawModule">Uma matriz de bytes que é uma imagem baseada em COFF que contém módulo omitido ou um recurso.</param>
        <param name="rawSymbolStore">Uma matriz de bytes que contém os bytes brutos que representa os símbolos para o módulo. Deve ser <see langword="null" /> quando se trata de um arquivo de recurso.</param>
        <summary>Carrega o módulo, interno a esse assembly, com uma imagem baseada no formato COFF que contém um módulo emitido ou um arquivo de recurso. Os bytes brutos que representa os símbolos para o módulo também são carregados.</summary>
        <returns>O módulo carregado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="moduleName" /> ou <paramref name="rawModule" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="moduleName" /> não coincide com uma entrada de arquivo no manifesto deste assembly.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawModule" /> não é um módulo válido.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para fornecer evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Carrega um assembly do diretório do aplicativo ou do cache de assembly global usando um nome parcial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  As sobrecargas do <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> método estão obsoleto e foi mantido para compatibilidade com versões anteriores. A alternativa não obsoleta é <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName">O nome para exibição do assembly.</param>
        <summary>Carrega um assembly do diretório do aplicativo ou do cache de assembly global usando um nome parcial.</summary>
        <returns>O assembly carregado. Se <paramref name="partialName" /> não foi encontrado, este método retorn <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> método está obsoleto e foi mantido para compatibilidade com versões anteriores. A alternativa não obsoleta é <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Aplicativos que carregar assemblies com esse método serão afetados por atualizações desses assemblies. Portanto, não use esse método; recriar o aplicativo para usar o <xref:System.Reflection.Assembly.Load%28System.String%29> sobrecarga de método ou o <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> sobrecarga do método.  
  
 Este método primeiro chama <xref:System.Reflection.Assembly.Load%2A>. Se o assembly não for encontrado, esse método retorna o assembly do cache de assembly global que tem o mesmo nome simples e o maior número de versão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="partialName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="partialName" /> foi compilada com uma versão posterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName">O nome para exibição do assembly.</param>
        <param name="securityEvidence">Evidência para carregar o assembly.</param>
        <summary>Carrega um assembly do diretório do aplicativo ou do cache de assembly global usando um nome parcial. O assembly é carregado no domínio do chamador usando a evidência fornecida.</summary>
        <returns>O assembly carregado. Se <paramref name="partialName" /> não foi encontrado, este método retorn <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> método está obsoleto e foi mantido para compatibilidade com versões anteriores. A alternativa não obsoleta é <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.  
  
 Evidência é o conjunto de informações que constitui a entrada para decisões de política de segurança, como quais permissões podem ser concedidas ao código.  
  
 Aplicativos que carregar assemblies com esse método serão afetados por atualizações desses assemblies. Portanto, não use esse método; recriar o aplicativo para usar o <xref:System.Reflection.Assembly.Load%2A> método ou o <xref:System.Reflection.Assembly.LoadFrom%2A> método.  
  
 Este método primeiro chama <xref:System.Reflection.Assembly.Load%2A>. Se o assembly não for encontrado, esse método retorna o assembly do cache de assembly global que tem o mesmo nome simples e o maior número de versão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException">Um assembly ou módulo foi carregado duas vezes com dois conjuntos de evidências.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="partialName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="partialName" /> foi compilada com uma versão posterior.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado e carregar um assembly com evidência. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho completo ou uma localização UNC do arquivo carregado que contém o manifesto.</summary>
        <value>A localização do arquivo carregado que contém o manifesto. Se o arquivo carregado foi copiado de sombra, o local é que o arquivo depois de ser copiado de sombra. Se o assembly for carregado de uma matriz de bytes, como ao usar a sobrecarga de método <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, o valor retornado será uma cadeia de caracteres vazia ("").</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter o local antes que o arquivo tenha sido copiado de sombra, use o <xref:System.Reflection.Assembly.CodeBase%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir exibe o local do arquivo carregado que contém o manifesto.  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O assembly atual é um assembly dinâmico, representado por um objeto <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar o caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o módulo que contém o manifesto do assembly atual.</summary>
        <value>O módulo que contém o manifesto do assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o comuns carregadores de classe de tempo de execução de linguagem não é possível resolver uma referência a um módulo interno de um assembly por meios normais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este evento dá o retorno de chamada a oportunidade de localizar e carregar o módulo em si e retorná-lo.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção que contém os módulos neste assembly.</summary>
        <value>Uma coleção que contém os módulos neste assembly.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">O assembly a ser comparado com <c>direito</c>.</param>
        <param name="right">O assembly a ser comparado com <c>esquerdo</c>.</param>
        <summary>Indica se dois objetos <see cref="T:System.Reflection.Assembly" /> são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left">O assembly a ser comparado com <c>direito</c>.</param>
        <param name="right">O assembly a ser comparado com <c>esquerdo</c>.</param>
        <summary>Indica se dois <see cref="T:System.Reflection.Assembly" /> objetos não são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> não for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o conjunto de concessões do assembly atual.</summary>
        <value>O conjunto de concessões do assembly atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.PermissionSet>objetos podem conter informações confidenciais, como caminhos. Portanto, a confiança total é necessária para acessar esses objetos.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um <see cref="T:System.Boolean" /> valor que indica se esse assembly foi carregado no contexto exclusivo de reflexão.</summary>
        <value>
          <see langword="true" />Se o assembly foi carregado no contexto exclusivo de reflexão, em vez do contexto de execução; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um assembly foi carregado no contexto exclusivo de reflexão, usando o <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método, você não pode executar o código no assembly. Para executar o código, o assembly deve ser carregado no contexto de execução.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Uma matriz de byte que é uma imagem baseada em COFF contendo um assembly emitido.</param>
        <summary>Carrega o assembly de uma imagem baseada em formato COFF contendo um assembly emitido. O assembly é carregado no contexto de somente reflexão do domínio do aplicativo do chamador.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não pode executar o código de um assembly carregado no contexto exclusivo de reflexão. Para executar o código, o assembly deve ser carregado no contexto de execução, usando o <xref:System.Reflection.Assembly.Load%2A> método.  
  
 O contexto exclusivo de reflexão não é diferente de outros contextos. Assemblies são carregados no contexto de podem ser descarregados somente por descarregar o domínio de aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> é <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="rawAssembly" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="rawAssembly" /> não pode ser carregado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">O nome de exibição do assembly, conforme retornado pela propriedade <see cref="P:System.Reflection.AssemblyName.FullName" />.</param>
        <summary>Carrega um assembly no contexto somente de reflexão, dado seu nome de exibição.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dependências não são automaticamente carregadas no contexto exclusivo de reflexão.  
  
 Você não pode executar o código de um assembly carregado no contexto exclusivo de reflexão. Para executar o código, o assembly deve ser carregado no contexto de execução, usando o <xref:System.Reflection.Assembly.Load%2A> método.  
  
 Se determinadas permissões são concedidas ou não a um assembly é algo que se baseia na evidência. As regras para o assembly e a mesclagem de evidência de segurança são da seguinte maneira:  
  
> [!NOTE]
>  Refletir em arquivos executáveis compilados em C++ pode acionar um <xref:System.IO.FileLoadException>. Isso provavelmente é causado pelo compilador C++ tirando os endereços de relocação ou a seção de .reloc do seu arquivo executável. Para preservar o endereço .reloc, especifique `/fixed:no` quando você está vinculando.  
  
 O contexto exclusivo de reflexão não é diferente de outros contextos. Assemblies são carregados no contexto de podem ser descarregados somente por descarregar o domínio de aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyString" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyString" /> foi encontrado, mas não pode ser carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyString" /> foi compilada com uma versão posterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O caminho do arquivo que contém o manifesto do assembly.</param>
        <summary>Carrega um assembly no contexto somente de reflexão, dado seu caminho.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dependências não são automaticamente carregadas no contexto exclusivo de reflexão. Para carregar automaticamente as dependências, tratar o <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> eventos e carregar a dependência no manipulador de eventos.  
  
 Você não pode executar o código de um assembly que foi carregado no contexto exclusivo de reflexão. Para executar o código, carregar o assembly com o <xref:System.Reflection.Assembly.LoadFile%2A> método.  
  
 O `assemblyFile` parâmetro deve se referir a um URI sem caracteres de escape. Esse método fornece caracteres de escape para todos os caracteres inválidos no URI.  
  
 O caminho especificado para `assemblyFile` é relativo ao diretório atual. O assembly é carregado para o domínio do chamador.  
  
 O contexto exclusivo de reflexão não é diferente de outros contextos. Assemblies são carregados no contexto de podem ser descarregados somente por descarregar o domínio de aplicativo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyFile" /> foi encontrado, mas não pôde ser carregado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 A versão 2,0 ou posterior do Common Language Runtime está carregada e <paramref name="assemblyFile" /> foi compilada com uma versão posterior.</exception>
        <exception cref="T:System.Security.SecurityException">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.IO.PathTooLongException">O nome do assembly é maior que os caracteres MAX_PATH.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler um URI que começa com "file://". Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <permission cref="T:System.Net.WebPermission">para ler um URI que não começa com "file://".</permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica qual conjunto de segurança regras o common language runtime (CLR) impõe a este assembly.</summary>
        <value>O conjunto de regras de segurança que impõe o CLR para esse assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, os assemblies que são compilados com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] ter transparência, embora você pode torná-los explicitamente em vez disso. Assemblies que foram compilados com versões anteriores do .NET Framework tem transparência de nível 1.  
  
 Consulte [Alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o tipo da instância atual.</summary>
        <returns>Um objeto que representa o tipo <see cref="T:System.Reflection.Assembly" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o nome completo do assembly, também conhecido como o nome para exibição.</summary>
        <returns>O nome completo do assembly, ou o nome de classe, se o nome completo do assembly não pode ser determinado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">O nome ou o caminho do arquivo que contém o manifesto do assembly.</param>
        <summary>Carrega um assembly no contexto de carga, ignorando algumas verificações de segurança.</summary>
        <returns>O assembly carregado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para carregar um assembly local que o sistema operacional foi sinalizada como tendo sido carregado da Web (por exemplo, um arquivo temporário que foi baixado da Internet ou intranet). Antes do [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], esses assemblies foram carregadas automaticamente para um domínio de aplicativo na área restrita. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], elas são carregadas com confiança total.  
  
 Como alternativa para usar esse método, você pode aplicar o [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) em seu arquivo de configuração do aplicativo. Isso faz com que o common language runtime reverter para a política de segurança do [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
> [!CAUTION]
>  Se você usar qualquer uma dessas soluções, você deve certificar-se é seguro carregar `assemblyFile` com confiança total.  
  
 Para obter uma discussão de contextos de carga, incluindo o contexto de carga, consulte o <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> sobrecarga do método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> não foi encontrado, ou o módulo que você está tentando carregar não especifica uma extensão de nome de arquivo.</exception>
        <exception cref="T:System.IO.FileLoadException">Não foi possível carregar um arquivo que foi encontrado.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> não é um assembly válido.  
  
 -ou-  
  
 <paramref name="assemblyFile" /> foi compilado com uma versão posterior do Common Language Runtime do que a versão carregada atualmente.</exception>
        <exception cref="T:System.Security.SecurityException">Uma base de código que não é iniciada com “file://” foi especificada sem o <see cref="T:System.Net.WebPermission" /> necessário.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="assemblyFile" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">O nome do assembly é maior que os caracteres MAX_PATH.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
