<Type Name="CriticalFinalizerObject" FullName="System.Runtime.ConstrainedExecution.CriticalFinalizerObject">
  <TypeSignature Language="C#" Value="public abstract class CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CriticalFinalizerObject extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Garante que todo o código de finalização em classes derivadas seja marcado como crítico.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derivando de classes de <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe implicitamente são tratados como uma região de execução restrita (CER).  Isso requer código no finalizador somente chamar código com um contrato de confiabilidade forte. Para obter mais informações sobre as CERs, consulte o <xref:System.Runtime.ConstrainedExecution> namespace.  
  
 Em classes derivadas do <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe, o common language runtime (CLR) garante que todo o código crítico de finalização terá a oportunidade de executar, desde que o finalizador segue as regras para uma CER, mesmo em situações em que o CLR forçadamente descarrega um domínio de aplicativo ou anula um thread. Se um finalizador viola as regras para uma CER, ele não pode executar com êxito. Além disso, o CLR estabelece uma ordenação fraca entre finalizadores normais e críticos: para objetos recuperados pela coleta de lixo ao mesmo tempo, todos os finalizadores não críticos são chamados antes de qualquer os finalizadores críticos. Por exemplo, uma classe como <xref:System.IO.FileStream>, que armazena dados no <xref:System.Runtime.InteropServices.SafeHandle> classe derivada de <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, pode executar um finalizador padrão para liberar os dados existentes em buffer.  
  
 Na maioria dos casos, você não precisa escrever classes que derivam de <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> classe. A biblioteca de classes do .NET Framework fornece duas classes, <xref:System.Runtime.InteropServices.SafeHandle> e <xref:System.Runtime.InteropServices.CriticalHandle>, que fornecem funcionalidade de finalização crítico para recursos do identificador. Além disso, o .NET Framework fornece um conjunto de classes boa derivado a <xref:System.Runtime.InteropServices.SafeHandle> classe e esse conjunto está localizado no <xref:Microsoft.Win32.SafeHandles> namespace. Essas classes são projetadas para fornecer funcionalidade comum para dar suporte a identificadores de arquivo e sistema operacional.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso da <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> classe para fornecer finalização crítica para os fluxos de saída e entrada padrão. O <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, derivada do <xref:System.Runtime.InteropServices.SafeHandle> de classe, que é passado para o fluxo de arquivos no <xref:System.IO.FileStream> construtor.  
  
 [!code-csharp[SafeHandle.SafeFileHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle.SafeFileHandle/CS/program.cs#1)]
 [!code-vb[SafeHandle.SafeFileHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle.SafeFileHandle/vb/program.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Esta classe não pode ser usada pelo código parcialmente confiável.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CriticalFinalizerObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ConstrainedExecution.CriticalFinalizerObject.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Esta classe não pode ser usada pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~CriticalFinalizerObject ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.ConstrainedExecution.CriticalFinalizerObject.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela classe <see cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O finalizador para qualquer tipos derivados de <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject> tem a oportunidade de executar e não será ser interrompida, supondo que o finalizador corretamente segue as regras para uma região de execução restrita (CER).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
