<Type Name="Package" FullName="System.IO.Packaging.Package">
  <TypeSignature Language="C#" Value="public abstract class Package : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Package extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Packaging.Package" />
  <AssemblyInfo>
    <AssemblyName>System.IO.Packaging</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa um contêiner que pode armazenar vários objetos de dados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package>é uma classe abstrata que pode ser usada para organizar objetos em uma única entidade de um formato físico definido para a portabilidade e acesso eficiente.  
  
 Um arquivo ZIP é o principal formato físico para o <xref:System.IO.Packaging.Package>.  Outros <xref:System.IO.Packaging.Package> implementações podem usar outros formatos físicos, como um documento XML, um banco de dados ou serviço da Web.  
  
 Como um sistema de arquivos, os itens contidos em um <xref:System.IO.Packaging.Package> são referenciados em uma organização hierárquica de pastas e arquivos.  
  
 Embora <xref:System.IO.Packaging.Package> em si é uma classe abstrata, o <xref:System.IO.Packaging.ZipPackage> classe derivada é usado como padrão pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Um <xref:System.IO.Packaging.PackagePart> ("parte") é a classe abstrata que representa um objeto que é armazenado em um <xref:System.IO.Packaging.Package>.  
  
 Um <xref:System.IO.Packaging.PackageRelationship> ("relação") define uma associação entre uma fonte de <xref:System.IO.Packaging.Package> ou <xref:System.IO.Packaging.PackagePart> e um objeto de destino.  Um <xref:System.IO.Packaging.PackageRelationship> pode ser um dos dois tipos, cada um deles pode ser uma das duas formas:  
  
-   Uma relação de nível de pacote (criado pelo <xref:System.IO.Packaging.Package.CreateRelationship%2A?displayProperty=nameWithType> método) relaciona uma <xref:System.IO.Packaging.Package> como:  
  
    -   Uma parte de destino no pacote.  
  
    -   Um recurso de destino fora do pacote.  
  
-   Uma relação de nível de parte (criado pelo <xref:System.IO.Packaging.PackagePart.CreateRelationship%2A?displayProperty=nameWithType> método) está relacionada a uma fonte de <xref:System.IO.Packaging.PackagePart> como:  
  
    -   Outra parte de destino no pacote.  
  
    -   Um recurso de destino fora do pacote.  
  
 Origem da relação <xref:System.IO.Packaging.Package> ou origem <xref:System.IO.Packaging.PackagePart> é considerada "proprietário" da relação.  Quando o objeto de origem é excluído, todas as relações de propriedade do objeto de origem também são excluídas.  O processo de criação ou exclusão de uma relação não altera os objetos de origem ou destino de alguma forma fisicamente.  
  
 Um <xref:System.IO.Packaging.PackageDigitalSignature> ("assinatura digital") é uma composição de partes e relações que representa uma assinatura digital incluída com um <xref:System.IO.Packaging.Package>.  A assinatura digital identifica o remetente e valida as partes assinados e as relações contidas no <xref:System.IO.Packaging.Package> não foram modificadas.  
  
 Pacotes também oferecem suporte a gerenciamento de direitos digitais (DRM), que permite que os elementos de conteúdo em um <xref:System.IO.Packaging.Package> a serem criptografados com direitos de acesso específicos concedidos a usuários autorizados.  
  
 Com base no <xref:System.IO.Packaging.Package> arquitetura, um <xref:System.Windows.Xps.Packaging.XpsDocument> é um tipo de pacote criado para armazenar documentos com base em abrir [XML Paper Specification (XPS)](http://go.microsoft.com/fwlink/?LinkID=65761).  
  
 [!INCLUDE[TLA#tla_avalonwinfx](~/includes/tlasharptla-avalonwinfx-md.md)]usa pacotes para armazenar o conteúdo, recursos e relações para páginas e documentos usando um arquivo ZIP padrão por padrão. Assim como com qualquer arquivo ZIP, seu aplicativo pode usar o <xref:System.IO.Packaging> classes para armazenar e, opcionalmente, proteger qualquer tipo ou o número de arquivos de dados em um único contêiner de acesso eficiente.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra as etapas básicas para criar um <xref:System.IO.Packaging.Package>.  Neste exemplo, um pacote é criado para conter um documento junto com uma imagem de gráfico é exibido como parte do documento.  (Isso é semelhante ao caso em que um arquivo HTML possui um \<IMG > marca que faz referência a um arquivo de imagem externa.)  Dois <xref:System.IO.Packaging.PackageRelationship> elementos também são incluídos no pacote.  Primeiro, uma relação de "nível de pacote", define a parte do documento como elemento de raiz do pacote.  Uma relação de segundo, "nível de parte" define a associação entre a parte do documento (a "origem" da relação de nível de parte) e seu uso da parte de imagem (o "destino" da relação de nível de parte).  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">As permissões de e/s de arquivo para o pacote.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.Packaging.Package" /> classe que usa um determinado <see cref="T:System.IO.FileAccess" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A>é um construtor protegido a <xref:System.IO.Packaging.Package> classe base abstrata. Quando chamado em uma classe derivada, o <xref:System.IO.Packaging.Package.%23ctor%2A> construtor inicializa uma nova instância da classe derivada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="openFileAccess" /> não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Package (System.IO.FileAccess openFileAccess, bool streaming);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(valuetype System.IO.FileAccess openFileAccess, bool streaming) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.#ctor(System.IO.FileAccess,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="openFileAccess" Type="System.IO.FileAccess" />
        <Parameter Name="streaming" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="openFileAccess">As permissões de e/s de arquivo para o pacote.</param>
        <param name="streaming">
          <see langword="true" />Para abrir o pacote para streaming; Caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.IO.Packaging.Package" /> classe que usa um determinado <see cref="T:System.IO.FileAccess" /> e opção de streaming.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.%23ctor%2A>é um construtor protegido a <xref:System.IO.Packaging.Package> abstrato de classe base abstrata de base. Quando chamado em uma classe derivada, o <xref:System.IO.Packaging.Package.%23ctor%2A> construtor inicializa uma nova instância da classe derivada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="openFileAccess" /> não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva e fecha o pacote e todos os fluxos de parte subjacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para o <xref:System.IO.Packaging.Package> classe <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> executar a mesma operação, não há nenhum motivo para chamar <xref:System.IO.Packaging.Package.Dispose%2A> se você chamar <xref:System.IO.Packaging.Package.Close%2A>, ou vice-versa.  
  
 <xref:System.IO.Packaging.Package.Close%2A>e <xref:System.IO.Packaging.Package.Dispose%2A> internamente chamar <xref:System.IO.Packaging.Package.Flush%2A>.  
  
> [!NOTE]
>  O `using` instrução (diferente de `using` diretiva de namespace) é a maneira recomendada para <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> um pacote.  [Escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055) e [ler um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160034) mostram como fechar e descartar um pacote usando o `using` instrução.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreatePart">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma nova parte do pacote.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A>inicializa um vazio <xref:System.IO.Stream> para a nova parte.  O <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> método pode ser usado para obter uma referência para a instância de fluxo associada à parte.  
  
 Para obter mais informações sobre as partes do pacote, consulte a seção 1.1 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo <xref:System.IO.Packaging.PackagePart> e, em seguida, armazenar dados em parte.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="Overload:System.IO.Packaging.Package.CreatePart" />chama internamente a classe derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> método para criar a parte com base no formato físico implementado na classe derivada.</para>
        </block>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partUri">O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] da parte de novo.</param>
        <param name="contentType">O tipo de conteúdo do fluxo de dados.</param>
        <summary>Cria uma nova parte descompactada com um URI e tipo de conteúdo específicos.</summary>
        <returns>A nova parte criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.CreatePart%2A>inicializa um vazio <xref:System.IO.Stream> para a nova parte.  O <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> método pode ser usado para obter uma referência para a instância de fluxo associada à parte.  
  
 A parte <xref:System.IO.Packaging.PackagePart.CompressionOption%2A> é <xref:System.IO.Packaging.CompressionOption?displayProperty=nameWithType>.  
  
 Para obter informações adicionais sobre as partes do pacote, consulte a seção 1.1 na especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo <xref:System.IO.Packaging.PackagePart> e, em seguida, armazenar dados em parte.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> ou <paramref name="contentType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />não é válido <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Uma parte com o <paramref name="partUri" /> especificado já existe no pacote.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente leitura (não é possível adicionar uma nova parte).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String)" />chama internamente a classe derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> método para criar a parte com base no formato físico implementado na classe derivada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreatePart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart CreatePart (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart CreatePart(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">O [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] da parte de novo.</param>
        <param name="contentType">O tipo de conteúdo do fluxo de dados.</param>
        <param name="compressionOption">A opção de compactação do fluxo de dados, <see cref="F:System.IO.Packaging.CompressionOption.NotCompressed" /> ou compactação <see cref="F:System.IO.Packaging.CompressionOption.Normal" />.</param>
        <summary>Cria uma nova parte com um URI, um tipo de conteúdo e uma opção de compactação específicos.</summary>
        <returns>A nova parte criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para o padrão <xref:System.IO.Packaging.ZipPackage> derivado da classe, o <xref:System.IO.Packaging.Package.CreatePart%2A> método só dá suporte a dois `compressionOption` valores, <xref:System.IO.Packaging.CompressionOption.NotCompressed> ou <xref:System.IO.Packaging.CompressionOption.Normal> compactação.  Outros <xref:System.IO.Packaging.CompressionOption> valores de <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, ou <xref:System.IO.Packaging.CompressionOption.SuperFast> usar <xref:System.IO.Packaging.CompressionOption.Normal> compactação.  
  
 <xref:System.IO.Packaging.Package.CreatePart%2A>cria um vazio <xref:System.IO.Stream> para a nova parte.  O <xref:System.IO.Packaging.PackagePart.GetStream%2A?displayProperty=nameWithType> método pode ser usado para obter uma referência para a instância de fluxo associada à parte.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo <xref:System.IO.Packaging.PackagePart> e, em seguida, armazenar dados em parte.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePart](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepart)]
 [!code-vb[PackageWrite#PackageWriteCreatePart](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepart)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> ou <paramref name="contentType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />não é válido <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Uma parte com o <paramref name="partUri" /> especificado já existe no pacote.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor <paramref name="compressionOption" /> não é válido.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente leitura (não é possível adicionar uma nova parte).</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.CreatePart(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />chama internamente a classe derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> método para criar a parte com base no formato físico implementado na classe derivada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreatePartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart CreatePartCore (Uri partUri, string contentType, System.IO.Packaging.CompressionOption compressionOption);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart CreatePartCore(class System.Uri partUri, string contentType, valuetype System.IO.Packaging.CompressionOption compressionOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
        <Parameter Name="contentType" Type="System.String" />
        <Parameter Name="compressionOption" Type="System.IO.Packaging.CompressionOption" />
      </Parameters>
      <Docs>
        <param name="partUri">O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] para a parte que está sendo criada.</param>
        <param name="contentType">O tipo de conteúdo do fluxo de dados.</param>
        <param name="compressionOption">A opção de compactação do fluxo de dados.</param>
        <summary>Quando substituído em uma classe derivada, cria uma nova parte no pacote.</summary>
        <returns>A parte criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derivada <xref:System.IO.Packaging.Package.CreatePartCore%2A> método é chamado pelo <xref:System.IO.Packaging.Package.CreatePart%2A> método para criar uma parte com base no formato físico implementado na classe derivada.  
  
 Por padrão, um <xref:System.IO.Packaging.ZipPackage> derivado a implementação da classe de abstrata <xref:System.IO.Packaging.Package> classe é fornecida e usada.  Na operação padrão, <xref:System.IO.Packaging.Package.CreatePart%2A> chama internamente <xref:System.IO.Packaging.Package.CreatePartCore%2A> do <xref:System.IO.Packaging.ZipPackage> classe para criar uma nova parte de um arquivo ZIP.  
  
 Para o padrão <xref:System.IO.Packaging.ZipPackage> derivado da classe, o <xref:System.IO.Packaging.Package.CreatePartCore%2A> método só dá suporte a dois `compressionOption` valores, <xref:System.IO.Packaging.CompressionOption.NotCompressed> ou <xref:System.IO.Packaging.CompressionOption.Normal> compactação.  Outros <xref:System.IO.Packaging.CompressionOption> valores de <xref:System.IO.Packaging.CompressionOption.Maximum>, <xref:System.IO.Packaging.CompressionOption.Fast>, ou <xref:System.IO.Packaging.CompressionOption.SuperFast> usar <xref:System.IO.Packaging.CompressionOption.Normal> compactação.  
  
 Para obter mais informações sobre o modelo de pacote e as partes do pacote, consulte o capítulo 1 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Derivada <see cref="M:System.IO.Packaging.Package.CreatePartCore(System.Uri,System.String,System.IO.Packaging.CompressionOption)" /> implementação deve não faça suposições sobre a ordem ou operações executadas pelo <see cref="Overload:System.IO.Packaging.Package.CreatePart" /> método que o chama.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateRelationship">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma relação de nível de pacote para uma determinada peça.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma relação de nível de pacote define uma associação entre o pacote e uma parte de destino associado ou um recurso.  Uma relação de nível de pacote pode ser uma das duas formas.  
  
-   Entre um <xref:System.IO.Packaging.Package> para um destino <xref:System.IO.Packaging.PackagePart> dentro do pacote.  
  
-   Entre um <xref:System.IO.Packaging.Package> a um recurso de destino fora do pacote.  
  
 Em uma relação de pacote, o pacote é considerado "proprietário" da relação.  Quando o pacote é excluído, todas as relações de propriedade do pacote também são excluídas.  O processo de criar ou excluir a relação não altera fisicamente a parte de destino ou o recurso de qualquer forma.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir ilustra a criação de um <xref:System.IO.Packaging.PackageRelationship> entre um <xref:System.IO.Packaging.Package> e uma parte do documento raiz.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[PackageWrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] da parte de destino.</param>
        <param name="targetMode">Indica se a parte de destino é <see cref="F:System.IO.Packaging.TargetMode.Internal" /> ou <see cref="F:System.IO.Packaging.TargetMode.External" /> ao pacote.</param>
        <param name="relationshipType">Um URI que define exclusivamente a função da relação.</param>
        <summary>Cria uma relação de nível de pacote a uma parte com um determinado URI, o modo de destino e o tipo de relação.</summary>
        <returns>A relação de nível de pacote para a parte especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma relação de nível de pacote define uma associação entre o pacote e uma parte de destino associado ou um recurso.  Uma relação de nível de pacote pode ser uma das duas formas.  
  
-   Entre um <xref:System.IO.Packaging.Package> para uma parte de destino no pacote.  
  
-   Entre um <xref:System.IO.Packaging.Package> a um recurso de destino fora do pacote.  
  
 Em uma relação de pacote, o pacote é considerado "proprietário" da relação.  Quando o pacote é excluído, todas as relações de propriedade do pacote também são excluídas.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A>não alterar fisicamente a parte de destino ou o recurso de qualquer forma.  
  
 O destino de uma relação não pode ser outra relação.  
  
 Se `targetMode` é especificado como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` deve ser um URI relativo que é formado de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) especificação de sintaxe genérica do identificador de recurso uniforme (URI).  O URI relativo interno pode ser um caminho absoluto que começa com uma barra ("/") caracteres, como "/ Page1" ou "/ images/picture4.jpg", ou um caminho relativo, como "... / imagespicture1.jpg "que resolve em relação a raiz do pacote ("/ ") como o URI de base.  
  
 Se `targetMode` é especificado como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` pode ser qualquer um absoluto ou URI relativo formado de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) especificação de sintaxe genérica do identificador de recurso uniforme (URI).  "http://www.microsoft.com/page2.xml" é um exemplo de um URI absoluto que faz referência a um recurso externo de destino "page2.xml".  "images/picture1.jpg" é um exemplo de um URI relativo que também faz referência a um destino externo recurso "1.jpg" mas que resolve em relação ao URI do próprio pacote.  
  
 `relationshipType`deve ser um [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] que é formado de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) especificação de sintaxe genérica do identificador de recurso uniforme (URI).  A tabela a seguir mostra o nível de pacote `relationshipType` URIs definido pela especificação Open Packaging Conventions (OPC).  
  
|Relação de nível de pacote|Tipo de relação URI|  
|---------------------------------|---------------------------|  
|Propriedades de núcleo|http://schemas.openxmlformats.org/Package/2006/Relationships/meta/core-propriedades de dados|  
|Assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-assinatura/assinatura|  
|Certificado de assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-/ certificado de assinatura|  
|Origem de assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-/ origem da assinatura|  
|Miniatura|dados de http://schemas.openxmlformats.org/Package/2006/Relationships/meta/miniatura|  
  
 Para obter mais informações sobre pacotes e relações do pacote, consulte a seção 1.3 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir ilustra como usar <xref:System.IO.Packaging.Package.CreateRelationship%2A> para criar um <xref:System.IO.Packaging.PackageRelationship> entre um <xref:System.IO.Packaging.Package> e uma parte do documento raiz.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> ou <paramref name="relationshipType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="targetUri" /> parte é uma <see cref="T:System.IO.Packaging.PackageRelationship" />, ou <paramref name="targetMode" /> é <see cref="F:System.IO.Packaging.TargetMode.Internal" /> e <paramref name="targetUri" /> é um URI absoluto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="targetMode" /> não é válido.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship CreateRelationship (Uri targetUri, System.IO.Packaging.TargetMode targetMode, string relationshipType, string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship CreateRelationship(class System.Uri targetUri, valuetype System.IO.Packaging.TargetMode targetMode, string relationshipType, string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.CreateRelationship(System.Uri,System.IO.Packaging.TargetMode,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetUri" Type="System.Uri" />
        <Parameter Name="targetMode" Type="System.IO.Packaging.TargetMode" />
        <Parameter Name="relationshipType" Type="System.String" />
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="targetUri">O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] da parte de destino.</param>
        <param name="targetMode">Indica se a parte de destino é <see cref="F:System.IO.Packaging.TargetMode.Internal" /> ou <see cref="F:System.IO.Packaging.TargetMode.External" /> ao pacote.</param>
        <param name="relationshipType">Um URI que define exclusivamente a função da relação.</param>
        <param name="id">Um identificador exclusivo do XML.</param>
        <summary>Cria uma relação de nível de pacote a uma parte com um determinado URI, o modo de destino, o tipo de relação, e [!INCLUDE[TLA#tla_id](~/includes/tlasharptla-id-md.md)].</summary>
        <returns>A relação de nível de pacote para a parte especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma relação de nível de pacote define uma associação entre o pacote e uma parte de destino associado ou um recurso.  Uma relação de nível de pacote pode ser uma das duas formas.  
  
-   Entre um <xref:System.IO.Packaging.Package> para uma parte de destino no pacote.  
  
-   Entre um <xref:System.IO.Packaging.Package> a um recurso de destino fora do pacote.  
  
 Em uma relação de pacote, o pacote é considerado "proprietário" da relação.  Quando o pacote é excluído, todas as relações de propriedade do pacote também são excluídas.  
  
 <xref:System.IO.Packaging.Package.CreateRelationship%2A>não alterar fisicamente a parte de destino ou o recurso de qualquer forma.  
  
 O destino de uma relação não pode ser outra relação.  
  
 `id`deve ser um identificador XML válido.  O `id` é xsd: ID de tipo e devem seguir as convenções de nomenclatura prescritas no esquema XML parte 2: especificação de tipos de dados (consulte [http://www.w3.org/TR/xmlschema-2/#ID](http://www.w3.org/TR/xmlschema-2/)).  
  
 Se `id` é especificado como `null` uma ID exclusiva será gerada automaticamente.  Um `id` especificado por um vazio cadeia de caracteres não é válida.  
  
 Se `targetMode` é especificado como <xref:System.IO.Packaging.TargetMode.Internal>, `targetUri` deve ser um URI relativo que é formado de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) especificação de sintaxe genérica do identificador de recurso uniforme (URI).  O URI relativo interno pode ser um caminho absoluto que começa com uma barra ("/") caracteres, como "/ Page1" ou "/ images/picture4.jpg", ou um caminho relativo, como "... / imagespicture1.jpg "que resolve em relação a raiz do pacote ("/ ") como o URI de base.  
  
 Se `targetMode` é especificado como <xref:System.IO.Packaging.TargetMode.External>, `targetUri` pode ser qualquer um absoluto ou URI relativo formado de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) especificação de sintaxe genérica do identificador de recurso uniforme (URI).  "http://www.microsoft.com/page2.xml" é um exemplo de um URI absoluto que faz referência a um recurso externo de destino "page2.xml".  "images/picture1.jpg" é um exemplo de um URI relativo que também faz referência a um destino externo recurso "1.jpg" mas que resolve em relação ao URI do próprio pacote.  
  
 `relationshipType`deve ser um URI que é formado de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) especificação de sintaxe genérica do identificador de recurso uniforme (URI).  A tabela a seguir mostra o nível de pacote `relationshipType` URIs definido pela especificação Open Packaging Conventions (OPC).  
  
|Relação de nível de pacote|Tipo de relação URI|  
|---------------------------------|---------------------------|  
|Propriedades de núcleo|http://schemas.openxmlformats.org/Package/2006/Relationships/meta/core-propriedades de dados|  
|Assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-assinatura/assinatura|  
|Certificado de assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-/ certificado de assinatura|  
|Origem de assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-/ origem da assinatura|  
|Miniatura|dados de http://schemas.openxmlformats.org/Package/2006/Relationships/meta/miniatura|  
  
 Para obter informações adicionais sobre o empacotamento e relações do pacote, consulte a seção 1.3 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir ilustra como usar <xref:System.IO.Packaging.Package.CreateRelationship%2A> para criar um <xref:System.IO.Packaging.PackageRelationship> entre um <xref:System.IO.Packaging.Package> e uma parte do documento raiz.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackagerelationship)]
 [!code-vb[packagewrite#PackageWriteCreatePackageRelationship](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackagerelationship)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="targetUri" /> ou <paramref name="relationshipType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="targetUri" /> parte é uma <see cref="T:System.IO.Packaging.PackageRelationship" />, ou <paramref name="targetMode" /> é <see cref="F:System.IO.Packaging.TargetMode.Internal" /> e <paramref name="targetUri" /> é um URI absoluto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="targetMode" /> não é válido.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente leitura.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />não é um identificador XML inválido; ou uma parte com especificado <paramref name="id" /> já está no pacote.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeletePart">
      <MemberSignature Language="C#" Value="public void DeletePart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeletePart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">O [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] da parte para excluir.</param>
        <summary>Exclui uma parte com um determinado URI do pacote.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `partUri`deve ser um URI relativo que consiste em um caminho absoluto que inicia com uma barra ("/") caracteres.  O caminho absoluto é relativo à raiz do pacote e é formado de acordo com o [RFC 3986](http://tools.ietf.org/html/rfc3986) especificação de sintaxe genérica do identificador de recurso uniforme (URI).  "/ Page1" e "/ images/picture4.jpg" são exemplos de URIs de parte válido.  
  
 Nenhuma exceção é gerada se uma parte com especificado `partUri` não está no pacote.  (Você pode usar o <xref:System.IO.Packaging.Package.PartExists%2A> método para determinar se uma parte com um especificado `partUri` no pacote.)  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />não é válido <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente leitura.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" />chama internamente a classe derivada <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> método para excluir, na verdade, a parte com base no formato físico implementado na classe derivada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DeletePartCore">
      <MemberSignature Language="C#" Value="protected abstract void DeletePartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DeletePartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">O <see cref="P:System.IO.Packaging.PackagePart.Uri" /> do <see cref="T:System.IO.Packaging.PackagePart" /> para excluir.</param>
        <summary>Quando substituído em uma classe derivada, exclui uma parte com um determinado URI.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, um <xref:System.IO.Packaging.ZipPackage> derivado a implementação da classe de abstrata <xref:System.IO.Packaging.Package> classe é fornecida e usada.  Na operação padrão, <xref:System.IO.Packaging.Package.DeletePart%2A> chama internamente <xref:System.IO.Packaging.Package.DeletePartCore%2A> do <xref:System.IO.Packaging.ZipPackage> com base no formato físico implementado na classe derivada de operação de exclusão de classe para executar o real.  
  
 Para obter mais informações sobre o modelo de pacote e as partes do pacote, consulte o capítulo 1 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>A classe derivada <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implementação é chamada pelo <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> método para a parte especificada com base no formato físico implementado na classe derivada.  
  
 Derivada <see cref="M:System.IO.Packaging.Package.DeletePartCore(System.Uri)" /> implementação deve não faça suposições sobre a ordem ou operações executadas pelo <see cref="M:System.IO.Packaging.Package.DeletePart(System.Uri)" /> método que o chama.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DeleteRelationship">
      <MemberSignature Language="C#" Value="public void DeleteRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DeleteRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.DeleteRelationship(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> do <see cref="T:System.IO.Packaging.PackageRelationship" /> para excluir.</param>
        <summary>Exclui uma relação de nível de pacote.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma relação de nível de pacote define uma associação entre o pacote e uma parte de destino associado ou um recurso.  Uma relação de nível de pacote pode ser uma das duas formas.  
  
-   Entre um <xref:System.IO.Packaging.Package> para uma parte de destino no pacote.  
  
-   Entre um <xref:System.IO.Packaging.Package> a um recurso de destino fora do pacote.  
  
 Em uma relação de pacote, o pacote é considerado "proprietário" da relação.  Quando o pacote é excluído, todas as relações de propriedade do pacote também são excluídas.  
  
 Nenhuma exceção é gerada se uma relação com a especificada `id` não está no pacote.  
  
 <xref:System.IO.Packaging.Package.DeleteRelationship%2A>não alterar fisicamente a parte de destino de qualquer forma.  
  
 Para obter mais informações sobre as relações do pacote, consulte a seção 1.3 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente leitura.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />não é um identificador XML válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera e salva o conteúdo de todas as partes e relações, fecha o pacote e libera todos os recursos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para certificar-se de que todas as alterações são salvas corretamente, <xref:System.IO.Packaging.Package.Dispose%2A> também finaliza, libera e fecha todas as partes e relações que estão contidas no pacote.  
  
 Para o <xref:System.IO.Packaging.Package> classe <xref:System.IO.Packaging.Package.Dispose%2A> e <xref:System.IO.Packaging.Package.Close%2A> executar a mesma operação - não há nenhum motivo para chamar <xref:System.IO.Packaging.Package.Dispose%2A> se você chamar <xref:System.IO.Packaging.Package.Close%2A>, ou vice-versa.  
  
 <xref:System.IO.Packaging.Package.Close%2A>e <xref:System.IO.Packaging.Package.Dispose%2A> internamente chamar <xref:System.IO.Packaging.Package.Flush%2A>.  
  
 Classes derivadas que alocar e gerenciar recursos de memória não devem substituir este método para liberar recursos quando <xref:System.IO.Packaging.Package.Dispose%2A> é chamado. Substituições de classe derivada também devem chamar <xref:System.IO.Packaging.Package.Flush%2A> e a classe base <xref:System.IO.Packaging.Package.Dispose%2A> método para certificar-se de que a limpeza de classe base sempre é executada.  
  
> [!NOTE]
>  O `using` instrução (diferente de `using` diretiva de namespace) é a maneira recomendada para <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> um pacote. [Escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055) mostra como fechar e descartar um pacote usando o `using` instrução.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FileOpenAccess">
      <MemberSignature Language="C#" Value="public System.IO.FileAccess FileOpenAccess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.IO.FileAccess FileOpenAccess" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.FileOpenAccess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAccess</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>O acesso a arquivos obtém configurações para o pacote.</summary>
        <value>Uma da <see cref="T:System.IO.FileAccess" /> valores: <see cref="F:System.IO.FileAccess.Read" />, <see cref="F:System.IO.FileAccess.Write" />, ou <see cref="F:System.IO.FileAccess.ReadWrite" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A propriedade <xref:System.IO.Packaging.Package.FileOpenAccess%2A> não tem valor padrão.  A configuração de acesso de arquivo é especificado no <xref:System.IO.Packaging.Package.%23ctor%2A> construtor chama quando você cria um novo pacote ou no <xref:System.IO.Packaging.Package.Open%2A> chamar quando você abrir um pacote existente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva o conteúdo de todas as partes e relações que estão contidas no pacote.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.Flush%2A>chama internamente a classe derivada <xref:System.IO.Packaging.Package.FlushCore%2A> implemetation para executar a operação de liberação específico formato real.  A classe derivada <xref:System.IO.Packaging.Package.FlushCore%2A> método é responsável para salvar o conteúdo de partes e relações, na verdade, a implementação da classe derivada de físico específico.  
  
 Por padrão, um <xref:System.IO.Packaging.ZipPackage> derivado de implementação do resumo <xref:System.IO.Packaging.Package> classe base é fornecida e usada. Na operação padrão, <xref:System.IO.Packaging.Package.Flush%2A> chama internamente <xref:System.IO.Packaging.Package.FlushCore%2A> para salvar as partes e relações em um pacote de arquivo ZIP.  
  
 <xref:System.IO.Packaging.Package.Flush%2A>é chamado automaticamente pelo <xref:System.IO.Packaging.Package.Close%2A> e <xref:System.IO.Packaging.Package.Dispose%2A> métodos.  Quando <xref:System.IO.Packaging.Package.Close%2A> ou <xref:System.IO.Packaging.Package.Dispose%2A> é chamado não é necessário chamar <xref:System.IO.Packaging.Package.Flush%2A> separadamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente leitura e não pode ser modificado.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.Flush" />chama internamente a classe derivada <see cref="M:System.IO.Packaging.Package.FlushCore" /> método para liberar, na verdade, a parte com base em do formato físico implementado na classe derivada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FlushCore">
      <MemberSignature Language="C#" Value="protected abstract void FlushCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void FlushCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.FlushCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, salva o conteúdo de todas as partes e relações para o armazenamento de classe derivada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.FlushCore%2A>é chamado pelo <xref:System.IO.Packaging.Package.Flush%2A> método para executar a operação de liberação real com base no formato físico implementado na classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Derivada <see cref="M:System.IO.Packaging.Package.FlushCore" /> implementação não deve fazer suposições sobre a ordem ou operações executadas pelo <see cref="M:System.IO.Packaging.Package.Flush" /> método que o chama.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPart">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePart GetPart (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePart GetPart(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPart(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] da parte a ser retornada.</param>
        <summary>Retorna a parte com um determinado URI.</summary>
        <returns>A parte com o <paramref name="partUri" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.InvalidOperationException> é gerada se uma parte com especificado `partUri` não existe.  
  
 O <xref:System.IO.Packaging.Package.PartExists%2A> método pode ser usado para determinar se `partUri` faz referência a uma parte existente.  
  
 Por padrão, um <xref:System.IO.Packaging.ZipPackage> derivado de implementação do resumo <xref:System.IO.Packaging.Package> classe base é fornecida e usada.  Na operação padrão, <xref:System.IO.Packaging.Package.GetPart%2A> chama internamente <xref:System.IO.Packaging.Package.GetPartCore%2A> do <xref:System.IO.Packaging.ZipPackage> classe para retornar uma parte solicitada de um arquivo ZIP.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como localizar, recuperar e ler partes que estão contidos em um pacote.  Para o exemplo completo, consulte [ler um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />não é válido <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.InvalidOperationException">Uma parte com o <paramref name="partUri" /> especificado não está no pacote.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente gravação.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" />chama internamente a classe derivada <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> método para liberar, na verdade, a parte com base em do formato físico implementado na classe derivada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPartCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart GetPartCore (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart GetPartCore(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">O [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] da parte para recuperar.</param>
        <summary>Quando substituído em uma classe derivada, retorna a parte endereçada por um determinado URI.</summary>
        <returns>A parte solicitada; ou <see langword="null" />, se uma parte com especificado <paramref name="partUri" /> não está no pacote.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, um <xref:System.IO.Packaging.ZipPackage> derivado de implementação do resumo <xref:System.IO.Packaging.Package> classe é fornecida e usada.  Na operação padrão, <xref:System.IO.Packaging.Package.GetPart%2A> chama internamente <xref:System.IO.Packaging.Package.GetPartCore%2A> do <xref:System.IO.Packaging.ZipPackage> classe para recuperar uma parte de um arquivo ZIP.  
  
 Para obter mais informações sobre o modelo de pacote e as partes do pacote, consulte o capítulo 1 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>A classe derivada <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implementação é chamada pelo <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> método para acessar e retornar a parte especificada com base no formato físico implementado na classe derivada.  
  
 Derivada <see cref="M:System.IO.Packaging.Package.GetPartCore(System.Uri)" /> implementação deve não faça suposições sobre a ordem ou operações executadas pelo <see cref="M:System.IO.Packaging.Package.GetPart(System.Uri)" /> método que o chama.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetParts">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackagePartCollection GetParts ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackagePartCollection GetParts() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetParts" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePartCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma coleção de todas as partes no pacote.</summary>
        <returns>Uma coleção de todos os elementos <see cref="T:System.IO.Packaging.PackagePart" /> contidos no pacote.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetParts%2A>Retorna uma coleção de todas as partes que estão contidos no pacote, incluindo <xref:System.IO.Packaging.PackageRelationship> partes.  
  
 <xref:System.IO.Packaging.Package.GetParts%2A>nunca retornarão `null`; no entanto, a coleção retornada conterá zero elemento se o pacote não contiver nenhuma parte.  
  
 Por padrão, um <xref:System.IO.Packaging.ZipPackage> derivado de implementação do resumo <xref:System.IO.Packaging.Package> classe base é fornecida e usada.  Na operação padrão, <xref:System.IO.Packaging.Package.GetParts%2A> chama o <xref:System.IO.Packaging.Package.GetPartsCore%2A> método o <xref:System.IO.Packaging.ZipPackage> classe para retornar as partes de um arquivo ZIP.  
  
 Para obter mais informações sobre pacotes e partes do pacote, consulte a seção 1.1 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.IO.Packaging.Package.GetParts%2A> método para obter uma coleção das partes contidas em um <xref:System.IO.Packaging.Package>.  Para o código-fonte completo do programa, consulte [criando um pacote com um exemplo de Assinatura Digital](http://go.microsoft.com/fwlink/?LinkID=159966).  
  
  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente gravação.</exception>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.IO.Packaging.Package.GetParts" />chama internamente a classe derivada <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> método para liberar, na verdade, a parte com base em do formato físico implementado na classe derivada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPartsCore">
      <MemberSignature Language="C#" Value="protected abstract System.IO.Packaging.PackagePart[] GetPartsCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.IO.Packaging.PackagePart[] GetPartsCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetPartsCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackagePart[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, retorna uma matriz de todas as partes do pacote.</summary>
        <returns>Uma matriz de todas as partes que estão contidos no pacote.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A classe derivada <xref:System.IO.Packaging.Package.GetPartsCore%2A> implementação é chamada pelo <xref:System.IO.Packaging.Package.GetParts%2A> método para acessar e retornar a matriz das partes com base em do formato físico implementado na classe derivada.  
  
 Por padrão, um <xref:System.IO.Packaging.ZipPackage> derivado de implementação do resumo <xref:System.IO.Packaging.Package> classe é fornecida e usada.  Na operação padrão, <xref:System.IO.Packaging.Package.GetParts%2A> chama internamente <xref:System.IO.Packaging.Package.GetPartCore%2A> do <xref:System.IO.Packaging.ZipPackage> classe para recuperar as partes de um arquivo ZIP.  
  
 Para obter mais informações sobre o modelo de pacote e as partes do pacote, consulte o capítulo 1 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Derivada <see cref="M:System.IO.Packaging.Package.GetPartsCore" /> implementação deve não faça suposições sobre a ordem ou operações executadas pelo <see cref="M:System.IO.Packaging.Package.GetParts" /> método que o chama.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetRelationship">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationship GetRelationship (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationship GetRelationship(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationship(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationship</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> da relação para retornar.</param>
        <summary>Retorna a relação de nível de pacote com o identificador fornecido.</summary>
        <returns>A relação de nível de pacote com especificado <paramref name="id" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `id`deve ser um identificador XML válido.  O `id` é xsd: ID de tipo e devem seguir as convenções de nomenclatura prescritas no esquema XML parte 2: especificação de tipos de dados (consulte [http://www.w3.org/TR/xmlschema-2/#ID](http://www.w3.org/TR/xmlschema-2/#ID)).  
  
 Para obter informações adicionais sobre o empacotamento e relações do pacote, consulte a seção 1.3 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />não é um identificador XML válido.</exception>
        <exception cref="T:System.InvalidOperationException">Uma relação com a especificada <paramref name="id" /> não está no pacote.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationships">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationships ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationships() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationships" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma coleção de todas as relações de nível de pacote.</summary>
        <returns>Uma coleção de todas as relações de nível de pacote que estão contidos no pacote.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A>nunca retornarão `null`; no entanto, a coleção retornada pode conter elementos de zero se o pacote não contiver nenhuma relação de nível de pacote.  
  
 Uma relação de nível de pacote define uma associação entre o pacote e uma parte de destino associado ou um recurso.  Uma relação de nível de pacote pode ser uma das duas formas.  
  
-   Entre um <xref:System.IO.Packaging.Package> para uma parte de destino no pacote.  
  
-   Entre um <xref:System.IO.Packaging.Package> a um recurso de destino fora do pacote.  
  
 Em uma relação de pacote, o pacote é considerado "proprietário" da relação.  Quando o pacote é excluído, todas as relações de propriedade do pacote também são excluídas.  O processo de criar ou excluir a relação não altera fisicamente a parte de destino ou o recurso de qualquer forma.  
  
 Para obter informações adicionais sobre o empacotamento e relações do pacote, consulte a seção 1.3 da especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipsByType">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType (string relationshipType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Packaging.PackageRelationshipCollection GetRelationshipsByType(string relationshipType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.GetRelationshipsByType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageRelationshipCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relationshipType" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relationshipType">O <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" /> para corresponder e retornar da coleção.</param>
        <summary>Retorna uma coleção de todas as relações de nível de pacote que correspondem a um determinado <see cref="P:System.IO.Packaging.PackageRelationship.RelationshipType" />.</summary>
        <returns>Uma coleção de relações de nível de pacote que correspondem à cadeia <paramref name="relationshipType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.Package.GetRelationships%2A>nunca retornarão `null`; no entanto, a coleção retornada pode conter zero elemento se não houver nenhuma relação de nível de pacote que correspondem à cadeia `relationshipType`.  
  
 A tabela a seguir mostra o nível de pacote `relationshipType` URIs definido pela especificação Open Packaging Conventions (OPC).  
  
|Relação de nível de pacote|Tipo de relação URI|  
|---------------------------------|---------------------------|  
|Propriedades de núcleo|http://schemas.openxmlformats.org/Package/2006/Relationships/meta/core-propriedades de dados|  
|Assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-assinatura/assinatura|  
|Certificado de assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-/ certificado de assinatura|  
|Origem de assinatura digital|http://schemas.openxmlformats.org/Package/2006/Relationships/Digit al-/ origem da assinatura|  
|Miniatura|dados de http://schemas.openxmlformats.org/Package/2006/Relationships/meta/miniatura|  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar as relações que foram definidas para o pacote.  Para o exemplo completo, consulte [ler um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relationshipType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="relationshipType" /> é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente gravação.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Open">
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Abre um pacote.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementos junto com os dados armazenados.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo de E/S no qual o pacote será aberto.</param>
        <summary>Abre um pacote em um determinado fluxo de E/S.</summary>
        <returns>O pacote aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Para abrir o pacote requer permissão de leitura/gravação e o <paramref name="stream" /> especificado é somente gravação ou então o pacote a abrir requer permissão de gravação ou de leitura/gravação e o <paramref name="stream" /> especificado é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho e o nome de arquivo do pacote.</param>
        <summary>Abre um pacote em um determinado caminho e nome de arquivo.</summary>
        <returns>O pacote aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Isso <xref:System.IO.Packaging.Package.Open%2A> método abre o pacote com os atributos padrão <xref:System.IO.FileMode.OpenOrCreate>, <xref:System.IO.FileAccess.ReadWrite>, e <xref:System.IO.FileShare.None> (para especificar atributos diferentes usam uma das sobrecargas de método Open).  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementos junto com os dados armazenados.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo de E/S no qual o pacote será aberto.</param>
        <param name="packageMode">O modo de arquivo no qual o pacote é aberto.</param>
        <summary>Abre um pacote com um determinado modo de arquivo e de fluxo de e/s.</summary>
        <returns>O pacote aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          O valor <paramref name="packageMode" /> não é válido.</exception>
        <exception cref="T:System.IO.IOException">Para abrir o pacote requer permissão de leitura/gravação e o <paramref name="stream" /> especificado é somente gravação ou então o pacote a abrir requer permissão de gravação ou de leitura/gravação e o <paramref name="stream" /> especificado é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">O caminho e o nome de arquivo do pacote.</param>
        <param name="packageMode">O modo de arquivo no qual o pacote é aberto.</param>
        <summary>Abre um pacote em um determinado caminho usando um modo de arquivo fornecido.</summary>
        <returns>O pacote aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Isso <xref:System.IO.Packaging.Package.Open%2A> método abre o pacote com os atributos padrão <xref:System.IO.FileAccess.ReadWrite> e <xref:System.IO.FileShare.None> (para especificar atributos diferentes usam uma das sobrecargas de método Open).  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementos junto com os dados armazenados.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor para <paramref name="packageMode" /> não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (System.IO.Stream stream, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(class System.IO.Stream stream, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.IO.Stream,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo de E/S no qual o pacote será aberto.</param>
        <param name="packageMode">O modo de arquivo no qual o pacote é aberto.</param>
        <param name="packageAccess">O acesso ao arquivo no qual o pacote é aberto.</param>
        <summary>Abre um pacote com um fluxo de E/S, um modo de arquivo e uma configuração de acesso a arquivos especificados.</summary>
        <returns>O pacote aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor de <paramref name="packageMode" /> ou <paramref name="packageAccess" /> não é válido.</exception>
        <exception cref="T:System.IO.IOException">O pacote a ser aberto exige a permissão de leitura ou leitura/gravação e o <paramref name="stream" /> especificado é somente gravação ou o pacote a ser aberto exige a permissão de gravação ou leitura/gravação e o <paramref name="stream" /> especificado é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">O caminho e o nome de arquivo do pacote.</param>
        <param name="packageMode">O modo de arquivo no qual abrir o pacote.</param>
        <param name="packageAccess">O acesso ao arquivo no qual o pacote é aberto.</param>
        <summary>Abre um pacote em um determinado caminho usando um modo de arquivo especificado e a configuração de acesso ao arquivo.</summary>
        <returns>O pacote aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Isso <xref:System.IO.Packaging.Package.Open%2A> método abre o pacote com um padrão <xref:System.IO.FileShare.None> atributo (para especificar um atributo diferente, use o <xref:System.IO.Packaging.Package.Open%2A> sobrecarga do método).  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como abrir e ler um <xref:System.IO.Packaging.Package> que contém <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementos junto com os dados armazenados.  Para o exemplo completo, consulte [ler um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160034).  
  
 [!code-csharp[PackageRead#PackageReadUsing](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageRead/CSharp/PackageRead.cs#packagereadusing)]
 [!code-vb[PackageRead#PackageReadUsing](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageRead/visualbasic/packageread.vb#packagereadusing)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor para <paramref name="packageMode" /> ou <paramref name="packageAccess" /> não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.Packaging.Package Open (string path, System.IO.FileMode packageMode, System.IO.FileAccess packageAccess, System.IO.FileShare packageShare);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Packaging.Package Open(string path, valuetype System.IO.FileMode packageMode, valuetype System.IO.FileAccess packageAccess, valuetype System.IO.FileShare packageShare) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.Package</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="packageMode" Type="System.IO.FileMode" />
        <Parameter Name="packageAccess" Type="System.IO.FileAccess" />
        <Parameter Name="packageShare" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">O caminho e o nome de arquivo do pacote.</param>
        <param name="packageMode">O modo de arquivo no qual abrir o pacote.</param>
        <param name="packageAccess">O acesso de arquivo no qual abrir o pacote.</param>
        <param name="packageShare">O modo de compartilhamento de arquivo no qual abrir o pacote.</param>
        <summary>Abre um pacote em um determinado caminho usando um dado modo de arquivo, acesso a arquivos e configurações de compartilhamento de arquivos.</summary>
        <returns>O pacote aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Packaging.ZipPackage>é o tipo de pacote padrão que é usado pelo <xref:System.IO.Packaging.Package.Open%2A> método.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo <xref:System.IO.Packaging.Package> que incorpora <xref:System.IO.Packaging.PackageRelationship> e <xref:System.IO.Packaging.PackagePart> elementos junto com os dados armazenados.  Para o exemplo completo, consulte [escrevendo um exemplo de pacote](http://go.microsoft.com/fwlink/?LinkID=160055).  
  
 [!code-csharp[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/csharp/VS_Snippets_Wpf/PackageWrite/CSharp/PackageWrite.cs#packagewritecreatepackage)]
 [!code-vb[PackageWrite#PackageWriteCreatePackage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PackageWrite/visualbasic/packagewrite.vb#packagewritecreatepackage)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor para <paramref name="packageMode" />, <paramref name="packageAccess" /> ou <paramref name="packageShare" /> não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="PackageProperties">
      <MemberSignature Language="C#" Value="public System.IO.Packaging.PackageProperties PackageProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Packaging.PackageProperties PackageProperties" />
      <MemberSignature Language="DocId" Value="P:System.IO.Packaging.Package.PackageProperties" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Packaging.PackageProperties</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as propriedades principais do pacote.</summary>
        <value>As propriedades principais do pacote.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações adicionais sobre as propriedades do pacote de núcleo, consulte a seção 3.1 na especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
      </Docs>
    </Member>
    <Member MemberName="PartExists">
      <MemberSignature Language="C#" Value="public virtual bool PartExists (Uri partUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PartExists(class System.Uri partUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.PartExists(System.Uri)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="partUri">O <see cref="T:System.Uri" /> da parte para verificar.</param>
        <summary>Indica se uma parte com um determinado URI está no pacote.</summary>
        <returns>
          <see langword="true" />Se uma parte com especificado <paramref name="partUri" /> está no pacote; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `partUri` deve começar com um caractere de barra "/" e ser absoluto da raiz do pacote.  
  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="partUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="partUri" />não é válido <see cref="T:System.IO.Packaging.PackagePart" /> [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)].</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente gravação (não não possível ler informações).</exception>
      </Docs>
    </Member>
    <Member MemberName="RelationshipExists">
      <MemberSignature Language="C#" Value="public bool RelationshipExists (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RelationshipExists(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.RelationshipExists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O <see cref="P:System.IO.Packaging.PackageRelationship.Id" /> da relação para verificar.</param>
        <summary>Indica se uma relação de nível de pacote com uma ID especificada está contida no pacote.</summary>
        <returns>
          <see langword="true" />Se uma relação de nível de pacote com especificado <paramref name="id" /> está no pacote; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte a especificação Open Packaging Conventions (OPC) disponível para download em [http://go.microsoft.com/fwlink/?LinkID=71255](http://go.microsoft.com/fwlink/?LinkID=71255).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="id" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="id" />não é um identificador XML válido.</exception>
        <exception cref="T:System.ObjectDisposedException">O pacote não está aberto (<see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> ou <see cref="M:System.IO.Packaging.Package.Close" /> foi chamado).</exception>
        <exception cref="T:System.IO.IOException">O pacote é somente gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Packaging.Package.System#IDisposable#Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.Packaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Esse membro oferece suporte a [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infraestrutura e não se destina ao uso do aplicativo.  Use a segurança de tipo <see cref="M:System.IO.Packaging.Package.Dispose(System.Boolean)" /> método em vez disso.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
