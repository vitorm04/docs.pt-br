<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define um bloqueio que dá suporte a autores únicos e múltiplos leitores.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] tem dois bloqueios de leitor-gravador, <xref:System.Threading.ReaderWriterLockSlim> e <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim>é recomendado para todos os novos desenvolvimentos. <xref:System.Threading.ReaderWriterLockSlim>é semelhante ao <xref:System.Threading.ReaderWriterLock>, mas ele simplificou regras de recursão e para atualizar e fazer o downgrade de estado de bloqueio. <xref:System.Threading.ReaderWriterLockSlim>evita muitos casos de potencial deadlock. Além disso, o desempenho de <xref:System.Threading.ReaderWriterLockSlim> é significativamente melhores do que <xref:System.Threading.ReaderWriterLock>.  
  
 <xref:System.Threading.ReaderWriterLock>é usado para sincronizar o acesso a um recurso. A qualquer momento determinado, ele permite que o acesso simultâneo de leitura para vários threads, ou acesso de gravação para um único thread. Em uma situação em que um recurso é alterado com frequência, um `ReaderWriterLock` fornece melhor taxa de transferência que um bloqueio de um em vez de simple, como <xref:System.Threading.Monitor>.  
  
 `ReaderWriterLock`funciona melhor em que acessa a maioria das leituras, enquanto as gravações são incomuns e de curta duração. Vários leitores alternam com gravadores único, para que nem leitores nem gravadores estão bloqueados por longos períodos.  
  
> [!NOTE]
>  Manter bloqueios de leitor ou bloqueios de gravação por longos períodos enfraquecer o outro thread. Para melhor desempenho, considere a reestruturação de seu aplicativo para minimizar a duração de gravações.  
  
 Um thread pode manter um leitor de bloqueio ou um bloqueio de gravador, mas não ambos ao mesmo tempo. Em vez de liberar um bloqueio de leitor para adquirir o bloqueio de gravador, você pode usar <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> e <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.  
  
 Solicitações de bloqueio recursiva aumentam a contagem de bloqueio em um bloqueio.  
  
 Os leitores e gravadores são enfileirados separadamente. Quando um thread libera o bloqueio de gravador, todos os threads aguardando na fila de leitor no momento são concedidos bloqueios de leitor; Quando todos os bloqueios de leitor foram lançados, a próxima espera de thread no gravador de fila, se houver, é concedido o bloqueio de gravador e assim por diante. Em outras palavras, `ReaderWriterLock` alterna entre uma coleção de leitores e um gravador.  
  
 Enquanto aguarda um thread na fila do gravador de bloqueios de leitor ativo a ser liberado, threads, solicitando novos bloqueios de leitor acumulam na fila leitor. As solicitações não são concedidas, mesmo que eles podem compartilhar acesso simultâneo com detentores de bloqueio de leitor existente; Isso ajuda a proteger gravadores em bloqueio indefinido por leitores.  
  
 A maioria dos métodos para adquirir bloqueios em uma `ReaderWriterLock` aceitar valores de tempo limite. Use tempos limite para evitar deadlocks em seu aplicativo. Por exemplo, um thread pode adquirir o bloqueio de gravador em um recurso e, em seguida, solicitam um bloqueio de leitor em um segundo recurso; Enquanto isso, outro thread pode adquirir o bloqueio de gravador no segundo recurso e solicitam um bloqueio de leitor no primeiro. A menos que tempos limite é usado, o bloqueio de threads.  
  
 Se o intervalo de tempo limite expira e não foi concedida a solicitação de bloqueio, o método retorna o controle para o thread de chamada, lançando um <xref:System.ApplicationException>. Um thread pode tratar essa exceção e determinar qual ação realizar em seguida.  
  
 Tempos limite é expressos em milissegundos. Se você usar um <xref:System.TimeSpan?displayProperty=nameWithType> para especificar o tempo limite, o valor usado é o número total de milissegundos representado pelo <xref:System.TimeSpan>. A tabela a seguir mostra os valores de tempo limite válido em milissegundos.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|-1|O thread aguarda até que o bloqueio é adquirido, independentemente de quanto tempo demora. Para métodos que especificar tempos limite de número inteiro, a constante <xref:System.Threading.Timeout.Infinite> pode ser usado.|  
|0|O thread não espera para adquirir o bloqueio. Se o bloqueio não é possível adquirir imediatamente, o método retorna.|  
|>0|O número de milissegundos de espera.|  
  
 Com exceção de -1, não são permitidos valores de tempo limite negativo. Se você especificar um inteiro negativo que não seja -1, um valor de tempo limite de zero será usado. (Ou seja, o método retorna sem esperar, se o bloqueio não é possível adquirir imediatamente.) Se você especificar um <xref:System.TimeSpan> que representa um número negativo de milissegundos que não seja -1, <xref:System.ArgumentOutOfRangeException> é gerada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar um <xref:System.Threading.ReaderWriterLock> para proteger um recurso compartilhado, um valor inteiro chamado `resource`, que é lido simultaneamente e gravado exclusivamente por vários threads. Observe que o <xref:System.Threading.ReaderWriterLock> é declarado no nível de classe para que seja visível para todos os threads.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como criar uma nova instância do <xref:System.Threading.ReaderWriterLock> classe.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
        <summary>Adquire um bloqueio de leitor, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>Bloquear se um thread diferente tiver o bloqueio de gravador, ou se pelo menos um thread está aguardando o bloqueio de gravador.  
  
> [!NOTE]
>  Se o thread atual já tem o bloqueio de gravador, nenhum bloqueio de leitor é adquirido. Em vez disso, a contagem de bloqueio no bloqueio de gravador é incrementada. Isso impede que um thread de bloqueio em seu próprio bloqueio de gravador. O resultado é exatamente o mesmo que chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>e uma chamada adicional para <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> é necessária ao liberar o bloqueio de gravador.  
  
 `AcquireReaderLock`oferece suporte a solicitações de bloqueio de leitor de recursiva. Isto é, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueio cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> uma vez para cada vez que você chamar `AcquireReaderLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila de leitor. Use bloqueios de recursiva com cuidado, para evitar o bloqueio de solicitações de bloqueio de gravador por longos períodos.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de leitor e como lidar com a exceção gerada quando uma solicitação de tempo limite.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see langword="TimeSpan" /> especificando o período de tempo limite.</param>
        <summary>Obtém um leitor de bloqueio, usando um <see cref="T:System.TimeSpan" /> valor para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A>Bloquear se um thread diferente tiver o bloqueio de gravador, ou se pelo menos um thread está aguardando o bloqueio de gravador.  
  
> [!NOTE]
>  Se o thread atual já tem o bloqueio de gravador, nenhum bloqueio de leitor é adquirido. Em vez disso, a contagem de bloqueio no bloqueio de gravador é incrementada. Isso impede que um thread de bloqueio em seu próprio bloqueio de gravador. O resultado é exatamente o mesmo que chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>e uma chamada adicional para <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> é necessária ao liberar o bloqueio de gravador.  
  
 `AcquireReaderLock`oferece suporte a solicitações de bloqueio de leitor de recursiva. Isto é, um thread pode chamar AcquireReaderLock várias vezes, que incrementa a contagem de bloqueio cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> uma vez para cada vez que você chamar `AcquireReaderLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila de leitor. Use bloqueios de recursiva com cuidado, para evitar o bloqueio de solicitações de bloqueio de gravador por longos períodos.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
        <summary>Adquire um bloqueio de gravador, usando um valor <see cref="T:System.Int32" /> para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método blocos se outro thread tiver um bloqueio de leitor ou gravador. Para obter uma descrição do modo como o bloqueio de gravador alterna com vários bloqueios de leitor simultâneas, consulte o <xref:System.Threading.ReaderWriterLock> classe.  
  
 Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de gravador de duas maneiras: por liberar o bloqueio de leitor antes de chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou chamando <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Se um thread chama `AcquireWriterLock` enquanto ele ainda possui um bloqueio de leitor, ela impedirá que seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, o thread de deadlock. Para evitar tais deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar se o thread atual já tem um bloqueio de leitor.  
  
 `AcquireWriterLock`dá suporte a solicitações de bloqueio de gravador recursiva. Isto é, um thread pode chamar `AcquireWriterLock` várias vezes, que incrementa a contagem de bloqueio cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> uma vez para cada vez que você chamar `AcquireWriterLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila do gravador.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de gravador e como lidar com a exceção gerada quando uma solicitação de tempo limite.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
        <summary>Adquire um bloqueio de gravador, usando um valor <see cref="T:System.TimeSpan" /> para o tempo limite.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método blocos se outro thread tiver um bloqueio de leitor ou gravador. Para obter uma descrição do modo como o bloqueio de gravador alterna com vários bloqueios de leitor simultâneas, consulte o <xref:System.Threading.ReaderWriterLock> classe.  
  
 Um thread que já tem um bloqueio de leitor pode adquirir o bloqueio de gravador de duas maneiras: por liberar o bloqueio de leitor antes de chamar <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, ou chamando <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
> [!CAUTION]
>  Se um thread chama `AcquireWriterLock` enquanto ele ainda possui um bloqueio de leitor, ela impedirá que seu próprio bloqueio de leitor; se for especificado um tempo limite infinito, o thread de deadlock. Para evitar tais deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar se o thread atual já tem um bloqueio de leitor.  
  
 `AcquireWriterLock`dá suporte a solicitações de bloqueio de gravador recursiva. Isto é, um thread pode chamar `AcquireWriterLock` várias vezes, que incrementa a contagem de bloqueio cada vez. Você deve chamar <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> uma vez para cada vez que você chamar `AcquireWriterLock`. Como alternativa, você pode chamar <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reduzir a contagem de bloqueio como zero imediatamente.  
  
 Solicitações de bloqueio recursiva sempre são concedidas imediatamente, sem colocar o thread de solicitação na fila do gravador.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">O número de sequência.</param>
        <summary>Indica se o bloqueio de gravador foi concedido para qualquer thread desde que o número de sequência foi obtido.</summary>
        <returns>
          <see langword="true" />Se o bloqueio de gravador recebeu qualquer thread desde que foi obtido o número de sequência; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> e `AnyWritersSince` para melhorar o desempenho do aplicativo. Por exemplo, um thread pode armazenar em cache as informações que ele obtém mantendo um bloqueio de leitor. Depois de liberar e posteriormente readquirir o bloqueio, o thread pode usar `AnyWritersSince` para determinar se outros threads foram gravadas para o recurso nesse ínterim; caso contrário, as informações em cache podem ser usadas. Essa técnica é útil onde a leitura das informações protegidas pelo bloqueio é caro; Por exemplo, executando uma consulta de banco de dados.  
  
 O chamador deve ser mantendo um bloqueio de leitor ou um bloqueio de gravador para que o número de sequência para serem úteis.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> método e o <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propriedade para determinar se outro thread adquiriu o bloqueio de gravador no recurso protegido desde o thread atual última mantém o bloqueio de gravador.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</param>
        <summary>Restaura o status de bloqueio do thread para o status prévio antes de <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> ser chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>libera o bloqueio de gravador, independentemente da contagem de bloqueio recursiva e restaura o bloqueio de leitor foi mantido pelo thread antes de atualizar para o bloqueio de gravador. A contagem de bloqueio no bloqueio de leitor é restaurada.  
  
> [!NOTE]
>  `DowngradeFromWriterLock`aceita um <xref:System.Threading.LockCookie> obtida chamando <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>. Não use um `LockCookie` retornado por <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.  
  
 Um thread não bloqueia ao fazer o downgrade do bloqueio de gravador, mesmo se outros threads estão aguardando o bloqueio de gravador, porque todas as solicitações de bloqueio de leitor são concedidas quando o bloqueio de gravador é liberado.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como solicitar um bloqueio de leitor, atualize o bloqueio de leitor para um bloqueio de gravador e fazer o downgrade para um bloqueio de leitor novamente.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O thread não tem o bloqueio de gravador.</exception>
        <exception cref="T:System.NullReferenceException">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see cref="T:System.Threading.ReaderWriterLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O coletor de lixo chama <xref:System.Threading.ReaderWriterLock.Finalize%2A> quando atual <xref:System.Threading.ReaderWriterLock> objeto está pronto para ser finalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o thread atual mantém um bloqueio de leitor.</summary>
        <value>
          <see langword="true" />Se o thread atual mantém um bloqueio de leitor; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como usar `IsReaderLockHeld` para evitar deadlocks.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o thread atual mantém o bloqueio de gravador.</summary>
        <value>
          <see langword="true" />Se o thread atual retém o bloqueio de gravador; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra que, quando é feita uma tentativa de adquirir um bloqueio de leitor em um thread que possui um bloqueio de gravador `ReaderWriterLock` não concede o bloqueio de leitor, mas em vez disso, incrementa a contagem de bloqueio no bloqueio de gravador.  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera o bloqueio, independentemente do número de vezes que o thread adquiriu o bloqueio.</summary>
        <returns>Um <see cref="T:System.Threading.LockCookie" /> valor que representa o bloqueio liberado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>libera o bloqueio de leitor ou gravador, independentemente da contagem de bloqueio recursiva. Para restaurar o estado do bloqueio, incluindo a contagem de bloqueio, passar o <xref:System.Threading.LockCookie> para <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar o bloqueio, independentemente de quantas vezes ela foi adquirido por thread e como restaurar o estado do bloqueio mais tarde.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Diminui a contagem de bloqueio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A>diminui a contagem de bloqueio. Quando a contagem chega a zero, o bloqueio seja liberado.  
  
> [!NOTE]
>  Se um thread tem o bloqueio de gravador, chamando `ReleaseReaderLock` tem o mesmo efeito da chamada <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>. Se um thread não tem nenhum bloqueio, chamando `ReleaseReaderLock` lança um <xref:System.ApplicationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de leitor e como lidar com a exceção gerada quando uma solicitação de tempo limite.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O thread não tem nenhum bloqueio de leitor ou de gravador.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Diminui a contagem de bloqueio no bloqueio de gravador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>decrementa o bloqueio de gravador contagem. Quando a contagem chega a zero, o bloqueio de gravador é liberado.  
  
> [!NOTE]
>  Se um thread tem um bloqueio de leitor ou nenhum bloqueio, chamando `ReleaseWriterLock` lança um <xref:System.ApplicationException>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como adquirir e liberar um bloqueio de gravador e como lidar com a exceção gerada quando uma solicitação de tempo limite.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">O thread não tem o bloqueio de gravador.</exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">Um <see cref="T:System.Threading.LockCookie" /> retornado por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</param>
        <summary>Restaura o status de bloqueio do thread ao que era antes de chamar <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O estado restaurado por `RestoreLock` inclui a contagem de bloqueio recursiva.  
  
 Blocos de thread se tentar restaurar um bloqueio de leitor depois de outro thread tenha adquirido o bloqueio de gravador, ou se tentar restaurar o bloqueio de gravador depois de outro thread adquiriu um bloqueio de leitor ou gravador. Porque `RestoreLock` não aceita um tempo limite, você deve ter cuidado para evitar deadlocks possíveis.  
  
> [!CAUTION]
>  Antes de chamar `RestoreLock`, certifique-se de ter lançado todos os bloqueios adquiridos desde a chamada para <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>. Por exemplo, um thread deadlocks se adquire um bloqueio de leitor e, em seguida, tenta restaurar um bloqueio de gravador anterior. Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> e <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> para detectar esses bloqueios adicionais.  
  
 Não use um <xref:System.Threading.LockCookie> retornado de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar o bloqueio, independentemente de quantas vezes ela foi adquirido por thread e como restaurar o estado do bloqueio mais tarde.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">O endereço de <paramref name="lockCookie" /> é um ponteiro nulo.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O tempo limite em milissegundos.</param>
        <summary>Atualiza um bloqueio de leitor para o bloqueio de gravador, usando um valor <see langword="Int32" /> para o tempo limite.</summary>
        <returns>Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread chama `UpgradeToWriterLock` o bloqueio de leitor é liberado, independentemente da contagem de bloqueio, e o thread vai para o final da fila para o bloqueio de gravador. Portanto, outros threads podem gravar o recurso antes do thread que solicitou que a atualização é concedida o bloqueio de gravador.  
  
> [!IMPORTANT]
>  A exceção de tempo limite não é lançada até que o thread que chamou o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método pode readquirir o bloqueio de leitor. Se não houver nenhum outro thread aguarda o bloqueio de gravador, isso ocorre imediatamente. No entanto, se outro thread estiver na fila para o bloqueio de gravador, o thread que chamaram a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método não é possível readquirir o bloqueio de leitor até que todos os leitores atuais lançou seus bloqueios e um thread tem adquiridos e liberados o bloqueio de gravador. Isso é verdadeiro mesmo se outro thread que solicitou o bloqueio de gravador solicitou depois que o segmento atual é chamado de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.  
  
 Para restaurar o estado de bloqueio, chame <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> usando o <xref:System.Threading.LockCookie> retornado por `UpgradeToWriterLock`. Não use isso `LockCookie` com <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Quando um thread não tem nenhum bloqueio de leitor, não use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> em seu lugar.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como solicitar um bloqueio de leitor, atualize o bloqueio de leitor para um bloqueio de gravador e fazer o downgrade para um bloqueio de leitor novamente.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          O <paramref name="millisecondsTimeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">O <see langword="TimeSpan" /> que especifica o período de tempo limite.</param>
        <summary>Bloqueio de um bloqueio de leitor para o gravador de atualizações, usando um <see langword="TimeSpan" /> valor para o tempo limite.</summary>
        <returns>Um valor <see cref="T:System.Threading.LockCookie" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread chama `UpgradeToWriterLock` o bloqueio de leitor é liberado, independentemente da contagem de bloqueio, e o thread vai para o final da fila para o bloqueio de gravador. Portanto, outros threads podem gravar o recurso antes do thread que solicitou que a atualização é concedida o bloqueio de gravador.  
  
> [!IMPORTANT]
>  A exceção de tempo limite não é lançada até que o thread que chamou o <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método pode readquirir o bloqueio de leitor. Se não houver nenhum outro thread aguarda o bloqueio de gravador, isso ocorre imediatamente. No entanto, se outro thread estiver na fila para o bloqueio de gravador, o thread que chamaram a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método não é possível readquirir o bloqueio de leitor até que todos os leitores atuais lançou seus bloqueios e um thread tem adquiridos e liberados o bloqueio de gravador. Isso é verdadeiro mesmo se outro thread que solicitou o bloqueio de gravador solicitou depois que o segmento atual é chamado de <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.  
  
 Para restaurar o estado de bloqueio, chame <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> usando o <xref:System.Threading.LockCookie> retornado por `UpgradeToWriterLock`. Não use isso `LockCookie` com <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.  
  
 Quando um thread não tem nenhum bloqueio de leitor, não use `UpgradeToWriterLock`. Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> em seu lugar.  
  
 Para obter valores de tempo limite válido, consulte <xref:System.Threading.ReaderWriterLock>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          O <paramref name="timeout" /> expira antes que a solicitação de bloqueio seja concedida.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> especifica um valor negativo diferente de -1 milissegundo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de sequência atual.</summary>
        <value>O número de sequência atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência número aumenta sempre que um thread adquire o bloqueio de gravador. Você pode salvar o número de sequência e passá-lo para <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> em um momento posterior, se você quiser determinar se outros threads tem adquirido o bloqueio de gravador nesse meio tempo.  
  
 Você pode usar `WriterSeqNum` para melhorar o desempenho do aplicativo. Por exemplo, um thread pode armazenar em cache as informações que ele obtém mantendo um bloqueio de leitor. Depois de liberar e posteriormente readquirir o bloqueio, o thread pode determinar se outros threads foram gravadas para o recurso chamando `AnyWritersSince`; se não, as informações em cache podem ser usadas. Essa técnica é útil quando as informações protegidas pelo bloqueio de leitura é caro; Por exemplo, executando uma consulta de banco de dados.  
  
 O chamador deve ser mantendo um bloqueio de leitor ou um bloqueio de gravador para que o número de sequência para serem úteis.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propriedade e o <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> método para determinar se outro thread adquiriu o bloqueio de gravador no recurso protegido desde o thread atual última mantém o bloqueio de gravador.  
  
 Esse código é parte de um exemplo maior fornecido para a <xref:System.Threading.ReaderWriterLock> classe.  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
