<Type Name="EventWaitHandle" FullName="System.Threading.EventWaitHandle">
  <TypeSignature Language="C#" Value="public class EventWaitHandle : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventWaitHandle extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.EventWaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um evento de sincronização de thread.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.EventWaitHandle> classe permite que os threads para se comunicar entre si por sinalização. Normalmente, um ou mais threads bloqueiam um <xref:System.Threading.EventWaitHandle> até que um thread desbloqueado chama o <xref:System.Threading.EventWaitHandle.Set%2A> método, liberando um ou mais threads bloqueados. Um thread pode sinalizar um <xref:System.Threading.EventWaitHandle> e, em seguida, bloquear, chamando o `static` (`Shared` no Visual Basic) <xref:System.Threading.WaitHandle.SignalAndWait%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  O <xref:System.Threading.EventWaitHandle> classe fornece acesso a chamado sistema de eventos de sincronização.  
  
 O comportamento de um <xref:System.Threading.EventWaitHandle> que tem sido sinalizado depende de seu modo de redefinição. Um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador redefine automaticamente quando sinalizado, após o lançamento de um único thread de espera. Um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador permanece sinalizado até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.  
  
 Eventos de redefinição automática fornecem acesso exclusivo a um recurso. Se um evento de redefinição automática é sinalizado quando não há threads estão esperando, ele permanecerá sinalizado até que um thread tente esperar. O evento libera o thread e redefine imediatamente, bloqueando threads subsequentes.  
  
 Eventos são como entradas de redefinição manual. Quando o evento não será sinalizado, bloqueará threads que esperam nele. Quando o evento é sinalizado, todos os threads de espera são liberados e o evento permanece sinalizado (ou seja, esperas subsequentes não bloqueiam) até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado. Eventos de redefinição manual são úteis quando um thread deve concluir uma atividade para outros threads podem continuar.  
  
 <xref:System.Threading.EventWaitHandle>objetos podem ser usados com o `static`(`Shared` no Visual Basic) <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> e <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos.  
  
 Para obter mais informações sobre mecanismos de sincronização de thread, consulte [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.  
  
 O exemplo inicia cinco threads e permite bloquear um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER. O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> para definir o estado inicial como sinalizado; <see langword="false" /> para defini-lo como não sinalizado.</param>
        <param name="mode">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente e se ele redefine automática ou manualmente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador é especificado para `mode`, threads que esperar o evento não serão bloqueado. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.  
  
 O exemplo inicia cinco threads e permite bloquear um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER. O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <see langword="false" /> para defini-lo como não sinalizado.</param>
        <param name="mode">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
        <param name="name">O nome de um evento de sincronização de todo o sistema.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente e o nome de um evento de sincronização do sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `name` é `null` ou uma cadeia de caracteres vazia, um local <xref:System.Threading.EventWaitHandle> é criado.  
  
 Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro é ignorado.  
  
> [!IMPORTANT]
>  Ao usar esse construtor para eventos do sistema nomeada, especifique `false` para `initialState`. Este construtor oferece nenhuma forma de determinar se um evento do sistema nomeado foi criado, portanto, você não pode fazer suposições sobre o estado do evento nomeado. Para determinar se um evento nomeado foi criado, use o <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%29> construtor ou <xref:System.Threading.EventWaitHandle.%23ctor%28System.Boolean%2CSystem.Threading.EventResetMode%2CSystem.String%2CSystem.Boolean%40%2CSystem.Security.AccessControl.EventWaitHandleSecurity%29> construtor.  
  
 Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador é especificado para `mode`, threads que esperar o evento não serão bloqueado. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe e tem o controle de acesso de segurança, mas o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O evento nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <see langword="false" /> para defini-lo como não sinalizado.</param>
        <param name="mode">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
        <param name="name">O nome de um evento de sincronização de todo o sistema.</param>
        <param name="createdNew">Quando este método retorna, contém <see langword="true" /> se um evento local foi criado (ou seja, se <c>nome</c> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o evento do sistema nomeado especificado foi criado; <see langword="false" /> se o evento do sistema nomeado especificado já existe. Este parâmetro é passado não inicializado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente, o nome de um evento de sincronização do sistema e uma variável booliana cujo valor após a chamada indica se o evento de sistema nomeado foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro é ignorado. Depois de chamar este construtor, use o valor na variável especificada para o `ref` parâmetro (`ByRef` parâmetro no Visual Basic)`createdNew` para determinar se o evento do sistema nomeado já existia ou foi criado.  
  
 Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador é especificado para `mode`, threads que esperar o evento não serão bloqueado. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe e tem o controle de acesso de segurança, mas o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O evento nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initialState, valuetype System.Threading.EventResetMode mode, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.#ctor(System.Boolean,System.Threading.EventResetMode,System.String,System.Boolean@,System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialState" Type="System.Boolean" />
        <Parameter Name="mode" Type="System.Threading.EventResetMode" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="initialState">
          <see langword="true" /> para definir o estado inicial como sinalizado se o evento nomeado for criado como resultado dessa chamada, <see langword="false" /> para defini-lo como não sinalizado.</param>
        <param name="mode">Um dos valores <see cref="T:System.Threading.EventResetMode" /> que determina se o evento redefine automática ou manualmente.</param>
        <param name="name">O nome de um evento de sincronização de todo o sistema.</param>
        <param name="createdNew">Quando este método retorna, contém <see langword="true" /> se um evento local foi criado (ou seja, se <c>nome</c> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o evento do sistema nomeado especificado foi criado; <see langword="false" /> se o evento do sistema nomeado especificado já existe. Este parâmetro é passado não inicializado.</param>
        <param name="eventSecurity">Um <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> objeto que representa a segurança de controle de acesso a ser aplicado ao evento sistema nomeado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.EventWaitHandle" />, especificando se o identificador de espera é sinalizado inicialmente se for criado como resultado dessa chamada, se ele é redefinido manual ou automaticamente, o nome de um evento de sincronização do sistema, uma variável booliana cujo valor após a chamada indica se o evento de sistema nomeado foi criado e a segurança de controle de acesso a ser aplicada ao evento nomeado se ele tiver sido criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor para aplicar segurança de controle de acesso a um evento do sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle do evento.  
  
 Este construtor inicializa um <xref:System.Threading.EventWaitHandle> objeto que representa um evento do sistema. Você pode criar várias <xref:System.Threading.EventWaitHandle> objetos que representam o mesmo evento do sistema.  
  
 Se o evento do sistema não existir, ele será criado com a segurança de controle de acesso especificado. Se o evento existir, a segurança de controle de acesso especificado será ignorada.  
  
> [!NOTE]
>  O chamador tem controle total sobre recém-criado <xref:System.Threading.EventWaitHandle> objeto mesmo se `eventSecurity` nega ou falhar ao conceder a alguns direitos de acesso para o usuário atual. No entanto, se o usuário atual tenta obter outro <xref:System.Threading.EventWaitHandle> representar o mesmo chamado event, usando um construtor do objeto ou o <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método, Windows, segurança de controle de acesso é aplicada.  
  
 Se um evento do sistema com o nome especificado para o `name` já existe um parâmetro, o `initialState` parâmetro é ignorado. Depois de chamar este construtor, use o valor na variável especificada para o `ref` parâmetro (`ByRef` parâmetro no Visual Basic) `createdNew` para determinar se o evento do sistema nomeado já existia ou foi criado.  
  
 Se o estado inicial do evento é não sinalizado, threads que esperar o evento serão bloqueado. Se o estado inicial é sinalizado e o <xref:System.Threading.EventResetMode.ManualReset> sinalizador é especificado para `mode`, threads que esperar o evento não serão bloqueado. Se o estado inicial é sinalizado, e `mode` é <xref:System.Threading.EventResetMode.AutoReset>, o primeiro thread aguarda o evento será liberado imediatamente, após o qual o evento será redefinido e bloquearão threads subsequentes.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões são alteradas, o evento é aberto com os direitos necessários para esperar e sinalizá-lo. Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe e tem o controle de acesso de segurança, mas o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O evento nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.EventWaitHandleSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> objeto que representa a segurança de controle de acesso para o evento do sistema nomeado representado pelo atual <see cref="T:System.Threading.EventWaitHandle" /> objeto.</summary>
        <returns>Um <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> objeto que representa a segurança de controle de acesso para o evento do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para procurar permissões: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections?displayProperty=nameWithType>.  
  
 O usuário deve ter <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> direitos para chamar esse método e o evento devem ter sido abertos com o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões tenham sido lidos, usando o <xref:System.Threading.EventWaitHandle.GetAccessControl%2A> método, e o evento alterado, é aberto com os direitos necessários para esperar e sinalizá-lo. Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Atual <see cref="T:System.Threading.EventWaitHandle" /> objeto representa um evento do sistema nomeado, e o usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.  
  
 -ou-  
  
 Atual <see cref="T:System.Threading.EventWaitHandle" /> objeto representa um evento do sistema nomeada e não foi aberto com <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ReadPermissions" />.</exception>
        <exception cref="T:System.NotSupportedException">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</exception>
        <exception cref="T:System.ObjectDisposedException">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do evento de sincronização de sistema a ser aberto.</param>
        <summary>Abre o evento de sincronização nomeado especificado, caso ele já exista.</summary>
        <returns>Um objeto que representa o evento do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método tenta abrir o evento de sistema nomeado especificado. Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema. Para criar o evento do sistema quando ele ainda não existir, use uma da <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas a este método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.  
  
 Especificando o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador permite que um thread para esperar o evento do sistema nomeado e especificando o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões são alteradas, o evento é aberto com os direitos necessários para esperar e sinalizá-lo. Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O evento do sistema nomeado não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.EventWaitHandle OpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.EventWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
      </Parameters>
      <Docs>
        <param name="name">O nome do evento de sincronização de sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representam o acesso de segurança desejado.</param>
        <summary>Abre o evento de sincronização nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</summary>
        <returns>Um objeto que representa o evento do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador para permitir que os threads para esperar o evento e o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 O <xref:System.Threading.EventWaitHandle.OpenExisting%2A> método tenta abrir um evento de sistema nomeado existente. Se o evento do sistema não existir, este método lança uma exceção em vez de criar o evento do sistema. Para criar o evento do sistema quando ele ainda não existir, use uma da <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas a este método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões são alteradas, o evento é aberto com os direitos necessários para esperar e sinalizá-lo. Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O evento do sistema nomeado não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public bool Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o estado do evento como não sinalizado, fazendo com que os threads sejam bloqueados.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public bool Set ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Set() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.Set" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o estado do evento a ser sinalizado, permitindo que um ou mais threads de espera prossigam.</summary>
        <returns>
          <see langword="true" /> se a operação for bem-sucedida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para uma <xref:System.Threading.EventWaitHandle> com <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> (incluindo <xref:System.Threading.AutoResetEvent>), o <xref:System.Threading.EventWaitHandle.Set%2A> método libera um único thread. Se não houver nenhum thread de espera, o identificador de espera permanece sinalizado até que um thread tente esperar nele, ou até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.  
  
> [!IMPORTANT]
>  Não há nenhuma garantia de que todas as chamadas para o <xref:System.Threading.EventWaitHandle.Set%2A> método lançará um thread de um <xref:System.Threading.EventWaitHandle> cujo modo redefinição é <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType>. Se duas chamadas estiverem muito juntos, para que a segunda chamada ocorre antes de um thread foi liberado, apenas um thread é liberado. É como se a segunda chamada não aconteceu. Além disso, se <xref:System.Threading.EventWaitHandle.Set%2A> é chamado quando não houver nenhum thread de espera e o <xref:System.Threading.EventWaitHandle> já está sinalizado, a chamada não tem nenhum efeito.  
  
 Para uma <xref:System.Threading.EventWaitHandle> com <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> (incluindo <xref:System.Threading.ManualResetEvent>), chamar o <xref:System.Threading.EventWaitHandle.Set%2A> método deixa o identificador de espera em um estado sinalizado até que seu <xref:System.Threading.EventWaitHandle.Reset%2A> método é chamado.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.  
  
 O exemplo inicia cinco threads e permite bloquear um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.AutoReset?displayProperty=nameWithType> sinalizador e, em seguida, tempo de um thread de versões, o usuário pressiona a tecla ENTER. O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode.ManualReset?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.EventWaitHandleSecurity eventSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventSecurity" Type="System.Security.AccessControl.EventWaitHandleSecurity" />
      </Parameters>
      <Docs>
        <param name="eventSecurity">Um <see cref="T:System.Security.AccessControl.EventWaitHandleSecurity" /> objeto que representa a segurança de controle de acesso a ser aplicado ao evento sistema nomeado.</param>
        <summary>Define a segurança de controle de acesso para um evento do sistema nomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O usuário deve ter <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> direitos para chamar esse método e o evento devem ter sido abertos com o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um evento do sistema nomeado com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um evento nomeado.  
  
 Se o evento não existir, ele é criado com a propriedade inicial e segurança de controle de acesso que impede o direito de usar o evento que o usuário atual, mas concede o direito de leitura e alterar as permissões no evento.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29>. A exceção é capturada e o exemplo usa o <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga do método para esperar o evento com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, usando o <xref:System.Threading.EventWaitHandle.SetAccessControl%2A> método, o evento é aberto com os direitos necessários para esperar e sinalizá-lo. Se você executar o exemplo compilado em uma terceira janela de comando, o exemplo é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/CS/source.cs#1)]
 [!code-vb[System.Threading.EventWaitHandle.ctor named 5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.EventWaitHandle.ctor named 5/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="eventSecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.  
  
 -ou-  
  
 O evento não foi aberto com <see cref="F:System.Security.AccessControl.EventWaitHandleRights.ChangePermissions" />.</exception>
        <exception cref="T:System.SystemException">Atual <see cref="T:System.Threading.EventWaitHandle" /> objeto não representa um evento do sistema nomeado.</exception>
        <exception cref="T:System.ObjectDisposedException">O método <see cref="M:System.Threading.WaitHandle.Close" /> foi chamado anteriormente neste <see cref="T:System.Threading.EventWaitHandle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">O nome do evento de sincronização de sistema a ser aberto.</param>
        <param name="result">Quando este método retorna, contém um <see cref="T:System.Threading.EventWaitHandle" /> objeto que representa o evento nomeado sincronização se a chamada foi bem-sucedida, ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Abre o evento de sincronização nomeado especificado, se ele já existir e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns>
          <see langword="true" />Se o evento de sincronização nomeado foi aberto com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o evento de sincronização nomeada não existir, este método não criá-lo. Para criar o evento do sistema quando ele ainda não existir, use uma da <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se existe um evento de sincronização nomeado, use essa sobrecarga de método em vez do <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%29> sobrecarga de método, o que gera uma exceção se o evento de sincronização não existe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.EventWaitHandle.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%2CSystem.Threading.EventWaitHandle%40%29> sobrecarga de método e especificando <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> e <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit. Especificando o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador permite que um thread para esperar o evento do sistema nomeado e especificando o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 Várias chamadas a este método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.EventWaitHandleRights rights, [out] class System.Threading.EventWaitHandle&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.EventWaitHandleRights" />
        <Parameter Name="result" Type="System.Threading.EventWaitHandle&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">O nome do evento de sincronização de sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representam o acesso de segurança desejado.</param>
        <param name="result">Quando este método retorna, contém um <see cref="T:System.Threading.EventWaitHandle" /> objeto que representa o evento nomeado sincronização se a chamada foi bem-sucedida, ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Abre o evento de sincronização nomeada especificada, se ele já existe, o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns>
          <see langword="true" />Se o evento de sincronização nomeado foi aberto com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o evento de sincronização nomeada não existir, este método não criá-lo. Para criar o evento do sistema quando ele ainda não existir, use uma da <xref:System.Threading.EventWaitHandle.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se existe um evento de sincronização nomeado, use essa sobrecarga de método em vez do <xref:System.Threading.EventWaitHandle.OpenExisting%28System.String%2CSystem.Security.AccessControl.EventWaitHandleRights%29> sobrecarga de método, o que gera uma exceção se o evento de sincronização não existe.  
  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador para permitir que os threads para esperar o evento e o <xref:System.Security.AccessControl.EventWaitHandleRights?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.EventWaitHandle.Set%2A> e <xref:System.Threading.EventWaitHandle.Reset%2A> métodos.  
  
 Várias chamadas a este método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.EventWaitHandle> do objeto, mesmo que os objetos que são retornados representam o mesmo evento sistema nomeado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O evento nomeado existe, mas o usuário não tem o acesso de segurança desejado.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
