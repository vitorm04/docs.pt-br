<Type Name="WaitHandle" FullName="System.Threading.WaitHandle">
  <TypeSignature Language="C#" Value="public abstract class WaitHandle : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit WaitHandle extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Encapsula objetos específicos do sistema operacional que aguardam acesso exclusivo aos recursos compartilhados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.WaitHandle> classe encapsula os manipuladores de sincronização do Win32 e é usada para representar todos os objetos de sincronização no tempo de execução que permitem que várias operações de espera. Para obter uma comparação de identificadores de espera com outros objetos de sincronização, consulte [visão geral dos primitivos de sincronização](~/docs/standard/threading/overview-of-synchronization-primitives.md).  
  
 O <xref:System.Threading.WaitHandle> própria classe é abstrata. Classes derivadas de <xref:System.Threading.WaitHandle> definir um mecanismo de sinalização para indicar demorando ou liberar o acesso a um recurso compartilhado, mas utilizam o herdadas <xref:System.Threading.WaitHandle> métodos seja bloqueado enquanto aguarda para acessar os recursos compartilhados. As classes derivadas de <xref:System.Threading.WaitHandle> incluem:  
  
-   O <xref:System.Threading.Mutex> classe. Consulte [Mutexes](~/docs/standard/threading/mutexes.md).  
  
-   O <xref:System.Threading.EventWaitHandle> classe e suas classes derivadas, <xref:System.Threading.AutoResetEvent> e <xref:System.Threading.ManualResetEvent>. Consulte [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  
  
-   O <xref:System.Threading.Semaphore> classe. Consulte [Semaphore e SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  
  
 Threads podem bloquear um identificador de espera individuais chamando o método de instância <xref:System.Threading.WaitHandle.WaitOne%2A>, que é herdado por classes derivadas de <xref:System.Threading.WaitHandle>.  
  
 As classes derivadas de <xref:System.Threading.WaitHandle> diferem na afinidade do thread. Identificadores de espera de eventos (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, e <xref:System.Threading.ManualResetEvent>) e semáforos não têm afinidade de thread; qualquer thread pode sinalizar um identificador de espera do evento ou um semáforo. Mutexes, por outro lado, têm afinidade de thread; o thread que possui um mutex deve liberá-lo e uma exceção será lançada se um thread chama o <xref:System.Threading.Mutex.ReleaseMutex%2A> método em um mutex que não possui.  
  
 Porque o <xref:System.Threading.WaitHandle> classe derivada de <xref:System.MarshalByRefObject>, essas classes podem ser usadas para sincronizar as atividades de threads nos limites do domínio de aplicativo.  
  
 Além de suas classes derivadas, a <xref:System.Threading.WaitHandle> classe tiver um número de métodos estáticos que o bloqueio de um thread até que um ou mais objetos de sincronização recebem um sinal. Elas incluem:  
  
-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, que permite que um thread para sinalizar um identificador de espera e aguarde imediatamente em outro.  
  
-   <xref:System.Threading.WaitHandle.WaitAll%2A>, que permite que um thread de espera até que todos os identificadores de espera em uma matriz recebem um sinal.  
  
-   <xref:System.Threading.WaitHandle.WaitAny%2A>, que permite que um thread de espera até que qualquer um de um conjunto especificado de identificadores de espera foi sinalizado.  
  
 As sobrecargas dos métodos a seguir fornecem os intervalos de tempo limite para abandonar a espera e a oportunidade de sair de um contexto de sincronização antes de entrar em espera, permitindo que outros threads para usar o contexto de sincronização.  
  
> [!IMPORTANT]
>  Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo ou um tipo derivado dele, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.Threading.WaitHandle.Close%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
 <xref:System.Threading.WaitHandle>implementa o <xref:System.IDisposable.Dispose%2A> padrão. Consulte [Dispose padrão](~/docs/standard/design-guidelines/dispose-pattern.md). Quando você deriva de <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo. Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos adicionais de não gerenciados.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como dois threads podem fazem tarefas em segundo plano enquanto principal thread aguarda as a conclusão de tarefas usando o estático <xref:System.Threading.WaitHandle.WaitAny%2A> e <xref:System.Threading.WaitHandle.WaitAll%2A> métodos de <xref:System.Threading.WaitHandle> classe.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos mantidos pelo <see cref="T:System.Threading.WaitHandle" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é a implementação pública a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método para o <xref:System.Threading.WaitHandle> classe e suas classes derivadas. Ele fornece uma implementação padrão chama o `Dispose(Boolean)` sobrecarga com um `true` argumento e, em seguida, chama o <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método. Chame este método para liberar todos os recursos mantidos por uma instância de `WaitHandle` ou uma classe derivada.  
  
 Quando este método é chamado, as referências à instância atual causam um comportamento indefinido.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>. Caso contrário, os recursos que está usando não serão liberados.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir o <see langword="Dispose(Boolean)" /> classes derivadas de método para liberar recursos alocados.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Threading.WaitHandle" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.Threading.WaitHandle.Close%2A> método.  
  
> [!NOTE]
>  Sempre chamar <xref:System.Threading.WaitHandle.Close%2A> ou <xref:System.Threading.WaitHandle.Dispose> antes de liberar sua última referência para o <xref:System.Threading.WaitHandle>. Caso contrário, os recursos que está usando não serão liberados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool explicitDisposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool explicitDisposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="explicitDisposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="explicitDisposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Quando substituído em uma classe derivada, libera os recursos não gerenciados usados pelo <see cref="T:System.Threading.WaitHandle" />e, opcionalmente, libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo <xref:System.Threading.WaitHandle.Close%2A> e <xref:System.Threading.WaitHandle.Dispose> métodos com o `explicitDisposing` parâmetro definido como `true`.  Quando o `explicitDisposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Threading.WaitHandle> referências de objeto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir o <see cref="M:System.Threading.WaitHandle.Dispose(System.Boolean)" /> classes derivadas de método para liberar recursos alocados.  
  
 O <see cref="M:System.Threading.WaitHandle.Close" /> ou <see cref="M:System.Threading.WaitHandle.Dispose" /> método pode ser chamado várias vezes por outros objetos. Ao substituir esse método, tenha cuidado para não fazer referência a objetos que foi descartados anteriormente em uma chamada anterior para <see langword="Dispose" /> ou <see langword="Close" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use the SafeWaitHandle property instead.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o identificador de sistema operacional nativo.</summary>
        <value>Um <see langword="IntPtr" /> que representa o identificador do sistema operacional nativo. O padrão é o valor do campo <see cref="F:System.Threading.WaitHandle.InvalidHandle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atribuir um novo valor para o <xref:System.Threading.WaitHandle.Handle%2A> propriedade não fechar o identificador anterior. Isso pode resultar em um identificador vazou.  
  
 Não use essa propriedade no .NET Framework versão 2.0 ou posterior; Use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade em vez disso. Definir essa propriedade como um identificador válido também define o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, mas defini-la como <xref:System.Threading.WaitHandle.InvalidHandle> pode resultar em um identificador vazou.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato definir o valor da propriedade. Este membro não pode ser definido por código parcialmente confiável ou transparente.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para definir o valor da propriedade.</permission>
      </Docs>
    </Member>
    <Member MemberName="InvalidHandle">
      <MemberSignature Language="C#" Value="protected static readonly IntPtr InvalidHandle;" />
      <MemberSignature Language="ILAsm" Value=".field family static initonly native int InvalidHandle" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.InvalidHandle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa um identificador de sistema operacional nativo inválido. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usada internamente para inicializar o <xref:System.Threading.WaitHandle.Handle%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você pode usar esse valor para determinar se o <see cref="P:System.Threading.WaitHandle.Handle" /> propriedade contém um identificador válido do sistema operacional nativo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeWaitHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle" />
      <MemberSignature Language="DocId" Value="P:System.Threading.WaitHandle.SafeWaitHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeWaitHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o identificador de sistema operacional nativo.</summary>
        <value>Um <see cref="T:Microsoft.Win32.SafeHandles.SafeWaitHandle" /> que representa o identificador de sistema operacional nativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você atribui um novo valor para o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade, o identificador anterior será fechado quando anterior <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> objeto é coletado. Não feche manualmente a alça, porque isso resulta em uma <xref:System.ObjectDisposedException> quando o <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> tenta fechar o identificador.  
  
 <xref:System.Threading.WaitHandle>implementa o <xref:System.IDisposable.Dispose%2A> padrão. Consulte [Dispose padrão](~/docs/standard/design-guidelines/dispose-pattern.md). Quando você deriva de <xref:System.Threading.WaitHandle>, use o <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> propriedade para armazenar seu identificador de sistema operacional do identificador nativo. Você não precisa substituir o protegido <xref:System.Threading.WaitHandle.Dispose%2A> método, a menos que você use recursos adicionais de não gerenciados.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">Tipos derivados devem ter <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> para chamar esse membro.</permission>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="toSignal">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</param>
        <param name="toWaitOn">O <see cref="T:System.Threading.WaitHandle" /> para aguardar.</param>
        <summary>Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera em outro.</summary>
        <returns>
          <see langword="true" />Se o sinal e o tempo de espera é concluída com êxito; Se a espera não for concluída, o método não retornar.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele espera `toWaitOn`, um thread que está sendo executado em outro processador pode sinalizar `toWaitOn` ou esperar.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> sobrecarga do método para permitir que o thread principal de sinalizar um thread bloqueado e, em seguida, aguarde até que o thread conclui uma tarefa.  
  
 O exemplo inicia cinco threads, permite bloquear um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode?displayProperty=nameWithType> sinalizador e versões de um thread cada vez o usuário pressiona a tecla ENTER. O exemplo, em seguida, as filas outro threads cinco e libera todos os usando um <xref:System.Threading.EventWaitHandle> criado com o <xref:System.Threading.EventResetMode?displayProperty=nameWithType> sinalizador.  
  
 [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="toWaitOn" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O método foi chamado em um thread que tenha <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Esse método não tem suporte no Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" />é um sinal, e ele já tem uma contagem total.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</param>
        <param name="toWaitOn">O <see cref="T:System.Threading.WaitHandle" /> para aguardar.</param>
        <param name="millisecondsTimeout">Um inteiro que representa o intervalo de espera. Se o valor for <see cref="F:System.Threading.Timeout.Infinite" />, ou seja, -1, a espera é infinita.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera-se em outro, especificando um intervalo de tempo limite como um inteiro assinado de 32 bits e especificar se deseja sair do domínio para o contexto de sincronização antes de entrar em espera.</summary>
        <returns>
          <see langword="true" />Se o sinal e o tempo de espera foi concluída com êxito, ou <see langword="false" /> se o sinal concluída, mas a espera atingiu o tempo limite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele espera `toWaitOn`, um thread que está sendo executado em outro processador pode sinalizar `toWaitOn` ou esperar.  
  
 Se `millisecondsTimeout` for zero, o método não bloquear. Ele testa o estado do `toWaitOn` e retorna imediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="toWaitOn" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O método é chamado em um thread que tenha <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Esse método não tem suporte no Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Threading.WaitHandle" /> não pode ser sinalizado porque excederia a contagem máxima.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignalAndWait">
      <MemberSignature Language="C#" Value="public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SignalAndWait(class System.Threading.WaitHandle toSignal, class System.Threading.WaitHandle toWaitOn, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toSignal" Type="System.Threading.WaitHandle" />
        <Parameter Name="toWaitOn" Type="System.Threading.WaitHandle" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="toSignal">O <see cref="T:System.Threading.WaitHandle" /> para sinalizar.</param>
        <param name="toWaitOn">O <see cref="T:System.Threading.WaitHandle" /> para aguardar.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o intervalo de espera. Se o valor for -1, a espera é infinita.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Sinaliza uma <see cref="T:System.Threading.WaitHandle" /> e espera-se em outro, especificando o intervalo de tempo limite como um <see cref="T:System.TimeSpan" /> e especificar se deseja sair do domínio para o contexto de sincronização antes de entrar em espera.</summary>
        <returns>
          <see langword="true" />Se o sinal e o tempo de espera foi concluída com êxito, ou <see langword="false" /> se o sinal concluída, mas a espera atingiu o tempo limite.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação não é garantida atômicas. Após os sinais de thread atual `toSignal` , mas antes de ele espera `toWaitOn`, um thread que está sendo executado em outro processador pode sinalizar `toWaitOn` ou esperar.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Se `timeout` for zero, o método não bloquear. Ele testa o estado do `toWaitOn` e retorna imediatamente.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.SignalAndWait%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toSignal" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="toWaitOn" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O método foi chamado em um thread que tenha <see cref="T:System.STAThreadAttribute" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Esse método não tem suporte no Windows 98 ou Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="toSignal" />é um sinal, e ele já tem uma contagem total.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" />é avaliada como um número negativo de milissegundos diferente de -1.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Essa matriz não pode conter várias referências ao mesmo objeto.</param>
        <summary>Aguarda até que todos os elementos na matriz especificada recebam um sinal.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, o método nunca retornará.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando todos os identificadores são sinalizados. Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e a especificação de -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação está na fila como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda até que todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />. -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> são <see langword="null" />.  
  
 -ou-  
  
 <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.ArgumentException" />, em vez disso.  
  
</para>
          </block>  
  
 A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
 -ou-  
  
 O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera encerrada porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Esta matriz não pode conter várias referências ao mesmo objeto (duplicatas).</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido. Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada. Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.ArgumentException" />, em vez disso.  
  
</para>
          </block>  
  
 A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
 -ou-  
  
 O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Essa matriz não pode conter várias referências ao mesmo objeto.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Espera que todos os elementos na matriz especificada recebam um sinal usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou quando ocorre um tempo limite. Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.ArgumentException" />, em vez disso.  
  
</para>
          </block>  
  
 A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
 -ou-  
  
 O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera encerrada porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Esta matriz não pode conter várias referências ao mesmo objeto (duplicatas).</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Espera todos os elementos da matriz especificada receberem um sinal, usando um valor <see cref="T:System.Int32" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, que significa que quando todos os identificadores são sinalizados ou quando o tempo limite seja atingido. Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada. Se houver duplicatas na matriz, a chamada falhará com um <xref:System.DuplicateWaitObjectException>.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem o <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação está na fila como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda até que todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
 -ou-  
  
 O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAll">
      <MemberSignature Language="C#" Value="public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool WaitAll(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará. Essa matriz não pode conter várias referências ao mesmo objeto.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Aguarda até que todos os elementos da matriz especificada recebam um sinal, usando um valor <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificando se sairá do domínio de sincronização antes da espera.</summary>
        <returns>
          <see langword="true" /> quando todos os elementos em <paramref name="waitHandles" /> tiverem recebido um sinal; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna quando a espera termina, o que significa que qualquer todos os identificadores são sinalizados ou quando ocorre um tempo limite. Em algumas implementações, se mais de 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada. Se a matriz contém duplicatas, a chamada falhará.  
  
> [!NOTE]
>  O <xref:System.Threading.WaitHandle.WaitAll%2A> método não tem suporte em segmentos com <xref:System.STAThreadAttribute>.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAll%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se você estiver executando um método em uma classe que não é derivada de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAll%2A> método. Ele retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAll%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAll%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAll%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar o pool de threads para criar e gravar em um grupo de arquivos de forma assíncrona. Cada operação de gravação está na fila como um item de trabalho e sinaliza quando ele for concluído. O thread principal aguarda até que todos os itens sinalizar e, em seguida, sai.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.DuplicateWaitObjectException">A matriz <paramref name="waitHandles" /> contém elementos duplicados.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.  
  
 -ou-  
  
 O atributo <see cref="T:System.STAThreadAttribute" /> é aplicado ao procedimento de thread para o thread atual e <paramref name="waitHandles" /> contém mais de um elemento.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera encerrada porque um thread foi encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <summary>Aguarda até que todos os elementos na matriz especificada recebam um sinal.</summary>
        <returns>O índice da matriz do objeto que atendeu à espera.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, pois um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Em versões do .NET Framework anterior à versão 2.0, se um thread encerrado ou anulada sem soltar explicitamente um <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128, em vez de 0.  
  
 Esse método retorna quando qualquer identificador é sinalizado. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga de método e a especificação de -1 (ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>) para `millisecondsTimeout` e `true` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a chamar o <xref:System.Threading.WaitHandle.WaitAny%2A> método.  
  
 [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]
 [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]
 [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Espera qualquer um dos elementos na matriz especificada receber um sinal usando um inteiro com sinal de 32 bits a fim de especificar o intervalo de tempo.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
 Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Aguarda até todos os elementos na matriz especificada receberem um sinal usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
 Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Espera todos os elementos na matriz especificada receberem um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="millisecondsTimeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, pois um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Em versões do .NET Framework anterior à versão 2.0, se um thread encerrado ou anulada sem soltar explicitamente um <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128, em vez de 0.  
  
 Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de threads para pesquisar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitAny">
      <MemberSignature Language="C#" Value="public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 WaitAny(class System.Threading.WaitHandle[] waitHandles, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitHandles" Type="System.Threading.WaitHandle[]" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitHandles">Uma matriz <see langword="WaitHandle" /> que contém os objetos que a instância atual aguardará.</param>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Espera todos os elementos na matriz especificada receberem um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se deseja sair do domínio de sincronização antes do tempo de espera.</summary>
        <returns>O índice de matriz do objeto que atendeu à espera ou <see cref="F:System.Threading.WaitHandle.WaitTimeout" />, se nenhum objeto tiver atendido à espera e um tempo de intervalo igual a <paramref name="timeout" /> tiver passado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloquear. Ele testa o estado de identificadores de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna `true` se a espera for concluída, pois um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O <xref:System.Threading.WaitHandle.WaitAny%2A> método lança um <xref:System.Threading.AbandonedMutexException> somente quando o tempo de espera é concluída devido a um mutex abandonado. Se `waitHandles` contém um mutex lançado com um número de índice menor que o mutex abandonado, o <xref:System.Threading.WaitHandle.WaitAny%2A> método normalmente é concluído e a exceção não é gerada.  
  
> [!NOTE]
>  Em versões do .NET Framework anterior à versão 2.0, se um thread encerrado ou anulada sem soltar explicitamente um <xref:System.Threading.Mutex>e que `Mutex` está no índice 0 (zero) em um `WaitAny` matriz em outro thread, o índice retornado pela `WaitAny` é 128, em vez de 0.  
  
 Esse método retorna quando a espera termina, quando qualquer uma das alças são sinalizados ou quando ocorre um tempo limite. Se mais de um objeto se torna sinalizado durante a chamada, o valor de retorno é o índice de matriz do objeto sinalizado com o menor valor de índice de todos os objetos sinalizados. Em algumas implementações, se mais que 64 identificadores são passados, um <xref:System.NotSupportedException> é gerada.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitAny%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitAny%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitAny%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitAny%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitAny%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de threads para pesquisar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="waitHandles" /> é <see langword="null" />.  
  
 -ou-  
  
 Um ou mais dos objetos na matriz <paramref name="waitHandles" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">O número de objetos em <paramref name="waitHandles" /> é maior do que o sistema permite.</exception>
        <exception cref="T:System.ApplicationException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 1.0 ou 1.1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="waitHandles" /> é uma matriz sem elementos e a versão do .NET Framework é 2.0 ou posterior.</exception>
        <exception cref="T:System.InvalidOperationException">A matriz <paramref name="waitHandles" /> contendo um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal.</summary>
        <returns>
          <see langword="true" /> se a instância atual receber um sinal. Se a instância atual nunca foi sinalizada, <see cref="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" /> nunca retorna.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos esse método indefinidamente até que a instância atual recebe um sinal. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método e a especificação de -1 ou <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para o primeiro parâmetro e `false` para o segundo parâmetro.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo em milissegundos.</summary>
        <returns>
          <see langword="true" />Se a instância atual recebe um sinal; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloquear. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <summary>Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo.</summary>
        <returns>
          <see langword="true" />Se a instância atual recebe um sinal; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloquear. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
 Chamar essa sobrecarga de método é o mesmo que chamar o <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> sobrecarga e especificando `false` para `exitContext`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">O número de milissegundos para aguardar ou <see cref="F:System.Threading.Timeout.Infinite" /> (- 1) para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Bloqueia o thread atual até que o <see cref="T:System.Threading.WaitHandle" /> atual receba um sinal, usando um inteiro com sinal de 32 bits para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</summary>
        <returns>
          <see langword="true" />Se a instância atual recebe um sinal; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `millisecondsTimeout` for zero, o método não bloquear. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
   
  
## Examples  
 A exemplo a seguir mostra como o <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> sobrecarga de método se comporta quando ele é chamado dentro de um domínio de sincronização. Primeiro, um thread aguarda com `exitContext` definido como `false` e bloqueia até que o tempo limite de espera expire. Um thread de segundo é executado após o primeiro thread termina e aguarda com `exitContext` definido como `true`. A chamada para indicar que o identificador de espera para esse thread de segundo não é bloqueada e o thread seja concluída antes do tempo limite de espera.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="millisecondsTimeout" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitOne">
      <MemberSignature Language="C#" Value="public virtual bool WaitOne (TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool WaitOne(valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="timeout">Um <see cref="T:System.TimeSpan" /> que representa o número de milissegundos para aguardar ou um <see cref="T:System.TimeSpan" /> que representa -1 milissegundos para aguardar indefinidamente.</param>
        <param name="exitContext">
          <see langword="true" /> para sair do domínio de sincronização do contexto antes do tempo de espera (se estiver em um contexto sincronizado) e readquiri-lo posteriormente; caso contrário, <see langword="false" />.</param>
        <summary>Bloqueia o thread atual até que a instância atual receba um sinal, usando um <see cref="T:System.TimeSpan" /> para especificar o intervalo de tempo e especificar se sairá do domínio de sincronização antes da espera.</summary>
        <returns>
          <see langword="true" />Se a instância atual recebe um sinal; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `timeout` for zero, o método não bloquear. Ele testa o estado do identificador de espera e retorna imediatamente.  
  
 <xref:System.Threading.AbandonedMutexException>é novo no .NET Framework versão 2.0. Nas versões anteriores, o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna `true` quando um mutex é abandonado. Um mutex abandonado geralmente indica um erro grave de codificação. No caso de um mutex de todo o sistema, isso pode indicar que um aplicativo foi finalizado abruptamente (por exemplo, usando o Gerenciador de tarefas do Windows). A exceção contém informações úteis para depuração.  
  
 O chamador de blocos este método até que a instância atual recebe um sinal ou um tempo limite ocorre. Use esse método para bloquear até um <xref:System.Threading.WaitHandle> recebe um sinal de outro thread, como é gerado quando uma operação assíncrona é concluída. Para obter mais informações, consulte o <xref:System.IAsyncResult> interface.  
  
 Substitua este método para personalizar o comportamento de classes derivadas.  
  
 O valor máximo para `timeout` é <xref:System.Int32.MaxValue?displayProperty=nameWithType>.  
  
## <a name="notes-on-exiting-the-context"></a>Anotações na saída do contexto  
 O `exitContext` parâmetro não tem nenhum efeito a menos que o <xref:System.Threading.WaitHandle.WaitOne%2A> método é chamado de dentro de um contexto gerenciado não padrão. Isso pode acontecer se o thread está dentro de uma chamada para uma instância de uma classe derivada de <xref:System.ContextBoundObject>. Mesmo se atualmente você estiver executando um método em uma classe que não é derivado de <xref:System.ContextBoundObject>, como <xref:System.String>, você pode estar em um contexto não padrão se um <xref:System.ContextBoundObject> está na sua pilha no domínio do aplicativo atual.  
  
 Quando seu código está em execução em um contexto não padrão, especificando `true` para `exitContext` faz com que o thread sair do contexto gerenciado não padrão (ou seja, a transição para o contexto padrão) antes de executar o <xref:System.Threading.WaitHandle.WaitOne%2A> método. O thread retorna para o contexto não padrão original após a chamada para o <xref:System.Threading.WaitHandle.WaitOne%2A> método é concluído.  
  
 Isso pode ser útil quando a classe de contexto associado tem <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. Nesse caso, todas as chamadas para membros da classe serão sincronizadas automaticamente, e o domínio de sincronização é todo o corpo de código para a classe. Se o código na pilha de chamadas de um membro chama o <xref:System.Threading.WaitHandle.WaitOne%2A> método e especifica `true` para `exitContext`, o thread sai do domínio de sincronização, permitindo que um thread que está bloqueado em uma chamada para qualquer membro do objeto para continuar. Quando o <xref:System.Threading.WaitHandle.WaitOne%2A> método retorna, o thread que fez a chamada deve esperar para digitar novamente o domínio de sincronização.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar um identificador de espera para impedir que um processo de encerramento enquanto aguarda um thread em segundo plano sejam concluídas.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">A instância atual já foi descartada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="timeout" /> é um número negativo diferente de -1 milissegundo, que representa um tempo limite infinito.  
  
 -ou-  
  
 <paramref name="timeout" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.Threading.AbandonedMutexException">A espera foi concluída porque um thread encerrado sem liberar um mutex. Essa exceção não é lançada no Windows 98 nem no Windows Millennium Edition.</exception>
        <exception cref="T:System.InvalidOperationException">A instância atual é um proxy transparente para um <see cref="T:System.Threading.WaitHandle" /> em outro domínio de aplicativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="WaitTimeout">
      <MemberSignature Language="C#" Value="public const int WaitTimeout = 258;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 WaitTimeout = (258)" />
      <MemberSignature Language="DocId" Value="F:System.Threading.WaitHandle.WaitTimeout" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>258</MemberValue>
      <Docs>
        <summary>Indica que uma operação <see cref="M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)" /> atingiu o tempo limite antes que algum dos identificadores de espera fosse sinalizado. Este campo é constante.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este campo é um dos possíveis valores de retorno de `WaitAny`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o pool de threads para pesquisar um arquivo em vários discos simultaneamente. Para economizar espaço, somente o diretório raiz de cada disco é pesquisado.  
  
 [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]
 [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
