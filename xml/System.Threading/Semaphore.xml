<Type Name="Semaphore" FullName="System.Threading.Semaphore">
  <TypeSignature Language="C#" Value="public sealed class Semaphore : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Semaphore extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Semaphore" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Limita o número de threads que podem acessar um recurso ou um pool de recursos simultaneamente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Threading.Semaphore> classe para controlar o acesso a um pool de recursos. Threads de inserir o semáforo chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método, que é herdado do <xref:System.Threading.WaitHandle> classe e liberar o semáforo chamando o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 A contagem em um semáforo é decrementada cada vez que um thread entra o semáforo e incrementado quando um thread libera o sinal. Quando a contagem for zero, as solicitações subsequentes bloqueiam até que outros threads de liberar o semáforo. Depois que todos os threads libera o sinal, a contagem é o valor máximo especificada quando o semáforo foi criado.  
  
 Não há nenhuma garantia de ordem, como PEPS ou UEPS, na qual os threads bloqueados inserir o sinal.  
  
 Um thread pode inserir várias vezes, do semáforo chamando o <xref:System.Threading.WaitHandle.WaitOne%2A> método repetidamente. Para liberar algumas ou todas essas entradas, o thread pode chamar o sem parâmetros <xref:System.Threading.Semaphore.Release> sobrecarga do método várias vezes, ou ele pode chamar o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga do método que especifica o número de entradas para ser liberado.  
  
 O <xref:System.Threading.Semaphore> classe não impõe a identidade do thread em chamadas para <xref:System.Threading.WaitHandle.WaitOne%2A> ou <xref:System.Threading.Semaphore.Release%2A>. É responsabilidade do programador para garantir que threads não liberar o semáforo muitas vezes. Por exemplo, suponha que um sinal tenha uma contagem máxima de dois, e que o thread A e o thread B insiram o sinal. Se um erro de programação em thread B faz com que ele chame <xref:System.Threading.Semaphore.Release%2A> duas vezes, as duas chamadas tenha êxito. A contagem de semáforo está cheio e quando thread um eventualmente chama <xref:System.Threading.Semaphore.Release%2A>, um <xref:System.Threading.SemaphoreFullException> é gerada.  
  
 São sinais de dois tipos: locais semáforos e semáforos sistema nomeado. Se você criar um <xref:System.Threading.Semaphore> usando um construtor que aceita um nome de objeto é associado com um sinal de sistema operacional do nome. Chamado sistema de semáforos são visíveis em todo o sistema operacional e podem ser usados para sincronizar as atividades de processos. Você pode criar várias <xref:System.Threading.Semaphore> objetos que representam o mesmo sistema semáforo e você pode usar o <xref:System.Threading.Semaphore.OpenExisting%2A> sistema semáforo de método para abrir um existente.  
  
 Um semáforo local existe somente em seu processo. Ele pode ser usado por qualquer thread no processo que tem uma referência ao local <xref:System.Threading.Semaphore> objeto. Cada <xref:System.Threading.Semaphore> objeto é um semáforo local separado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, que bloqueiam aguardando o sinal. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga do método para liberar o semáforo. Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do sinal. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um sinal sem nome. Todos os threads que usam uma instância de tal um semáforo devem ter referências à instância.  
  
 Se `initialCount` é menor que `maximumCount`, o efeito é o mesmo como se tivesse chamado do thread atual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes. Se você não deseja reservar todas as entradas para o thread que cria o sinal, use o mesmo número de `maximumCount` e `initialCount`.  
  
   
  
## Examples  
 O exemplo a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, que bloqueiam aguardando o sinal. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga do método para liberar o semáforo. Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do sinal. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
 -ou-  
  
 <paramref name="initialCount" /> é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser concedidas ao mesmo tempo.</param>
        <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas e, opcionalmente, especificando o nome de um objeto de sinal de sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado. Você pode criar várias <xref:System.Threading.Semaphore> objetos que representam o mesmo sistema semáforo.  
  
 Se o sinal do sistema nomeada não existir, ele será criado com a contagem inicial e máximo especificados por `initialCount` e `maximumCount`. Se o sinal do sistema nomeado já existir, `initialCount` e `maximumCount` não são usados, embora ainda, valores inválidos causam exceções. Se você precisar determinar se ou não um sinal de sistema nomeado foi criado, use o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> sobrecarga do construtor.  
  
> [!IMPORTANT]
>  Quando você usa essa sobrecarga de construtor, a prática recomendada é especificar o mesmo número de `initialCount` e `maximumCount`. Se `initialCount` é menor que `maximumCount`e um semáforo de sistema nomeado é criado, o efeito é o mesmo como se tivesse chamado do thread atual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes. No entanto, com essa sobrecarga de construtor não é possível determinar se um semáforo de sistema nomeado foi criado.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia para `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor.  
  
 Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos além dos limites do processo.  
  
 Se você deseja saber se existe um semáforo de sistema nomeado, use o <xref:System.Threading.Semaphore.OpenExisting%2A> método. O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir um semáforo existente e lança uma exceção se o sinal do sistema não existe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome. O exemplo cria um semáforo com nome com uma contagem máxima de cinco e uma contagem inicial de cinco. O programa faz três chamadas para o <xref:System.Threading.WaitHandle.WaitOne%2A> método. Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará na terceira chamada <xref:System.Threading.WaitHandle.WaitOne%2A>. Liberar uma ou mais entradas na primeira cópia do programa para desbloquear o segundo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
 -ou-  
  
 <paramref name="initialCount" /> é menor que 0.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo com nome existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
        <param name="createdNew">Quando este método retorna, contém <see langword="true" /> se um semáforo local foi criado (ou seja, se <c>nome</c> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o sinal do sistema nomeado especificado foi criado; <see langword="false" /> se especificado semáforo sistema já existia. Este parâmetro é passado não inicializado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema e especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado. Você pode criar várias <xref:System.Threading.Semaphore> objetos que representam o mesmo sistema semáforo.  
  
 Se o sinal do sistema nomeada não existir, ele será criado com a contagem inicial e máximo especificados por `initialCount` e `maximumCount`. Se o sinal do sistema nomeado já existir, `initialCount` e `maximumCount` não são usados, embora ainda, valores inválidos causam exceções. Use `createdNew` para determinar se o sinal do sistema foi criado.  
  
 Se `initialCount` é menor que `maximumCount`, e `createdNew` é `true`, o efeito é o mesmo como se tivesse chamado do thread atual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia para `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor. Nesse caso, `createdNew` é sempre `true`.  
  
 Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos além dos limites do processo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome. O exemplo cria um semáforo com nome com uma contagem máxima de cinco e uma contagem inicial de dois. Ou seja, ele reserva três entradas para o thread que chama o construtor. Se `createNew` é `false`, o programa faz três chamadas para o <xref:System.Threading.WaitHandle.WaitOne%2A> método. Portanto, se você executar o exemplo compilado em duas janelas de comando, a segunda cópia bloqueará na terceira chamada <xref:System.Threading.WaitHandle.WaitOne%2A>. Liberar uma ou mais entradas na primeira cópia do programa para desbloquear o segundo.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
 -ou-  
  
 <paramref name="initialCount" /> é menor que 0.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo com nome existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 initialCount, int32 maximumCount, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="initialCount" Type="System.Int32" />
        <Parameter Name="maximumCount" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean&amp;" RefType="out" />
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="initialCount">O número inicial de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="maximumCount">O número máximo de solicitações para o semáforo que podem ser atendidas simultaneamente.</param>
        <param name="name">O nome de um objeto de sinal de sistema nomeado.</param>
        <param name="createdNew">Quando este método retorna, contém <see langword="true" /> se um semáforo local foi criado (ou seja, se <c>nome</c> é <see langword="null" /> ou uma cadeia de caracteres vazia) ou se o sinal do sistema nomeado especificado foi criado; <see langword="false" /> se especificado semáforo sistema já existia. Este parâmetro é passado não inicializado.</param>
        <param name="semaphoreSecurity">Um <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> objeto que representa a segurança de controle de acesso a ser aplicado ao sinal do sistema nomeado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Threading.Semaphore" />, especificando o número inicial de entradas e o número máximo de entradas simultâneas, opcionalmente especificando o nome de um objeto de semáforo de sistema, especificando uma variável que recebe um valor que indica se um novo semáforo do sistema foi criado e especificando o controle de acesso de segurança para o semáforo do sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este construtor para aplicar segurança de controle de acesso a um semáforo de sistema nomeado quando ele é criado, impedindo que o outro código assumindo o controle de semáforo.  
  
 Este construtor inicializa um <xref:System.Threading.Semaphore> objeto que representa um semáforo de sistema nomeado. Você pode criar várias <xref:System.Threading.Semaphore> objetos que representam o mesmo sistema semáforo.  
  
 Se o sinal do sistema nomeada não existir, ele será criado com a segurança de controle de acesso especificado. Se o sinal nomeado existir, a segurança de controle de acesso especificado será ignorada.  
  
> [!NOTE]
>  O chamador tem controle total sobre recém-criado <xref:System.Threading.Semaphore> objeto mesmo se `semaphoreSecurity` nega ou falhar ao conceder a alguns direitos de acesso para o usuário atual. No entanto, se o usuário atual tenta obter outro <xref:System.Threading.Semaphore> representar o mesmo semáforo, usando um construtor do objeto ou o <xref:System.Threading.Semaphore.OpenExisting%2A> método, Windows, segurança de controle de acesso é aplicada.  
  
 Se o sinal do sistema nomeada não existir, ele será criado com a contagem inicial e máximo especificados por `initialCount` e `maximumCount`. Se o sinal do sistema nomeado já existir, `initialCount` e `maximumCount` não são usados, embora ainda, valores inválidos causam exceções. Use o `createdNew` parâmetro para determinar se o sinal do sistema foi criado por este construtor.  
  
 Se `initialCount` é menor que `maximumCount`, e `createdNew` é `true`, o efeito é o mesmo como se tivesse chamado do thread atual <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` menos `initialCount`) vezes.  
  
 Se você especificar `null` ou uma cadeia de caracteres vazia para `name`, um semáforo local é criado, como se você tivesse chamado o <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> sobrecarga de construtor. Nesse caso, `createdNew` é sempre `true`.  
  
 Como semáforos nomeados são visíveis em todo o sistema operacional, eles podem ser usados para coordenar o uso de recursos além dos limites do processo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um semáforo com nome. Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo. Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e versão. Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="initialCount" /> é maior que <paramref name="maximumCount" />.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maximumCount" /> é menor que 1.  
  
 -ou-  
  
 <paramref name="initialCount" /> é menor que 0.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo com nome existe e tem segurança de controle de acesso e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.FullControl" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O sinal nomeado não pode ser criado, talvez porque um identificador de espera de um tipo diferente tem o mesmo nome.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.SemaphoreSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.SemaphoreSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém a segurança de controle de acesso para um semáforo de sistema nomeado.</summary>
        <returns>Um <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> objeto que representa a segurança de controle de acesso para o sinal do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Semaphore.GetAccessControl%2A> método usa a seguinte combinação de sinalizadores (combinados usando a operação OR bit a bit) para procurar permissões: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=nameWithType>, e <xref:System.Security.AccessControl.AccessControlSections?displayProperty=nameWithType>.  
  
 O usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos para chamar esse método e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos.  
  
 Em um semáforo local, a segurança de controle de acesso é irrelevante. Se o <xref:System.Threading.Semaphore> objeto não representa um semáforo de sistema nomeada, esse método retorna um <xref:System.Security.AccessControl.SemaphoreSecurity> objeto que concede todos os direitos a qualquer usuário.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um semáforo com nome.  
  
 Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões. A segurança de controle de acesso para o sinal do sistema é obtida por meio de <xref:System.Threading.Semaphore.GetAccessControl%2A> método.  
  
 Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e versão. Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">Atual <see cref="T:System.Threading.Semaphore" /> objeto representa um semáforo de sistema nomeado, e o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> direitos.  
  
 -ou-  
  
 Atual <see cref="T:System.Threading.Semaphore" /> objeto representa um semáforo de sistema nomeada e não foi aberto com <see cref="F:System.Security.AccessControl.SemaphoreRights.ReadPermissions" /> direitos.</exception>
        <exception cref="T:System.NotSupportedException">Sem suporte para o Windows 98 ou o Windows Millennium Edition.</exception>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <summary>Abre o semáforo nomeado especificado, caso ele já exista.</summary>
        <returns>Um objeto que representa o sinal do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir o semáforo especificado. Se o sinal do sistema não existir, este método lança uma exceção em vez de criar o semáforo de sistema. Para criar o semáforo de sistema quando ele ainda não existir, use um do <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas a este método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, embora os objetos que são retornados representam o mesmo sinal do sistema.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Semaphore.OpenExisting%2A> sobrecarga de método e especificando <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit.  
  
 Especificando o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador permite que um thread entrar no sinal e especificando o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um semáforo com nome.  
  
 Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas que concede o direito de leitura e alterar permissões o semáforo.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada a <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga do método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O semáforo com nome não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo com nome existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para abrir um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Semaphore OpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Semaphore</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representam o acesso de segurança desejado.</param>
        <summary>Abre o semáforo nomeado especificado, caso ele já exista, com o acesso de segurança desejado.</summary>
        <returns>Um objeto que representa o sinal do sistema nomeado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador para permitir que os threads entrar no sinal e o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 O <xref:System.Threading.Semaphore.OpenExisting%2A> método tenta abrir um semáforo existente. Se o sinal do sistema não existir, este método lança uma exceção em vez de criar o semáforo de sistema. Para criar o semáforo de sistema quando ele ainda não existir, use um do <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Várias chamadas a este método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, embora os objetos que são retornados representam o mesmo sinal do sistema.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um semáforo com nome.  
  
 Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões são alteradas, o sinal é aberto com os direitos necessários para inserir e liberá-lo. Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException">O semáforo com nome não existe.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo nomeado existe, mas o usuário não tem os direitos de acesso de segurança desejados.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado para criar um semáforo de sistema nomeado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.  
  
 Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.PrePrepareMethod</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sai do sinal e retorna à contagem anterior.</summary>
        <returns>A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os threads geralmente usam o <xref:System.Threading.WaitHandle.WaitOne%2A> método para inserir o sinal e eles normalmente usam essa sobrecarga de método para sair.  
  
 Se um <xref:System.Threading.SemaphoreFullException> é gerada pelo <xref:System.Threading.Semaphore.Release%2A> método, ele não indica necessariamente um problema com o thread de chamada. Um erro de programação em outro thread pode ter causado essa thread para sair do sinal do mais vezes que ele inserido.  
  
 Se o atual <xref:System.Threading.Semaphore> objeto representa um semáforo de sistema nomeado, o usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, que bloqueiam aguardando o sinal. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga do método para liberar o semáforo.  
  
 Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do sinal. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.SemaphoreFullException">A contagem de semáforo já está no valor máximo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro do Win32 com um semáforo com nome.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O sinal do atual representa um semáforo de sistema nomeado, mas o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.  
  
 -ou-  
  
 O sinal do atual representa um sinal de sistema nomeado, mas não foi aberto com <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Release">
      <MemberSignature Language="C#" Value="public int Release (int releaseCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Release(int32 releaseCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.Release(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="releaseCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="releaseCount">O número de vezes para sair do sinal.</param>
        <summary>Sai do sinal de um número de vezes especificado e retorna à contagem anterior.</summary>
        <returns>A contagem no sinal antes do método <see cref="Overload:System.Threading.Semaphore.Release" /> ser chamado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um thread entrou o semáforo várias vezes, essa sobrecarga de método permite que a contagem de semáforo toda a ser restaurado com uma chamada.  
  
 Se um <xref:System.Threading.SemaphoreFullException> é gerada pelo <xref:System.Threading.Semaphore.Release%2A> método, ele não indica necessariamente um problema com o thread de chamada. Um erro de programação em outro thread pode ter causado essa thread para sair do sinal do mais vezes que ele inserido.  
  
 Se o atual <xref:System.Threading.Semaphore> objeto representa um semáforo de sistema nomeado, o usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um semáforo com uma contagem máxima de três e uma contagem inicial de zero. O exemplo inicia cinco threads, que bloqueiam aguardando o sinal. O thread principal usa o <xref:System.Threading.Semaphore.Release%28System.Int32%29> sobrecarga do método para aumentar a contagem de semáforo ao seu máximo, permitindo que três threads entrar no sinal. Cada thread usa o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método esperar por um segundo, para simular o trabalho e, em seguida, chama o <xref:System.Threading.Semaphore.Release> sobrecarga do método para liberar o semáforo.  
  
 Cada vez que o sinal é liberado, a contagem de semáforo anterior é exibida. Console mensagens controlar o uso do sinal. O intervalo de trabalho simulada aumenta um pouco para cada thread, para facilitar a leitura de saída.  
  
 [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="releaseCount" /> é menor que 1.</exception>
        <exception cref="T:System.Threading.SemaphoreFullException">A contagem de semáforo já está no valor máximo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro do Win32 com um semáforo com nome.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O sinal do atual representa um semáforo de sistema nomeado, mas o usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" /> direitos.  
  
 -ou-  
  
 O sinal atual representa um sinal de sistema nomeado, mas não foi aberto com direitos de <see cref="F:System.Security.AccessControl.SemaphoreRights.Modify" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="semaphoreSecurity" Type="System.Security.AccessControl.SemaphoreSecurity" />
      </Parameters>
      <Docs>
        <param name="semaphoreSecurity">Um <see cref="T:System.Security.AccessControl.SemaphoreSecurity" /> objeto que representa a segurança de controle de acesso a ser aplicado ao sinal do sistema nomeado.</param>
        <summary>Define a segurança de controle de acesso para um semáforo de sistema nomeado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode definir a segurança de controle de acesso somente no <xref:System.Threading.Semaphore> objetos que representam o sistema nomeado semáforos.  
  
 O usuário deve ter <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos para chamar esse método e o sinal devem ter sido abertos com <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o comportamento de processo cruzado de um semáforo com nome com a segurança de controle de acesso. O exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga do método para testar a existência de um semáforo com nome.  
  
 Se o sinal não existir, ele será criado com uma contagem máxima de dois e segurança de controle de acesso que impede que o usuário atual o direito de usar o sinal, mas concede o direito de leitura e alterar permissões o semáforo.  
  
 Se você executar o exemplo compilado em duas janelas de comando, a segunda cópia lançará uma exceção de violação de acesso na chamada para o <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> método. A exceção é capturada e o exemplo usa o <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga do método para abrir o semáforo com os direitos necessários para ler e alterar as permissões.  
  
 Depois que as permissões forem alteradas, usando o <xref:System.Threading.Semaphore.SetAccessControl%2A> método, o sinal é aberto com os direitos necessários para inserir e versão. Se você executar o exemplo compilado em uma terceira janela de comando, ele é executado usando as novas permissões.  
  
 [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]
 [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="semaphoreSecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O usuário não tem <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> direitos.  
  
 -ou-  
  
 O sinal não foi aberto com <see cref="F:System.Security.AccessControl.SemaphoreRights.ChangePermissions" /> direitos.</exception>
        <exception cref="T:System.NotSupportedException">O objeto <see cref="T:System.Threading.Semaphore" /> atual não representa um semáforo de sistema nomeado.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <param name="result">Quando este método retorna, contém um <see cref="T:System.Threading.Semaphore" /> objeto que representa o semáforo com nome se a chamada foi bem-sucedida, ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Abre o semáforo nomeado especificado, caso ele já exista e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns>
          <see langword="true" />Se o sinal nomeado foi aberto com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o sinal nomeado não existir, este método não criá-lo. Para criar o semáforo de sistema quando ele ainda não existir, use um do <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se existe um semáforo nomeado, use essa sobrecarga de método em vez do <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> sobrecarga de método, o que gera uma exceção se o sinal não existe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Threading.Semaphore.TryOpenExisting%2A> sobrecarga de método e especificando <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> e <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> direitos, combinados com a operação OR bit a bit. Especificando o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador permite que um thread entrar no sinal e especificando o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador permite que um thread chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo com nome existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.SemaphoreRights rights, [out] class System.Threading.Semaphore&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.SemaphoreRights" />
        <Parameter Name="result" Type="System.Threading.Semaphore&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">O nome do semáforo do sistema a ser aberto.</param>
        <param name="rights">Uma combinação bit a bit dos valores de enumeração que representam o acesso de segurança desejado.</param>
        <param name="result">Quando este método retorna, contém um <see cref="T:System.Threading.Semaphore" /> objeto que representa o semáforo com nome se a chamada foi bem-sucedida, ou <see langword="null" /> se a chamada falhou. Esse parâmetro é tratado como não inicializado.</param>
        <summary>Abre o semáforo com nome especificado, se ele já existe, o acesso de segurança desejado e retorna um valor que indica se a operação foi bem-sucedida.</summary>
        <returns>
          <see langword="true" />Se o sinal nomeado foi aberto com êxito; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o sinal nomeado não existir, este método não criá-lo. Para criar o semáforo de sistema quando ele ainda não existir, use um do <xref:System.Threading.Semaphore.%23ctor%2A> construtores que tem um `name` parâmetro.  
  
 Se você não tiver certeza se existe um semáforo nomeado, use essa sobrecarga de método em vez do <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> sobrecarga de método, o que gera uma exceção se o sinal não existe.  
  
 O `rights` parâmetro deve incluir o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador para permitir que os threads entrar no sinal e o <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=nameWithType> sinalizador para permitir que os threads chamar o <xref:System.Threading.Semaphore.Release%2A> método.  
  
 Várias chamadas a este método que usam o mesmo valor para `name` não necessariamente retornam o mesmo <xref:System.Threading.Semaphore> do objeto, embora os objetos que são retornados representam o mesmo sinal do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="name" /> tem mais de 260 caracteres.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Erro do Win32.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O semáforo com nome existe, mas o usuário não tem o acesso de segurança necessário para usá-lo.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
