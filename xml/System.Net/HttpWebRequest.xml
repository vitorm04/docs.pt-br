<Type Name="HttpWebRequest" FullName="System.Net.HttpWebRequest">
  <TypeSignature Language="C#" Value="public class HttpWebRequest : System.Net.WebRequest, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable HttpWebRequest extends System.Net.WebRequest implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Net.HttpWebRequest" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Requests</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Net.WebRequest</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Fornece uma implementação específica de HTTP da classe <see cref="T:System.Net.WebRequest" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest> classe oferece suporte para as propriedades e métodos definidos no <xref:System.Net.WebRequest> e para outras propriedades e métodos que permitem que o usuário interaja diretamente com os servidores usando HTTP.  
  
 Não use o <xref:System.Net.HttpWebRequest.%23ctor%2A> construtor. Use o <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType> método para inicializar novas <xref:System.Net.HttpWebRequest> objetos. Se o esquema para o identificador de URI (Uniform Resource) é `http://` ou `https://`, <xref:System.Net.WebRequest.Create%2A> retorna um <xref:System.Net.HttpWebRequest> objeto.  
  
 O <xref:System.Net.HttpWebRequest.GetResponse%2A> método faz uma solicitação síncrona para o recurso especificado no <xref:System.Net.HttpWebRequest.RequestUri%2A> propriedade e retorna um <xref:System.Net.HttpWebResponse> que contém o objeto de resposta. Os dados de resposta podem ser recebidos usando o fluxo retornado por <xref:System.Net.HttpWebResponse.GetResponseStream%2A>. Se o objeto de resposta ou o fluxo de resposta estiver fechado, dados restantes serão perdidos. Os dados restantes serão descarregados e o soquete será reutilizado para solicitações subsequentes ao fechar o objeto de resposta ou fluxo se mantenha as seguintes condições: esta é uma solicitação de manutenção de funcionamento ou pipeline, apenas uma pequena quantidade de dados precisa ser recebido, ou o dados restantes recebido em um pequeno intervalo. Se nenhuma das condições mencionadas mantenha ou o esgotamento de tempo for excedido, o soquete será fechado. Para conexões de manutenção de funcionamento ou pipeline, é altamente recomendável que o aplicativo lê os fluxos de até o EOF. Isso garante que o soquete será reutilizado para solicitações subsequentes, resultando em um melhor desempenho e menos recursos usados.  
  
 Quando você deseja enviar dados para o recurso, o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método retorna um <xref:System.IO.Stream> objeto a ser usado para enviar dados. O <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos fornecem acesso assíncrono para o fluxo de dados de envio.  
  
 Para autenticação de cliente com <xref:System.Net.HttpWebRequest>, o certificado do cliente deve ser instalado no meu repositório de certificados do usuário atual.  
  
 O <xref:System.Net.HttpWebRequest> classe lança um <xref:System.Net.WebException> quando ocorrem erros ao acessar um recurso. O <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> propriedade contém um <xref:System.Net.WebExceptionStatus> valor que indica a origem do erro. Quando <xref:System.Net.WebException.Status%2A?displayProperty=nameWithType> é <xref:System.Net.WebExceptionStatus.ProtocolError?displayProperty=nameWithType>, o <xref:System.Net.WebException.Response%2A> propriedade contém o <xref:System.Net.HttpWebResponse> recebida do recurso.  
  
 <xref:System.Net.HttpWebRequest>expõe os valores de cabeçalho HTTP comuns enviada para o recurso de Internet como propriedades, definido por métodos ou definido pelo sistema; a tabela a seguir contém uma lista completa. Você pode definir outros cabeçalhos no <xref:System.Net.HttpWebRequest.Headers%2A> a propriedade como pares nome/valor. Observe que servidores e os caches podem alterar ou adicionar cabeçalhos durante a solicitação.  
  
 A tabela a seguir lista os cabeçalhos HTTP que são definidos por propriedades ou métodos ou o sistema.  
  
|Cabeçalho|Definido pelo|  
|------------|------------|  
|Aceitar|Definida pelo <xref:System.Net.HttpWebRequest.Accept%2A> propriedade.|  
|Conexão|Definida pelo <xref:System.Net.HttpWebRequest.Connection%2A> propriedade <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade.|  
|Tamanho do conteúdo|Definida pelo <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade.|  
|Tipo de conteúdo|Definida pelo <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade.|  
|Esperar|Definida pelo <xref:System.Net.HttpWebRequest.Expect%2A> propriedade.|  
|Date|Definido pelo sistema para a data atual.|  
|Host|Definido pelo sistema para obter informações de host atual.|  
|If-Modified-Since|Definida pelo <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade.|  
|Intervalo|Definida pelo <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Referência|Definida pelo <xref:System.Net.HttpWebRequest.Referer%2A> propriedade.|  
|Codificação de transferência|Definida pelo <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade (o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade deve ser `true`).|  
|Agente do usuário|Definida pelo <xref:System.Net.HttpWebRequest.UserAgent%2A> propriedade.|  
  
> [!NOTE]
>  <xref:System.Net.HttpWebRequest>é registrado automaticamente. Você não precisa chamar o <xref:System.Net.WebRequest.RegisterPrefix%2A> método para registrar <xref:System.Net.HttpWebRequest?displayProperty=nameWithType> antes de usar URIs começando com `http://` ou `https://`.  
  
 O computador local ou o arquivo de configuração de aplicativo pode especificar que um proxy padrão ser usado. Se o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade for especificada, em seguida, as configurações de proxy do <xref:System.Net.HttpWebRequest.Proxy%2A> o computador local ou o arquivo de configuração do aplicativo de substituição de propriedade e o <xref:System.Net.HttpWebRequest> instância usará as configurações de proxy especificadas. Se nenhum proxy for especificado em um arquivo de configuração e o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade não for especificada, a <xref:System.Net.HttpWebRequest> classe usa as configurações de proxy herdadas do Internet Explorer no computador local. Se não houver nenhuma configuração de proxy no Internet Explorer, a solicitação é enviada diretamente para o servidor.  
  
 O <xref:System.Net.HttpWebRequest> classe analisa uma lista de proxies com caracteres curinga herdadas do Internet Explorer de modo diferente que a lista de bypass é analisada diretamente pelo Internet Explorer. Por exemplo, a <xref:System.Net.HttpWebRequest> classe analisa uma lista de bypass de "nt *" do Internet Explorer como uma expressão regular "nt. $". Isso é diferente do comportamento nativo do Internet Explorer. Para uma URL de "`http://intxxxxx`" ignoram o proxy usando o <xref:System.Net.HttpWebRequest> de classe, mas não ignoram o proxy usando o Internet Explorer.  
  
> [!NOTE]
>  A estrutura armazena em cache as sessões SSL conforme eles são criados e tenta reutilizar uma sessão em cache para uma nova solicitação, se possível. Ao tentar reutilizar uma sessão SSL, a estrutura usa o primeiro elemento da <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se houver), ou tentar reutilizar um sessões anônimas se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vazio.  
  
> [!NOTE]
>  Por motivos de segurança, os cookies estão desabilitados por padrão. Se você quiser usar cookies, use o <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade para habilitar cookies.  
  
 O .NET Framework 4.6 inclui um novo recurso de segurança que bloqueia insegura criptografia e algoritmos para conexões de hash. Aplicativos de uso do TLS/SSL por meio de APIs como HttpClient HttpWebRequest, FTPClient, SmtpClient, SslStream, etc. e o direcionamento do .NET Framework 4.6 obtém o comportamento mais seguros por padrão.  
  
 Os desenvolvedores talvez queira desativar esse comportamento para manter a interoperabilidade com seus serviços SSL3 existentes ou TLS com serviços de RC4. [Este artigo](https://support.microsoft.com/kb/3069494) explica como modificar seu código para que o novo comportamento está desabilitado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Net.HttpWebRequest> para o URI http://www.contoso.com/.  
  
 [!code-cpp[Classic HttpWebRequest Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.WebPermission">para acessar o URI solicitado ou qualquer URI que a solicitação é redirecionada para. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.HttpWebRequest" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.HttpWebRequest" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpWebRequest (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Uri)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HttpWebRequest (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Serialization is obsoleted for this type", false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o objeto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <param name="streamingContext">Um objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado ao novo objeto <see cref="T:System.Net.HttpWebRequest" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.HttpWebRequest" /> das instâncias especificadas das classes <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo deve ser executado no modo de confiança total ao usar a serialização.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obter acesso irrestrito aos recursos da rede. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public override void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.Abort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela uma solicitação para um recurso de Internet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Abort%2A> método cancela uma solicitação para um recurso. Depois que uma solicitação for cancelada, chamando o <xref:System.Net.HttpWebRequest.GetResponse%2A>, <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.EndGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, ou <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método faz com que um <xref:System.Net.WebException> com o <xref:System.Net.WebException.Status%2A> propriedade definida como <xref:System.Net.WebExceptionStatus.RequestCanceled>.  
  
 O <xref:System.Net.HttpWebRequest.Abort%2A> método sincronicamente executará o retorno de chamada especificado para o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> métodos se o <xref:System.Net.HttpWebRequest.Abort%2A> método é chamado enquanto qualquer uma dessas operações estão pendente. Isso pode levar a problemas potenciais de deadlock.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede](http://msdn.microsoft.com/en-us/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 No caso de solicitações assíncronas, é responsabilidade do aplicativo cliente para implementar seu próprio mecanismo de tempo limite. O exemplo de código a seguir mostra como fazer isso.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public string Accept { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Accept" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Accept" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Accept" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Accept" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para limpar o `Accept` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.Accept%2A> propriedade `null`.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.Accept%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_Accept#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Accept/CPP/httpwebrequest_accept.cpp#1)]
 [!code-csharp[HttpWebRequest_Accept#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Accept/CS/httpwebrequest_accept.cs#1)]
 [!code-vb[HttpWebRequest_Accept#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Accept/VB/httpwebrequest_accept.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddRange">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adiciona um cabeçalho de intervalo para a solicitação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo de bytes a uma solicitação de um intervalo específico, do início ou do fim dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Se `range` for positivo, a `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados do `range` parâmetro especificado até o final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados da entidade de HTTP para o `range` parâmetro especificado.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que solicita o envio de servidor os primeiros 100 bytes (desde o início até a posição do byte 99) seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-intervalos. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um cabeçalho de intervalo para a solicitação.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo de bytes a uma solicitação de um intervalo específico, do início ou do fim dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Se `range` for positivo, a `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados do `range` parâmetro especificado até o final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados da entidade de HTTP para o `range` parâmetro especificado.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que solicita o envio de servidor os primeiros 100 bytes (desde o início até a posição do byte 99) seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-intervalos. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo de byte à solicitação de um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `from` parâmetro deve ser especificado como 0 e o `to` parâmetro deve ser especificado como 99. O especificador de intervalo é automaticamente definido como "bytes" por este método.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-intervalos. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um cabeçalho de intervalo para a solicitação.  
  
 [!code-cpp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/cpp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cpp/source.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/csharp/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/cs/source.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.AddRange2#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/system.net.httpwebrequest.addrange2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> é maior que <paramref name="to" />  
  
 -ou-  
  
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
        <altmember cref="Overload:System.Net.HttpWebRequest.AddRange" />
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo de byte à solicitação de um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo de bytes para a solicitação.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `from` parâmetro deve ser especificado como 0 e o `to` parâmetro deve ser especificado como 99. O especificador de intervalo é automaticamente definido como "bytes" por este método.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-intervalos. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> é maior que <paramref name="to" />  
  
 -ou-  
  
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação para um intervalo específico de início ou no final dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Se `range` for positivo, a `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados do `range` parâmetro especificado até o final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados da entidade de HTTP para o `range` parâmetro especificado.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", pois esse é o único especificador de intervalo reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite suporte para especificadores de intervalo personalizado diferente de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes" e o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="range" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="range">O ponto inicial ou final do intervalo.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação para um intervalo específico de início ou no final dos dados solicitados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Se `range` for positivo, a `range` parâmetro especifica o ponto inicial do intervalo. O servidor deve começar a enviar dados do `range` parâmetro especificado até o final dos dados na entidade HTTP.  
  
 Se `range` for negativo, o `range` parâmetro especifica o ponto final do intervalo. O servidor deve começar a enviar dados desde o início dos dados da entidade de HTTP para o `range` parâmetro especificado.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", pois esse é o único especificador de intervalo reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite suporte para especificadores de intervalo personalizado diferente de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes" e o `range` parâmetro seria -99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, int from, int to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int32 from, int32 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int32" />
        <Parameter Name="to" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação para um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", pois esse é o único especificador de intervalo reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite suporte para especificadores de intervalo personalizado diferente de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes", o `from` parâmetro deve ser 0 e o `to` parâmetro seria 99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 A cadeia de caracteres especificada no cabeçalho Accept-Ranges é o especificador de intervalo que deve ser especificado no `rangeSpecifier` parâmetro deste método.  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> é maior que <paramref name="to" />  
  
 -ou-  
  
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddRange">
      <MemberSignature Language="C#" Value="public void AddRange (string rangeSpecifier, long from, long to);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddRange(string rangeSpecifier, int64 from, int64 to) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.AddRange(System.String,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rangeSpecifier" Type="System.String" />
        <Parameter Name="from" Type="System.Int64" />
        <Parameter Name="to" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="rangeSpecifier">A descrição do intervalo.</param>
        <param name="from">A posição na qual iniciar o envio de dados.</param>
        <param name="to">A posição na qual interromper o envio de dados.</param>
        <summary>Adiciona um cabeçalho de intervalo a uma solicitação para um intervalo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.AddRange%2A?displayProperty=nameWithType> método adiciona um cabeçalho de intervalo para a solicitação.  
  
 Como todas as entidades HTTP são representadas em mensagens HTTP como sequências de bytes, o conceito de um intervalo de bytes é significativo para qualquer entidade HTTP. No entanto, nem todos os clientes e servidores precisam dar suporte a operações de intervalo de bytes.  
  
 O cabeçalho de intervalo em uma solicitação permite que um cliente solicitar que apenas deseja receber alguma parte do intervalo especificado de bytes em uma entidade HTTP. Servidores não são necessários para dar suporte a solicitações de cabeçalho de intervalo.  
  
 O `rangeSpecifier` parâmetro normalmente seria especificado como "bytes", pois esse é o único especificador de intervalo reconhecido pela maioria dos servidores HTTP. Definindo o `rangeSpecifier` parâmetro para alguma outra cadeia de caracteres permite suporte para especificadores de intervalo personalizado diferente de bytes (o especificador de intervalo de bytes definido na RFC 2616 pela IETF).  
  
 Um exemplo de um cabeçalho de intervalo em uma solicitação do protocolo HTTP que seriam solicitações os primeiros 100 bytes seria o seguinte:  
  
 `Range: bytes=0-99\r\n\r\n`  
  
 Neste exemplo, o `rangeSpecifier` parâmetro deve ser especificado como "bytes", o `from` parâmetro deve ser 0 e o `to` parâmetro seria 99.  
  
 Um servidor HTTP indica suporte para cabeçalhos de intervalo com o cabeçalho Accept-Ranges na resposta. Um exemplo do cabeçalho Accept-intervalos de um servidor que oferece suporte a intervalos de bytes seria da seguinte maneira:  
  
 `Accept-Ranges: bytes\r\n\r\n`  
  
 A cadeia de caracteres especificada no cabeçalho Accept-Ranges é o especificador de intervalo que deve ser especificado no `rangeSpecifier` parâmetro deste método.  
  
 Se um cabeçalho Accept-Ranges não for recebido no cabeçalho de resposta do servidor, o servidor não oferece suporte a cabeçalhos de intervalo. Um exemplo do cabeçalho Accept-intervalos de um servidor que não oferece suporte a intervalos, mas reconhece o cabeçalho Accept-Ranges, seria da seguinte maneira:  
  
 `Accept-Ranges: none\r\n\r\n`  
  
 Ao receber a resposta de uma solicitação de intervalo, somente os cabeçalhos HTTP associados à solicitação inteira são analisados e disponibilizados por meio de propriedades de <xref:System.Net.HttpWebResponse> classe. Cabeçalhos associados a cada intervalo são retornados na resposta.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rangeSpecifier" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="from" /> é maior que <paramref name="to" />  
  
 -ou-  
  
 <paramref name="from" /> ou <paramref name="to" /> é menor que 0.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="rangeSpecifier" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">Não foi possível adicionar o cabeçalho de intervalo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Address">
      <MemberSignature Language="C#" Value="public Uri Address { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Address" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Address" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI (Uniform Resource Identifier) do recurso de Internet que realmente responde à solicitação.</summary>
        <value>Um <see cref="T:System.Uri" /> que identifica o recurso de Internet que realmente responde à solicitação. O padrão é o URI usado pelo método <see cref="M:System.Net.WebRequest.Create(System.String)" /> para inicializar a solicitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Address%2A> propriedade é definida para o URI após a conclusão qualquer redirecionamentos que ocorrem durante a solicitação.  
  
 O URI da solicitação original é mantido <xref:System.Net.HttpWebRequest.RequestUri%2A> propriedade.  
  
   
  
## Examples  
 O seguinte código de exemplo verifica se o <xref:System.Net.HttpWebRequest> objeto `req` foi redirecionado para outro local para atender à solicitação e define o valor da `hasChanged` variável para `true` se a solicitação foi redirecionada; casocontrário`hasChanged`é definido como `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowAutoRedirect">
      <MemberSignature Language="C#" Value="public virtual bool AllowAutoRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowAutoRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowAutoRedirect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a solicitação deve seguir as respostas de redirecionamento.</summary>
        <value>
          <see langword="true" /> se a solicitação precisar seguir automaticamente as respostas de redirecionamento do recurso da Internet; caso contrário, <see langword="false" />. O valor padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> para `true` se você quiser que a solicitação a seguir automaticamente os cabeçalhos de redirecionamento de HTTP para o novo local do recurso. O número máximo de redirecionamentos a seguir é definido <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriedade.  
  
 Se <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> é definido como `false`, todas as respostas com um código de status HTTP de 300 a 399 é retornado ao aplicativo.  
  
 O cabeçalho de autorização está desmarcado na redirecionamentos automáticos e <xref:System.Net.HttpWebRequest> automaticamente tenta autenticar novamente para o local de redirecionamento. Na prática, isso significa que um aplicativo não é possível colocar informações de autenticação personalizado para o cabeçalho de autorização se é possível encontrar o redirecionamento. Em vez disso, o aplicativo deve implementar e registrar um módulo de autenticação personalizada. O <xref:System.Net.AuthenticationManager?displayProperty=nameWithType> e a classe relacionada são usadas para implementar um módulo de autenticação personalizada. O <xref:System.Net.AuthenticationManager.Register%2A?displayProperty=nameWithType> método registra um módulo de autenticação personalizada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> propriedade para permitir que a solicitação para seguir respostas de redirecionamento.  
  
 [!code-cpp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CPP/httpwebrequest_allowautoredirect.cpp#2)]
 [!code-csharp[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/CS/httpwebrequest_allowautoredirect.cs#2)]
 [!code-vb[HttpWebRequest_AllowAutoRedirect#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowAutoRedirect/VB/httpwebrequest_allowautoredirect.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowReadStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowReadStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowReadStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowReadStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o recebido do recurso da Internet deve ser armazenado em buffer.</summary>
        <value>
          <see langword="true" /> para habilitar o armazenamento em buffer dos dados recebidos do recurso da Internet; <see langword="false" /> para desabilitar o armazenamento em buffer. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowWriteStreamBuffering">
      <MemberSignature Language="C#" Value="public virtual bool AllowWriteStreamBuffering { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowWriteStreamBuffering" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os dados enviados para o recurso de Internet devem ser armazenados em buffer.</summary>
        <value>
          <see langword="true" /> para habilitar o armazenamento em buffer dos dados enviados para o recurso da Internet, <see langword="false" /> para desabilitar o armazenamento em buffer. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> é `true`, os dados são armazenados em buffer na memória para que ele está pronto para ser reenviados no caso de redirecionamentos ou autenticação de solicitações.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.AllowWriteStreamBuffering%2A> propriedade para desabilitar o buffer de dados.  
  
 [!code-cpp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CPP/httpwebrequest_allowwritestreambuffering.cpp#1)]
 [!code-csharp[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/CS/httpwebrequest_allowwritestreambuffering.cs#1)]
 [!code-vb[HttpWebRequest_AllowWriteStreamBuffering#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_AllowWriteStreamBuffering/VB/httpwebrequest_allowwritestreambuffering.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Configuração <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> para <see langword="true" /> pode causar problemas de desempenho ao carregar grandes conjuntos de dados porque o buffer de dados pode usar toda a memória disponível.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AutomaticDecompression">
      <MemberSignature Language="C#" Value="public System.Net.DecompressionMethods AutomaticDecompression { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.DecompressionMethods AutomaticDecompression" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.AutomaticDecompression" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.DecompressionMethods</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de descompactação usada.</summary>
        <value>Um <see cref="T:System.Net.DecompressionMethods" /> objeto que indica o tipo de descompactação é usado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Estado atual do objeto não permite que esse tipo de propriedade seja definido.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetRequestStream">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetRequestStream (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetRequestStream(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">O objeto de estado dessa solicitação.</param>
        <summary>Inicia uma solicitação assíncrona para um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à solicitação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método inicia uma solicitação assíncrona para um fluxo usado para enviar dados o <xref:System.Net.HttpWebRequest>. O método de retorno de chamada assíncrono usa o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para retornar o fluxo real.  
  
 O <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método exige algumas tarefas de instalação síncrona para concluir (resolução de DNS, a detecção de proxy e conexão de soquete TCP, por exemplo) antes desse método torna-se assíncrona. Como resultado, esse método deve nunca ser chamado em um thread de interface do usuário porque ele pode demorar um tempo considerável (até vários minutos dependendo das configurações de rede) para concluir as tarefas de configuração inicial de síncrona antes de uma exceção para um erro será lançado ou o método for bem-sucedido.  
  
 Para saber mais sobre o pool de threads, consulte [o Pool de threads gerenciados](~/docs/standard/threading/the-managed-thread-pool.md).  
  
> [!NOTE]
>  O aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método para fazer uma solicitação assíncrona para uma instância de fluxo.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">A propriedade <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está sendo usado por uma chamada anterior a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.  
  
 -ou-  
  
 O pool de threads está ficando sem threads.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, as solicitações que gravam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.</exception>
        <exception cref="T:System.ObjectDisposedException">Em um aplicativo .NET Compact Framework, um fluxo de solicitação com tamanho de conteúdo zero não foi obtido e fechado corretamente. Para obter mais informações sobre como lidar com zero solicitações de comprimento de conteúdo, consulte [de programação de rede no .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginGetResponse">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginGetResponse (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginGetResponse(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" /></param>
        <param name="state">O objeto de estado dessa solicitação.</param>
        <summary>Inicia uma solicitação assíncrona para um recurso da Internet.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à solicitação assíncrona de uma resposta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método inicia uma solicitação assíncrona para uma resposta do recurso da Internet. O método de retorno de chamada assíncrono usa o <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para retornar o valor real <xref:System.Net.WebResponse>.  
  
 Um <xref:System.Net.ProtocolViolationException> é gerada em alguns casos, quando as propriedades definidas no <xref:System.Net.HttpWebRequest> classe estão em conflito. Essa exceção ocorre se um aplicativo define a <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade e o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade `true`e, em seguida, envia uma solicitação HTTP GET. Essa exceção ocorre se um aplicativo tentar enviar em partes para um servidor que só dá suporte ao protocolo HTTP 1.0, em que isso não é suportado. Essa exceção ocorre se um aplicativo tentar enviar dados sem definir o <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade ou o <xref:System.Net.HttpWebRequest.SendChunked%2A> é `false` quando o buffer está desativado e em uma conexão de keepalive (o <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`)`.`  
  
 Se um <xref:System.Net.WebException> é acionada, use o <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> propriedades da exceção para determinar a resposta do servidor.  
  
 O <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método exige algumas tarefas de instalação síncrona para concluir (resolução de DNS, a detecção de proxy e conexão de soquete TCP, por exemplo) antes desse método torna-se assíncrona. Como resultado, esse método deve nunca ser chamado em um thread de interface do usuário porque ele pode demorar um tempo considerável (até vários minutos dependendo das configurações de rede) para concluir as tarefas de configuração inicial de síncrona antes de uma exceção para um erro será lançado ou o método for bem-sucedido.  
  
 Para saber mais sobre o pool de threads, consulte [&#91;\< Topic://cpconthreadpooling > &#93; ](http://msdn.microsoft.com/en-us/2be05b06-a42e-4c9d-a739-96c21d673927).  
  
> [!NOTE]
>  O aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [&#91;\< Topic://conUsingNetworkTracing > &#93; ](http://msdn.microsoft.com/en-us/e993b7c3-087f-45d8-9c02-9dded936d804).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método para fazer uma solicitação assíncrona para um recurso de Internet.  
  
> [!NOTE]
>  No caso de solicitações assíncronas, é responsabilidade do aplicativo cliente para implementar seu próprio mecanismo de tempo limite. O exemplo de código a seguir mostra como fazer isso.  
  
 [!code-cpp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CPP/begingetresponse.cpp#1)]
 [!code-csharp[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/CS/begingetresponse.cs#1)]
 [!code-vb[System.Net.HttpWebRequest.BeginGetResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.HttpWebRequest.BeginGetResponse/VB/begingetresponse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo já está sendo usado por uma chamada anterior a <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.  
  
 -ou-  
  
 O pool de threads está ficando sem threads.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que zero ou <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="true" />.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.  
  
 -ou-  
  
 O <see cref="T:System.Net.HttpWebRequest" /> tem um corpo de entidade, mas o método <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" /> é chamado sem chamar o método <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.  
  
 -ou-  
  
 O <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que zero, mas o aplicativo não grava todos os dados prometidos.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientCertificates">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.X509Certificates.X509CertificateCollection ClientCertificates" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ClientCertificates" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.X509Certificates.X509CertificateCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a coleção de certificados de segurança que estão associadas essa solicitação.</summary>
        <value>Um <see cref="T:System.Security.Cryptography.X509Certificates.X509CertificateCollection" /> que contém os certificados de segurança associados a essa solicitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo pode adicionar um certificado a uma coleção, mas pode não ter direitos de acesso a ele. Para usar um certificado contido na coleção, o aplicativo deve ter os mesmos direitos de acesso que a entidade que emitiu o certificado.  
  
> [!NOTE]
>  A estrutura armazena em cache as sessões SSL conforme eles são criados e tenta reutilizar uma sessão em cache para uma nova solicitação, se possível. Ao tentar reutilizar uma sessão SSL, a estrutura usa o primeiro elemento da <xref:System.Net.HttpWebRequest.ClientCertificates%2A> (se houver), ou tentar reutilizar um sessões anônimas se <xref:System.Net.HttpWebRequest.ClientCertificates%2A> está vazio.  
  
> [!NOTE]
>  Por motivos de desempenho, você não deve adicionar um certificado de cliente a um <xref:System.Net.HttpWebRequest> , a menos que você sabe que o servidor pedirá para ele.  
>   
>  Para obter um exemplo de código que ilustra como enumerar os certificados no repositório de certificados de cliente, consulte o <xref:System.Security.Cryptography.X509Certificates.X509Certificate2Collection> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor especificado para uma operação de definição é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connection">
      <MemberSignature Language="C#" Value="public string Connection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Connection" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Connection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Connection" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Connection" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Envia a solicitação de <xref:System.Net.HttpWebRequest.Connection%2A> propriedade para o recurso de Internet como a `Connection` cabeçalho HTTP. Se o valor da <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`, o valor "Keep-alive" é acrescentado ao final do `Connection` cabeçalho.  
  
 Para limpar o `Connection` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.Connection%2A> propriedade `null`.  
  
 Alterando o <xref:System.Net.HttpWebRequest.Connection%2A> propriedade depois que a solicitação foi iniciada chamando o <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.Connection%2A> propriedade para definir o valor do cabeçalho HTTP de Conexão.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor de <see cref="P:System.Net.HttpWebRequest.Connection" /> é definido como Keep-alive ou Fechar.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectionGroupName">
      <MemberSignature Language="C#" Value="public override string ConnectionGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ConnectionGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ConnectionGroupName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do grupo de conexões para a solicitação.</summary>
        <value>O nome do grupo de conexão para essa solicitação. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriedade permite que você associe uma solicitação com um grupo de conexão. Isso é útil quando seu aplicativo faz solicitações para um servidor para usuários diferentes, como um site da Web que recupera informações de cliente de um servidor de banco de dados.  
  
   
  
## Examples  
 O exemplo de código a seguir mostram como usar informações do usuário para formar um grupo de conexão, supondo-se que as variáveis `username`, `password`, e `domain` são definidos pelo aplicativo antes que esse código é chamado.  
  
 [!code-cpp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.ConnectionGroupName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.ConnectionGroupName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Cada grupo de conexão cria conexões adicionais para um servidor. Isso pode resultar em exceder o número de conexões definida <see cref="P:System.Net.ServicePoint.ConnectionLimit" /> propriedade para o servidor.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ContentLength">
      <MemberSignature Language="C#" Value="public override long ContentLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 ContentLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o cabeçalho HTTP <see langword="Content-length" />.</summary>
        <value>O número de bytes de dados a serem enviados ao recurso de Internet. O padrão é -1, que indica que a propriedade não foi definida e que não há dados de solicitação para enviar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade contém o valor a ser enviado como o `Content-length` cabeçalho HTTP com a solicitação.  
  
 Qualquer valor diferente de -1 no <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade indica que a solicitação carrega dados e que somente os métodos que carregam dados podem ser definidas no <xref:System.Net.HttpWebRequest.Method%2A> propriedade.  
  
 Após o <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade é definida como um valor, esse número de bytes deve ser gravado para o fluxo da solicitação que é retornado ao chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método ou ambos o <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> e <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> métodos.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade para o comprimento da cadeia de caracteres que está sendo lançada.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada chamando o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O novo valor <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public override string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Content-type" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Content-type" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade contém o tipo de mídia da solicitação. Valores atribuídos para a <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade substituir qualquer conteúdo existente quando a solicitação envia o `Content-type` cabeçalho HTTP.  
  
 Para limpar o `Content-type` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade `null`.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection> . Se <xref:System.Net.WebHeaderCollection> estiver definido, o valor da propriedade é perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_ContentLength#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#1)]
 [!code-csharp[HttpWebRequest_ContentLength#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#1)]
 [!code-vb[HttpWebRequest_ContentLength#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueDelegate">
      <MemberSignature Language="C#" Value="public System.Net.HttpContinueDelegate ContinueDelegate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.HttpContinueDelegate ContinueDelegate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueDelegate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.HttpContinueDelegate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o método delegado chamado quando um HTTP 100-continue a resposta é recebida do recurso da Internet.</summary>
        <value>Um delegado que implementa o método de retorno de chamada que é executado quando uma resposta HTTP continuar é retornada do recurso da Internet. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> propriedade especifica o método de retorno de chamada para chamar quando o cliente recebe um 100-Continue a resposta.  
  
 Quando o <xref:System.Net.HttpWebRequest.ContinueDelegate%2A> estiver definida, o cliente chama o representante sempre que as respostas do tipo de protocolo <xref:System.Net.HttpStatusCode.Continue?displayProperty=nameWithType> (100) são recebidas. Isso é útil se você quiser que o cliente para exibir o status dos dados sendo recebidos do recurso da Internet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContinueTimeout">
      <MemberSignature Language="C#" Value="public int ContinueTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ContinueTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ContinueTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um tempo limite, em milissegundos, para aguardar até que o 100-Continue seja recebido do servidor.</summary>
        <value>O tempo limite, em milissegundos, para aguardar até que o 100-Continue seja recebido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a 100-Continue a resposta for recebida antes do tempo limite expirar, o corpo da entidade pode ser enviado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieContainer">
      <MemberSignature Language="C#" Value="public virtual System.Net.CookieContainer CookieContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.CookieContainer CookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.CookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.CookieContainer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define os cookies associados à solicitação.</summary>
        <value>Um <see cref="T:System.Net.CookieContainer" /> que contém os cookies associados a essa solicitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade fornece uma instância do <xref:System.Net.CookieContainer> classe que contém os cookies associados a esta solicitação.  
  
 <xref:System.Net.HttpWebRequest.CookieContainer%2A>é `null` por padrão. Você deve atribuir um <xref:System.Net.CookieContainer> objeto à propriedade para ter os cookies retornados no <xref:System.Net.HttpWebResponse.Cookies%2A> propriedade do <xref:System.Net.HttpWebResponse> retornado pelo <xref:System.Net.HttpWebRequest.GetResponse%2A> método.  
  
> [!NOTE]
>  Por motivos de segurança, os cookies estão desabilitados por padrão. Se você quiser usar cookies, use o <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade para habilitar cookies.  
  
   
  
## Examples  
 O exemplo de código a seguir envia uma solicitação para uma URL e exibe os cookies retornados na resposta.  
  
 [!code-cpp[NCLCookies#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLCookies/CPP/cookiessnippets.cpp#1)]
 [!code-csharp[NCLCookies#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLCookies/CS/cookiessnippets.cs#1)]
 [!code-vb[NCLCookies#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLCookies/VB/cookiessnippets.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Credentials">
      <MemberSignature Language="C#" Value="public override System.Net.ICredentials Credentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ICredentials Credentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Credentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ICredentials</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define informações de autenticação para a solicitação.</summary>
        <value>Um <see cref="T:System.Net.ICredentials" /> que contém as credenciais de autenticação associadas à solicitação. O padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Credentials%2A> propriedade contém informações de autenticação para identificar o criador da solicitação. O <xref:System.Net.HttpWebRequest.Credentials%2A> propriedade pode ser um <xref:System.Net.NetworkCredential>, no qual caso o usuário, senha e informações de domínio contidas no <xref:System.Net.NetworkCredential> objeto é usado para autenticar a solicitação, ou pode ser um <xref:System.Net.CredentialCache>, caso em que o Uniform Resource Identificador (URI) da solicitação é usado para determinar o usuário, senha e informações de domínio a ser usado para autenticar a solicitação.  
  
 Na maioria dos cenários de cliente, você deve usar o <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriedade, que contém as credenciais do usuário conectado no momento. Para fazer isso, defina o <xref:System.Net.WebClient.UseDefaultCredentials%2A> propriedade `true` em vez de definir esta propriedade.  
  
 Se o <xref:System.Net.HttpWebRequest> classe está sendo usada em um aplicativo de camada intermediária, como um aplicativo ASP.NET, as credenciais no <xref:System.Net.CredentialCache.DefaultCredentials%2A> propriedade pertence à conta de execução da página ASP (as credenciais do servidor). Normalmente, você deve definir essa propriedade para as credenciais do cliente em cujo nome a solicitação é feita.  
  
> [!NOTE]
>  O esquema de autenticação NTLM não pode ser usado para representar outro usuário. Kerberos especialmente deve ser configurado para dar suporte à representação.  
  
 Para restringir HttpWebRequest para um ou mais métodos de autenticação, use o <xref:System.Net.CredentialCache> de classe e vincular suas credenciais para um ou mais esquemas de autenticação  
  
 Esquemas de autenticação com suporte incluem Digest, Negotiate, Kerberos, NTLM e Basic.  
  
 Por motivos de segurança, ao seguir automaticamente redirecionamentos, armazenar as credenciais que você deseja incluir no redirecionamento em um <xref:System.Net.CredentialCache> e atribuí-la a essa propriedade. Essa propriedade será definida automaticamente `null` após redirecionamento se ele contiver qualquer coisa exceto um <xref:System.Net.CredentialCache>. Com o valor da propriedade a ser definida automaticamente como `null` nessas condições impede que as credenciais sejam enviadas a qualquer destino não intencional.
  
## Examples  
 O exemplo de código a seguir define as credenciais para uma solicitação.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Date">
      <MemberSignature Language="C#" Value="public DateTime Date { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime Date" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Date" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Date" /> a usar em uma solicitação HTTP.</summary>
        <value>O valor do cabeçalho de Data na solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o cabeçalho de data for `null`, em seguida, o valor de retorno será definido como <xref:System.DateTime.MinValue?displayProperty=nameWithType>.  
  
 O <xref:System.Net.HttpWebRequest.Date%2A> propriedade é um padrão <xref:System.DateTime?displayProperty=nameWithType> de objeto e pode conter um <xref:System.DateTimeKind?displayProperty=nameWithType> campo de <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualquer tipo de tempo pode ser definido ao usar o <xref:System.Net.HttpWebRequest.Date%2A> propriedade. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> está definido ou recuperado, o <xref:System.Net.HttpWebRequest.Date%2A> propriedade será considerada <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 As classes de <xref:System.Net> namespace sempre grave-os a <xref:System.Net.HttpWebRequest.Date%2A> propriedade na conexão durante a transmissão no formulário padrão usando o formato de GMT (Utc).  
  
 Se o <xref:System.Net.HttpWebRequest.Date%2A> está definida como <xref:System.DateTime.MinValue?displayProperty=nameWithType>, em seguida, o `Date` cabeçalho HTTP é removido do <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
 Se o <xref:System.Net.HttpWebRequest.Date%2A> é de propriedade <xref:System.DateTime.MinValue?displayProperty=nameWithType>, isso indica que o `Date` cabeçalho HTTP não está incluído no <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
 Se o <xref:System.Net.HttpWebRequest.Date%2A> está definida e é feita uma tentativa de enviar um <xref:System.Net.HttpWebRequest> sem corpo, uma <xref:System.Net.ProtocolViolationException?displayProperty=nameWithType> será lançada pelo <xref:System.Net.HttpWebRequest.BeginGetResponse%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, e <xref:System.Net.HttpWebRequest.EndGetResponse%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCachePolicy">
      <MemberSignature Language="C#" Value="public static System.Net.Cache.RequestCachePolicy DefaultCachePolicy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Net.Cache.RequestCachePolicy DefaultCachePolicy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultCachePolicy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Cache.RequestCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a política de cache padrão para essa solicitação.</summary>
        <value>Um <see cref="T:System.Net.Cache.HttpRequestCachePolicy" /> que especifica a política de cache em vigor para essa solicitação quando nenhuma outra política é aplicável.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A definição dessa propriedade registra a política especificada para as esquemas HTTP e HTTPS. Essa política é usada para esta solicitação se:  
  
 Não há nenhum <xref:System.Net.WebRequest.CachePolicy%2A?displayProperty=nameWithType> propriedade especificada para esta solicitação.  
  
 \- ou -  
  
 A configuração de máquina e do aplicativo que arquivos não especificar uma política de cache que é aplicável para o URI Uniform Resource Identifier () usada para criar esta solicitação.  
  
 Política de cache que determina se o recurso solicitado pode ser obtido um cache em vez de enviar a solicitação para o computador de host do recurso.  
  
 Uma cópia de um recurso só é adicionada ao cache se o fluxo de resposta para o recurso for recuperado e ler até o final do fluxo. Para que outra solicitação para o mesmo recurso pode usar uma cópia armazenada em cache, dependendo do nível de política de cache para esta solicitação.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Para obter acesso irrestrito aos recursos da rede. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumErrorResponseLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumErrorResponseLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumErrorResponseLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumErrorResponseLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho máximo padrão de uma resposta de erro HTTP.</summary>
        <value>O tamanho máximo padrão de uma resposta de erro HTTP.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é menor que 0 e não é igual a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultMaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public static int DefaultMaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 DefaultMaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o padrão para o <see cref="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" /> propriedade.</summary>
        <value>O comprimento, em quilobytes (1024 bytes), o padrão máximo para cabeçalhos de resposta recebidos. O arquivo de configuração padrão define esse valor como 64 kilobytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do cabeçalho da resposta recebida a linha de status de resposta e quaisquer caracteres de controle adicional que são recebidos como parte do protocolo HTTP. Um valor de-1 significa que sem limite é imposto nos cabeçalhos de resposta recebidos; um valor de 0 significa que todas as solicitações falharem.  
  
 Esse valor também pode ser alterado no arquivo de configuração. O impacto dessa propriedade pode ser substituído pela configuração de <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriedade em uma instância do <xref:System.Net.HttpWebRequest> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor não é igual a -1 e é menor que zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndGetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Encerra uma solicitação assíncrona para um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação pendente de um fluxo.</param>
        <summary>Encerra uma solicitação assíncrona para um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> uma solicitação assíncrona para um fluxo que foi iniciada pela conclusão do método de <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
> [!NOTE]
>  Você deve definir o valor de <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade antes de gravar dados no fluxo.  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que o aplicativo para execução fora de conexões.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> método para encerrar uma solicitação assíncrona para uma instância de fluxo.  
  
 [!code-cpp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CPP/httpwebrequest_begingetrequeststream.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/CS/httpwebrequest_begingetrequeststream.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetRequestStream#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetRequestStream/VB/httpwebrequest_begingetrequeststream.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">A solicitação não foi concluída e nenhum fluxo está disponível.</exception>
        <exception cref="T:System.ArgumentException">
          O <paramref name="asyncResult" /> não foi retornado pela instância atual de uma chamada a <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente usando <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
 -ou-  
  
 Ocorreu um erro ao processar a solicitação.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream EndGetRequestStream (IAsyncResult asyncResult, out System.Net.TransportContext transportContext);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream EndGetRequestStream(class System.IAsyncResult asyncResult, [out] class System.Net.TransportContext&amp; transportContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetRequestStream(System.IAsyncResult,System.Net.TransportContext@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação pendente de um fluxo.</param>
        <param name="transportContext">To be added.</param>
        <summary>Termina uma solicitação assíncrona para um <see cref="T:System.IO.Stream" /> objeto a ser usado para gravar dados e saídas de <see cref="T:System.Net.TransportContext" /> associado o fluxo.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.EndGetRequestStream%2A> uma solicitação assíncrona para um fluxo que foi iniciada pela conclusão do método de <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método e saídas o <xref:System.Net.TransportContext> associado com o fluxo. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Talvez seja necessário consultar a camada de transporte usada por alguns aplicativos que usam autenticação integrada do Windows com proteção estendida <xref:System.Net.HttpWebRequest> para recuperar o token de associação de canal (CBT) do canal TLS subjacente. O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método fornece acesso a essas informações para os métodos HTTP que têm um corpo de solicitação (`POST` e `PUT` solicitações). Isso é necessário somente se o aplicativo está implementando sua própria autenticação e precisa acessar o CBT.  
  
> [!NOTE]
>  Se um aplicativo precisa definir o valor de <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade, em seguida, isso deve ser feito antes de recuperar o fluxo e gravar dados nele.  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que o aplicativo para execução fora de conexões.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado pela instância atual de uma chamada para <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente usando <paramref name="asyncResult" />.</exception>
        <exception cref="T:System.IO.IOException">A solicitação não foi concluída e nenhum fluxo está disponível.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
 -ou-  
  
 Ocorreu um erro ao processar a solicitação.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndGetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse EndGetResponse (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse EndGetResponse(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.EndGetResponse(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação pendente para uma resposta.</param>
        <summary>Encerra uma solicitação assíncrona para um recurso da Internet.</summary>
        <returns>Um <see cref="T:System.Net.WebResponse" /> que contém a resposta do recurso da Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método é concluído em uma solicitação assíncrona para um recurso de Internet que foi iniciada chamando o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.Net.HttpWebResponse.Close%2A> método para fechar o fluxo e liberar a conexão. Falha ao fazer isso pode causar o aplicativo para execução fora de conexões.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.EndGetResponse%2A> método para encerrar uma solicitação assíncrona para um recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CPP/httpwebrequest_begingetresponse.cpp#2)]
 [!code-csharp[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/CS/httpwebrequest_begingetresponse.cs#2)]
 [!code-vb[HttpWebRequest_BeginGetResponse#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_BeginGetResponse/VB/httpwebrequest_begingetresponse.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esse método foi chamado anteriormente usando <paramref name="asyncResult." />  
  
 -ou-  
  
 A propriedade <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que 0, mas os dados não foram gravados no fluxo de solicitação.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
 -ou-  
  
 Ocorreu um erro ao processar a solicitação.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado pela instância atual de uma chamada para <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expect">
      <MemberSignature Language="C#" Value="public string Expect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Expect" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Expect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Expect" />.</summary>
        <value>O conteúdo do cabeçalho HTTP <see langword="Expect" />. O valor padrão é <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 O valor dessa propriedade é armazenado em <see cref="T:System.Net.WebHeaderCollection" />. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
</para></block></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <see langword="Expect" /> é definido como uma cadeia de caracteres que contém "100-continue" como uma subcadeia de caracteres.</exception>
        <altmember cref="P:System.Net.Configuration.HttpWebRequestElement.MaximumUnauthorizedUploadLength" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected override void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> a ser preenchido com dados.</param>
        <param name="streamingContext">Um <see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica o destino dessa serialização.</param>
        <summary>Popula um <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com os dados necessários para serializar o objeto de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os objetos incluídos no <xref:System.Runtime.Serialization.SerializationInfo> automaticamente são rastreadas e serializado pelo formatador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRequestStream">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public override System.IO.Stream GetRequestStream ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IO.Stream GetRequestStream() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método retorna um fluxo a ser usado para enviar dados o <xref:System.Net.HttpWebRequest>. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Se um aplicativo precisa definir o valor de <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade, em seguida, isso deve ser feito antes de recuperar o fluxo.  
  
 Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que o aplicativo para execução fora de conexões.  
  
> [!NOTE]
>  O aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método para retornar uma instância de fluxo.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.ProtocolViolationException">A propriedade <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.</exception>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> é chamado mais de uma vez.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, as solicitações que gravam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
 -ou-  
  
 O período de tempo limite da solicitação expirou.  
  
 -ou-  
  
 Ocorreu um erro ao processar a solicitação.</exception>
        <exception cref="T:System.ObjectDisposedException">Em um aplicativo .NET Compact Framework, um fluxo de solicitação com tamanho de conteúdo zero não foi obtido e fechado corretamente. Para obter mais informações sobre como lidar com zero solicitações de comprimento de conteúdo, consulte [de programação de rede no .NET Compact Framework](https://msdn.microsoft.com/subscriptions/downloads/1afx2b0f\(v=vs.80\).aspx).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRequestStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream GetRequestStream (out System.Net.TransportContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.Stream GetRequestStream([out] class System.Net.TransportContext&amp; context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetRequestStream(System.Net.TransportContext@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Net.TransportContext&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="context">O <see cref="T:System.Net.TransportContext" /> para o <see cref="T:System.IO.Stream" />.</param>
        <summary>Obtém um objeto <see cref="T:System.IO.Stream" /> a ser usado para gravar os dados de solicitação e gera o <see cref="T:System.Net.TransportContext" /> associado ao fluxo.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> a ser usado para gravar dados de solicitação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método retorna um fluxo a ser usado para enviar dados o <xref:System.Net.HttpWebRequest> e gera o <xref:System.Net.TransportContext> associado o fluxo. Após o <xref:System.IO.Stream> objeto foi retornado, você pode enviar dados com o <xref:System.Net.HttpWebRequest> usando o <xref:System.IO.Stream.Write%2A?displayProperty=nameWithType> método.  
  
 Talvez seja necessário consultar a camada de transporte usada por alguns aplicativos que usam autenticação integrada do Windows com proteção estendida <xref:System.Net.HttpWebRequest> para recuperar o token de associação de canal (CBT) do canal TLS subjacente. O <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método fornece acesso a essas informações para os métodos HTTP que têm um corpo de solicitação (`POST` e `PUT` solicitações). Isso é necessário somente se o aplicativo está implementando sua própria autenticação e precisa acessar o CBT.  
  
 Se um aplicativo precisa definir o valor de <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade, em seguida, isso deve ser feito antes de recuperar o fluxo.  
  
 Você deve chamar o <xref:System.IO.Stream.Close%2A?displayProperty=nameWithType> método para fechar o fluxo e liberar a conexão para reutilização. Falha ao fechar o fluxo faz com que o aplicativo para execução fora de conexões.  
  
> [!NOTE]
>  O aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">O método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> não pôde obter o <see cref="T:System.IO.Stream" />.</exception>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" /> é chamado mais de uma vez.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, as solicitações que gravam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">A propriedade <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
 -ou-  
  
 O período de tempo limite da solicitação expirou.  
  
 -ou-  
  
 Ocorreu um erro ao processar a solicitação.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetResponse">
      <MemberSignature Language="C#" Value="public override System.Net.WebResponse GetResponse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Net.WebResponse GetResponse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.GetResponse" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebResponse</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma resposta de um recurso da Internet.</summary>
        <returns>Um <see cref="T:System.Net.WebResponse" /> que contém a resposta do recurso da Internet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.GetResponse%2A> método retorna um <xref:System.Net.WebResponse> objeto que contém a resposta do recurso da Internet. A instância real retornado é um <xref:System.Net.HttpWebResponse>e pode ser conversão de tipo de classe para propriedades de acesso HTTP específica.  
  
 Um <xref:System.Net.ProtocolViolationException> é gerada em alguns casos, quando as propriedades definidas no <xref:System.Net.HttpWebRequest> classe estão em conflito. Essa exceção ocorre se um aplicativo define a <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade e o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade `true`e, em seguida, envia uma solicitação HTTP GET. Essa exceção ocorre se um aplicativo tentar enviar em partes para um servidor que só dá suporte ao protocolo HTTP 1.0, em que isso não é suportado. Essa exceção ocorre se um aplicativo tentar enviar dados sem definir o <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade ou o <xref:System.Net.HttpWebRequest.SendChunked%2A> é `false` quando o buffer está desativado e em uma conexão de keepalive (o <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`)`.`  
  
> [!CAUTION]
>  Você deve chamar o <xref:System.Net.HttpWebResponse.Close%2A> método para fechar o fluxo e liberar a conexão. Falha ao fazer isso pode causar o aplicativo para execução fora de conexões.  
  
 Ao usar o método POST, obter o fluxo da solicitação, gravar os dados a ser lançado e feche o fluxo. Esse método bloqueia aguardando conteúdo a postagem. Se não há nenhum tempo limite definido e você não fornecer conteúdo, os blocos de thread chamada indefinidamente.  
  
> [!NOTE]
>  Diversas chamadas para <xref:System.Net.HttpWebRequest.GetResponse%2A> retornar o mesmo objeto de resposta; a solicitação não seja enviado novamente.  
  
> [!NOTE]
>  O aplicativo não pode combinar métodos síncronos e assíncronos para uma determinada solicitação. Se você chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método, você deve usar o <xref:System.Net.HttpWebRequest.GetResponse%2A> método para recuperar a resposta.  
  
> [!NOTE]
>  Se um <xref:System.Net.WebException> é acionada, use o <xref:System.Net.WebException.Response%2A> e <xref:System.Net.WebException.Status%2A> propriedades da exceção para determinar a resposta do servidor.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Por motivos de segurança, os cookies estão desabilitados por padrão. Se você quiser usar cookies, use o <xref:System.Net.HttpWebRequest.CookieContainer%2A> propriedade para habilitar cookies.  
  
   
  
## Examples  
 O exemplo de código a seguir obtém a resposta para uma solicitação.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo já está sendo usado por uma chamada anterior para <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como um valor e <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.Net.ProtocolViolationException">
          <see cref="P:System.Net.HttpWebRequest.Method" /> é GET ou HEAD e <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior ou igual a zero ou <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="true" />.  
  
 -ou-  
  
 <see cref="P:System.Net.HttpWebRequest.KeepAlive" /> é <see langword="true" />, <see cref="P:System.Net.HttpWebRequest.AllowWriteStreamBuffering" /> é <see langword="false" />, <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é -1, <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" /> e <see cref="P:System.Net.HttpWebRequest.Method" /> é POST ou PUT.  
  
 -ou-  
  
 O <see cref="T:System.Net.HttpWebRequest" /> tem um corpo de entidade, mas o método <see cref="M:System.Net.HttpWebRequest.GetResponse" /> é chamado sem chamar o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.  
  
 -ou-  
  
 O <see cref="P:System.Net.HttpWebRequest.ContentLength" /> é maior que zero, mas o aplicativo não grava todos os dados prometidos.</exception>
        <exception cref="T:System.NotSupportedException">O validador de cache de solicitações indicou que a resposta para essa solicitação pode ser atendida no cache; no entanto, essa solicitação inclui dados a serem enviados ao servidor. Solicitações que enviam dados não devem usar o cache. Essa exceção poderá ocorrer se você estiver usando um validador de cache personalizado implementado incorretamente.</exception>
        <exception cref="T:System.Net.WebException">
          <see cref="M:System.Net.HttpWebRequest.Abort" /> foi chamado anteriormente.  
  
 -ou-  
  
 O período de tempo limite da solicitação expirou.  
  
 -ou-  
  
 Ocorreu um erro ao processar a solicitação.</exception>
      </Docs>
    </Member>
    <Member MemberName="HaveResponse">
      <MemberSignature Language="C#" Value="public virtual bool HaveResponse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HaveResponse" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.HaveResponse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se uma resposta foi recebida de um recurso da Internet.</summary>
        <value>
          <see langword="true" /> se uma resposta foi recebida; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte código de exemplo verifica o <xref:System.Net.HttpWebRequest.HaveResponse%2A> propriedade para determinar se uma resposta foi recebida de um recurso da Internet.  
  
 [!code-cpp[Httpwebrequest_HaveResponse#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CPP/httpwebrequest_haveresponse.cpp#1)]
 [!code-csharp[Httpwebrequest_HaveResponse#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/CS/httpwebrequest_haveresponse.cs#1)]
 [!code-vb[Httpwebrequest_HaveResponse#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_HaveResponse/VB/httpwebrequest_haveresponse.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public override System.Net.WebHeaderCollection Headers { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.WebHeaderCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Headers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.WebHeaderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica uma coleção de pares nome/valor que compõem os cabeçalhos HTTP.</summary>
        <value>Um <see cref="T:System.Net.WebHeaderCollection" /> que contém os pares nome/valor que compõem os cabeçalhos da solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Headers%2A> coleção contém cabeçalhos de protocolo associados à solicitação. A tabela a seguir lista os cabeçalhos HTTP que não são armazenados no <xref:System.Net.HttpWebRequest.Headers%2A> coleção mas são definido pelo sistema ou definido por propriedades ou métodos.  
  
|Cabeçalho|Definido pelo|  
|------------|------------|  
|Aceitar|Definida pelo <xref:System.Net.HttpWebRequest.Accept%2A> propriedade.|  
|Conexão|Definida pelo <xref:System.Net.HttpWebRequest.Connection%2A> propriedade e <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade.|  
|Tamanho do conteúdo|Definida pelo <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade.|  
|Tipo de conteúdo|Definida pelo <xref:System.Net.HttpWebRequest.ContentType%2A> propriedade.|  
|Esperar|Definida pelo <xref:System.Net.HttpWebRequest.Expect%2A> propriedade.|  
|Date|Definida pelo <xref:System.Net.HttpWebRequest.Date%2A> propriedade.|  
|Host|Definida pelo <xref:System.Net.HttpWebRequest.Host%2A> propriedade.|  
|If-Modified-Since|Definida pelo <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade.|  
|Intervalo|Definida pelo <xref:System.Net.HttpWebRequest.AddRange%2A> método.|  
|Referência|Definida pelo <xref:System.Net.HttpWebRequest.Referer%2A> propriedade.|  
|Codificação de transferência|Definida pelo <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade (o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade deve ser true).|  
|Agente do usuário|Definida pelo <xref:System.Net.HttpWebRequest.UserAgent%2A> propriedade.|  
  
 O <xref:System.Net.WebHeaderCollection.Add%2A> método lança um <xref:System.ArgumentException> se você tentar definir um desses cabeçalhos protegido.  
  
 Alterando o <xref:System.Net.HttpWebRequest.Headers%2A> propriedade depois que a solicitação foi iniciada chamando <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>.  
  
 Você não deve presumir que os valores de cabeçalho permanecerá inalterados, porque os caches e servidores Web podem mudar ou adicionar cabeçalhos para uma solicitação da Web.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.Headers%2A> propriedade imprimir os pares de nome/valor do cabeçalho HTTP para o console.  
  
 [!code-cpp[HttpWebRequest_Headers#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Headers/CPP/httpwebrequest_headers.cpp#1)]
 [!code-csharp[HttpWebRequest_Headers#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Headers/CS/httpwebrequest_headers.cs#1)]
 [!code-vb[HttpWebRequest_Headers#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Headers/VB/httpwebrequest_headers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada chamando o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de cabeçalho do Host a ser usado em uma solicitação HTTP, independente do URI de solicitação.</summary>
        <value>O valor do cabeçalho de Host na solicitação HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Host%2A> propriedade pode ser usada para definir o Host do valor de cabeçalho a ser usado em uma solicitação HTTP independente do URI da solicitação. O <xref:System.Net.HttpWebRequest.Host%2A> propriedade pode consistir em um nome de host e um número de porta opcional. Um cabeçalho de Host sem informações de porta implica a porta padrão para o serviço solicitado (porta 80 para uma URL HTTP, por exemplo).  
  
 O formato para especificar um host e porta deve seguir as regras na seção 14.23 RFC2616 publicada pela IETF. Um exemplo em conformidade com esses requisitos que especifica uma porta 8080 seria o seguinte valor para o <xref:System.Net.HttpWebRequest.Host%2A> propriedade:  
  
 `www.contoso.com:8080`  
  
 Usando o <xref:System.Net.HttpWebRequest.Host%2A> propriedade para especificar explicitamente um valor de cabeçalho de Host personalizado também afeta a áreas de armazenamento em cache, cookies e autenticação. Quando um aplicativo fornece credenciais para um prefixo URI específico, os aplicativos precisa certificar-se de usar o URI que contém o valor do cabeçalho do Host, não no servidor de destino no URI. A chave usada ao armazenar em cache os recursos, usa o valor do cabeçalho de Host em vez de URI de solicitação. Os cookies são armazenados em um <xref:System.Net.CookieContainer> e logicamente agrupados pelo nome de domínio do servidor. Se o aplicativo especificar um cabeçalho de Host, em seguida, esse valor será usado como o domínio.  
  
 Se o <xref:System.Net.HttpWebRequest.Host%2A> propriedade não estiver definida, o valor do cabeçalho de Host a ser usado em uma solicitação HTTP é com base no URI da solicitação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O cabeçalho do Host não pode ser definido como <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O cabeçalho do Host não pode ser definido com um valor inválido.</exception>
        <exception cref="T:System.InvalidOperationException">O cabeçalho do Host não pode ser definido após o <see cref="T:System.Net.HttpWebRequest" /> já ter começado o envio.</exception>
      </Docs>
    </Member>
    <Member MemberName="IfModifiedSince">
      <MemberSignature Language="C#" Value="public DateTime IfModifiedSince { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime IfModifiedSince" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.IfModifiedSince" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="If-Modified-Since" />.</summary>
        <value>Um <see cref="T:System.DateTime" /> que contém o conteúdo do cabeçalho HTTP <see langword="If-Modified-Since" />. O valor padrão é a data e hora atuais.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade é um padrão <xref:System.DateTime?displayProperty=nameWithType> de objeto e pode conter um <xref:System.DateTimeKind?displayProperty=nameWithType> campo de <xref:System.DateTimeKind.Local?displayProperty=nameWithType>, <xref:System.DateTimeKind.Utc?displayProperty=nameWithType>, ou <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType>. Qualquer tipo de tempo pode ser definido ao usar o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade. Se <xref:System.DateTimeKind.Unspecified?displayProperty=nameWithType> está definido ou recuperado, o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade será considerada <xref:System.DateTimeKind.Local?displayProperty=nameWithType> (hora local).  
  
 As classes de <xref:System.Net> namespace sempre grave-os a <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade na conexão durante a transmissão no formulário padrão usando o formato de GMT (Utc).  
  
 Se o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> está definida como <xref:System.DateTime.MinValue?displayProperty=nameWithType>, em seguida, o `If-Modified-Since` cabeçalho HTTP é removido do <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
 Se o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> é de propriedade <xref:System.DateTime.MinValue?displayProperty=nameWithType>, isso indica que o `If-Modified-Since` cabeçalho HTTP não está incluído no <xref:System.Net.HttpWebRequest.Headers%2A> propriedade e o <xref:System.Net.WebHeaderCollection>.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte código de exemplo verifica o <xref:System.Net.HttpWebRequest.IfModifiedSince%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CPP/httpwebrequest_ifmodifiedsince.cpp#1)]
 [!code-csharp[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/CS/httpwebrequest_ifmodifiedsince.cs#1)]
 [!code-vb[HttpWebRequest_IfModifiedSince#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_IfModifiedSince/VB/httpwebrequest_ifmodifiedsince.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public bool KeepAlive { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeepAlive" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.KeepAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se é necessário fazer uma conexão persistente com o recurso da Internet.</summary>
        <value>
          <see langword="true" /> se a solicitação para o recurso de Internet deve conter um cabeçalho HTTP <see langword="Connection" /> com o valor keep-alive; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina essa propriedade como `true` para enviar um `Connection` cabeçalho HTTP com o valor Keep-alive. Um aplicativo usa <xref:System.Net.HttpWebRequest.KeepAlive%2A> para indicar a preferência de conexões persistentes. Quando o <xref:System.Net.HttpWebRequest.KeepAlive%2A> é de propriedade `true`, o aplicativo faz conexões persistentes aos servidores que dão suporte a eles.  
  
> [!NOTE]
>  Ao usar o HTTP/1.1, Keep-Alive está ativado por padrão. Configuração <xref:System.Net.HttpWebRequest.KeepAlive%2A> para `false` pode resultar na enviando um `Connection: Close` cabeçalho para o servidor.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade `false` para evitar o estabelecimento de uma conexão persistente com o recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_Connection#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Connection/CPP/httpwebrequest_connection.cpp#1)]
 [!code-csharp[HttpWebRequest_Connection#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Connection/CS/httpwebrequest_connection.cs#1)]
 [!code-vb[HttpWebRequest_Connection#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Connection/VB/httpwebrequest_connection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumAutomaticRedirections">
      <MemberSignature Language="C#" Value="public int MaximumAutomaticRedirections { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumAutomaticRedirections" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumAutomaticRedirections" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de redirecionamentos que a solicitação segue.</summary>
        <value>O número máximo de respostas de redirecionamento que a solicitação segue. O valor padrão é 50.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.MaximumAutomaticRedirections%2A> propriedade define o número máximo de redirecionamentos de solicitação a seguir se o <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> é de propriedade `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir define o valor dessa propriedade.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor é definido como 0 ou menos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaximumResponseHeadersLength">
      <MemberSignature Language="C#" Value="public int MaximumResponseHeadersLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumResponseHeadersLength" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MaximumResponseHeadersLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Use this")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o comprimento máximo permitido dos cabeçalhos de resposta.</summary>
        <value>O comprimento, em quilobytes (1024 bytes), dos cabeçalhos de resposta.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do cabeçalho de resposta inclui a linha de status de resposta e quaisquer caracteres de controle adicional que são recebidos como parte do protocolo HTTP. Um valor de-1 significa que sem limite é imposto nos cabeçalhos de resposta; um valor de 0 significa que todas as solicitações falharem.  
  
 Se o <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriedade não for explicitamente definida, o padrão é o valor de <xref:System.Net.HttpWebRequest.DefaultMaximumResponseHeadersLength%2A> propriedade.  
  
 Se o tamanho do cabeçalho da resposta recebido excede o valor da <xref:System.Net.HttpWebRequest.MaximumResponseHeadersLength%2A> propriedade, o <xref:System.Net.HttpWebRequest.EndGetResponse%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> métodos lançará um <xref:System.Net.WebException> com o <xref:System.Net.WebException.Status%2A> propriedade definida como <xref:System.Net.WebExceptionStatus.MessageLengthLimitExceeded>.  
  
   
  
## Examples  
 O exemplo de código a seguir define o valor dessa propriedade.  
  
 [!code-cpp[NCLResponse1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLResponse1/CPP/httpwebrequest1.cpp#1)]
 [!code-csharp[NCLResponse1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLResponse1/CS/httpwebrequest1.cs#1)]
 [!code-vb[NCLResponse1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLResponse1/VB/httpwebrequest1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade é definida depois que a solicitação já foi enviada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor é menor que 0 e não é igual a -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="MediaType">
      <MemberSignature Language="C#" Value="public string MediaType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MediaType" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.MediaType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tipo de mídia da solicitação.</summary>
        <value>O tipo de mídia da solicitação. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de <xref:System.Net.HttpWebRequest.MediaType%2A> propriedade afeta o <xref:System.Net.HttpWebResponse.CharacterSet%2A> propriedade. Quando você define o <xref:System.Net.HttpWebRequest.MediaType%2A> na solicitação, o tipo de mídia correspondente é escolhido na lista de conjuntos de caracteres retornados na resposta `Content-type` cabeçalho HTTP.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public override string Method { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Method" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o método para a solicitação.</summary>
        <value>O método de solicitação a ser usado para contatar o recurso de Internet. O valor padrão é GET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Method%2A> propriedade pode ser definida para qualquer um dos verbos de protocolo HTTP 1.1: GET, HEAD, POST, PUT, excluir, rastreamento ou opções.  
  
 Se o <xref:System.Net.HttpWebRequest.ContentLength%2A> propriedade é definida como qualquer valor diferente de -1, o <xref:System.Net.HttpWebRequest.Method%2A> propriedade deve ser definida como uma propriedade do protocolo que carrega dados.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.Method%2A> propriedade POST.  
  
 [!code-cpp[HttpWebRequest_ContentLength#4](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CPP/httpwebrequest_contentlength.cpp#4)]
 [!code-csharp[HttpWebRequest_ContentLength#4](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ContentLength/CS/httpwebrequest_contentlength.cs#4)]
 [!code-vb[HttpWebRequest_ContentLength#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ContentLength/VB/httpwebrequest_contentlength.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nenhum método é fornecido.  
  
 -ou-  
  
 A cadeia de caracteres de método contém caracteres inválidos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pipelined">
      <MemberSignature Language="C#" Value="public bool Pipelined { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Pipelined" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Pipelined" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se deve-se fazer pipeline da solicitação ao recurso de Internet.</summary>
        <value>
          <see langword="true" /> se a solicitação deve ser por pipeline; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo usa o <xref:System.Net.HttpWebRequest.Pipelined%2A> propriedade para indicar a preferência de conexões de pipeline. Quando <xref:System.Net.HttpWebRequest.Pipelined%2A> é `true`, um aplicativo faz conexões com pipelining para os servidores que oferecem suporte a eles.  
  
 Pipeline de conexões é feitas somente quando o <xref:System.Net.HttpWebRequest.KeepAlive%2A> propriedade também é `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir imprime o valor do <xref:System.Net.HttpWebRequest.Pipelined%2A> propriedade para o console.  
  
 [!code-cpp[HttpWebRequest_PipeLined#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CPP/httpwebrequest_pipelined.cpp#1)]
 [!code-csharp[HttpWebRequest_PipeLined#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_PipeLined/CS/httpwebrequest_pipelined.cs#1)]
 [!code-vb[HttpWebRequest_PipeLined#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_PipeLined/VB/httpwebrequest_pipelined.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreAuthenticate">
      <MemberSignature Language="C#" Value="public override bool PreAuthenticate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreAuthenticate" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.PreAuthenticate" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se é necessário enviar um cabeçalho de autorização com a solicitação.</summary>
        <value>
          <see langword="true" /> para enviar um cabeçalho de autorização HTTP com solicitações após a autenticação ser realizada; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de uma solicitação de cliente para um determinado <xref:System.Uri> for autenticado com êxito, se <xref:System.Net.HttpWebRequest.PreAuthenticate%2A> é `true` e as credenciais sejam fornecidas, o cabeçalho de autorização é enviado com cada solicitação para qualquer <xref:System.Uri> que corresponde a específica <xref:System.Uri>até o último barra. Portanto, se a solicitação do cliente é autenticado com êxito para um determinado <xref:System.Uri> que contém o seguinte:  
  
 `http://www.contoso.com/firstpath/`  
  
 O cabeçalho de autorização para pré-autenticação é enviado com cada solicitação para qualquer um dos seguintes <xref:System.Uri> instâncias:  
  
 `http://www.contoso.com/firstpath/`  
  
 `http://www.contoso.com/firstpath/default`  
  
 `http://www.contoso.com/firstpath/default.html`  
  
 `http://www.contoso.com/firstpath/sample.html`  
  
 No entanto, o cabeçalho de autorização não é enviado com solicitações para qualquer um dos seguintes <xref:System.Uri> instâncias:  
  
 `http://www.contoso.com/`  
  
 `http://www.contoso.com/firstpath`  
  
 `http://www.contoso.com/secondpath/`  
  
 Se o cliente a solicitação para um determinado <xref:System.Uri> é autenticado não com êxito, a solicitação usa os procedimentos de autenticação padrão.  
  
 Com exceção da primeira solicitação, o <xref:System.Net.WebRequest.PreAuthenticate%2A> propriedade indica se deseja enviar informações de autenticação com solicitações subsequentes para um <xref:System.Uri> que corresponde a específica <xref:System.Uri> até o último barra sem esperar que o servidor ser um desafio.  
  
 A caixa de diálogo a seguir entre cliente e servidor ilustra o efeito dessa propriedade. A caixa de diálogo pressupõe que a autenticação básica está em uso.  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A>é `false`:  
  
 Cliente: SomeUrl GET  
  
 Servidor: Basic WWW-401 Authenticate  
  
 Cliente: GET com cabeçalhos de autorização  
  
 Servidor: 200 Okey  
  
 Cliente: SomeUrl GET  
  
 Servidor: Basic WWW-401 Authenticate  
  
 Cliente: GET com cabeçalhos de autorização  
  
 Servidor: 200 Okey  
  
 <xref:System.Net.HttpWebRequest.PreAuthenticate%2A>é `true`:  
  
 Cliente: SomeUrl GET  
  
 Servidor: Basic WWW-401 Authenticate  
  
 Cliente: GET com cabeçalhos de autorização  
  
 Servidor: 200 Okey  
  
 Cliente: Obter someUrl com cabeçalhos de autorização  
  
 Se o esquema de autenticação não oferecer suporte a pré-autenticação, o valor dessa propriedade é ignorado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtocolVersion">
      <MemberSignature Language="C#" Value="public Version ProtocolVersion { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version ProtocolVersion" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ProtocolVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a versão do HTTP a ser usada para a solicitação.</summary>
        <value>A versão do HTTP a ser usada para a solicitação. O padrão é <see cref="F:System.Net.HttpVersion.Version11" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest> classe oferece suporte somente para versões 1.0 e 1.1 do HTTP. Definindo <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> para uma versão diferente lança uma exceção.  
  
> [!NOTE]
>  Para definir a versão HTTP da solicitação atual, use o <xref:System.Net.HttpVersion.Version10> e <xref:System.Net.HttpVersion.Version11> campos de <xref:System.Net.HttpVersion> classe.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.ProtocolVersion%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CPP/httpwebrequest_protocolversion.cpp#1)]
 [!code-csharp[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/CS/httpwebrequest_protocolversion.cs#1)]
 [!code-vb[HttpWebRequest_ProtocolVersion#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_ProtocolVersion/VB/httpwebrequest_protocolversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A versão do HTTP é definida como um valor diferente de 1.0 ou 1.1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Proxy">
      <MemberSignature Language="C#" Value="public override System.Net.IWebProxy Proxy { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.IWebProxy Proxy" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Proxy" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.IWebProxy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define informações de proxy da solicitação.</summary>
        <value>O objeto <see cref="T:System.Net.IWebProxy" /> a ser usado para o proxy da solicitação. O valor padrão é definido com a chamada à propriedade <see cref="P:System.Net.GlobalProxySelection.Select" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade identifica o <xref:System.Net.WebProxy> objeto a ser usado para processar solicitações aos recursos da Internet. Para especificar que nenhum proxy deve ser usada, defina o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade para a instância do proxy retornada pelo <xref:System.Net.GlobalProxySelection.GetEmptyWebProxy%2A?displayProperty=nameWithType> método.  
  
 O computador local ou o arquivo de configuração de aplicativo pode especificar que um proxy padrão ser usado. Se o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade for especificada, em seguida, as configurações de proxy do <xref:System.Net.HttpWebRequest.Proxy%2A> o computador local ou o arquivo de configuração do aplicativo de substituição de propriedade e o <xref:System.Net.HttpWebRequest> instância usará as configurações de proxy especificadas. Se nenhum proxy for especificado em um arquivo de configuração e o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade não for especificada, a <xref:System.Net.HttpWebRequest> classe usa as configurações de proxy herdadas do Internet Explorer no computador local. Se não houver nenhuma configuração de proxy no Internet Explorer, a solicitação é enviada diretamente para o servidor.  
  
 O <xref:System.Net.HttpWebRequest> classe analisa uma lista de proxies com caracteres curinga herdada do Internet Explorer o mesmo que a lista de bypass é analisada diretamente pelo Internet Explorer. Por exemplo, o <xref:System.Net.HttpWebRequest> classe analisa uma lista de bypass de "nt *" do Internet Explorer como uma expressão regular "nt.\*". Para uma URL de "`http://nt.com`" ignoram o proxy usando o <xref:System.Net.HttpWebRequest> classe e usando o Internet Explorer.  
  
 O <xref:System.Net.HttpWebRequest> classe dá suporte ao desvio de proxy local. A classe considera um destino local se qualquer uma das seguintes condições forem atendidas:  
  
-   O destino contém um nome simples (sem pontos na URL).  
  
-   O destino contém um endereço de loopback (<xref:System.Net.IPAddress.Loopback> ou <xref:System.Net.IPAddress.IPv6Loopback>) ou o destino contém um <xref:System.Net.IPAddress> atribuído ao computador local.  
  
-   O sufixo do domínio de destino corresponde o sufixo do domínio do computador local (<xref:System.Net.NetworkInformation.IPGlobalProperties.DomainName%2A>).  
  
 Alterando o <xref:System.Net.HttpWebRequest.Proxy%2A> propriedade depois que a solicitação foi iniciada chamando o <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>. Para obter informações sobre o elemento de proxy, consulte [ \&lt; defaultProxy\&gt; (Configurações de rede) do elemento](~/docs/framework/configure-apps/file-schema/network/defaultproxy-element-network-settings.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Net.HttpWebRequest.Proxy%2A> método para obter as informações de proxy para a solicitação.  
  
 [!code-cpp[Httpwebrequest_proxy#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Httpwebrequest_proxy/CPP/httpwebrequest_proxy.cpp#1)]
 [!code-csharp[Httpwebrequest_proxy#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Httpwebrequest_proxy/CS/httpwebrequest_proxy.cs#1)]
 [!code-vb[Httpwebrequest_proxy#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Httpwebrequest_proxy/VB/httpwebrequest_proxy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <see cref="P:System.Net.HttpWebRequest.Proxy" /> é definido como <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada com a chamada a <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem permissão para a operação solicitada.</exception>
        <permission cref="T:System.Net.WebPermission">Para obter ou definir o <see cref="P:System.Net.HttpWebRequest.Proxy" /> propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadWriteTimeout">
      <MemberSignature Language="C#" Value="public int ReadWriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadWriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ReadWriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um tempo limite em milissegundos ao gravar ou ler de um fluxo.</summary>
        <value>O número de milissegundos antes da gravação ou leitura expirar. O valor padrão é 300.000 milissegundos (5 minutos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade é usada ao gravar o fluxo retornado pelo <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método ou ler o fluxo retornado pelo <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método.  
  
 Especificamente, o <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade controla o tempo limite para o <xref:System.IO.Stream.Read%2A> método, que é usado para ler o fluxo retornado pelo <xref:System.Net.HttpWebResponse.GetResponseStream%2A> método e para o <xref:System.IO.Stream.Write%2A> método, que é usado para gravar o fluxo retornado pelo <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método.  
  
 Para especificar a quantidade de tempo de espera para concluir a solicitação, use o <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como definir o <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade.  
  
 [!code-csharp[Classic HttpWebRequest Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest Example/CS/source.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação já foi enviada.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor ou igual a zero e é diferente de <see cref="F:System.Threading.Timeout.Infinite" /></exception>
      </Docs>
    </Member>
    <Member MemberName="Referer">
      <MemberSignature Language="C#" Value="public string Referer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Referer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Referer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Referer" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Referer" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Net.HttpWebRequest.AllowAutoRedirect%2A> é de propriedade `true`, o <xref:System.Net.HttpWebRequest.Referer%2A> propriedade é definida automaticamente quando a solicitação é redirecionada para outro site.  
  
 Para limpar o `Referer` cabeçalho HTTP, defina o <xref:System.Net.HttpWebRequest.Referer%2A> propriedade `null`.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.Referer%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_Referer#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Referer/CPP/httpwebrequest_referer.cpp#1)]
 [!code-csharp[HttpWebRequest_Referer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Referer/CS/httpwebrequest_referer.cs#1)]
 [!code-vb[HttpWebRequest_Referer#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Referer/VB/httpwebrequest_referer.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestUri">
      <MemberSignature Language="C#" Value="public override Uri RequestUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri RequestUri" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.RequestUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI (Uniform Resource Identifier) original da solicitação.</summary>
        <value>Um <see cref="T:System.Uri" /> que contém o URI do recurso da Internet passado para o método <see cref="M:System.Net.WebRequest.Create(System.String)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri> objeto passado para <xref:System.Net.HttpWebRequest> pela chamada para <xref:System.Net.WebRequest.Create%2A?displayProperty=nameWithType>.  
  
 A seguir um redirecionamento de cabeçalho não altera o <xref:System.Net.HttpWebRequest.RequestUri%2A> propriedade. Para obter o URI real que respondeu à solicitação, examine o <xref:System.Net.HttpWebRequest.Address%2A> propriedade.  
  
   
  
## Examples  
 O seguinte código de exemplo verifica se o <xref:System.Net.HttpWebRequest> objeto `req` foi redirecionado para outro local para atender à solicitação e define o valor da `hasChanged` variável para `true` se a solicitação foi redirecionada; caso contrário, `hasChanged` é definido como `false`.  
  
 [!code-cpp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/CS/source.cs#1)]
 [!code-vb[Classic HttpWebRequest.RequestUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic HttpWebRequest.RequestUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SendChunked">
      <MemberSignature Language="C#" Value="public bool SendChunked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SendChunked" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SendChunked" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se é necessário enviar os dados em segmentos para o recurso da Internet.</summary>
        <value>
          <see langword="true" /> para enviar dados para o recurso da Internet em segmentos; caso contrário, <see langword="false" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Net.HttpWebRequest.SendChunked%2A> é `true`, a solicitação envia dados para o recurso de Internet em segmentos. O recurso de Internet deve dar suporte a receber dados em partes.  
  
 Alterando o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade depois que a solicitação foi iniciada chamando o <xref:System.Net.HttpWebRequest.GetRequestStream%2A>, <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A>, <xref:System.Net.HttpWebRequest.GetResponse%2A>, ou <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método lança um <xref:System.InvalidOperationException>.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade `true` para que os dados podem ser enviados em segmentos para o recurso de Internet.  
  
 [!code-cpp[HttpWebRequest_SendChunked#2](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CPP/httpwebrequest_sendchunked.cpp#2)]
 [!code-csharp[HttpWebRequest_SendChunked#2](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_SendChunked/CS/httpwebrequest_sendchunked.cs#2)]
 [!code-vb[HttpWebRequest_SendChunked#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_SendChunked/VB/httpwebrequest_sendchunked.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A solicitação foi iniciada chamando o método <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />, <see cref="M:System.Net.HttpWebRequest.BeginGetRequestStream(System.AsyncCallback,System.Object)" />, <see cref="M:System.Net.HttpWebRequest.GetResponse" /> ou <see cref="M:System.Net.HttpWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ServerCertificateValidationCallback">
      <MemberSignature Language="C#" Value="public System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Security.RemoteCertificateValidationCallback ServerCertificateValidationCallback" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServerCertificateValidationCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Security.RemoteCertificateValidationCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma função de retorno de chamada para validar o certificado do servidor.</summary>
        <value>Uma função de retorno de chamada para validar o certificado do servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O padrão é que nenhuma função de retorno de chamada é definida e o <xref:System.Net.HttpWebRequest.ServerCertificateValidationCallback%2A> é de propriedade `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ServicePoint">
      <MemberSignature Language="C#" Value="public System.Net.ServicePoint ServicePoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.ServicePoint ServicePoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.ServicePoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.ServicePoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o ponto de serviço a ser usado para a solicitação.</summary>
        <value>Um <see cref="T:System.Net.ServicePoint" /> que representa a conexão de rede para o recurso de Internet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.ServicePoint.Address%2A?displayProperty=nameWithType> propriedade pode ser diferente de <xref:System.Net.HttpWebRequest.Address%2A?displayProperty=nameWithType> se a solicitação é redirecionada.  
  
   
  
## Examples  
 [!code-cpp[System.Net.ServicePoint#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.ServicePoint/CPP/servicepoint.cpp#6)]
 [!code-csharp[System.Net.ServicePoint#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.ServicePoint/CS/servicepoint.cs#6)]
 [!code-vb[System.Net.ServicePoint#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.ServicePoint/VB/servicepoint.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsCookieContainer">
      <MemberSignature Language="C#" Value="public virtual bool SupportsCookieContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsCookieContainer" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.SupportsCookieContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a solicitação fornece suporte para um <see cref="T:System.Net.CookieContainer" />.</summary>
        <value>
          <see langword="true" />Se a solicitação fornece suporte para um <see cref="T:System.Net.CookieContainer" />; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.HttpWebRequest.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">O <see cref="T:System.Runtime.Serialization.SerializationInfo" /> a ser preenchido com dados.</param>
        <param name="streamingContext">Um <see cref="T:System.Runtime.Serialization.StreamingContext" /> que especifica o destino dessa serialização.</param>
        <summary>Popula um <see cref="T:System.Runtime.Serialization.SerializationInfo" /> com os dados necessários para serializar o objeto de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os objetos incluídos no <xref:System.Runtime.Serialization.SerializationInfo> automaticamente são rastreadas e serializado pelo formatador.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Timeout">
      <MemberSignature Language="C#" Value="public override int Timeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Timeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.Timeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de tempo limite em milissegundos para os métodos <see cref="M:System.Net.HttpWebRequest.GetResponse" /> e <see cref="M:System.Net.HttpWebRequest.GetRequestStream" />.</summary>
        <value>O número de milissegundos de espera antes que a solicitação atinja o tempo limite. O valor padrão é 100.000 milissegundos (100 segundos).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.HttpWebRequest.Timeout%2A>é o número de milissegundos que uma solicitação síncrona subsequente feita com o <xref:System.Net.HttpWebRequest.GetResponse%2A> método aguarda uma resposta e o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> método aguarda um fluxo. O <xref:System.Net.HttpWebRequest.Timeout%2A> se aplica a toda solicitação e resposta, não individualmente para o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> e <xref:System.Net.HttpWebRequest.GetResponse%2A> chamadas de método. Se o recurso não é retornado dentro do período de tempo limite, a solicitação gerará uma <xref:System.Net.WebException> com o <xref:System.Net.WebException.Status%2A> propriedade definida como <xref:System.Net.WebExceptionStatus.Timeout?displayProperty=nameWithType>.  
  
 O <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade deve ser definida antes do <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> método é chamado. Alterando o <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade depois de chamar o <xref:System.Net.HttpWebRequest.GetRequestStream%2A> ou <xref:System.Net.HttpWebRequest.GetResponse%2A> método não tem nenhum efeito  
  
 O <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade não tem efeito sobre solicitações assíncronas feitas com o <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> ou <xref:System.Net.HttpWebRequest.BeginGetRequestStream%2A> método.  
  
> [!CAUTION]
>  No caso de solicitações assíncronas, o aplicativo cliente implementa seu próprio mecanismo de tempo limite. Consulte o exemplo de <xref:System.Net.HttpWebRequest.BeginGetResponse%2A> método.  
  
 Para especificar a quantidade de tempo a aguardar antes de uma leitura ou gravação operação expire, use o <xref:System.Net.HttpWebRequest.ReadWriteTimeout%2A> propriedade.  
  
 Uma consulta de sistema de nome de domínio (DNS) pode levar até 15 segundos para retornar ou tempo limite. Se a solicitação contém um nome de host que requer que a resolução e definir <xref:System.Net.FileWebRequest.Timeout%2A> para um valor menor que 15 segundos, pode levar 15 segundos ou mais antes de um <xref:System.Net.WebException> é gerada para indicar um tempo limite em sua solicitação.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.Timeout%2A> propriedade o <xref:System.Net.HttpWebRequest> objeto.  
  
 [!code-cpp[HttpWebRequest_Timeout#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CPP/httpwebrequest_timeout.cpp#1)]
 [!code-csharp[HttpWebRequest_Timeout#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_Timeout/CS/httpwebrequest_timeout.cs#1)]
 [!code-vb[HttpWebRequest_Timeout#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_Timeout/VB/httpwebrequest_timeout.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado é menor que zero e não é <see cref="F:System.Threading.Timeout.Infinite" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TransferEncoding">
      <MemberSignature Language="C#" Value="public string TransferEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TransferEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.TransferEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="Transfer-encoding" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="Transfer-encoding" />. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Antes de configurar o <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade, você deve primeiro definir a <xref:System.Net.HttpWebRequest.SendChunked%2A> propriedade `true`. Limpando <xref:System.Net.HttpWebRequest.TransferEncoding%2A> definindo-a como `null` não tem efeito sobre o valor de <xref:System.Net.HttpWebRequest.SendChunked%2A>.  
  
 Os valores atribuídos para a <xref:System.Net.HttpWebRequest.TransferEncoding%2A> propriedade substituir qualquer conteúdo existente.  
  
> [!NOTE]
>  O valor dessa propriedade é armazenado em <xref:System.Net.WebHeaderCollection>. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido quando <see cref="P:System.Net.HttpWebRequest.SendChunked" /> é <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Net.HttpWebRequest.TransferEncoding" /> é definido como o valor "Em bloco".</exception>
      </Docs>
    </Member>
    <Member MemberName="UnsafeAuthenticatedConnectionSharing">
      <MemberSignature Language="C#" Value="public bool UnsafeAuthenticatedConnectionSharing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UnsafeAuthenticatedConnectionSharing" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se deve ser permitido o compartilhamento de conexão de alta velocidade autenticado por NTLM.</summary>
        <value>
          <see langword="true" /> para manter a conexão autenticada aberta, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão dessa propriedade é `false`, que faz com que a conexão atual a ser fechada depois que uma solicitação é concluída. Seu aplicativo deve percorrer a sequência de autenticação toda vez que ele emite uma nova solicitação.  
  
 Se essa propriedade é definida como `true`, a conexão usada para recuperar a resposta permanece aberta após a autenticação foi executada. Nesse caso, outras solicitações que têm esta propriedade definida como `true` podem usar a conexão sem autenticar novamente. Em outras palavras, se uma conexão foi autenticado para o usuário A, usuário B pode reutilizar uma conexão; solicitação do usuário B é atendida com base nas credenciais do usuário A.  
  
> [!CAUTION]
>  Como é possível que um aplicativo para usar a conexão sem autenticação, é necessário certificar-se de que não há nenhuma vulnerabilidade administrativa em seu sistema ao definir essa propriedade como `true`. Se seu aplicativo envia solicitações para vários usuários (representa várias contas de usuário) e se baseia na autenticação para proteger recursos, não defina essa propriedade como `true` , a menos que você use grupos de conexão, conforme descrito abaixo.  
  
 Você talvez queira considerar a habilitação desse mecanismo, se seu está tendo problemas de desempenho e seu aplicativo é executado em um servidor Web com autenticação integrada do Windows.  
  
 Habilitar essa configuração, o sistema quanto a riscos de segurança é aberta. Se você definir o <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> propriedade `true` Certifique-se de tomar as seguintes precauções:  
  
-   Use o <xref:System.Net.HttpWebRequest.ConnectionGroupName%2A> propriedade para gerenciar conexões para usuários diferentes. Isso evita o uso potencial da conexão por aplicativos não-autenticadas. Por exemplo, o usuário deve ter um nome de grupo de conexão exclusiva que é diferente do usuário B. Isso fornece uma camada de isolamento para cada conta de usuário.  
  
-   Execute o aplicativo em um ambiente protegido para ajudar a evitar explorações de conexão possíveis.  
  
 Se você controlar o servidor de back-end, como alternativa você pode considerar a desativação de persistência de autenticação. Isso aumenta o desempenho em um nível menor, mas é mais seguro. Para obter mais detalhes, procure AuthPersistence na biblioteca MSDN em [http://msdn.microsoft.com/library](http://msdn.microsoft.com/library).  
  
> [!NOTE]
>  Se ambos os <xref:System.Net.WebRequest.PreAuthenticate%2A> e <xref:System.Net.HttpWebRequest.UnsafeAuthenticatedConnectionSharing%2A> são definidos como `true`, cada solicitação é enviada usando uma conexão do pool não seguro, mas com um cabeçalho de autorização.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Net.WebPermission">Permissão de Web irrestrito é necessária para definir essa propriedade.</permission>
      </Docs>
    </Member>
    <Member MemberName="UseDefaultCredentials">
      <MemberSignature Language="C#" Value="public override bool UseDefaultCredentials { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseDefaultCredentials" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UseDefaultCredentials" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que controla se as credenciais padrão são enviadas com solicitações.</summary>
        <value>
          <see langword="true" /> se as credenciais padrão forem usadas; caso contrário, <see langword="false" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina essa propriedade como `true` quando solicitações feitas por essa <xref:System.Net.HttpWebRequest> objeto, se solicitado pelo servidor, forem autenticado usando as credenciais do usuário conectado no momento. Para aplicativos cliente, esse é o comportamento desejado na maioria dos cenários. Para aplicativos de camada intermediária, como aplicativos do ASP.NET, em vez de usar essa propriedade, você normalmente definirá o <xref:System.Net.HttpWebRequest.Credentials%2A> propriedade para as credenciais do cliente em cujo nome a solicitação é feita.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Você tentou definir essa propriedade depois que a solicitação foi enviada.</exception>
      </Docs>
    </Member>
    <Member MemberName="UserAgent">
      <MemberSignature Language="C#" Value="public string UserAgent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserAgent" />
      <MemberSignature Language="DocId" Value="P:System.Net.HttpWebRequest.UserAgent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Requests</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor do cabeçalho HTTP <see langword="User-agent" />.</summary>
        <value>O valor do cabeçalho HTTP <see langword="User-agent" />. O valor padrão é <see langword="null" />.  
  
 <block subset="none" type="note"><para>  
 O valor dessa propriedade é armazenado em <see cref="T:System.Net.WebHeaderCollection" />. Se WebHeaderCollection for definido, o valor da propriedade será perdido.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.HttpWebRequest.UserAgent%2A> propriedade.  
  
 [!code-cpp[HttpWebRequest_UserAgent#1](~/samples/snippets/cpp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CPP/httpwebrequest_useragent.cpp#1)]
 [!code-csharp[HttpWebRequest_UserAgent#1](~/samples/snippets/csharp/VS_Snippets_Remoting/HttpWebRequest_UserAgent/CS/httpwebrequest_useragent.cs#1)]
 [!code-vb[HttpWebRequest_UserAgent#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/HttpWebRequest_UserAgent/VB/httpwebrequest_useragent.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
