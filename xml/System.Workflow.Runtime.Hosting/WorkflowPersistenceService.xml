<Type Name="WorkflowPersistenceService" FullName="System.Workflow.Runtime.Hosting.WorkflowPersistenceService">
  <TypeSignature Language="C#" Value="public abstract class WorkflowPersistenceService : System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WorkflowPersistenceService extends System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Workflow.Runtime.Hosting.WorkflowRuntimeService</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A classe base abstrata da qual persistência de todos os serviços são derivados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Quando certas condições ocorrem enquanto o fluxo de trabalho está em execução, o mecanismo de tempo de execução do fluxo de trabalho mantém informações de estado sobre a instância de fluxo de trabalho. Persistência pode ocorrer, por exemplo, quando concluído uma transação atômica, quando a instância de fluxo de trabalho ficar ociosa, quando o host chama <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType> na instância do fluxo de trabalho, ou quando uma instância de fluxo de trabalho é encerrada ou termina. Quando a semântica de mecanismo de tempo de execução do fluxo de trabalho determinarem que persistência deve ocorrer, o mecanismo de tempo de execução do fluxo de trabalho chama métodos que são fornecidos por um serviço de persistência para salvar as informações de estado sobre a instância de fluxo de trabalho. Da mesma forma, quando o mecanismo de tempo de execução do fluxo de trabalho precisa restaurar uma instância de fluxo de trabalho persistentes anteriormente, ele chama os métodos que são fornecidos pelo serviço de persistência para carregar essas informações de estado. O mecanismo de tempo de execução do fluxo de trabalho manipula toda a semântica sobre quando a persistência será executada. O serviço de persistência trata realmente salvar e carregar as informações de estado de fluxo de trabalho para ou de um repositório de dados.  
  
 Você pode criar um serviço de persistência derivando uma classe a partir de <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> classe.  Você pode adicionar o serviço de persistência para o mecanismo de tempo de execução do fluxo de trabalho chamando <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> ou fazendo uma entrada apropriada no arquivo de configuração do aplicativo. O <xref:System.Workflow.Runtime.WorkflowRuntime> deve conter apenas um serviço de persistência. O Windows Workflow Foundation fornece o <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> classe, um serviço de persistência de fora da caixa, que pode ser usado como está ou estender.  
  
 O mecanismo de tempo de execução do fluxo de trabalho tem semântica de bloqueio de informações de estado de fluxo de trabalho para uso em ambientes onde os serviços de persistência que são executados em diferentes processos podem ter acesso a um único repositório de dados. O <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> classe fornece a capacidade de oferecer suporte essa funcionalidade do mecanismo de tempo de execução do fluxo de trabalho, fornecendo um parâmetro para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> que especifica se as informações de estado de uma instância de fluxo de trabalho devem ser desbloqueadas no repositório de dados e fornecendo um método <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> desbloquear anteriormente bloqueada informações de estado de fluxo de trabalho. Em um serviço de persistência que implementa o bloqueio, uma chamada para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> deve bloquear as informações de estado para uma instância de fluxo de trabalho.  
  
 O serviço de persistência deve lançar um <xref:System.Workflow.Runtime.Hosting.PersistenceException> se ele falhar ao salvar as informações de estado para seu repositório de dados ou carregar informações de estado do seu repositório de dados. O mecanismo de tempo de execução do fluxo de trabalho espera que esse comportamento.  
  
 Um mecanismo de envio em lote é fornecido para serviços que usam um armazenamento durável para salvar as informações de estado de fluxo de trabalho. É importante para manter a consistência entre o armazenamento durável que é usado pelo serviço de persistência e o estado interno do mecanismo de tempo de execução do fluxo de trabalho nesses casos. Você pode adicionar funcionalidade definida pelo <xref:System.Workflow.Runtime.IPendingWork> interface para o serviço e, em seguida, participar de lotes de transações de fluxo de trabalho fornecida pelo <xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> adicionando as alterações para o repositório de dados como itens de trabalho para o <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. O armazenamento durável em si deve implementar a <xref:System.Transactions.IEnlistmentNotification> de interface, para que as informações de fluxo de trabalho não são mantidas incorretamente no caso de uma reversão de transação. Para obter mais informações, consulte <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity%2A> ou <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowPersistenceService ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Quando implementada em uma classe derivada, inicializa uma nova instância do <see cref="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" /> classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma instância do `SqlWorkflowPersistenceService` classe (derivado de `WorkflowPersistenceService`). Este exemplo é da amostra do SDK de manipuladores de exceção aninhados, da classe Program.cs.  Para obter mais informações, consulte o [exemplo de manipuladores de exceção aninhados](http://msdn.microsoft.com/en-us/d1da0209-842b-41c8-9b7c-0cbaa1034265).  
  
 [!code-csharp[WF_Samples#161](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#161)]
 [!code-vb[WF_Samples#161](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static byte[] GetDefaultSerializedForm (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig unsigned int8[] GetDefaultSerializedForm(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">O <see cref="T:System.Workflow.ComponentModel.Activity" /> cujo formato serializado é solicitado.</param>
        <summary>Recupera a forma padrão serializado do <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
        <returns>Formato serializado padrão a <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsBlocked">
      <MemberSignature Language="C#" Value="protected static bool GetIsBlocked (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool GetIsBlocked(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Indica se a atividade especificada está bloqueada.</summary>
        <returns>
          <see langword="true" />Se a atividade especificada é bloqueada. Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSuspendOrTerminateInfo">
      <MemberSignature Language="C#" Value="protected static string GetSuspendOrTerminateInfo (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig string GetSuspendOrTerminateInfo(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Recupera o encerramento ou suspender as informações de cada atividade.</summary>
        <returns>Um <see cref="T:System.String" /> que contém o encerramento ou suspender informações.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowStatus">
      <MemberSignature Language="C#" Value="protected static System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig valuetype System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Recupera o status do fluxo de trabalho.</summary>
        <returns>Um <see cref="T:System.Workflow.Runtime.WorkflowStatus" /> valor de enumeração que indica o status do fluxo de trabalho.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected abstract System.Workflow.ComponentModel.Activity LoadCompletedContextActivity (Guid scopeId, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadCompletedContextActivity(valuetype System.Guid scopeId, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity(System.Guid,System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeId" Type="System.Guid" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="scopeId">O <see cref="T:System.Guid" /> do escopo concluído.</param>
        <param name="outerActivity">Um <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa a atividade que inclui o escopo concluído.</param>
        <summary>Quando implementada em uma classe derivada, carrega o escopo concluído especificado novamente na memória.</summary>
        <returns>Um <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa o escopo concluído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O mecanismo de tempo de execução do fluxo de trabalho usa <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> para implementar a compensação. Você deve restaurar uma cópia idêntica do escopo concluído. Para fazer isso, você deve restaurar válido <xref:System.IO.Stream> em sua representação do escopo completo dos dados de armazenamento. Em seguida, você deve passar isso <xref:System.IO.Stream> para um dos métodos sobrecarregados do <xref:System.Workflow.ComponentModel.Activity.Load%2A> para executar a desserialização do escopo.  
  
 Se o serviço de persistência não pode carregar o escopo concluído do seu repositório de dados, ela deve gerar um <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem apropriada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação de `LoadCompletedContextActivity` método. Este exemplo é do exemplo do serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected abstract System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState(System.Guid)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">O <see cref="T:System.Guid" /> da atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Quando implementada em uma classe derivada, carrega o estado especificado da instância de fluxo de trabalho de volta na memória.</summary>
        <returns>Um <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa a atividade de raiz da instância do fluxo de trabalho.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve restaurar uma cópia idêntica da atividade. Para fazer isso, você deve restaurar válido <xref:System.IO.Stream> de sua representação da instância do fluxo de trabalho no repositório de dados; em seguida, você deve passar isso <xref:System.IO.Stream> para um dos sobrecarregados <xref:System.Workflow.ComponentModel.Activity.Load%2A> estado da instância de métodos para desserializar o fluxo de trabalho. Se o serviço de persistência não pode carregar o estado da instância de fluxo de trabalho do seu repositório de dados, ela deve gerar um <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem apropriada.  
  
 O mecanismo de tempo de execução do fluxo de trabalho implementa a semântica de bloqueio para restringir o acesso a um estado de instância de fluxo de trabalho é salvo em um repositório de dados. Isso pode ser acessado por serviços de persistência que são executados em vários processos. A semântica de bloqueio é projetada para impedir que os serviços de persistência que são executados em dois processos diferentes de carregar a mesma instância de fluxo de trabalho na memória ao mesmo tempo. Dependendo do tipo de ambiente que o serviço de persistência é projetado para oferecer suporte, você pode optar por suportam esta funcionalidade. Se você escolher para dar suporte a semântica de bloqueio de tempo de execução, e se esse fluxo de trabalho de instância de estado foi bloqueado anteriormente por outro processo, você deve lançar uma <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Caso contrário, você deve bloquear o acesso para o estado da instância de fluxo de trabalho no seu repositório de dados. O estado da instância de fluxo de trabalho pode ser desbloqueado por uma chamada para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> ou uma chamada para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> com o parâmetro de desbloqueio definido como `true`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação de `LoadWorkflowInstanceState` método. Este exemplo é do exemplo do serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#266](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#266)]
 [!code-vb[WF_Samples#266](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#266)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFromDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm (byte[] activityBytes, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm(unsigned int8[] activityBytes, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm(System.Byte[],System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityBytes" Type="System.Byte[]" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activityBytes">O formato serializado do <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <param name="outerActivity">Externa <see cref="T:System.Workflow.ComponentModel.Activity" />, que contém o <see cref="T:System.Workflow.ComponentModel.Activity" /> para restaurar.</param>
        <summary>Restaura o <see cref="T:System.Workflow.ComponentModel.Activity" /> de sua forma serializada.</summary>
        <returns>Restaurado <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra uma implementação de `RestoreFromDefaultSerializedForm` método. Este exemplo é do exemplo do serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected abstract void SaveCompletedContextActivity (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveCompletedContextActivity(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">Um <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa o escopo concluído.</param>
        <summary>Quando implementada em uma classe derivada, salva o escopo concluído especificado em um repositório de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O mecanismo de tempo de execução do fluxo de trabalho salva o estado de atividades de escopo concluído para implementar a compensação. Você deve chamar um dos sobrecarregados <xref:System.Workflow.ComponentModel.Activity.Save%2A> métodos para serializar `activity` em uma <xref:System.IO.Stream>; você pode optar por processar além do <xref:System.IO.Stream> antes de gravá-la em seu armazenamento de dados. No entanto, quando o mecanismo de tempo de execução do fluxo de trabalho chama <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A>, você deve restaurar uma cópia idêntica da atividade.  
  
 Você deve ser capaz de associar o escopo concluído com a instância de fluxo de trabalho delimitador para marcar o escopo como desnecessários em seu armazenamento de dados quando a instância de fluxo de trabalho for concluída ou terminada. Portanto, você também deve salvar o <xref:System.Guid> da instância de fluxo de trabalho que está associada com o escopo concluído; isso pode ser obtido o <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> propriedade do <xref:System.Workflow.Runtime.WorkflowInstance> associado `activity`.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A>usa o <xref:System.Guid> do escopo concluído como um parâmetro. Portanto, você também deve salvar o <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ContextGuid%2A> propriedade associada `activity`. Essa propriedade pode ser referenciada por meio de <xref:System.Workflow.ComponentModel.Activity.ActivityContextGuidProperty> campo de `activity`.  
  
 Se você estiver implementando um serviço de persistência que usa um armazenamento durável, para manter a consistência com o estado interno do mecanismo de tempo de execução de fluxo de trabalho, você deve participar de transações de fluxo de trabalho em lotes para adiar a gravação real para o repositório durável até o ponto de uma confirmação do fluxo de trabalho. Para participar do processamento em lotes, adicionar um item de trabalho para o <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> propriedade que representa as alterações pendentes no banco de dados e implementa o <xref:System.Workflow.Runtime.IPendingWork> interface em seu serviço de persistência.  
  
 Se você não pode salvar o escopo concluído para o repositório de dados, você deve lançar uma <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem de erro apropriado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação de `SaveCompletedContextActivity` método. Este exemplo é do exemplo do serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#268](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#268)]
 [!code-vb[WF_Samples#268](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#268)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected abstract void SaveWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity, bool unlock);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity, bool unlock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState(System.Workflow.ComponentModel.Activity,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
        <Parameter Name="unlock" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <param name="unlock">
          <see langword="true" /> se a instância de fluxo de trabalho não deve ser bloqueada; <see langword="false" /> se a instância de fluxo de trabalho deve ser bloqueada.</param>
        <summary>Quando implementado em uma classe derivada, salva o estado da instância de fluxo de trabalho em um armazenamento de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar um dos sobrecarregados <xref:System.Workflow.ComponentModel.Activity.Save%2A> métodos para serializar `rootActivity` em um <xref:System.IO.Stream>. Você pode optar por processar adicionalmente a <xref:System.IO.Stream> antes de gravá-la em seu armazenamento de dados. No entanto, quando o mecanismo de tempo de execução do fluxo de trabalho chama <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A>, você deve restaurar uma cópia idêntica de atividade raiz. Se você não pode salvar o estado da instância de fluxo de trabalho para o repositório de dados, você deve lançar uma <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem de erro apropriado.  
  
 O mecanismo de tempo de execução do fluxo de trabalho fornece a semântica de bloqueio para restringir o acesso a um estado de instância de fluxo de trabalho é salvo no repositório de dados. Isso pode ser acessado pelos serviços de persistência em execução em vários hosts e apontando para o mesmo armazenamento de dados. A semântica de bloqueio é projetada para impedir que os serviços de persistência que são executados em dois tempos de execução do fluxo de trabalho diferentes de carregar a mesma instância de fluxo de trabalho na memória ao mesmo tempo. Dependendo do tipo de ambiente de que seu serviço de persistência é projetado para oferecer suporte, você pode optar por suportam esta funcionalidade. Se você escolher para dar suporte a semântica de bloqueio de tempo de execução, então, se um serviço de persistência tenta salvar o estado de instância de fluxo de trabalho que foi previamente bloqueado por outro serviço de persistência, você deve lançar uma <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Se `unlock` é `true`, você deve desbloquear o acesso para o estado da instância de fluxo de trabalho depois que você salvá-lo.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A>usa o <xref:System.Guid> da instância do fluxo de trabalho como um parâmetro. Portanto, você deve salvar este <xref:System.Guid>. Você também pode usar isso <xref:System.Guid> para associar a instância de fluxo de trabalho com os estados salvos dos escopos concluídos. Você deve fazer isso porque você deve ser capaz de marcar os escopos concluídos como desnecessários quando a instância de fluxo de trabalho seja concluída.  
  
 As chamadas de mecanismo de tempo de execução do fluxo de trabalho <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> uma última vez em que a instância de fluxo de trabalho é concluída ou terminada. Portanto, se <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus%2A> é igual a <xref:System.Workflow.Runtime.WorkflowStatus.Completed> ou <xref:System.Workflow.Runtime.WorkflowStatus.Terminated>, você pode excluir com segurança a instância de fluxo de trabalho e todos os seus escopos concluídos associados de seu repositório de dados. Como alternativa, você pode assinar o <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> ou <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> eventos para determinar quando ele é seguro excluir registros associados à instância de fluxo de trabalho. Se você realmente excluir os registros de seu repositório de dados depende de sua implementação.  
  
 Se você implementar um serviço de persistência que usa um armazenamento durável, em seguida, para manter a consistência com o estado interno do mecanismo de tempo de execução de fluxo de trabalho, você deve participar de transações de fluxo de trabalho em lotes para adiar a gravação real para o repositório durável até o ponto de uma confirmação do fluxo de trabalho. Para participar do processamento em lotes, adicionar um item de trabalho que representa as alterações pendentes para o armazenamento durável para o <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> propriedade e implementar o <xref:System.Workflow.Runtime.IPendingWork> interface em seu serviço de persistência.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação de `SaveWorkflowInstanceState` método. Este exemplo é do exemplo do serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#264](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#264)]
 [!code-vb[WF_Samples#264](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#264)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadOnIdle">
      <MemberSignature Language="C#" Value="protected abstract bool UnloadOnIdle (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool UnloadOnIdle(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">Um <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa o escopo concluído.</param>
        <summary>Determina se um fluxo de trabalho deve ser descarregado quando ocioso.</summary>
        <returns>Se <see langword="true" />, o mecanismo de tempo de execução do fluxo de trabalho descarrega o fluxo de trabalho especificado quando ele estiver ocioso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra uma implementação de `UnloadOnIdle` método. Este exemplo é do exemplo do serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#270](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#270)]
 [!code-vb[WF_Samples#270](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#270)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected abstract void UnlockWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void UnlockWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState(System.Workflow.ComponentModel.Activity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Quando substituído em uma classe derivada, desbloqueia o estado da instância de fluxo de trabalho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é abstrato, portanto ele não contém uma implementação padrão no bloqueio e desbloqueio.  
  
 Ao implementar um serviço de persistência personalizado, se você quiser implementar um esquema de bloqueio você precisará substituir este método e fornecem um mecanismo de bloqueio de desbloqueio no <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> método com base no valor do parâmetro de desbloqueio.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação de `UnlockWorkflowInstanceState` método. Este exemplo é do exemplo do serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](http://msdn.microsoft.com/en-us/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#267](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#267)]
 [!code-vb[WF_Samples#267](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#267)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
