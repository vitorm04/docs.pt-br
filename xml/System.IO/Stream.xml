<Type Name="Stream" FullName="System.IO.Stream">
  <TypeSignature Language="C#" Value="public abstract class Stream : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Stream extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IO.Stream" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece uma exibição genérica de uma sequência de bytes. Esta é uma classe abstrata.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/io/stream.cs#f956b0c07e86df64). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 <xref:System.IO.Stream>é a classe base abstrata de todos os fluxos. Um fluxo é uma abstração de uma sequência de bytes, como um arquivo, um dispositivo de arquivos entrada/saída, um pipe de comunicação de inter- processo, ou um soquete TCP/IP. O <xref:System.IO.Stream> classe e suas classes derivadas fornecem uma exibição genérica desses tipos diferentes de entrada e saída e isolar o programador de detalhes específicos do sistema operacional e os dispositivos subjacentes.  
  
 Fluxos envolvem estas três operações fundamentais:  
  
-   Você pode ler a partir de fluxos. Leitura é a transferência de dados de um fluxo em uma estrutura de dados, como uma matriz de bytes.  
  
-   Você pode escrever fluxos. A gravação é a transferência de dados de uma estrutura de dados em um fluxo.  
  
-   Fluxos podem suportar busca. Busca refere-se a consulta e a modificação da posição atual dentro de um fluxo. Busca de recurso depende do tipo de repositório de backup tem um fluxo. Por exemplo, fluxos de rede não têm unificado conceito de uma posição atual e, portanto, normalmente não oferecem suporte a busca.  
  
 Algumas das mais comumente usado fluxos que herdam de <xref:System.IO.Stream> são <xref:System.IO.FileStream>, e <xref:System.IO.MemoryStream>.  
  
 Dependendo da fonte de dados subjacente ou o repositório, os fluxos podem suportar apenas alguns desses recursos. Você pode consultar um fluxo para seus recursos usando o <xref:System.IO.Stream.CanRead%2A>, <xref:System.IO.Stream.CanWrite%2A>, e <xref:System.IO.Stream.CanSeek%2A> propriedades da <xref:System.IO.Stream> classe.  
  
 O <xref:System.IO.Stream.Read%2A> e <xref:System.IO.Stream.Write%2A> métodos ler e gravar dados em uma variedade de formatos. Para fluxos de suporte para busca, use o <xref:System.IO.Stream.Seek%2A> e <xref:System.IO.Stream.SetLength%2A> métodos e <xref:System.IO.Stream.Position%2A> e <xref:System.IO.Stream.Length%2A> propriedades para consultar e modificar a posição atual e o comprimento de um fluxo.  
  
 Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
 Descartando um <xref:System.IO.Stream> objeto libera todos os dados armazenados em buffer e chama essencialmente o <xref:System.IO.Stream.Flush%2A> método para você. <xref:System.IO.Stream.Dispose%2A>também libera recursos do sistema operacional, como identificadores de arquivos, conexões de rede ou memória usada para qualquer buffer interno. O <xref:System.IO.BufferedStream> classe fornece a capacidade de quebra automática de um fluxo em buffer em torno de outro fluxo para melhorar a leitura e gravação de desempenho.  
  
 Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], o <xref:System.IO.Stream> classe inclui métodos assíncronos para simplificar as operações assíncronas. Contém um método assíncrono `Async` em seu nome, como <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>. Esses métodos permitem executar operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Quando usado em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo, <xref:System.IO.Stream> inclui dois métodos de extensão: <xref:System.IO.WindowsRuntimeStreamExtensions.AsInputStream%2A> e <xref:System.IO.WindowsRuntimeStreamExtensions.AsOutputStream%2A>. Esses métodos convertem um <xref:System.IO.Stream> objeto em um fluxo no [!INCLUDE[wrt](~/includes/wrt-md.md)]. Você também pode converter um fluxo no [!INCLUDE[wrt](~/includes/wrt-md.md)] para um <xref:System.IO.Stream> objeto usando o <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForRead%2A> e <xref:System.IO.WindowsRuntimeStreamExtensions.AsStreamForWrite%2A> métodos. Para obter mais informações, consulte [como: converter entre fluxos do .NET Framework e tempo de execução do Windows](~/docs/standard/io/how-to-convert-between-dotnet-streams-and-winrt-streams.md)  
  
 Algumas implementações de fluxo executam buffer local dos dados subjacentes para melhorar o desempenho. Para tais fluxos, você pode usar o <xref:System.IO.Stream.Flush%2A> ou <xref:System.IO.Stream.FlushAsync%2A> método para limpar qualquer buffers internos e certifique-se de que todos os dados foram gravados para a fonte de dados ou o repositório subjacente.  
  
 Se você precisar de um fluxo com nenhum armazenamento de backup (também conhecido como um bloco de bits), use o <xref:System.IO.Stream.Null> campo a recuperar uma instância de um fluxo que foi projetado para essa finalidade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar duas <xref:System.IO.FileStream> objetos de forma assíncrona copiar os arquivos de um diretório para outro diretório. O <xref:System.IO.FileStream> classe deriva de <xref:System.IO.Stream> classe. Observe que o <xref:System.Web.UI.WebControls.Button.Click> manipulador de eventos para o <xref:System.Windows.Controls.Button> controle está marcado com o `async` modificador porque chama um método assíncrono.  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Quando você implementa uma classe derivada de <see cref="T:System.IO.Stream" />, você deve fornecer implementações para o <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> métodos. Os métodos assíncronos <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />, <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />, e <see cref="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" /> usar os métodos síncronos <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> em suas implementações. Portanto, suas implementações de <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> funcionarão corretamente com os métodos assíncronos. As implementações padrão de <see cref="M:System.IO.Stream.ReadByte" /> e <see cref="M:System.IO.Stream.WriteByte(System.Byte)" /> criar uma nova matriz de byte único elemento e, em seguida, chamar as implementações de <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> e <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Quando você deriva de <see cref="T:System.IO.Stream" />, recomendamos que você substitua esses métodos para acessar o buffer interno, se você tiver um, para um desempenho significativamente melhor. Você também deve fornecer implementações de <see cref="P:System.IO.Stream.CanRead" />, <see cref="P:System.IO.Stream.CanSeek" />, <see cref="P:System.IO.Stream.CanWrite" />, <see cref="M:System.IO.Stream.Flush" />, <see cref="P:System.IO.Stream.Length" />, <see cref="P:System.IO.Stream.Position" />, <see cref="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />, e <see cref="M:System.IO.Stream.SetLength(System.Int64)" />.  
  
 Não substituir o <see cref="M:System.IO.Stream.Close" /> método, em vez disso, colocar todos o <see cref="T:System.IO.Stream" /> lógica de limpeza no <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> método. Para obter mais informações, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Stream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IO.Stream>é a classe base abstrata de todos os fluxos.  
  
 Algumas das mais comumente usado fluxos que herdam de <xref:System.IO.Stream> são <xref:System.IO.FileStream>, e <xref:System.IO.MemoryStream>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginRead (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginRead(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para ler os dados.</param>
        <param name="offset">O deslocamento de byte no <c>buffer</c> no qual começar a gravar os dados lidos do fluxo.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <param name="callback">Um retorno de chamada assíncrono opcional, a ser chamado quando a leitura for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de leitura assíncrona específica de outras solicitações.</param>
        <summary>Inicia uma operação de leitura assíncrona. (Considere o uso de <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> em vez disso.)</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que representa a operação de leitura assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.Stream.BeginRead%2A> e <xref:System.IO.Stream.EndRead%2A> para implementar operações de e/s assíncronas. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, ajudam a implementar operações de e/s assíncronas mais facilmente.  
  
 A implementação padrão de `BeginRead` em um fluxo de chamadas a <xref:System.IO.Stream.Read%2A> método de forma síncrona, o que significa que `Read` podem bloquear em alguns fluxos. No entanto, instâncias de classes, como `FileStream` e `NetworkStream` suporte para operações assíncronas totalmente se as instâncias de tem sido abertas assincronamente. Portanto, chamadas para `BeginRead` não bloqueará esses fluxos. Você pode substituir `BeginRead` (usando delegados assíncronos, por exemplo) para fornecer o comportamento assíncrono.  
  
 Passar o `IAsyncResult` retornar o valor para o <xref:System.IO.Stream.EndRead%2A> método do fluxo para determinar o número de bytes foram lidas e para liberar recursos do sistema operacional usados para leitura. <xref:System.IO.Stream.EndRead%2A>deve ser chamado uma vez para cada chamada a <xref:System.IO.Stream.BeginRead%2A>. Você pode fazer isso usando o mesmo código que chamou `BeginRead` ou em um retorno de chamada transmitido para `BeginRead`.  
  
 A posição atual no fluxo é atualizada quando a gravação ou leitura assíncrona é emitida, não quando a operação de e/s é concluída.  
  
 Várias solicitações assíncronas simultâneas renderizam a ordem de conclusão de solicitação indefinido.  
  
 Use o <xref:System.IO.Stream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 Se um fluxo está fechado ou se você passar um argumento inválido, as exceções são geradas imediatamente de `BeginRead`. Erros que ocorrem durante uma solicitação de leitura assíncrona, como uma falha de disco durante a solicitação de e/s, ocorrer no thread de pool de thread e lançam exceções ao chamar `EndRead`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tentativa de uma leitura assíncrona após o final do fluxo ou ocorre um erro de disco.</exception>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see langword="Stream" /> atual não dá suporte à operação de leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public virtual IAsyncResult BeginWrite (byte[] buffer, int offset, int count, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] buffer, int32 offset, int32 count, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer do qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de byte no <c>buffer</c> da qual começar a escrever.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <param name="callback">Um retorno de chamada assíncrona opcional, a ser chamada quando a operação de gravação for concluída.</param>
        <param name="state">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação assíncrona específica de outras solicitações.</param>
        <summary>Inicia uma operação de gravação assíncrona. (Considere o uso de <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> em vez disso.)</summary>
        <returns>Um <see langword="IAsyncResult" /> que representa a gravação assíncrona, que ainda pode estar pendente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.Stream.BeginWrite%2A> e <xref:System.IO.Stream.EndWrite%2A> para implementar operações de e/s assíncronas. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, ajudam a implementar operações de e/s assíncronas mais facilmente.  
  
 A implementação padrão de `BeginWrite` em um fluxo de chamadas a <xref:System.IO.Stream.Write%2A> método de forma síncrona, o que significa que `Write` podem bloquear em alguns fluxos. No entanto, instâncias de classes, como `FileStream` e `NetworkStream` suporte para operações assíncronas totalmente se as instâncias de tem sido abertas assincronamente. Portanto, chamadas para `BeginWrite` não bloqueará esses fluxos. Você pode substituir `BeginWrite` (usando delegados assíncronos, por exemplo) para fornecer o comportamento assíncrono.  
  
 Passar o `IAsyncResult` retornado pelo método atual para <xref:System.IO.Stream.EndWrite%2A> para garantir que a gravação é concluída e libera recursos adequadamente. <xref:System.IO.Stream.EndWrite%2A>deve ser chamado uma vez para cada chamada a <xref:System.IO.Stream.BeginWrite%2A>. Você pode fazer isso usando o mesmo código que chamou `BeginWrite` ou em um retorno de chamada transmitido para `BeginWrite`. Se ocorrer um erro durante uma gravação assíncrona, uma exceção será lançada não até `EndWrite` é chamado com o `IAsyncResult` retornado por esse método.  
  
 Se um fluxo gravável, gravando no final do fluxo expande o fluxo.  
  
 A posição atual no fluxo é atualizada quando você emitir a gravação ou leitura assíncrona não quando a operação de e/s é concluída. Várias solicitações assíncronas simultâneas renderizam a ordem de conclusão de solicitação indefinido.  
  
 Use o <xref:System.IO.Stream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
 Se um fluxo está fechado ou se você passar um argumento inválido, as exceções são geradas imediatamente de `BeginWrite`. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, ocorrer no thread de pool de thread e lançam exceções ao chamar `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Houve uma tentativa de gravação assíncrona após o final do fluxo ou ocorreu um erro de disco.</exception>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos são inválidos.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see langword="Stream" /> atual não dá suporte à operação de gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public abstract bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o fluxo atual dá suporte à leitura.</summary>
        <value>
          <see langword="true" /> se o fluxo der suporte à leitura; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não dá suporte para leitura, chamadas para o <xref:System.IO.Stream.Read%2A>, <xref:System.IO.Stream.ReadByte%2A>, e <xref:System.IO.Stream.BeginRead%2A> métodos lançam uma <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 A seguir está um exemplo de como usar o `CanRead` propriedade.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public abstract bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o fluxo atual dá suporte à busca.</summary>
        <value>
          <see langword="true" /> se o fluxo der suporte à busca, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não dá suporte para busca, chamadas para <xref:System.IO.Stream.Length%2A>, <xref:System.IO.Stream.SetLength%2A>, <xref:System.IO.Stream.Position%2A>, e <xref:System.IO.Stream.Seek%2A> lançar um <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanTimeout">
      <MemberSignature Language="C#" Value="public virtual bool CanTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que determina se o fluxo atual pode atingir o tempo limite.</summary>
        <value>Um valor que determina se o fluxo atual pode atingir o tempo limite.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.CanTimeout%2A> propriedade sempre retorna `false`. Algumas implementações de fluxo exigem um comportamento diferente, como <xref:System.Net.Sockets.NetworkStream>, que o tempo limite se a conectividade de rede for interrompida ou perdida. Se você estiver implementando um fluxo que deve ser capaz de atingir o tempo limite, essa propriedade deve ser substituída para retornar `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public abstract bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o fluxo atual dá suporte à gravação.</summary>
        <value>
          <see langword="true" /> se o fluxo der suporte à gravação; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não oferece suporte à gravação, uma chamada para <xref:System.IO.Stream.Write%2A>, <xref:System.IO.Stream.BeginWrite%2A>, ou <xref:System.IO.Stream.WriteByte%2A> lança um <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 A seguir está um exemplo de como usar o `CanWrite` propriedade.  
  
 [!code-cpp[Classic Stream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o fluxo atual e libera todos os recursos (como soquetes e identificadores de arquivos) associados ao fluxo atual. Em vez de chamar esse método, verifique se o fluxo é descartado corretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama <xref:System.IO.Stream.Dispose%2A>, especificando `true` para liberar todos os recursos. Você não precisa chamar especificamente a <xref:System.IO.Stream.Close%2A> método. Em vez disso, verifique se cada <xref:System.IO.Stream> objeto seja corretamente descartado. Você pode declarar <xref:System.IO.Stream> objetos dentro de um `using` bloco (ou `Using` bloquear no Visual Basic) para garantir que o fluxo e todos os seus recursos são descartados, ou você pode chamar explicitamente o <xref:System.IO.Stream.Dispose%2A> método.  
  
 Liberando o fluxo não liberar seu codificador subjacente, a menos que você chamar explicitamente uma implementação de <xref:System.IO.Stream.Flush%2A> ou `Close`. Configuração <xref:System.IO.StreamWriter.AutoFlush%2A> para `true` significa que os dados serão liberados do buffer no fluxo, mas o estado de codificador não será liberado. Isso permite que o codificador deve manter o estado (parcial caracteres) para que ele pode codificar o próximo bloco de caracteres corretamente. Este cenário afeta UTF8 e UTF7 onde determinados caracteres podem ser codificados somente depois que o codificador recebe adjacentes ou mais caracteres.  
  
 Tentativas de manipular o fluxo após o fluxo foi fechado podem acionar um <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Em classes derivadas, não substituem o <see cref="M:System.IO.Stream.Close" /> método, em vez disso, colocar todos os <see langword="Stream" /> lógica de limpeza no <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> método. Para obter mais informações, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">O fluxo para o qual o conteúdo do fluxo atual será copiado.</param>
        <summary>Lê os bytes do fluxo atual e os grava em outro fluxo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cópia começa na posição atual no fluxo atual e não redefinir a posição do fluxo de destino após a conclusão da operação de cópia.  
  
   
  
## Examples  
 O exemplo a seguir copia o conteúdo de um <xref:System.IO.FileStream> para um <xref:System.IO.MemoryStream>.  
  
 [!code-csharp[System.IO.Stream.CopyTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.stream.copyto/cs/program.cs#1)]
 [!code-vb[System.IO.Stream.CopyTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.stream.copyto/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para a leitura no fluxo atual.  
  
 -ou-  
  
 <paramref name="destination" /> não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo atual ou <paramref name="destination" /> foram fechados antes do método <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> ser chamado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyTo(System.IO.Stream,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">O fluxo para o qual o conteúdo do fluxo atual será copiado.</param>
        <param name="bufferSize">O tamanho do buffer. Esse valor deve ser maior que zero. O tamanho padrão é 81920.</param>
        <summary>Lê os bytes do fluxo atual e os grava em outro fluxo usando um tamanho do buffer especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cópia começa na posição atual no fluxo atual e não redefinir a posição do fluxo de destino após a conclusão da operação de cópia.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é negativo ou zero.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para a leitura no fluxo atual.  
  
 -ou-  
  
 <paramref name="destination" /> não dá suporte à gravação.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo atual ou <paramref name="destination" /> foram fechados antes do método <see cref="M:System.IO.Stream.CopyTo(System.IO.Stream)" /> ser chamado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="destination">O fluxo para o qual o conteúdo do fluxo atual será copiado.</param>
        <summary>Lê de forma assíncrona os bytes do fluxo atual e os grava em outro fluxo.</summary>
        <returns>Uma tarefa que representa a operação de cópia assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.CopyToAsync%2A> método permite que você execute operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 A cópia começa na posição atual no fluxo atual.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar duas <xref:System.IO.FileStream> objetos de forma assíncrona copiar os arquivos de um diretório para outro. O <xref:System.IO.FileStream> classe deriva de <xref:System.IO.Stream> classe.  Observe que o <xref:System.Web.UI.WebControls.Button.Click> manipulador de eventos para o <xref:System.Windows.Controls.Button> controle está marcado com o `async` modificador porque chama um método assíncrono  
  
 [!code-csharp[Asynchronous_File_IO_async#1](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example.cs#1)]
 [!code-vb[Asynchronous_File_IO_async#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo atual ou o fluxo de destino é descartado.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo atual não dá suporte à leitura ou o fluxo de destino não dá suporte à gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="destination">O fluxo para o qual o conteúdo do fluxo atual será copiado.</param>
        <param name="bufferSize">O tamanho do buffer, em bytes. Esse valor deve ser maior que zero. O tamanho padrão é 81920.</param>
        <summary>Lê de maneira assíncrona os bytes do fluxo atual e os grava em outro fluxo usando um tamanho do buffer especificado.</summary>
        <returns>Uma tarefa que representa a operação de cópia assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.CopyToAsync%2A> método permite que você execute operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 A cópia começa na posição atual no fluxo atual.  
  
 Para obter um exemplo de copiar entre dois fluxos, consulte o <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> é negativo ou zero.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo atual ou o fluxo de destino é descartado.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo atual não dá suporte à leitura ou o fluxo de destino não dá suporte à gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyToAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task CopyToAsync (System.IO.Stream destination, int bufferSize, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task CopyToAsync(class System.IO.Stream destination, int32 bufferSize, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.IO.Stream" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="destination">O fluxo para o qual o conteúdo do fluxo atual será copiado.</param>
        <param name="bufferSize">O tamanho do buffer, em bytes. Esse valor deve ser maior que zero. O tamanho padrão é 81.920.</param>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento. O valor padrão é <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Lê de forma assíncrona os bytes do fluxo atual e os grava em outro fluxo usando um tamanho do buffer especificado e um token de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de cópia assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.CopyToAsync%2A> método permite que você execute operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade.  
  
 A cópia começa na posição atual no fluxo atual.  
  
 Para obter um exemplo de copiar entre dois fluxos, consulte o <xref:System.IO.Stream.CopyToAsync%28System.IO.Stream%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> é negativo ou zero.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo atual ou o fluxo de destino é descartado.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo atual não dá suporte à leitura ou o fluxo de destino não dá suporte à gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateWaitHandle">
      <MemberSignature Language="C#" Value="protected virtual System.Threading.WaitHandle CreateWaitHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Threading.WaitHandle CreateWaitHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.CreateWaitHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("CreateWaitHandle will be removed eventually.  Please use "new ManualResetEvent(false)" instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.WaitHandle</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aloca um objeto <see cref="T:System.Threading.WaitHandle" />.</summary>
        <returns>Uma referência ao <see langword="WaitHandle" /> alocado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando chamado pela primeira vez, o método atual cria um `WaitHandle` do objeto e o retorna. Em chamadas subsequentes, `CreateWaitHandle` retorna uma referência a um novo identificador de espera.  
  
 Use este método se você implementa os métodos assíncronos e requer um modo de bloqueio no <xref:System.IO.Stream.EndRead%2A> ou <xref:System.IO.Stream.EndWrite%2A> até que a operação assíncrona é concluída.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pelo <see cref="T:System.IO.Stream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método descarta o fluxo, escrevendo as alterações ao repositório de backup e fechar o fluxo para liberar recursos.  
  
 Chamando `Dispose` permite que os recursos usados pelo <xref:System.IO.Stream> para ser realocada para outros fins. Para obter mais informações sobre `Dispose`, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Colocar toda a lógica de limpeza para seu objeto de fluxo em <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />. Não substitua <see cref="M:System.IO.Stream.Close" />.  
  
 Observe que, devido aos requisitos de compatibilidade com versões anteriores, implementação desse método diferente com as diretrizes recomendadas para o padrão Dispose.  Este método chama <see cref="M:System.IO.Stream.Close" />, que, em seguida, chama <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.IO.Stream" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve liberar todos os recursos especificando `true` para `disposing`. Quando `disposing` é `true`, o fluxo também pode garantir dados seja liberados para o buffer subjacente e acessarem outros objetos finalizáveis.  Isso talvez não seja possível quando chamado a partir de um finalizador devido à falta de ordenação entre finalizadores.  
  
 Se o fluxo está usando um identificador de sistema operacional para se comunicar com sua fonte, considere o uso de uma subclasse de <xref:System.Runtime.InteropServices.SafeHandle> para essa finalidade.  
  
 Este método é chamado pelo método público <xref:System.ComponentModel.Component.Dispose%2A> e pelo método <xref:System.Object.Finalize%2A>. <xref:System.ComponentModel.Component.Dispose%2A> invoca o método <xref:System.IO.Stream.Dispose%2A> protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.Stream.Dispose%2A> com `disposing` definido como `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Em classes derivadas, não substituem o <see cref="M:System.IO.Stream.Close" /> método, em vez disso, colocar toda a lógica de limpeza de fluxo no <see cref="M:System.IO.Stream.Dispose(System.Boolean)" /> método.  
  
 <see cref="M:System.ComponentModel.Component.Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, tome cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see cref="M:System.ComponentModel.Component.Dispose" />. Para obter mais informações sobre como implementar <see cref="M:System.IO.Stream.Dispose(System.Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public virtual int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndRead(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A referência à solicitação assíncrona pendente a ser concluída.</param>
        <summary>Espera a leitura assíncrona pendente ser concluída. (Considere o uso de <see cref="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" /> em vez disso.)</summary>
        <returns>O número de bytes lidos do fluxo, entre zero (0) e o número de bytes solicitado. Os fluxos retornam zero (0) somente no final do fluxo, caso contrário, eles devem ser bloqueados até que pelo menos um byte esteja disponível.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.Stream.BeginRead%2A> e <xref:System.IO.Stream.EndRead%2A> para implementar operações de e/s assíncronas. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, ajudam a implementar operações de e/s assíncronas mais facilmente.  
  
 Chamar `EndRead` para determinar o número de bytes que foram lidos do fluxo.  
  
 `EndRead`pode ser chamado uma vez em cada <xref:System.IAsyncResult> de <xref:System.IO.Stream.BeginRead%2A>.  
  
 Esse método bloqueia até que a operação de e/s foi concluída.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Um identificador para a operação de leitura pendente não está disponível.  
  
 -ou-  
  
 A operação pendente não dá suporte à leitura.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="asyncResult" /> não é proveniente de um método <see cref="M:System.IO.Stream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> no fluxo atual.</exception>
        <exception cref="T:System.IO.IOException">O fluxo está fechado ou ocorreu um erro interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public virtual void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.EndWrite(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Uma referência à solicitação de E/S assíncrona pendente.</param>
        <summary>Encerra uma operação de gravação assíncrona. (Considere o uso de <see cref="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" /> em vez disso.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.Stream.BeginWrite%2A> e <xref:System.IO.Stream.EndWrite%2A> para implementar operações de e/s assíncronas. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.Stream.ReadAsync%2A>, <xref:System.IO.Stream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.Stream.FlushAsync%2A>, ajudam a implementar operações de e/s assíncronas mais facilmente.  
  
 `EndWrite`deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> de <xref:System.IO.Stream.BeginWrite%2A>.  
  
 Esse método bloqueia até que a operação de e/s foi concluída. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, ocorrem no thread do pool e ficam visíveis após uma chamada para `EndWrite`. Exceções geradas pelo thread do pool não estarão visíveis ao chamar `EndWrite`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Não há um identificador disponível para a operação de gravação pendente.  
  
 -ou-  
  
 A operação pendente não dá suporte à gravação.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="asyncResult" /> não é proveniente de um método <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> no fluxo atual.</exception>
        <exception cref="T:System.IO.IOException">O fluxo está fechado ou ocorreu um erro interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public abstract void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando é substituído em uma classe derivada, limpa todos os buffers nesse fluxo e faz com que todos os dados armazenados em buffer sejam gravados no dispositivo subjacente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituir `Flush` em fluxos que implementam um buffer. Use esse método para mover todas as informações de um buffer de base para seu destino, limpe o buffer, ou ambos. Dependendo do estado do objeto, você talvez precise modificar a posição atual dentro do fluxo (por exemplo, se dá suporte à busca de fluxo subjacente). Para obter mais informações, consulte <xref:System.IO.Stream.CanSeek%2A>.  
  
 Ao usar o <xref:System.IO.StreamWriter> ou <xref:System.IO.BinaryWriter> da classe, não liberar a base <xref:System.IO.Stream> objeto. Em vez disso, use a classe <xref:System.IO.Stream.Flush%2A> ou <xref:System.IO.Stream.Close%2A> método, que garante que os dados são liberados para o fluxo subjacente primeiro e, em seguida, gravados no arquivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa de forma assíncrona todos os buffers nesse fluxo e faz com que os dados armazenados em buffer sejam gravados no dispositivo subjacente.</summary>
        <returns>Uma tarefa que representa a operação de liberação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada, como <xref:System.IO.Compression.DeflateStream> ou <xref:System.IO.Compression.GZipStream>, não liberar o buffer em sua implementação do <xref:System.IO.Stream.Flush%2A> método, o <xref:System.IO.Stream.FlushAsync%2A> método não liberará o buffer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento. O valor padrão é <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Limpa todos os buffers nesse fluxo de forma assíncrona, faz com que os dados armazenados em buffer sejam gravados no dispositivo subjacente e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de liberação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade.  
  
 Se uma classe derivada, como <xref:System.IO.Compression.DeflateStream> ou <xref:System.IO.Compression.GZipStream>, não liberar o buffer em sua implementação do <xref:System.IO.Stream.Flush%2A> método, o <xref:System.IO.Stream.FlushAsync%2A> método não liberará o buffer.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public abstract long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o tamanho em bytes do fluxo.</summary>
        <value>Um valor longo que representa o tamanho do fluxo em bytes.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Uma classe derivada de <see langword="Stream" /> não dá suporte à busca.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.Stream Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.Stream Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.Stream.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Um <see langword="Stream" /> sem repositório de backup.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use `Null` para redirecionar a saída para um fluxo que não consumirá quaisquer recursos do sistema operacional. Quando os métodos de `Stream` que fornecem a gravação são chamados em `Null`, simplesmente retorna a chamada e nenhum dado seja gravado. `Null`também implementa um `Read` método que retorna zero sem ler dados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ObjectInvariant">
      <MemberSignature Language="C#" Value="protected virtual void ObjectInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ObjectInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ObjectInvariant" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Do not call or override this method.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fornece suporte para um <see cref="T:System.Diagnostics.Contracts.Contract" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public abstract long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém ou define a posição dentro do fluxo atual.</summary>
        <value>A posição atual no fluxo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O fluxo deve oferecer suporte a busca obter ou definir a posição. Use o <xref:System.IO.Stream.CanSeek%2A> propriedade para determinar se o fluxo oferece suporte à busca.  
  
 Há suporte para busca em qualquer local além do comprimento do fluxo.  
  
 O `Position` propriedade não manter o controle do número de bytes do fluxo que tiverem sido consumidos, ignorado, ou ambos.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte à busca.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract int Read (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Read([out] unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de bytes. Quando este método retorna, o buffer contém a matriz de bytes especificada com os valores entre <c>deslocamento</c> e (<c>deslocamento</c> + <c>contagem</c> - 1) substituídos pelo bytes lidos da origem atual.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <c>buffer</c> no qual começar a armazenar os dados lidos do fluxo atual.</param>
        <param name="count">O número máximo de bytes a serem lidos no fluxo atual.</param>
        <summary>Quando for substituído em uma classe derivada, lê uma sequência de bytes do fluxo atual e avança a posição dentro do fluxo até o número de bytes lidos.</summary>
        <returns>O número total de bytes lidos do buffer. Isso poderá ser menor que o número de bytes solicitado se esses muitos bytes não estiverem disponíveis no momento, ou zero (0) se o final do fluxo tiver sido atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Stream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura. Use o <xref:System.IO.Stream.ReadAsync%2A> método de leitura assíncrona no fluxo atual.  
  
 As implementações desse método ler um máximo de `count` bytes do atual fluxo e armazená-los em `buffer` começando no `offset`. A posição atual dentro do fluxo for avançada pelo número de bytes lido; No entanto, se ocorrer uma exceção, a posição atual dentro do fluxo permanece inalterada. Implementações de retornam o número de bytes lidos. A implementação será bloqueado até que pelo menos um byte de dados podem ser lidos, que não há dados disponíveis. <xref:System.IO.Stream.Read%2A>Retorna 0 somente quando não houver nenhuma mais dados no fluxo e não mais é esperado (como um soquete fechado ou o final do arquivo). Uma implementação está livre para retornar menos bytes que solicitado, mesmo que não foi atingido o fim do fluxo.  
  
 Use <xref:System.IO.BinaryReader> para ler tipos de dados primitivos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar <xref:System.IO.Stream.Read%2A> para ler um bloco de dados.  
  
 [!code-cpp[Classic Stream.Read Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Stream.Read Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Stream.Read Example/CS/source.cs#1)]
 [!code-vb[Classic Stream.Read Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Stream.Read Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer no qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de byte no <c>buffer</c> no qual começar a gravar dados no fluxo.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <summary>Lê uma sequência de bytes do fluxo atual de forma assíncrona e avança a posição no fluxo até o número de bytes lidos.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de bytes lidos no buffer. O valor do resultado poderá ser menor que o número de bytes solicitados se o número de bytes disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo foi atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.ReadAsync%2A> método permite que você execute operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.Stream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
   
  
## Examples  
 O exemplo a seguir mostra como ler de um arquivo de forma assíncrona. O exemplo usa o <xref:System.IO.FileStream> classe que deriva de <xref:System.IO.Stream> classe.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer no qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de byte no <c>buffer</c> no qual começar a gravar dados no fluxo.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento. O valor padrão é <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Lê de forma assíncrona uma sequência de bytes do fluxo atual, avança a posição no fluxo até o número de bytes lidos e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de bytes lidos no buffer. O valor do resultado poderá ser menor que o número de bytes solicitados se o número de bytes disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo foi atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.ReadAsync%2A> método permite que você execute operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.Stream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade.  
  
 Para obter um exemplo, consulte o <xref:System.IO.Stream.ReadAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public virtual int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.ReadByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê um byte do fluxo e avança a posição no fluxo em um byte ou retorna -1 caso esteja no final do fluxo.</summary>
        <returns>O byte sem sinal convertido em um <see langword="Int32" /> ou -1 se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Stream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 Tentativas de manipular o fluxo após o fluxo foi fechado podem gerar um <xref:System.ObjectDisposedException>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
        <block subset="none" type="overrides">
          <para>A implementação padrão em <see langword="Stream" /> cria uma nova matriz de byte único e, em seguida, chama <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Enquanto estiver formalmente correto, é ineficiente. Qualquer fluxo com um buffer interno deve substituir este método e fornecer uma versão muito mais eficiente do que lê o buffer diretamente, evitando a alocação de matriz extra em cada chamada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ReadTimeout">
      <MemberSignature Language="C#" Value="public virtual int ReadTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReadTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.ReadTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor, em milissegundos, que determina quanto tempo o fluxo tentará realizar a leitura antes do tempo limite.</summary>
        <value>Um valor, em milissegundos, que determina quanto tempo o fluxo tentará realizar a leitura antes do tempo limite.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">O método <see cref="P:System.IO.Stream.ReadTimeout" /> sempre gera um <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides">
          <para>O <see cref="P:System.IO.Stream.ReadTimeout" /> propriedade deve ser substituída para fornecer o comportamento apropriado para o fluxo. Se o fluxo não oferece suporte para o tempo limite, essa propriedade deve gerar um <see cref="T:System.InvalidOperationException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public abstract long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Um deslocamento de bytes relativo a <c>origem</c> parâmetro.</param>
        <param name="origin">Um valor do tipo <see cref="T:System.IO.SeekOrigin" /> indicando o ponto de referência usado para obter a nova posição.</param>
        <summary>Quando substituído em uma classe derivada, define a posição dentro do fluxo atual.</summary>
        <returns>A nova posição dentro do fluxo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Stream.CanSeek%2A> propriedade para determinar se a instância atual oferece suporte à busca.  
  
 Se `offset` é negativo, a nova posição deve preceder a posição especificada pelo `origin` pelo número de bytes especificado por `offset`. Se `offset` é zero (0), a nova posição é necessária para ser a posição especificada pelo `origin`. Se `offset` for positivo, a nova posição é necessária para acompanhar a posição especificada pelo `origin` pelo número de bytes especificado por `offset`.  
  
 Classes derivadas de `Stream` suporte busca deve substituir esse método para fornecer a funcionalidade descrita acima.  
  
 Há suporte para busca em qualquer local além do comprimento do fluxo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte à busca, como se o fluxo fosse construído por meio de uma saída do console ou pipe.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public abstract void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.SetLength(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O tamanho desejado do fluxo atual em bytes.</param>
        <summary>Quando substituído em uma classe derivada, define o tamanho do fluxo atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o valor especificado é menor que o tamanho atual do fluxo, o fluxo é truncado. Se o valor especificado é maior do que o tamanho atual do fluxo, o fluxo é expandido. Se o fluxo é expandido, o conteúdo do fluxo entre o antigo e o novo tamanho não está definido.  
  
 Um fluxo deve dão suporte a gravação e busca de `SetLength` para trabalhar.  
  
 Use o <xref:System.IO.Stream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação e o <xref:System.IO.Stream.CanSeek%2A> propriedade para determinar se a busca é suportada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte à gravação nem à busca, como se o fluxo fosse construído por meio de uma saída do console ou pipe.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.IO.Stream Synchronized (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream Synchronized(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Synchronized(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O objeto <see cref="T:System.IO.Stream" /> a ser sincronizado.</param>
        <summary>Cria um wrapper thread-safe (sincronizado) em torno do objeto <see cref="T:System.IO.Stream" /> especificado.</summary>
        <returns>Um objeto <see cref="T:System.IO.Stream" /> thread-safe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna uma classe que encapsula especificado <xref:System.IO.Stream> do objeto e restringe o acesso a ele de vários threads. Todos os acessos para o <xref:System.IO.Stream> objeto será thread-safe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public abstract void Write (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Write(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de bytes. Esse método copia <c>contagem</c> bytes do <c>buffer</c> para o fluxo atual.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <c>buffer</c> no qual começar a copiar bytes para o fluxo atual.</param>
        <param name="count">O número de bytes a serem gravados no fluxo atual.</param>
        <summary>Quando for substituído em uma classe derivada, grava uma sequência de bytes no fluxo atual e avança a posição atual dentro desse fluxo até o número de bytes gravados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Stream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação. Use o <xref:System.IO.Stream.WriteAsync%2A> método para gravar de forma assíncrona para o fluxo atual.  
  
 Se a operação de gravação for bem-sucedida, a posição dentro do fluxo avança pelo número de bytes gravados. Se ocorrer uma exceção, a posição dentro do fluxo permanecerá inalterada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o comprimento do buffer.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como não ser possível encontrar o arquivo especificado.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">
          <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" /> foi chamado depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer do qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <c>buffer</c> da qual começar a copiar bytes para o fluxo.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <summary>Grava assincronamente uma sequência de bytes no fluxo atual e avança a posição atual dentro desse fluxo no número de bytes gravados.</summary>
        <returns>Uma tarefa que representa a operação de gravação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.WriteAsync%2A> método permite que você execute operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.Stream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
   
  
## Examples  
 O exemplo a seguir mostra como gravar em um arquivo de forma assíncrona. O exemplo usa o <xref:System.IO.FileStream> classe que deriva de <xref:System.IO.Stream> classe.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está em uso no momento por uma operação de gravação anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer do qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <c>buffer</c> da qual começar a copiar bytes para o fluxo.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento. O valor padrão é <see cref="P:System.Threading.CancellationToken.None" />.</param>
        <summary>Grava uma sequência de bytes no fluxo atual assincronamente, avança a posição atual dentro desse fluxo pelo número de bytes gravados e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de gravação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Stream.WriteAsync%2A> método permite que você execute operações de e/s de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.Stream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
 Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade.  
  
 Para obter um exemplo, consulte o <xref:System.IO.Stream.WriteAsync%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está em uso no momento por uma operação de gravação anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public virtual void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Stream.WriteByte(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O byte a ser gravado no fluxo.</param>
        <summary>Grava um byte na posição atual no fluxo e avança a posição dentro no fluxo em um byte.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Stream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte à gravação ou o fluxo já foi fechado.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
        <block subset="none" type="overrides">
          <para>A implementação padrão em <see langword="Stream" /> cria uma nova matriz de byte único e, em seguida, chama <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Enquanto estiver formalmente correto, é ineficiente. Qualquer fluxo com um buffer interno deve substituir este método e fornecer uma versão muito mais eficiente do que grava no buffer diretamente, evitando a alocação de matriz extra em cada chamada.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WriteTimeout">
      <MemberSignature Language="C#" Value="public virtual int WriteTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriteTimeout" />
      <MemberSignature Language="DocId" Value="P:System.IO.Stream.WriteTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor, em milissegundos, que determina quanto tempo o fluxo tentará realizar a gravação antes do tempo limite.</summary>
        <value>Um valor, em milissegundos, que determina quanto tempo o fluxo tentará realizar a gravação antes do tempo limite.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">O método <see cref="P:System.IO.Stream.WriteTimeout" /> sempre gera um <see cref="T:System.InvalidOperationException" />.</exception>
        <block subset="none" type="overrides">
          <para>O <see cref="P:System.IO.Stream.WriteTimeout" /> propriedade deve ser substituída para fornecer o comportamento apropriado para o fluxo. Se o fluxo não oferece suporte para o tempo limite, essa propriedade deve gerar um <see cref="T:System.InvalidOperationException" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
