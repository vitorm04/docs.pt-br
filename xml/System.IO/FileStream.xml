<Type Name="FileStream" FullName="System.IO.FileStream">
  <TypeSignature Language="C#" Value="public class FileStream : System.IO.Stream" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FileStream extends System.IO.Stream" />
  <TypeSignature Language="DocId" Value="T:System.IO.FileStream" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.Stream</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece um <see cref="T:System.IO.Stream" /> para um arquivo, dando suporte a operações de leitura e gravação síncronas e assíncronas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/io/filestream.cs#e23a38af5d11ddd3). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Use o <xref:System.IO.FileStream> classe para leitura, gravação, abrir e fechar arquivos em um sistema de arquivos e para manipular outros identificadores do sistema de operacional relacionadas a arquivos, como pipes, entrada e saída padrão. Você pode usar o <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.Stream.CopyTo%2A>, e <xref:System.IO.FileStream.Flush%2A> métodos para executar operações síncronas, ou o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A> métodos para executar operações assíncronas. Use os métodos assíncronos para executar operações de arquivo de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. <xref:System.IO.FileStream>buffers de entrada e saída para obter melhor desempenho.  
  
> [!IMPORTANT]
>  Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
 O <xref:System.IO.FileStream.IsAsync%2A> propriedade detecta se o identificador de arquivo foi aberto de forma assíncrona. Especifique esse valor quando você cria uma instância do <xref:System.IO.FileStream> classe usando um construtor que tenha uma `isAsync`, `useAsync`, ou `options` parâmetro. Quando a propriedade for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, o <xref:System.IO.FileStream.IsAsync%2A> propriedade não tem que ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> método. Quando o <xref:System.IO.FileStream.IsAsync%2A> é de propriedade `false` e chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona.  
  
 O <xref:System.IO.FileStream.Seek%2A> método dá suporte ao acesso aleatório aos arquivos. <xref:System.IO.FileStream.Seek%2A>permite que a posição de leitura/gravação a ser movido para qualquer posição dentro do arquivo. Isso é feito com parâmetros de ponto de referência de deslocamento de byte. O deslocamento de byte é relativo ao ponto de referência a busca, que pode ser no início, a posição atual ou o final do arquivo de base, conforme representado por três membros do <xref:System.IO.SeekOrigin> enumeração.  
  
> [!NOTE]
>  Arquivos de disco sempre oferecem suporte a acesso aleatório. No momento da construção, a <xref:System.IO.FileStream.CanSeek%2A> o valor da propriedade é definido como `true` ou `false` dependendo do tipo de arquivo base. Se o tipo subjacente do arquivo é FILE_TYPE_DISK, conforme definido no WinBase, o <xref:System.IO.FileStream.CanSeek%2A> é o valor da propriedade `true`. Caso contrário, o <xref:System.IO.FileStream.CanSeek%2A> é o valor da propriedade `false`.  
  
 Se um processo termina com a parte de um arquivo bloqueado ou fecha um arquivo que tenha bloqueios pendentes, o comportamento será indefinido.  
  
 Para operações de diretório e outras operações de arquivo, consulte o <xref:System.IO.File>, <xref:System.IO.Directory>, e <xref:System.IO.Path> classes. O <xref:System.IO.File> é uma classe de utilitário que tem métodos estáticos principalmente para a criação de <xref:System.IO.FileStream> objetos com base em caminhos de arquivo. O <xref:System.IO.MemoryStream> classe cria um fluxo de uma matriz de bytes e é semelhante de <xref:System.IO.FileStream> classe.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
## <a name="detection-of-stream-position-changes"></a>Detecção de alterações feitas na posição de fluxo  
 Quando um <xref:System.IO.FileStream> objeto não tem um bloqueio exclusivo no seu identificador, outro thread pode acessar o identificador de arquivo simultaneamente e alterar a posição do ponteiro de arquivo do sistema operacional que está associado com o identificador de arquivo. Nesse caso, a posição em cache no <xref:System.IO.FileStream> objeto e os dados armazenados em cache do buffer podem ser comprometidos. O <xref:System.IO.FileStream> objeto rotineiramente executa verificações nos métodos que acessam o buffer em cache para garantir que a posição do identificador do sistema operacional é o mesmo que a posição em cache usada pelo <xref:System.IO.FileStream> objeto.  
  
 Se uma alteração inesperada na posição identificador for detectada em uma chamada para o <xref:System.IO.FileStream.Read%2A> descarta o conteúdo do buffer de método, o .NET Framework e lê o fluxo do arquivo novamente. Isso pode afetar o desempenho, dependendo do tamanho do arquivo e outros processos que poderiam afetar a posição do fluxo de arquivo.  
  
 Se uma alteração inesperada na posição identificador for detectada em uma chamada para o <xref:System.IO.FileStream.Write%2A> método, o conteúdo do buffer são descartados e um <xref:System.IO.IOException> exceção será lançada.  
  
 Um <xref:System.IO.FileStream> objeto não terá um bloqueio exclusivo no seu identificador quando qualquer o <xref:System.IO.FileStream.SafeFileHandle%2A> propriedade é acessada para expor o identificador ou o <xref:System.IO.FileStream> objeto recebe o <xref:System.IO.FileStream.SafeFileHandle%2A> propriedade em seu construtor.  
  
   
  
## Examples  
 O exemplo a seguir demonstra alguns do <xref:System.IO.FileStream> construtores.  
  
 [!code-cpp[fstream class#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream Class/CPP/fstream class.cpp#1)]
 [!code-csharp[fstream class#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream Class/CS/fstream class.cs#1)]
 [!code-vb[fstream class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream Class/VB/fstream class.vb#1)]  
  
 O exemplo a seguir mostra como gravar em um arquivo de forma assíncrona. Esse código é executado em um aplicativo WPF que tem um TextBlock chamado UserInput e um botão vinculada a um manipulador de eventos de clique chamado Button_Click. O caminho do arquivo precisa ser alterado para um arquivo de saída no computador.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.IO.Stream.Close%2A> é chamado, o identificador também é fechado e a contagem de identificadores do arquivo é reduzida.  
  
 `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A> antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> não é um campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.IO.Stream.Close%2A> é chamado, o identificador também é fechado e a contagem de identificadores do arquivo é reduzida.  
  
 `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A> antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> não é um campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o modo de criação e o caminho especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O construtor receber acesso de leitura/gravação para o arquivo e ele é aberto no compartilhamento de acesso de leitura (ou seja, as solicitações para abrir o arquivo para gravação por este ou outro processo falharão até que o `FileStream` objeto foi fechado, mas as tentativas de leitura será bem-sucedida).  
  
 Você não pode usar esse construtor para abrir arquivos somente leitura; em vez disso, você deve usar um construtor que aceite um `FileAccess` parâmetro com o valor definido `FileAccess.Read`.  
  
 O tamanho do buffer é definido como o tamanho padrão de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
 Para construtores sem um <xref:System.IO.FileAccess> parâmetro, se o `mode` parâmetro está definido como <xref:System.IO.FileMode.Append>, <xref:System.IO.FileAccess.Write> é o acesso padrão. Caso contrário, o acesso é definido como <xref:System.IO.FileAccess.ReadWrite>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contém um valor inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante <see cref="T:System.IO.FileAccess" /> que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada e tamanho do buffer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A> antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador. Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="handle" /> é um identificador inválido.  
  
 -ou-  
  
 O parâmetro <paramref name="handle" /> é um identificador síncrono e foi usado assincronamente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="bufferSize" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Enumerações associadas:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> se o identificador de arquivo será de propriedade dessa instância <see langword="FileStream" />; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação especificada e a propriedade da instância <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileStream` objeto recebe acesso especificado para o arquivo. A propriedade do identificador será conforme especificado. Se esse processo possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A> método também fechará a alça e contagem de identificadores do arquivo é reduzida. O `FileStream` objeto tem o tamanho do buffer padrão de 4096 bytes.  
  
 `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A> antes usando o identificador e evite chamar métodos diferentes de `Close` depois que você usando o identificador.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="access" /> não é um campo de <see cref="T:System.IO.FileAccess" />.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" />é <see langword="true" /> se <c>caminho</c> Especifica um arquivo de disco.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação e a permissão de leitura/gravação especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O construtor receber acesso de leitura/gravação para o arquivo e ele é aberto no compartilhamento de acesso de leitura (ou seja, as solicitações para abrir o arquivo para gravação por este ou outro processo falharão até que o `FileStream` objeto foi fechado, mas as tentativas de leitura será bem-sucedida). O tamanho do buffer é definido como o tamanho padrão de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contém um valor inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (Microsoft.Win32.SafeHandles.SafeFileHandle handle, System.IO.FileAccess access, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class Microsoft.Win32.SafeHandles.SafeFileHandle handle, valuetype System.IO.FileAccess access, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(Microsoft.Win32.SafeHandles.SafeFileHandle,System.IO.FileAccess,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="Microsoft.Win32.SafeHandles.SafeFileHandle" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que este objeto <see langword="FileStream" /> encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="isAsync">
          <see langword="true" /> se o identificador foi aberto assincronicamente (isto é, no modo E/S sobreposto), caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo, com a permissão de leitura/gravação, o tamanho do buffer e o estado síncrono ou assíncrono especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir o `isAsync` parâmetro `true` para abrir o identificador de arquivo de forma assíncrona. Quando o parâmetro for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, o parâmetro não precisa ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> método. Quando o `isAsync` parâmetro é `false` e chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona.  
  
 `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A> antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador. Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="handle" /> é um identificador inválido.  
  
 -ou-  
  
 O parâmetro <paramref name="handle" /> é um identificador síncrono e foi usado assincronamente.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro <paramref name="bufferSize" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado. Enumerações associadas:<see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que este objeto <see langword="FileStream" /> encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> se o identificador de arquivo será de propriedade dessa instância <see langword="FileStream" />; caso contrário, <see langword="false" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação, a propriedade da instância <see langword="FileStream" /> e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileStream` objeto recebe acesso especificado para o arquivo. A propriedade do identificador será conforme especificado. Se este `FileStream` possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A> método também fechará o identificador. Em particular, a contagem de identificadores do arquivo é reduzida. O `FileStream` objeto tem o tamanho de buffer especificado.  
  
 `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A> antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador. Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" />é <see langword="true" /> se <c>caminho</c> Especifica um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho especificado, o modo de criação, permissão de leitura/gravação e permissões de compartilhamento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O construtor receber acesso de leitura/gravação para o arquivo e ele é aberto no compartilhamento de acesso de leitura (ou seja, as solicitações para abrir o arquivo para gravação por este ou outro processo falharão até que o `FileStream` objeto foi fechado, mas as tentativas de leitura será bem-sucedida). O tamanho do buffer é definido como o tamanho padrão de 4096 bytes (4 KB).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#2)]
 [!code-csharp[System.IO.FileStream3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#2)]
 [!code-vb[System.IO.FileStream3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O sistema está executando o Windows 98 ou o Windows 98 Second Edition e <paramref name="share" /> está definido como <see langword="FileShare.Delete" />.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> contém um valor inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (IntPtr handle, System.IO.FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(native int handle, valuetype System.IO.FileAccess access, bool ownsHandle, int32 bufferSize, bool isAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.IntPtr,System.IO.FileAccess,System.Boolean,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="isAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="handle">Um identificador de arquivo para o arquivo que este objeto <see langword="FileStream" /> encapsulará.</param>
        <param name="access">Uma constante que define as propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />.</param>
        <param name="ownsHandle">
          <see langword="true" /> se o identificador de arquivo será de propriedade dessa instância <see langword="FileStream" />; caso contrário, <see langword="false" />.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="isAsync">
          <see langword="true" /> se o identificador foi aberto assincronicamente (isto é, no modo E/S sobreposto), caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> para o identificador de arquivo especificado, com a permissão de leitura/gravação, a propriedade da instância <see langword="FileStream" />, o tamanho do buffer e o estado síncrono ou assíncrono especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileStream` objeto recebe acesso especificado para o arquivo. A propriedade do identificador será conforme especificado. Se este `FileStream` possui o identificador, uma chamada para o <xref:System.IO.Stream.Close%2A> método também fechará o identificador. Em particular, a contagem de identificadores do arquivo é reduzida. O `FileStream` objeto tem o tamanho de buffer especificado.  
  
 `FileStream`pressupõe-se de que tem controle exclusivo sobre o identificador. Leitura, gravação ou busca durante um `FileStream` também está mantendo um identificador pode resultar em corrupção de dados. Proteção de dados, para chamar <xref:System.IO.FileStream.Flush%2A> antes usando o identificador e evite chamar qualquer método que `Close` depois que você usando o identificador. Como alternativa, leitura e gravação para o identificador antes de chamar esse `FileStream` construtor.  
  
 `FileShare.Read`é o padrão para aqueles <xref:System.IO.FileStream> construtores sem um `FileShare` parâmetro.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="access" /> é menor que <see langword="FileAccess.Read" /> ou maior que <see langword="FileAccess.ReadWrite" /> ou <paramref name="bufferSize" /> é menor ou igual a 0.</exception>
        <exception cref="T:System.ArgumentException">O manipulador é inválido.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como um erro de disco.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o identificador de arquivo especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" /> e o identificador de arquivo está definido para o acesso somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acessar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" />é <see langword="true" /> se <c>caminho</c> Especifica um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, as permissões de leitura/gravação e compartilhamento e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é negativo ou zero.  
  
 -ou-  
  
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O sistema está executando o Windows 98 ou o Windows 98 Second Edition e <paramref name="share" /> está definido como <see langword="FileShare.Delete" />.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, bool useAsync);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, bool useAsync) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="useAsync" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" />é <see langword="true" /> se <c>caminho</c> Especifica um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="useAsync">Especifica se é necessário usar E/S síncrona ou assíncrona. No entanto, observe que o sistema operacional subjacente pode não dar suporte a E/S assíncrona, então, ao especificar <see langword="true" />, o identificador poderá ser aberto sincronicamente, dependendo da plataforma. Quando aberto de forma assíncrona, os métodos <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> e <see cref="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> executam melhor em leituras ou gravações grandes, mas podem ser muito mais lentos em leituras ou gravações pequenas. Se o aplicativo é projetado para tirar proveito de e/s assíncrona, defina o <c>useAsync</c> parâmetro <see langword="true" />. Usar E/S assíncrona corretamente pode acelerar os aplicativos em até um fator de 10, mas usá-la sem recriar o aplicativo para E/S assíncrona pode diminuir o desempenho em até um fator de 10.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho especificado, o modo de criação, leitura/gravação e permissões de compartilhamento, tamanho do buffer e estado síncrono ou assíncrono.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo de maneira assíncrona e, em seguida, verifique se que os dados foram gravados corretamente. Um `State` objeto é criado para passar informações do thread principal para o `EndReadCallback` e `EndWriteCallback` métodos.  
  
 [!code-cpp[System.IO.FileStream2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é negativo ou zero.  
  
 -ou-  
  
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O sistema está executando o Windows 98 ou o Windows 98 Second Edition e <paramref name="share" /> está definido como <see langword="FileShare.Delete" />.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see langword="FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="access">Uma constante que determina como o arquivo pode ser acessado pelo objeto <see langword="FileStream" />. Isso também determina os valores retornados pelas propriedades <see cref="P:System.IO.FileStream.CanRead" /> e <see cref="P:System.IO.FileStream.CanWrite" /> do objeto <see langword="FileStream" />. <see cref="P:System.IO.FileStream.CanSeek" />é <see langword="true" /> se <c>caminho</c> Especifica um arquivo de disco.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="options">Um valor que especifica as opções de arquivo adicionais.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, a permissão de compartilhamento e leitura/gravação, o acesso que outros FileStreams podem ter ao mesmo arquivo, o tamanho do buffer e as opções de arquivo adicionais especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 O `fileOptions` parâmetro é usado para fornecer acesso a operações mais avançadas que podem ser utilizados durante a criação de um <xref:System.IO.FileStream> objeto.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir grava dados em um arquivo e, em seguida, lê os dados usando o <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor1/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor1/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é negativo ou zero.  
  
 -ou-  
  
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.  
  
 -ou-  
  
 <see cref="F:System.IO.FileOptions.Encrypted" /> é especificado para <paramref name="options" />, mas a criptografia de arquivo não tem suporte na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="rights">Uma constante que determina os direitos de acesso a serem usados ao criar regras de acesso e auditoria para o arquivo.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="options">Uma constante que especifica opções de arquivo adicionais.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, os direitos de acesso e a permissão de compartilhamento, o tamanho do buffer e as opções de arquivo adicionais especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Use este <xref:System.IO.FileStream.%23ctor%2A> construtor para aplicar o acesso de direitos no ponto de criação de um arquivo. Para acessar ou modificar os direitos em um arquivo existente, considere o uso de <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 O `fileOptions` parâmetro é usado para fornecer acesso a operações mais avançadas que podem ser utilizados durante a criação de um <xref:System.IO.FileStream> objeto.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é negativo ou zero.  
  
 -ou-  
  
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.  
  
 -ou-  
  
 <see cref="F:System.IO.FileOptions.Encrypted" /> é especificado para <paramref name="options" />, mas a criptografia de arquivo não tem suporte na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O <paramref name="path" /> especificado, o nome de arquivo ou ambos ultrapassam o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FileStream (string path, System.IO.FileMode mode, System.Security.AccessControl.FileSystemRights rights, System.IO.FileShare share, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.IO.FileMode mode, valuetype System.Security.AccessControl.FileSystemRights rights, valuetype System.IO.FileShare share, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.#ctor(System.String,System.IO.FileMode,System.Security.AccessControl.FileSystemRights,System.IO.FileShare,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="rights" Type="System.Security.AccessControl.FileSystemRights" />
        <Parameter Name="share" Type="System.IO.FileShare" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho relativo ou absoluto para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsulará.</param>
        <param name="mode">Uma constante que determina como abrir ou criar o arquivo.</param>
        <param name="rights">Uma constante que determina os direitos de acesso a serem usados ao criar regras de acesso e auditoria para o arquivo.</param>
        <param name="share">Uma constante que determina como o arquivo será compartilhado pelos processos.</param>
        <param name="bufferSize">Um valor <see cref="T:System.Int32" /> positivo maior que 0, indicando o tamanho do buffer. O tamanho do buffer padrão é 4096.</param>
        <param name="options">Uma constante que especifica opções de arquivo adicionais.</param>
        <param name="fileSecurity">Uma constante que determina o controle de acesso e a segurança de auditoria para o arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.FileStream" /> com o caminho, o modo de criação, os direitos de acesso e a permissão de compartilhamento, o tamanho do buffer, as opções de arquivo adicionais, o controle de acesso e a segurança de auditoria especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework não dá suporte a acesso direto ao discos físicos por meio de caminhos que são nomes de dispositivo, como "\\\\. \PHYSICALDRIVE0".  
  
 Use este <xref:System.IO.FileStream.%23ctor%2A> construtor para aplicar o acesso de direitos no ponto de criação de um arquivo. Para acessar ou modificar os direitos em um arquivo existente, considere o uso de <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> métodos.  
  
 O `fileOptions` parâmetro é usado para fornecer acesso a operações mais avançadas que podem ser utilizados durante a criação de um <xref:System.IO.FileStream> objeto.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
> [!NOTE]
>  `path`não é necessário ser um arquivo armazenado em disco. pode ser qualquer parte de um sistema que dá suporte ao acesso por meio de fluxos. Por exemplo, dependendo do sistema, essa classe pode acessar um dispositivo físico.  
  
 <xref:System.IO.Stream.CanSeek%2A>é `true` para todos os <xref:System.IO.FileStream> objetos que encapsulam os arquivos. Se `path` indica um dispositivo que não dá suporte para busca, o <xref:System.IO.FileStream.CanSeek%2A> propriedade resultante <xref:System.IO.FileStream> é `false`. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A>.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir grava dados em um arquivo e, em seguida, lê os dados usando o <xref:System.IO.FileStream> objeto.  
  
 [!code-cpp[IO.FileStream.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.FileStream.ctor2/cpp/example.cpp#1)]
 [!code-csharp[IO.FileStream.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.FileStream.ctor2/CS/example.cs#1)]
 [!code-vb[IO.FileStream.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.FileStream.ctor2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia (“”), contém somente espaços em branco ou contém um ou mais caracteres inválidos.  
  
 -ou-  
  
 <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente NTFS.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> refere-se a um dispositivo não de arquivo, como "con:", "com1:", "lpt1:", etc. em um ambiente não NTFS.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é negativo ou zero.  
  
 -ou-  
  
 <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> contém um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não é possível localizar o arquivo, por exemplo, quando <paramref name="mode" /> é <see langword="FileMode.Truncate" /> ou <see langword="FileMode.Open" /> e o arquivo especificado por <paramref name="path" /> não existe. O arquivo já deve existir em um desses modos.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como especificar <see langword="FileMode.CreateNew" /> quando o arquivo especificado por <paramref name="path" /> já existe.  
  
 -ou-  
  
 O fluxo foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O <paramref name="access" /> solicitado não é permitido pelo sistema operacional para o <paramref name="path" /> especificado, como quando <paramref name="access" /> é <see langword="Write" /> ou <see langword="ReadWrite" />, e o arquivo ou diretório está configurado para acesso somente leitura.  
  
 -ou-  
  
 <see cref="F:System.IO.FileOptions.Encrypted" /> é especificado para <paramref name="options" />, mas a criptografia de arquivo não tem suporte na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O <paramref name="path" /> especificado, o nome de arquivo ou ambos ultrapassam o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler, gravar e anexadas a arquivos. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" />, e <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginRead">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginRead (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginRead(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O buffer no qual os dados serão lidos.</param>
        <param name="offset">O deslocamento de byte no <c>matriz</c> no qual começar a ler.</param>
        <param name="numBytes">O número máximo de bytes a serem lidos.</param>
        <param name="userCallback">O método a ser chamado quando a operação de leitura assíncrona for concluída.</param>
        <param name="stateObject">Um objeto fornecido pelo usuário que distingue essa solicitação de leitura assíncrona específica de outras solicitações.</param>
        <summary>Inicia uma operação de leitura assíncrona. (Considere o uso de <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em vez disso.)</summary>
        <returns>Um objeto que faz referência à leitura assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginRead%2A> e <xref:System.IO.FileStream.EndRead%2A> para implementar operações de arquivo assíncrono. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar operações de arquivo assíncrono mais facilmente.  
  
 <xref:System.IO.FileStream.EndRead%2A>deve ser chamado apenas uma vez para cada chamada a <xref:System.IO.FileStream.BeginRead%2A>. Falha ao encerrar um processo de leitura antes do início da leitura outra pode causar comportamento indesejado como deadlock.  
  
 <xref:System.IO.FileStream>fornece dois modos diferentes de operação: e/s síncronas e e/s assíncrona. Enquanto um pode ser usado, os recursos do sistema operacional subjacente podem permitir acesso em apenas um desses modos. Por padrão, <xref:System.IO.FileStream> abre o identificador de sistema operacional de forma síncrona. No Windows, isso reduz a velocidade de métodos assíncronos. Se os métodos assíncronos são usados, use o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura. Para obter mais informações, consulte: <xref:System.IO.Stream.CanRead%2A>.  
  
 Se um fluxo está fechado ou se você passar um argumento inválido, as exceções são geradas imediatamente de <xref:System.IO.FileStream.BeginRead%2A>. Erros que ocorrem durante uma solicitação de leitura assíncrona, como uma falha de disco durante a solicitação de e/s, ocorrem no thread do pool e ficam visíveis após uma chamada para <xref:System.IO.FileStream.EndRead%2A>.  
  
 <xref:System.IO.Stream.EndRead%2A>deve ser chamado com esse <xref:System.IAsyncResult> para descobrir o número de bytes foram lidas.  
  
 Várias solicitações assíncronas simultâneas renderizam a ordem de conclusão de solicitação indefinido.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho da matriz menos <paramref name="offset" /> é menor que <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="numBytes" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu uma tentativa de leitura assíncrona após o final do arquivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginWrite">
      <MemberSignature Language="C#" Value="public override IAsyncResult BeginWrite (byte[] array, int offset, int numBytes, AsyncCallback userCallback, object stateObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.IAsyncResult BeginWrite(unsigned int8[] array, int32 offset, int32 numBytes, class System.AsyncCallback userCallback, object stateObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="numBytes" Type="System.Int32" />
        <Parameter Name="userCallback" Type="System.AsyncCallback" />
        <Parameter Name="stateObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O buffer que contém dados a serem gravados no fluxo atual.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <c>matriz</c> no qual começar a copiar bytes para o fluxo atual.</param>
        <param name="numBytes">O número máximo de bytes a serem gravados.</param>
        <param name="userCallback">O método a ser chamado quando a operação de gravação assíncrona for concluída.</param>
        <param name="stateObject">Um objeto fornecido pelo usuário que distingue essa solicitação de gravação assíncrona específica de outras solicitações.</param>
        <summary>Inicia uma operação de gravação assíncrona. (Considere o uso de <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em vez disso.)</summary>
        <returns>Um objeto que faz referência à gravação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginWrite%2A> e <xref:System.IO.FileStream.EndWrite%2A> para implementar operações de arquivo assíncrono. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar operações de arquivo assíncrono mais facilmente.  
  
 <xref:System.IO.FileStream.EndWrite%2A>deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A>será bloqueado até que a operação de e/s foi concluída.  
  
 Este método substitui <xref:System.IO.Stream.BeginWrite%2A>.  
  
 <xref:System.IO.FileStream>fornece dois modos diferentes de operação: e/s síncronas e e/s assíncrona. Enquanto um pode ser usado, os recursos do sistema operacional subjacente podem permitir acesso em apenas um desses modos. Por padrão, <xref:System.IO.FileStream> abre o identificador de sistema operacional de forma síncrona. No Windows, isso reduz a velocidade de métodos assíncronos. Se os métodos assíncronos são usados, use o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 Se um fluxo está fechado ou se você passar um argumento inválido, as exceções são geradas imediatamente de <xref:System.IO.FileStream.BeginWrite%2A>. Erros que ocorrem durante uma solicitação de gravação assíncrona, como uma falha de disco durante a solicitação de e/s, ocorrem no thread do pool e ficam visíveis após uma chamada para <xref:System.IO.FileStream.EndWrite%2A>.  
  
 Várias solicitações assíncronas simultâneas renderizam a ordem de conclusão de solicitação indefinido.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          O tamanho de <paramref name="array" /> menos <paramref name="offset" /> é menor que <paramref name="numBytes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="numBytes" /> é negativo.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanRead">
      <MemberSignature Language="C#" Value="public override bool CanRead { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRead" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanRead" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte à leitura.</summary>
        <value>
          <see langword="true" /> se o fluxo dá suporte à leitura; <see langword="false" /> se o fluxo está fechado ou foi aberto com acesso somente gravação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não dá suporte para leitura, chamadas para o <xref:System.IO.FileStream.Read%2A>, <xref:System.IO.FileStream.ReadByte%2A>, e <xref:System.IO.FileStream.BeginRead%2A> métodos lançam uma <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra um uso de `CanRead` propriedade. A saída desse código é "MyFile.txt não é gravável." Para obter a mensagem de saída "MyFile.txt pode ser gravado e leiam.", altere o `FileAccess` parâmetro `ReadWrite` no `FileStream` construtor.  
  
 [!code-cpp[Classic FileStream.CanRead Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanRead Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanRead Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanRead Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSeek">
      <MemberSignature Language="C#" Value="public override bool CanSeek { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSeek" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanSeek" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte à busca.</summary>
        <value>
          <see langword="true" /> se o fluxo der suporte à busca; <see langword="false" /> se o fluxo estiver fechado ou se o <see langword="FileStream" /> tiver sido construído de um identificador de sistema operacional, como um pipe ou uma saída para o console.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não dá suporte para busca, chamadas para <xref:System.IO.FileStream.Length%2A>, <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Position%2A>, e <xref:System.IO.FileStream.Seek%2A> lançar um <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir usa o `CanSeek` propriedade para verificar se um fluxo oferece suporte à busca.  
  
 [!code-cpp[fstream canseek#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanSeek/CPP/fstream canseek.cpp#1)]
 [!code-csharp[fstream canseek#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanSeek/CS/fstream canseek.cs#1)]
 [!code-vb[fstream canseek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanSeek/VB/fstream canseek.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanWrite">
      <MemberSignature Language="C#" Value="public override bool CanWrite { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanWrite" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.CanWrite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o fluxo atual dá suporte à gravação.</summary>
        <value>
          <see langword="true" /> se o fluxo der suporte à gravação; <see langword="false" /> se o fluxo estiver fechado ou tiver sido aberto com acesso somente leitura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma classe derivada de <xref:System.IO.Stream> não oferece suporte à gravação, uma chamada para <xref:System.IO.FileStream.SetLength%2A>, <xref:System.IO.FileStream.Write%2A>, <xref:System.IO.FileStream.BeginWrite%2A>, ou <xref:System.IO.FileStream.WriteByte%2A> lança um <xref:System.NotSupportedException>.  
  
 Se o fluxo está fechado, essa propriedade retornará `false`.  
  
   
  
## Examples  
 O exemplo a seguir usa o `CanWrite` propriedade para verificar se um fluxo oferece suporte à gravação.  
  
 [!code-cpp[fstream canwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/FStream CanWrite/CPP/fstream canwrite.cpp#1)]
 [!code-csharp[fstream canwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/FStream CanWrite/CS/fstream canwrite.cs#1)]
 [!code-vb[fstream canwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FStream CanWrite/VB/fstream canwrite.vb#1)]  
  
 A seguir está um exemplo usando o `CanWrite` propriedade. A saída desse código é "MyFile.txt é gravável." Para obter a mensagem de saída "MyFile.txt pode ser gravado e leiam.", altere o `FileAccess` parâmetro `ReadWrite` no `FileStream` construtor.  
  
 [!code-cpp[Classic FileStream.CanWrite Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.CanWrite Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.CanWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.CanWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.IO.FileStream" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público <xref:System.ComponentModel.Component.Dispose%2A> e pelo método <xref:System.Object.Finalize%2A>. <xref:System.ComponentModel.Component.Dispose%2A> invoca o método <xref:System.IO.FileStream.Dispose%2A> protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca <xref:System.IO.FileStream.Dispose%2A> com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.IO.FileStream> referências. Este método invoca o método <xref:System.ComponentModel.Component.Dispose%2A> de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.ComponentModel.Component.Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" /> cuidado para não fazer referência a objetos que têm foi descartados anteriormente em uma chamada anterior para <see cref="M:System.ComponentModel.Component.Dispose" />. Para obter mais informações sobre como implementar <see cref="M:System.IO.FileStream.Dispose(System.Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see cref="M:System.ComponentModel.Component.Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndRead">
      <MemberSignature Language="C#" Value="public override int EndRead (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 EndRead(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndRead(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A referência à solicitação assíncrona pendente que deverá ser aguardada.</param>
        <summary>Aguarda a operação de leitura assíncrona pendente ser concluída. (Considere o uso de <see cref="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em vez disso.)</summary>
        <returns>O número de bytes lidos do fluxo, entre 0 e o número de bytes solicitado. Os fluxos retornam somente 0 no final do fluxo, caso contrário, eles devem ser bloqueados até que pelo menos 1 byte esteja disponível.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginRead%2A> e <xref:System.IO.FileStream.EndRead%2A> para implementar operações de arquivo assíncrono. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar operações de arquivo assíncrono mais facilmente.  
  
 <xref:System.IO.FileStream.EndRead%2A>deve ser chamado exatamente para todas as chamadas para <xref:System.IO.FileStream.BeginRead%2A>. Falha ao encerrar um processo de leitura antes do início da leitura outra pode causar comportamento indesejado como deadlock.  
  
 Este método substitui <xref:System.IO.Stream.EndRead%2A>.  
  
 <xref:System.IO.FileStream.EndRead%2A>pode ser chamado em cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginRead%2A>. Chamando <xref:System.IO.FileStream.EndRead%2A> indica quantos bytes foram lidos no fluxo. <xref:System.IO.FileStream.EndRead%2A>será bloqueado até que a operação de e/s foi concluída.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> não foi criado chamando <see cref="M:System.IO.FileStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nesta classe.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndRead(System.IAsyncResult)" /> é chamado várias vezes.</exception>
        <exception cref="T:System.IO.IOException">O fluxo está fechado ou ocorreu um erro interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndWrite">
      <MemberSignature Language="C#" Value="public override void EndWrite (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void EndWrite(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">A solicitação de E/S assíncrona pendente.</param>
        <summary>Termina uma operação de gravação assíncrona e bloqueia até que a operação de E/S seja concluída. (Considere o uso de <see cref="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" /> em vez disso.)</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O .NET Framework 4 e versões anteriores, você precisa usar métodos como <xref:System.IO.FileStream.BeginWrite%2A> e <xref:System.IO.FileStream.EndWrite%2A> para implementar operações de arquivo assíncrono. Esses métodos ainda estão disponíveis no [!INCLUDE[net_v45](~/includes/net-v45-md.md)] para dar suporte a código herdado; no entanto, os novos métodos assíncronos, tais como <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, <xref:System.IO.Stream.CopyToAsync%2A>, e <xref:System.IO.FileStream.FlushAsync%2A>, ajudam a implementar operações de arquivo assíncrono mais facilmente.  
  
 Este método substitui <xref:System.IO.Stream.EndWrite%2A>.  
  
 <xref:System.IO.FileStream.EndWrite%2A>deve ser chamado apenas uma vez em cada <xref:System.IAsyncResult> de <xref:System.IO.FileStream.BeginWrite%2A>. <xref:System.IO.FileStream.EndWrite%2A>será bloqueado até que a operação de e/s foi concluída.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#3)]
 [!code-csharp[System.IO.FileStream2#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#3)]
 [!code-vb[System.IO.FileStream2#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Este objeto <see cref="T:System.IAsyncResult" /> não foi criado chamando <see cref="M:System.IO.Stream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)" /> nesta classe.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.IO.FileStream.EndWrite(System.IAsyncResult)" /> é chamado várias vezes.</exception>
        <exception cref="T:System.IO.IOException">O fluxo está fechado ou ocorreu um erro interno.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~FileStream ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que os recursos são liberados e outras operações de limpeza são realizadas quando o coletor de lixo recupera o <see langword="FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O coletor de lixo chama `Finalize` quando o objeto atual está pronto para ser finalizado. `Finalize`Fecha o `FileStream`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public override void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa os buffers desse fluxo e faz com que todos os dados armazenados em buffer sejam gravados no arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Flush%2A?displayProperty=nameWithType>.  
  
 Quando você chama o <xref:System.IO.FileStream.Flush%2A?displayProperty=nameWithType> método, o buffer de e/s de sistema de operacional também é liberado.  
  
 Codificador do fluxo não é liberado, a menos que você chamar explicitamente <xref:System.IO.FileStream.Flush%2A> ou descartar o objeto. Configuração <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> para `true` significa que os dados serão liberados do buffer no fluxo, mas o estado de codificador não será liberado. Isso permite que o codificador deve manter o estado (parcial caracteres) para que ele pode codificar o próximo bloco de caracteres corretamente. Este cenário afeta UTF8 e UTF7 onde determinados caracteres podem ser codificados somente depois que o codificador recebe adjacentes ou mais caracteres.  
  
 Como um buffer pode ser usado para ler ou gravar, <xref:System.IO.FileStream.Flush> executa duas funções a seguir:  
  
-   Todos os dados gravados anteriormente para o buffer são copiados para o arquivo e o buffer está desmarcado, exceto o estado do codificador.  
  
-   Se <xref:System.IO.BufferedStream.CanSeek%2A?displayProperty=nameWithType> é `true` e foi anteriormente copiados do arquivo de dados para o buffer de leitura, a posição atual dentro do arquivo é reduzida pelo número de bytes não lidos no buffer. O buffer, em seguida, será limpo.  
  
 Use o <xref:System.IO.FileStream.Flush%28System.Boolean%29> sobrecarga de método quando você deseja garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#4)]
 [!code-csharp[System.IO.FileStream3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#4)]
 [!code-vb[System.IO.FileStream3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public virtual void Flush (bool flushToDisk);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Flush(bool flushToDisk) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Flush(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flushToDisk" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="flushToDisk">
          <see langword="true" /> para limpar todos os buffers de arquivo intermediário; caso contrário, <see langword="false" />.</param>
        <summary>Limpa os buffers desse fluxo e faz com que os dados armazenados em buffer sejam gravados no arquivo e também limpa todos os buffers de arquivo intermediário.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga quando você deseja garantir que todos os dados em buffer nos buffers de arquivo intermediário é gravada no disco.  
  
 Quando você chama o <xref:System.IO.FileStream.Flush%2A> método, o buffer de e/s de sistema de operacional também é liberado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task FlushAsync (System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task FlushAsync(valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.FlushAsync(System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento.</param>
        <summary>Limpa todos os buffers nesse fluxo de forma assíncrona, faz com que os dados armazenados em buffer sejam gravados no dispositivo subjacente e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de liberação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você chama o <xref:System.IO.FileStream.FlushAsync%2A> método, o buffer de e/s de sistema de operacional também é liberado.  
  
 Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade. Se o identificador para o arquivo for descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException> exceção no <xref:System.Threading.Tasks.Task.Exception%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.FileSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.FileSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.GetAccessControl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as entradas da ACL (lista de controle de acesso) do arquivo descrito pelo objeto <see cref="T:System.IO.FileStream" /> atual.</summary>
        <returns>Um objeto que encapsula as configurações de controle de acesso para o arquivo descrito pelo objeto <see cref="T:System.IO.FileStream" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enquanto o <xref:System.IO.FileStream> classe e <xref:System.IO.FileStream.GetAccessControl%2A> pode ser usado para recuperar as entradas de ACL (lista) de controle de acesso de um arquivo existente, considere o uso de <xref:System.IO.File.GetAccessControl%2A?displayProperty=nameWithType> , pois ele é mais fácil de usar.  
  
 Use o <xref:System.IO.FileStream.GetAccessControl%2A> método para recuperar as entradas ACL de um arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas sobre o arquivo especificado. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O arquivo está fechado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public virtual IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use SafeFileHandle instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de arquivo do sistema operacional do arquivo que o objeto <see langword="FileStream" /> atual encapsula.</summary>
        <value>O identificador de arquivo do sistema operacional para o arquivo encapsulado por esse objeto <see langword="FileStream" /> ou -1 se o <see langword="FileStream" /> tiver sido fechado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é um identificador de sistema operacional para uso com chamadas do sistema operacional-fornecido pelo sistema (como `ReadFile` no Windows). Ele não funcionará com funções de biblioteca C que espera um descritor de arquivo, como `fread`.  
  
 O identificador de sistema operacional pode ter sido aberto forma síncrona ou assíncrona, dependendo de qual `FileStream` construtor foi chamado. Use o <xref:System.IO.FileStream.IsAsync%2A> propriedade para descobrir se esse identificador foi aberto de forma assíncrona. No Win32, isso significa que o identificador foi aberto para e/s sobreposta e requer parâmetros diferentes para `ReadFile` e `WriteFile`.  
  
> [!CAUTION]
>  Corrupção de dados pode ocorrer se um `FileStream` é criado, seu identificador é passado, alguma operação Move o ponteiro do arquivo do identificador e, em seguida, o `FileStream` é usado novamente. Vários threads com segurança não é possível gravar no mesmo arquivo simultaneamente, e `FileStream` buffer código pressupõe que ele controla exclusivamente o identificador. `FileStream`poderá gerar um <xref:System.IO.IOException> se `FileStream` detecta que algum outro processo passou o ponteiro do arquivo. Para evitar isso, não grave os dados em uma parte do arquivo que `FileStream` pode ter em buffer e restaurar o ponteiro do arquivo para o local em que estava quando métodos foram chamados pela última vez em `FileStream`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">a capacidade de acessar o código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public virtual bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se <see langword="FileStream" /> foi aberto de forma assíncrona ou síncrona.</summary>
        <value>
          <see langword="true" /> se o <see langword="FileStream" /> tiver sido aberto de forma assíncrona; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `IsAsync` propriedade detecta se o `FileStream` identificador foi aberto de forma assíncrona, permitindo que o seu código para usar o <xref:System.IO.FileStream.Handle%2A> propriedade corretamente. No Win32, `IsAsync` sendo true significa que o identificador foi aberto para e/s sobreposta e, portanto, requer parâmetros diferentes para `ReadFile` e `WriteFile`.  
  
 Especifique esse valor quando você cria uma instância do <xref:System.IO.FileStream> classe usando um construtor que tenha uma `isAsync`, `useAsync`, ou `options` parâmetro. Quando a propriedade for `true`, utiliza o fluxo de e/s sobreposta para executar operações de arquivo de forma assíncrona. No entanto, o <xref:System.IO.FileStream.IsAsync%2A> propriedade não tem que ser `true` para chamar o <xref:System.IO.FileStream.ReadAsync%2A>, <xref:System.IO.FileStream.WriteAsync%2A>, ou <xref:System.IO.Stream.CopyToAsync%2A> método. Quando o <xref:System.IO.FileStream.IsAsync%2A> é de propriedade `false` e chamar a leitura assíncrona e operações de gravação, o thread de interface do usuário ainda não está bloqueado, mas a operação de e/s real é executada de forma síncrona.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#2)]
 [!code-csharp[System.IO.FileStream2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#2)]
 [!code-vb[System.IO.FileStream2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public override long Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Length" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho do fluxo em bytes.</summary>
        <value>Um valor longo que representa o tamanho do fluxo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o `Length` e `Position` propriedades para verificar se há uma condição de fim de arquivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <see cref="P:System.IO.FileStream.CanSeek" /> para esse fluxo é <see langword="false" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S, como o arquivo ser fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public virtual void Lock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Lock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Lock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O início do intervalo a ser bloqueado. O valor desse parâmetro deve ser igual ou maior que zero (0).</param>
        <param name="length">O intervalo a ser bloqueado.</param>
        <summary>Impede que outros processos façam a leitura ou gravação no <see cref="T:System.IO.FileStream" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bloqueio de um intervalo de um fluxo de arquivos oferece os threads do acesso exclusivo travamento do processo para o intervalo do fluxo de arquivo.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como parte de um arquivo de bloqueio para que outro processo não possam acessar essa parte do arquivo, mesmo que ela tenha acesso de leitura/gravação para o arquivo. Execute o programa simultaneamente na janela de comandos diferentes e investigue usando as opções de entrada do console diferente.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> ou <paramref name="length" /> é negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">O arquivo está fechado.</exception>
        <exception cref="T:System.IO.IOException">O processo não pode acessar o arquivo porque outro processo bloqueou uma parte dele.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do <see langword="FileStream" /> que foi passado ao construtor.</summary>
        <value>Uma cadeia de caracteres que é o nome do <see langword="FileStream" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%2CSystem.Boolean%29> construtor.  
  
 [!code-cpp[System.IO.FileStream2#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream2/CPP/source.cpp#4)]
 [!code-csharp[System.IO.FileStream2#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream2/CS/source.cs#4)]
 [!code-vb[System.IO.FileStream2#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream2/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar o caminho. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Position">
      <MemberSignature Language="C#" Value="public override long Position { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 Position" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.Position" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a posição atual desse fluxo.</summary>
        <value>A posição atual do fluxo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Há suporte para busca em qualquer local além do comprimento do fluxo.  Quando você busca além do comprimento do arquivo, o tamanho do arquivo aumenta.  No Microsoft Windows NT e mais recente, os dados adicionados ao final do arquivo são definidos como zero.  No Microsoft Windows 98 ou anterior, os dados adicionados ao final do arquivo não estão definidos como zero, o que significa que excluído anteriormente dados é visível para o fluxo. Definir a posição do fluxo para um valor grande além do fim do fluxo no Windows 98 ou anterior pode resultar em uma exceção seja gerada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o `Length` e `Position` propriedades para verificar se há uma condição de fim de arquivo.  
  
 [!code-cpp[Classic FileStream.Length Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CPP/source.cpp#1)]
 [!code-csharp[Classic FileStream.Length Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic FileStream.Length Example/CS/source.cs#1)]
 [!code-vb[Classic FileStream.Length Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic FileStream.Length Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte à busca.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.  
  
 \- ou -  
  
 A posição foi definida com um valor muito grande após o final do fluxo no Windows 98 ou anterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentativa de definir a posição com um valor negativo.</exception>
        <exception cref="T:System.IO.EndOfStreamException">Tentativa de busca após o término de um fluxo que não dá suporte a essa operação.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Quando este método retorna, contém a matriz de bytes especificada com os valores entre <c>deslocamento</c> e (<c>deslocamento</c> + <c>contagem</c> - 1<c>)</c> substituídos pelos bytes lidos da origem atual.</param>
        <param name="offset">O deslocamento de byte no <c>matriz</c> no qual os bytes de leitura serão colocados.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <summary>Lê um bloco de bytes do fluxo e grava os dados em um buffer específico.</summary>
        <returns>O número total de bytes lidos do buffer. Isso poderá ser menor que o número de bytes solicitado se esse número de bytes não estiver disponível no momento, ou zero, se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Read%2A>.  
  
 O `offset` parâmetro fornece o deslocamento de byte no `array` (o índice de buffer) no qual começar a ler e o `count` parâmetro fornece o número máximo de bytes a ser lido do fluxo. O valor retornado é o número real de bytes lidos ou zero se o fim do fluxo for atingido. Se a operação de leitura for bem-sucedida, a posição atual do fluxo for avançada pelo número de bytes lidos. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.  
  
 O <xref:System.IO.FileStream.Read%2A> método retorna zero somente depois de atingir o final do fluxo. Caso contrário, <xref:System.IO.FileStream.Read%2A> lê sempre pelo menos um byte do fluxo antes de retornar. Se não há dados disponíveis do fluxo após uma chamada para <xref:System.IO.FileStream.Read%2A>, o método será bloqueado até que pelo menos um byte de dados pode ser retornado. Uma implementação está livre para retornar menos bytes que solicitado, mesmo que não foi atingido o fim do fluxo.  
  
 Use <xref:System.IO.BinaryReader> para ler tipos de dados primitivos.  
  
 Não interrompa um thread que está executando uma operação de leitura. Embora o aplicativo pode parecer com êxito depois que o thread está desbloqueado, a interrupção pode diminuir o desempenho e a confiabilidade do seu aplicativo.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir lê o conteúdo de um <xref:System.IO.FileStream> e grava-o em outro <xref:System.IO.FileStream>.  
  
 [!code-csharp[FSRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/FSRead/CS/fsread.cs#1)]
 [!code-vb[FSRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FSRead/VB/fsread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> e <paramref name="count" /> descrevem um intervalo inválido em <paramref name="array" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer no qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de byte no <c>buffer</c> no qual começar a gravar dados no fluxo.</param>
        <param name="count">O número máximo de bytes a serem lidos.</param>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento.</param>
        <summary>Lê de forma assíncrona uma sequência de bytes do fluxo atual, avança a posição no fluxo até o número de bytes lidos e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de bytes lidos no buffer. O valor do resultado poderá ser menor que o número de bytes solicitados se o número de bytes disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo foi atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream.ReadAsync%2A> método permite que você execute operações de arquivos de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.FileStream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade. Se o identificador para o arquivo for descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException> exceção no <xref:System.Threading.Tasks.Task.Exception%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como ler de um arquivo de forma assíncrona.  
  
 [!code-csharp[Asynchronous_File_IO_async#4](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example4.cs#4)]
 [!code-vb[Asynchronous_File_IO_async#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadByte">
      <MemberSignature Language="C#" Value="public override int ReadByte ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadByte() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.ReadByte" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê um byte do arquivo e avança a posição de leitura em um byte.</summary>
        <returns>O byte, convertido em um <see cref="T:System.Int32" />, ou -1 se o final do fluxo foi atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.ReadByte%2A>.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanRead%2A> propriedade para determinar se a instância atual oferece suporte à leitura. Para obter mais informações, consulte: <xref:System.IO.Stream.CanRead%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para a leitura no fluxo atual.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo atual está fechado.</exception>
        <block subset="none" type="overrides">
          <para>A implementação padrão em <see langword="Stream" /> cria uma nova matriz de byte único e, em seguida, chama <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" />. Enquanto estiver formalmente correto, é ineficiente. Qualquer fluxo com um buffer interno deve substituir este método e fornecer uma versão muito mais eficiente do que lê o buffer diretamente, evitando a alocação de matriz extra em cada chamada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SafeFileHandle">
      <MemberSignature Language="C#" Value="public virtual Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeFileHandle SafeFileHandle" />
      <MemberSignature Language="DocId" Value="P:System.IO.FileStream.SafeFileHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeFileHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" /> que representa o identificador de arquivo do sistema operacional para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsula.</summary>
        <value>Um objeto que representa o identificador de arquivo do sistema operacional para o arquivo que o objeto <see cref="T:System.IO.FileStream" /> atual encapsula.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream.SafeFileHandle%2A> propriedade automaticamente libera o fluxo e define a posição do fluxo atual como 0.  Isso permite que o arquivo a ser movido ou a posição de fluxo a ser redefinido por meio de outro fluxo de <xref:System.IO.FileStream.SafeFileHandle%2A> retornado por essa propriedade.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">permissão chamar código não gerenciado.  
  
 Ação de segurança: demanda de Link  
  
 Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public override long Seek (long offset, System.IO.SeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 Seek(int64 offset, valuetype System.IO.SeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">O ponto relativo a <c>origem</c> no qual iniciar a busca.</param>
        <param name="origin">Especifica o início, fim ou a posição atual como um ponto de referência para <c>deslocamento</c>, usando um valor do tipo <see cref="T:System.IO.SeekOrigin" />.</param>
        <summary>Define a posição atual do fluxo para o valor especificado.</summary>
        <returns>A nova posição no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Seek%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanSeek%2A?displayProperty=nameWithType> propriedade para determinar se a instância atual oferece suporte à busca. Para obter mais informações, consulte: <xref:System.IO.Stream.CanSeek%2A?displayProperty=nameWithType>.  
  
 Você pode pesquisar em qualquer local além do comprimento do fluxo. Quando você busca além do comprimento do arquivo, o tamanho do arquivo aumenta. No Windows NT e versões posteriores, os dados adicionados ao final do arquivo são definidos como zero. No Windows 98 ou versões anteriores, os dados adicionados ao final do arquivo não são definidos como zero, o que significa que excluído anteriormente dados é visível para o fluxo.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 O exemplo a seguir lê o texto na direção inversa, do final do arquivo para o início do arquivo, usando os vários <xref:System.IO.SeekOrigin> valores com o <xref:System.IO.FileStream.Seek%2A> método.  
  
 [!code-csharp[System.IO.FileStream.Seek#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.filestream.seek/cs/source.cs#1)]
 [!code-vb[System.IO.FileStream.Seek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.filestream.seek/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte a busca, como se o <see langword="FileStream" /> fosse construído por meio de uma saída do console ou pipe.</exception>
        <exception cref="T:System.ArgumentException">A busca é tentada antes do início do fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">Foram chamados métodos depois que o fluxo foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetAccessControl(System.Security.AccessControl.FileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="fileSecurity">Um objeto que descreve uma entrada ACL para aplicar ao arquivo atual.</param>
        <summary>Aplica-se a entradas ACL (Lista de Controle de Acesso) descritas por um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> para o arquivo descrito pelo objeto <see cref="T:System.IO.FileStream" /> atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enquanto o <xref:System.IO.FileStream> classe e <xref:System.IO.FileStream.SetAccessControl%2A> pode ser usado em um arquivo existente, considere usar o <xref:System.IO.File.SetAccessControl%2A?displayProperty=nameWithType> método como ela é mais fácil de usar.  
  
 O <xref:System.IO.FileStream.SetAccessControl%2A> método se aplica a entradas ACL (lista) de controle de acesso a um arquivo que representa a lista ACL noninherited.  
  
> [!CAUTION]
>  A ACL especificado para o `fileSecurity` parâmetro substitui a ACL existente para o arquivo. Para adicionar permissões para um novo usuário, use o <xref:System.IO.FileStream.GetAccessControl%2A> método para obter a ACL existente, modificá-lo e, em seguida, usar <xref:System.IO.FileStream.SetAccessControl%2A> para aplicá-lo de volta para o arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas sobre o arquivo especificado. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O arquivo está fechado.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="fileSecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">O arquivo não pôde ser encontrado ou modificado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O processo atual não tem acesso para abrir o arquivo.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetLength">
      <MemberSignature Language="C#" Value="public override void SetLength (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void SetLength(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.SetLength(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo tamanho do fluxo.</param>
        <summary>Define o tamanho deste fluxo para o valor especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.SetLength%2A>.  
  
 Se o valor especificado é menor que o tamanho atual do fluxo, o fluxo é truncado. Nesse cenário, se a posição atual é maior do que o novo tamanho, a posição atual é movida para o último byte do fluxo. Se o valor especificado é maior que o tamanho atual do fluxo, o fluxo é expandido e a posição atual permanece o mesmo. Se o fluxo é expandido, o conteúdo do fluxo entre o antigo e o novo comprimento é indefinido.  
  
 Um fluxo deve dão suporte a gravação e busca de `SetLength` para trabalhar.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação e o <xref:System.IO.FileStream.CanSeek%2A> propriedade para determinar se a busca é suportada. Para obter mais informações, consulte <xref:System.IO.Stream.CanWrite%2A> e <xref:System.IO.Stream.CanSeek%2A>.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">O fluxo não dá suporte para gravação e busca.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentativa de definir o parâmetro <paramref name="value" /> como menos que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public virtual void Unlock (long position, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Unlock(int64 position, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Unlock(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="position">O início do intervalo a ser desbloqueado.</param>
        <param name="length">O intervalo a ser desbloqueado.</param>
        <summary>Permite o acesso por outros processos a todo ou parte de um arquivo que foi bloqueado anteriormente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como parte de um arquivo de bloqueio para que outro processo não pode acessar essa parte do arquivo, mesmo que ela tenha acesso de leitura/gravação para o arquivo e, em seguida, desbloqueie a parte especificada do arquivo. Execute o programa simultaneamente na janela de comandos diferentes e investigue usando as opções de entrada do console diferente.  
  
 [!code-cpp[System.IO.FileStream3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#1)]
 [!code-csharp[System.IO.FileStream3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#1)]
 [!code-vb[System.IO.FileStream3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="position" /> ou <paramref name="length" /> é negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public override void Write (byte[] array, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Write(unsigned int8[] array, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O buffer que contém dados a serem gravados no fluxo.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <c>matriz</c> da qual começar a copiar bytes para o fluxo.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <summary>Grava um bloco de bytes no fluxo de arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.Write%2A>.  
  
 O `offset` parâmetro fornece o deslocamento de byte no `array` (o índice de buffer) no qual começar a copiar e o `count` parâmetro retorna o número de bytes que serão gravados no fluxo. Se a operação de gravação for bem-sucedida, a posição atual do fluxo for avançada pelo número de bytes gravados. Se ocorrer uma exceção, a posição atual do fluxo está inalterada.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação. Para obter mais informações, consulte: <xref:System.IO.Stream.CanWrite%2A>.  
  
 Não interrompa um thread que está executando uma operação de gravação. Embora o aplicativo pode parecer com êxito depois que o thread está desbloqueado, a interrupção pode diminuir o desempenho e a confiabilidade do seu aplicativo.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.IO.FileStream.Lock%2A> método.  
  
 [!code-cpp[System.IO.FileStream3#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream3/CPP/fstreamlock.cpp#3)]
 [!code-csharp[System.IO.FileStream3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream3/CS/fstreamlock.cs#3)]
 [!code-vb[System.IO.FileStream3#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream3/VB/fstreamlock.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="offset" /> e <paramref name="count" /> descrevem um intervalo inválido em <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.  
  
 \- ou -  
  
 Outro thread pode ter causado uma alteração inesperada na posição do identificador de arquivo do sistema operacional.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
        <exception cref="T:System.NotSupportedException">A instância de fluxo atual não dá suporte à gravação.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteAsync (byte[] buffer, int offset, int count, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteAsync(unsigned int8[] buffer, int32 offset, int32 count, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer do qual os dados serão gravados.</param>
        <param name="offset">O deslocamento de bytes baseado em zero em <c>buffer</c> da qual começar a copiar bytes para o fluxo.</param>
        <param name="count">O número máximo de bytes a serem gravados.</param>
        <param name="cancellationToken">O token a se monitorar para solicitações de cancelamento.</param>
        <summary>Grava uma sequência de bytes no fluxo atual assincronamente, avança a posição atual dentro desse fluxo pelo número de bytes gravados e monitora as solicitações de cancelamento.</summary>
        <returns>Uma tarefa que representa a operação de gravação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream.WriteAsync%2A> método permite que você execute operações de arquivos de uso intensivo de recursos sem bloquear o thread principal. A consideração de desempenho é particularmente importante em uma [!INCLUDE[win8_appname_long](~/includes/win8-appname-long-md.md)] aplicativo ou [!INCLUDE[desktop_appname](~/includes/desktop-appname-md.md)] aplicativo em que uma operação demorada fluxo pode bloquear o thread de interface do usuário e tornar seu aplicativo aparecem como se ele não está funcionando. Os métodos assíncronos são usados em conjunto com o `async` e `await` palavras-chave no Visual Basic e c#.  
  
 Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à leitura.  
  
 Se a operação foi cancelada antes da conclusão, a tarefa retornada contém o <xref:System.Threading.Tasks.TaskStatus.Canceled> valor para o <xref:System.Threading.Tasks.Task.Status%2A> propriedade. Se o identificador para o arquivo for descartado, a tarefa retornada contém o <xref:System.ObjectDisposedException> exceção no <xref:System.Threading.Tasks.Task.Exception%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir mostra como gravar em um arquivo de forma assíncrona.  
  
 [!code-csharp[Asynchronous_File_IO_async#3](~/samples/snippets/csharp/VS_Snippets_CLR/Asynchronous_File_IO_async/cs/example3.cs#3)]
 [!code-vb[Asynchronous_File_IO_async#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Asynchronous_File_IO_async/vb/example3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="offset" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O fluxo está em uso no momento por uma operação de gravação anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteByte">
      <MemberSignature Language="C#" Value="public override void WriteByte (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteByte(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.FileStream.WriteByte(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Um byte a ser gravado no fluxo.</param>
        <summary>Grava um byte na posição atual no fluxo de arquivos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.Stream.WriteByte%2A>.  
  
 Use `WriteByte` para gravar um byte para um `FileStream` com eficiência. Se o fluxo está fechado ou não gravável, uma exceção será lançada.  
  
> [!NOTE]
>  Use o <xref:System.IO.FileStream.CanWrite%2A> propriedade para determinar se a instância atual oferece suporte à gravação. Para obter mais informações, consulte: <xref:System.IO.Stream.CanWrite%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como gravar dados em um arquivo, byte por byte e, em seguida, verifique se que os dados foram gravados corretamente.  
  
 [!code-cpp[System.IO.FileStream1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.FileStream1/CPP/source.cpp#1)]
 [!code-csharp[System.IO.FileStream1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.FileStream1/CS/source.cs#1)]
 [!code-vb[System.IO.FileStream1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.FileStream1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo está fechado.</exception>
        <exception cref="T:System.NotSupportedException">Não há suporte para gravação no fluxo.</exception>
        <block subset="none" type="overrides">
          <para>A implementação padrão em <see langword="Stream" /> cria uma nova matriz de byte único e, em seguida, chama <see cref="M:System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)" />. Enquanto estiver formalmente correto, é ineficiente. Qualquer fluxo com um buffer interno deve substituir este método e fornecer uma versão muito mais eficiente do que lê o buffer diretamente, evitando a alocação de matriz extra em cada chamada.  
  
 Para obter uma lista de operações de diretório e arquivos comuns, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
