<Type Name="File" FullName="System.IO.File">
  <TypeSignature Language="C#" Value="public static class File" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit File extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.File" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece métodos estáticos para a criação, cópia, exclusão, deslocamento e abertura de um arquivo, além de ajudar na criação de objetos <see cref="T:System.IO.FileStream" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/io/file.cs#1c7421e464f67b7e). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Use o <xref:System.IO.File> classe para operações comuns, como copiar, mover, renomear, criar, abrir, excluindo e anexar a um único arquivo cada vez. Você também pode usar o <xref:System.IO.File> classe para obter e definir atributos de arquivo ou <xref:System.DateTime> informações relacionadas à criação, acessar e gravação de um arquivo. Se você quiser executar operações em vários arquivos, consulte <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> ou <xref:System.IO.DirectoryInfo.GetFiles%2A?displayProperty=nameWithType>.  
  
 Muitas do <xref:System.IO.File> métodos retornam outros tipos de e/s ao criar ou abrir arquivos. Você pode usar esses outros tipos para manipular mais de um arquivo. Para obter mais informações, consulte específico <xref:System.IO.File> membros como <xref:System.IO.File.OpenText%2A>, <xref:System.IO.File.CreateText%2A>, ou <xref:System.IO.File.Create%2A>.  
  
 Como todos os <xref:System.IO.File> métodos são estáticos, pode ser mais eficiente usar um <xref:System.IO.File> método em vez de um correspondente <xref:System.IO.FileInfo> método de instância, se você quiser executar somente uma ação. Todos os <xref:System.IO.File> métodos requerem o caminho para o arquivo que você estiver manipulando.  
  
 Os métodos estáticos do <xref:System.IO.File> classe executar verificações de segurança em todos os métodos. Se você for reutilizar um objeto várias vezes, considere a possibilidade de usar o método de instância correspondente do <xref:System.IO.FileInfo> em vez disso, como a segurança verificar será nem sempre ser necessárias.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários.  
  
 A tabela a seguir descreve as enumerações que são usadas para personalizar o comportamento de vários <xref:System.IO.File> métodos.  
  
|Enumeração|Descrição|  
|-----------------|-----------------|  
|<xref:System.IO.FileAccess>|Especifica o acesso de leitura e gravação para um arquivo.|  
|<xref:System.IO.FileShare>|Especifica o nível de acesso permitido para um arquivo que já está em uso.|  
|<xref:System.IO.FileMode>|Especifica se o conteúdo de um arquivo existente é preservado ou substituído e se solicitações para criar um arquivo existente causam uma exceção.|  
  
> [!NOTE]
>  Em membros que aceitam um caminho como uma cadeia de caracteres de entrada, esse caminho deve ser bem formado ou uma exceção é gerada. Por exemplo, se um caminho é totalmente qualificado, mas começa com um espaço, o caminho não é fragmentado em métodos da classe. Portanto, o caminho está malformado e uma exceção é gerada. Da mesma forma, um caminho ou uma combinação de caminhos não pode ser totalmente qualificada duas vezes. Por exemplo, "c:\temp c:\windows" também gera uma exceção na maioria dos casos. Certifique-se de que seus caminhos são formados ao usar os métodos que aceitam uma cadeia de caracteres de caminho.  
  
 Membros que aceitam um caminho, o caminho pode se referir a um arquivo ou apenas um diretório. O caminho especificado também pode se referir a um caminho relativo ou um caminho de convenção de nomenclatura Universal (UNC) para um nome de compartilhamento e servidor. Por exemplo, todos os seguintes são aceitáveis caminhos:  
  
-   "c:\\\MyDir\\\MyFile.txt" em c# ou "c:\MyDir\MyFile.txt" no Visual Basic.  
  
-   "c:\\\MyDir" em c# ou "c:\MyDir" no Visual Basic.  
  
-   "MyDir\\\MySubdir" em c# ou "MyDir\MySubDir" no Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" em c#, ou "\\\MyServer\MyShare" no Visual Basic.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.IO.File> classe para verificar se existe um arquivo, e dependendo do resultado, crie um novo arquivo e gravar nele, ou abra o arquivo existente e lê-lo. Antes de executar o código, crie um `c:\temp` pasta.  
  
 [!code-cpp[File Class Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Class Example/CPP/file class example.cpp#1)]
 [!code-csharp[File Class Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Class Example/CS/file class example.cs#1)]
 [!code-vb[File Class Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Class Example/VB/file class example.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ao qual serão acrescentadas as linhas. Se ainda não existir, o arquivo será criado.</param>
        <param name="contents">As linhas a serem acrescentadas ao arquivo.</param>
        <summary>Acrescenta linhas a um arquivo e fecha o arquivo. Se o arquivo especificado não existir, esse método criará um arquivo, gravará as linhas especificadas no arquivo e fechará o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método criará o arquivo se ele não existir, mas não pode criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
   
  
## Examples  
 O exemplo a seguir grava linhas selecionadas de um arquivo de dados de exemplo em um arquivo e, em seguida, anexa mais linhas. O diretório chamado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem permissão para gravar no arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> é um diretório.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLines">
      <MemberSignature Language="C#" Value="public static void AppendAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ao qual serão acrescentadas as linhas. Se ainda não existir, o arquivo será criado.</param>
        <param name="contents">As linhas a serem acrescentadas ao arquivo.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Acrescenta linhas em um arquivo usando uma codificação especificada e, em seguida, fecha o arquivo. Se o arquivo especificado não existir, esse método criará um arquivo, gravará as linhas especificadas no arquivo e fechará o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método criará o arquivo se ele não existir, mas não pode criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
 Você pode usar esse método para criar um arquivo que contém o seguinte:  
  
-   Os resultados de uma [objetos LINQ to](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultar as linhas de um arquivo, como obtida usando o <xref:System.IO.File.ReadLines%2A> método.  
  
-   O conteúdo de uma coleção que implementa um <xref:System.Collections.Generic.IEnumerable%601> de cadeias de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" />, <paramref name="contents" />, ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> é um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo no qual a cadeia de caracteres especificada será anexada.</param>
        <param name="contents">A cadeia de caracteres a ser anexada ao arquivo.</param>
        <summary>Abre um arquivo, acrescenta a cadeia de caracteres especificada no arquivo e fecha o arquivo. Se o arquivo não existir, esse método criará um arquivo, gravará a cadeia de caracteres especificada no arquivo e fechará o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devido a uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, acrescenta a cadeia de caracteres ao final do arquivo e, em seguida, fecha o arquivo. O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
 O método criará o arquivo se ele não existir, mas não pode criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.AppendAllText%2A> para adicionar o texto extra ao final de um arquivo. Neste exemplo, um arquivo é criado se ainda não existir, e o texto é adicionado a ele. No entanto, o diretório denominado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso para gravar um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllText">
      <MemberSignature Language="C#" Value="public static void AppendAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AppendAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo no qual a cadeia de caracteres especificada será anexada.</param>
        <param name="contents">A cadeia de caracteres a ser anexada ao arquivo.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Acrescenta a cadeia de caracteres especificada ao arquivo, criando-o, caso ele ainda não exista.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devido a uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado acrescenta a cadeia de caracteres ao final do arquivo usando a codificação especificada e, em seguida, fecha o arquivo. O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
 O método criará o arquivo se ele não existir, mas não pode criar novos diretórios. Portanto, o valor da `path` parâmetro deve conter diretórios existentes.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.AppendAllText%2A> para adicionar o texto extra ao final de um arquivo. Neste exemplo, um arquivo é criado se ainda não existir, e o texto é adicionado a ele. No entanto, o diretório denominado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso para gravar um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task AppendAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task AppendAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter AppendText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter AppendText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.AppendText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo a ser anexado.</param>
        <summary>Cria um <see cref="T:System.IO.StreamWriter" /> que acrescenta um texto codificado para UTF-8 a um arquivo existente ou a um novo arquivo, se o arquivo especificado não existe.</summary>
        <returns>Um gravador de fluxo que acrescenta texto codificado para UTF-8 ao arquivo especificado ou a um novo arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> sobrecarga de construtor. Se o arquivo especificado por `path` não existir, ele é criado. Se o arquivo existir, as operações de gravação de <xref:System.IO.StreamWriter> adicionar texto ao arquivo. Threads adicionais têm permissão para ler o arquivo enquanto ele está aberto.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir acrescenta texto em um arquivo. O método cria um novo arquivo, se o arquivo não existe. No entanto, o diretório denominado `temp` na unidade C deve existir para o exemplo concluído com êxito.  
  
 [!code-cpp[File_AppendText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File_AppendText/CPP/file_appendtext.cpp#1)]
 [!code-csharp[File_AppendText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File_AppendText/CS/file_appendtext.cs#1)]
 [!code-vb[File_AppendText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File_AppendText/VB/file_appendtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, o diretório não existe ou está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para anexar o arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Append" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destFileName">O nome do arquivo de destino. Não pode ser um diretório ou um arquivo existente.</param>
        <summary>Copia um arquivo existente para um novo arquivo. Não é permitida a substituição de um arquivo de mesmo nome.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29> sobrecarga de método com o `overwrite` parâmetro definido como `false`.  
  
 O `sourceFileName` e `destFileName` parâmetros podem especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte o <xref:System.IO.Directory.GetCurrentDirectory%2A?displayProperty=nameWithType> método. Este método não oferece suporte a caracteres curinga nos parâmetros.  
  
 Os atributos do arquivo original são mantidos no arquivo copiado.  
  
   
  
## Examples  
 O exemplo a seguir copia arquivos para a pasta de backup C:\archives\2008. Ele usa as duas sobrecargas do <xref:System.IO.File.Copy%2A> método da seguinte maneira:  
  
-   Primeiro, ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecarga do método para copiar arquivos de texto (. txt). O código demonstra que essa sobrecarga não permitir a substituição de arquivos que já foram copiados.  
  
-   Ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método para copiar imagens (arquivos. jpg). O código demonstra que essa sobrecarga de permitir a substituição de arquivos que já foram copiados.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> especifica um diretório.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado em <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> existe.  
  
 -ou-  
  
 Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler de <paramref name="sourceFileName" /> e gravar em <paramref name="destFileName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (string sourceFileName, string destFileName, bool overwrite);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(string sourceFileName, string destFileName, bool overwrite) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Copy(System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
        <Parameter Name="overwrite" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O arquivo a ser copiado.</param>
        <param name="destFileName">O nome do arquivo de destino. Ele não pode ser um diretório.</param>
        <param name="overwrite">
          <see langword="true" /> se o arquivo de destino puder ser substituído; caso contrário, <see langword="false" />.</param>
        <summary>Copia um arquivo existente para um novo arquivo. É permitido substituir um arquivo de mesmo nome.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `sourceFileName` e `destFileName` parâmetros podem especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Este método não oferece suporte a caracteres curinga nos parâmetros.  
  
 Os atributos do arquivo original são mantidos no arquivo copiado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir copia arquivos para a pasta de backup C:\archives\2008. Ele usa as duas sobrecargas do <xref:System.IO.File.Copy%2A> método da seguinte maneira:  
  
-   Primeiro, ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecarga do método para copiar arquivos de texto (. txt). O código demonstra que essa sobrecarga não permitir a substituição de arquivos que já foram copiados.  
  
 Ele usa o <xref:System.IO.File.Copy%28System.String%2CSystem.String%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga do método para copiar imagens (arquivos. jpg). O código demonstra que essa sobrecarga de permitir a substituição de arquivos que já foram copiados.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="destFileName" /> é somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> especifica um diretório.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado em <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="sourceFileName" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="destFileName" /> existe e <paramref name="overwrite" /> é <see langword="false" />.  
  
 -ou-  
  
 Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler de <paramref name="sourceFileName" /> e gravar em <paramref name="destFileName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho e o nome do arquivo a ser criado.</param>
        <summary>Cria ou substitui um arquivo no caminho especificado.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> que fornece acesso de leitura/gravação para o arquivo especificado em <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream> objeto criado por esse método tem um padrão <xref:System.IO.FileShare> valor <xref:System.IO.FileShare.None>; nenhum outro processo ou código pode acessar o arquivo criado até que o identificador de arquivo original é fechado.  
  
 Esse método é equivalente a <xref:System.IO.File.Create%28System.String%2CSystem.Int32%29> sobrecarga de método usando o tamanho do buffer padrão.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um arquivo no caminho especificado, grava algumas informações para o arquivo e lê a partir do arquivo.  
  
 [!code-cpp[File Create1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create1/CPP/file create1.cpp#1)]
 [!code-csharp[File Create1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create1/CS/file create1.cs#1)]
 [!code-vb[File Create1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create1/VB/file create1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar no arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" /> . Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo.</param>
        <param name="bufferSize">O número de bytes armazenados em buffer para leituras e gravações no arquivo.</param>
        <summary>Cria ou substitui o arquivo especificado.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> com o tamanho do buffer especificado que fornece acesso de leitura/gravação para o arquivo especificado em <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.FileStream> objeto criado por esse método tem um padrão <xref:System.IO.FileShare> valor <xref:System.IO.FileShare.None>; nenhum outro processo ou código pode acessar o arquivo criado até que o identificador de arquivo original é fechado.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Esse método é equivalente a <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga de construtor. Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um arquivo com o tamanho de buffer especificado.  
  
 [!code-cpp[File Create2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Create2/CPP/file create2.cpp#1)]
 [!code-csharp[File Create2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Create2/CS/file create2.cs#1)]
 [!code-vb[File Create2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Create2/VB/file create2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar no arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo.</param>
        <param name="bufferSize">O número de bytes armazenados em buffer para leituras e gravações no arquivo.</param>
        <param name="options">Um dos valores de <see cref="T:System.IO.FileOptions" /> que descreve como criar ou substituir o arquivo.</param>
        <summary>Cria ou substitui o arquivo especificado, especificando um tamanho do buffer e um valor <see cref="T:System.IO.FileOptions" /> que descreve como criar ou substituir o arquivo.</summary>
        <returns>Um novo arquivo com o tamanho do buffer especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Esse método é equivalente a <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga de construtor. Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar no arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Create (string path, int bufferSize, System.IO.FileOptions options, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Create(string path, int32 bufferSize, valuetype System.IO.FileOptions options, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Create(System.String,System.Int32,System.IO.FileOptions,System.Security.AccessControl.FileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="options" Type="System.IO.FileOptions" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo.</param>
        <param name="bufferSize">O número de bytes armazenados em buffer para leituras e gravações no arquivo.</param>
        <param name="options">Um dos valores de <see cref="T:System.IO.FileOptions" /> que descreve como criar ou substituir o arquivo.</param>
        <param name="fileSecurity">Um dos valores de <see cref="T:System.Security.AccessControl.FileSecurity" /> que determina o controle de acesso e a segurança de auditoria para o arquivo.</param>
        <summary>Cria ou substitui no arquivo especificado o tamanho do buffer, as opções de arquivo e a segurança de arquivo especificados.</summary>
        <returns>Um novo arquivo com o tamanho do buffer, as opções de arquivo e a segurança de arquivo especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Esse método é equivalente a <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%2CSystem.Int32%29> sobrecarga de construtor. Se o arquivo especificado não existir, ele será criado; Se ele existe e não é somente leitura, o conteúdo será substituído.  
  
 Por padrão, o acesso de leitura/gravação completa para novos arquivos é concedido a todos os usuários. O arquivo é aberto com acesso de leitura/gravação e deve ser fechado antes que ele pode ser aberto por outro aplicativo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao criar o arquivo.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar no arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamWriter CreateText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamWriter CreateText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.CreateText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para gravação.</param>
        <summary>Cria ou abre um arquivo para gravar texto codificado em UTF-8. Se o arquivo já existir, seu conteúdo será substituído.</summary>
        <returns>Um <see cref="T:System.IO.StreamWriter" /> que grava no arquivo especificado usando a codificação UTF-8.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.IO.StreamWriter.%23ctor%28System.String%2CSystem.Boolean%29> sobrecarga de construtor com a `append` parâmetro definido como `false`. Se o arquivo especificado por `path` não existir, ele é criado. Se o arquivo existir, seu conteúdo será substituído. Threads adicionais têm permissão para ler o arquivo enquanto ele está aberto.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir cria um arquivo para gravação e leitura de texto.  
  
 [!code-cpp[File CreateText#1](~/samples/snippets/cpp/VS_Snippets_CLR/File CreateText/CPP/file createtext.cpp#1)]
 [!code-csharp[File CreateText#1](~/samples/snippets/csharp/VS_Snippets_CLR/File CreateText/CS/file createtext.cs#1)]
 [!code-vb[File CreateText#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File CreateText/VB/file createtext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public static void Decrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Decrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Decrypt(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho que descreve um arquivo a ser descriptografado.</param>
        <summary>Descriptografa um arquivo que foi criptografado pela conta atual usando o método <see cref="M:System.IO.File.Encrypt(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Decrypt%2A> método permite que você descriptografar um arquivo que estava criptografado usando o <xref:System.IO.File.Encrypt%2A> método.  O <xref:System.IO.File.Decrypt%2A> método possa descriptografar somente os arquivos que foram criptografados usando a conta de usuário atual.  
  
 O <xref:System.IO.File.Decrypt%2A> método requer acesso exclusivo ao arquivo ser descriptografado e gerará uma exceção se outro processo está usando o arquivo. Se o arquivo não é criptografado, <xref:System.IO.File.Decrypt%2A> retornará um valor diferente de zero, o que indica êxito.  
  
 Ambos os <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método usa o provedor de serviços de criptografia (CSP) instalado no computador e as chaves de criptografia de arquivo do processo de chamada do método.  
  
 O sistema de arquivos atual deve ser formatado como NTFS e o sistema operacional atual deve ser do Windows NT ou posterior.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método para criptografar e descriptografar um arquivo. O arquivo deve existir para o exemplo de trabalho.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo parâmetro <paramref name="path" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo. Por exemplo, o arquivo criptografado já está aberto.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.NotSupportedException">O sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O parâmetro <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar no arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O nome do arquivo a ser excluído. Não há suporte para caracteres curinga.</param>
        <summary>Exclui o arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Especifique um nome de arquivo com qualquer informação de caminho relativo ou absoluto para o `path` parâmetro. Caracteres curinga não podem ser incluídos. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se o arquivo a ser excluído não existe, nenhuma exceção é lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir copia os grupos de arquivos para a pasta de backup C:\archives\2008 e, em seguida, exclui-los da pasta de origem.  
  
 [!code-csharp[FileCopyDelete#1](~/samples/snippets/csharp/VS_Snippets_CLR/filecopydelete/cs/program.cs#1)]
 [!code-vb[FileCopyDelete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/filecopydelete/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">O arquivo especificado está sendo usado.  
  
 -ou-  
  
 Há um identificador aberto no arquivo, e o sistema operacional é o Windows XP ou uma versão anterior. Esse identificador aberto pode resultar da enumeração de diretórios e arquivos. Para obter mais informações, consulte [como: enumerar diretórios e arquivos](~/docs/standard/io/how-to-enumerate-directories-and-files.md).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  
  
 -ou-  
  
 O arquivo é um arquivo executável que está sendo usado.  
  
 -ou-  
  
 <paramref name="path" /> é um diretório.  
  
 -ou-  
  
 <paramref name="path" /> especificou um arquivo somente leitura.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Para excluir o arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public static void Encrypt (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Encrypt(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Encrypt(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Um caminho que descreve um arquivo a ser criptografado.</param>
        <summary>Criptografa um arquivo para que somente a conta usada para criptografar o arquivo possa descriptografá-lo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Encrypt%2A> método permite que você criptografar um arquivo de forma que apenas a conta usada para chamar esse método pode descriptografá-lo. Use o <xref:System.IO.File.Decrypt%2A> método para descriptografar um arquivo criptografado pelo <xref:System.IO.File.Encrypt%2A> método.  
  
 O <xref:System.IO.File.Encrypt%2A> método requer acesso exclusivo ao arquivo que está sendo criptografado e falharão se outro processo está usando o arquivo.  
  
 Ambos os <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método usa o provedor de serviços de criptografia (CSP) instalado no computador e as chaves de criptografia de arquivo do processo de chamada do método.  
  
 Este método não está disponível em todas as versões do Windows. Por exemplo, não está disponível nas edições Home.  
  
 O sistema de arquivos atual deve ser formatado como NTFS.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Encrypt%2A> método e o <xref:System.IO.File.Decrypt%2A> método para criptografar e descriptografar um arquivo. O arquivo deve existir para o exemplo de trabalho.  
  
 [!code-cpp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Encrypt-Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/CS/sample.cs#1)]
 [!code-vb[IO.File.Encrypt-Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Encrypt-Decrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo parâmetro <paramref name="path" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.NotSupportedException">O sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O parâmetro <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão Ler e gravar no arquivo descrito pelo <paramref name="path" /> parâmetro. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser verificado.</param>
        <summary>Determina se o arquivo especificado existe.</summary>
        <returns>
          <see langword="true" /> se o chamador tiver as permissões necessárias e <paramref name="path" /> contiver o nome de um arquivo existente; caso contrário, <see langword="false" />. Esse método também retornará <see langword="false" /> se <paramref name="path" /> for <see langword="null" />, um caminho inválido ou uma cadeia de comprimento zero. Se o chamador não tiver permissões suficientes para ler o arquivo especificado, nenhuma exceção será lançada e o método retornará <see langword="false" /> independentemente da existência de <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Exists%2A> método não deve ser usado para validação de caminho, este método simplesmente verifica se o arquivo especificado em `path` existe. Passando um caminho inválido para <xref:System.IO.File.Exists%2A> retorna `false`. Para verificar se o caminho contém caracteres inválidos, você pode chamar o <xref:System.IO.Path.GetInvalidPathChars%2A> método para recuperar os caracteres inválidos para o sistema de arquivos. Você também pode criar uma expressão regular para testar se o caminho é válido para o seu ambiente. Para obter exemplos de caminhos aceitáveis, consulte <xref:System.IO.File>.  
  
 Para verificar se existe um diretório, consulte <xref:System.IO.Directory.Exists%2A?displayProperty=nameWithType>.  
  
 Lembre-se de que outro processo potencialmente pode fazer algo com o arquivo entre a hora em que você chamar o <xref:System.IO.File.Exists%2A> método e executar outra operação no arquivo, como <xref:System.IO.File.Delete%2A>.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se `path` descreve um diretório, este método retorna `false`. Espaços à direita são removidos do `path` parâmetro antes de determinar se o arquivo existe.  
  
 O <xref:System.IO.File.Exists%2A> método retorna `false` se ocorrer algum erro durante a tentativa de determinar se o arquivo especificado existe. Isso pode ocorrer em situações que geram exceções como passar um nome de arquivo com caracteres inválidos ou número excessivo de caracteres, um disco ausente ou falhando, ou se o chamador não tem permissão para ler o arquivo.  
  
   
  
## Examples  
 O exemplo a seguir determina se um arquivo existe.  
  
 [!code-csharp[File Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Exists/CS/program.cs#1)]
 [!code-vb[File Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Exists/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAccessControl">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as entradas de ACL (lista de controle de acesso) para um arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.FileInfo.GetAccessControl%2A> entradas ACL (lista) para um arquivo especificado do controle de métodos para recuperar o acesso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um arquivo que contém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que descreve as informações de ACL (lista de controle de acesso) do arquivo.</param>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as entradas de ACL (lista de controle de acesso) para um arquivo especificado.</summary>
        <returns>Um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.File.GetAccessControl%2A> método para recuperar as entradas de ACL (lista) de controle de acesso para um arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas sobre o arquivo especificado. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> métodos para adicionar e remover um acesso de entrada ACL (lista) de um arquivo de controle.  Você deve fornecer uma conta de grupo ou de usuário válido para executar este exemplo.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O parâmetro <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Permissão Ler a lista de controle de acesso. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.FileSecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.FileSecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.FileSecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um arquivo que contém um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que descreve as informações de ACL (lista de controle de acesso) do arquivo.</param>
        <param name="includeSections">Um dos valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica o tipo de informações de ACL (lista de controle de acesso) a serem recebidas.</param>
        <summary>Obtém um objeto de <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula o tipo especificado de entradas de ACL (lista de controle de acesso) de um arquivo específico.</summary>
        <returns>Um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.File.GetAccessControl%2A> método para recuperar as entradas de ACL (lista) de controle de acesso para um arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas sobre o arquivo especificado. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O parâmetro <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Permissão Ler a lista de controle de acesso. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.View" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAttributes">
      <MemberSignature Language="C#" Value="public static System.IO.FileAttributes GetAttributes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.IO.FileAttributes GetAttributes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetAttributes(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileAttributes</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo.</param>
        <summary>Obtém o <see cref="T:System.IO.FileAttributes" /> do arquivo no caminho.</summary>
        <returns>O <see cref="T:System.IO.FileAttributes" /> do arquivo no caminho.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o `GetAttributes` e `SetAttributes` métodos aplicando o `Archive` e `Hidden` atributos para um arquivo.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> está vazio, contém somente espaços em branco ou contém caracteres inválidos.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="path" /> representa um arquivo e é inválido (por exemplo, está em uma unidade não mapeada) ou o arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> representa um diretório e é inválido (por exemplo, está em uma unidade não mapeada) ou o diretório não pode ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">O arquivo está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler arquivos. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora de criação.</param>
        <summary>Retorna a data e a hora de criação do arquivo ou diretório especificado.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida como a data e a hora de criação para o arquivo ou diretório especificado. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para horário local.  
  
 Unidades formatadas como NTFS podem armazenar em cache informações sobre um arquivo, como a hora de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituir um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra `GetCreationTime`.  
  
 [!code-vb[System.IO.File.GetCreationTime#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetCreationTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora de criação.</param>
        <summary>Retorna a data e a hora de criação, em UTC (tempo universal coordenado) do arquivo ou do diretório especificado.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida como a data e a hora de criação para o arquivo ou diretório especificado. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Unidades formatadas como NTFS podem armazenar em cache informações sobre um arquivo, como a hora de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituir um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.IO.File.GetCreationTimeUtc%2A> método.  
  
 [!code-vb[System.IO.File.GetCreationTime#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.getcreationtime/vb/module2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora em que o arquivo ou o diretório foi acessado pela última vez.</summary>
        <returns>Uma estrutura de <see cref="T:System.DateTime" /> definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra `GetLastAccessTime`.  
  
 [!code-cpp[File GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastAccess/CPP/file getlastaccess.cpp#1)]
 [!code-csharp[File GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastAccess/CS/file getlastaccess.cs#1)]
 [!code-vb[File GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastAccess/VB/file getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastAccessTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora, em UTC (Tempo Universal Coordenado), em que o arquivo ou diretório especificado foi acessado pela última vez.</summary>
        <returns>Uma estrutura de <see cref="T:System.DateTime" /> definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de gravação serão obtidas.</param>
        <summary>Retorna a data e hora em que o arquivo ou diretório especificado foi usado para gravação pela última vez.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida com a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional. Cada sistema operacional gerencia o último tempo de gravação acordo com suas próprias regras. Para melhorar o desempenho, um sistema operacional não pode definir o último valor de tempo de gravação para a hora exata da última operação de gravação, mas pode defini-lo como uma aproximação em vez disso.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra `GetLastWriteTime`.  
  
 [!code-cpp[File GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetLastWrite/CPP/file getlastwrite.cpp#1)]
 [!code-csharp[File GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetLastWrite/CS/file getlastwrite.cs#1)]
 [!code-vb[File GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetLastWrite/VB/file getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.GetLastWriteTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de gravação serão obtidas.</param>
        <summary>Retorna a data e hora, em UTC( horário universal coordenado), em que o arquivo ou diretório especificado foi gravado pela última vez.</summary>
        <returns>Uma estrutura <see cref="T:System.DateTime" /> definida com a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional. Cada sistema operacional gerencia o último tempo de gravação acordo com suas próprias regras. Para melhorar o desempenho, um sistema operacional não pode definir o último valor de tempo de gravação para a hora exata da última operação de gravação, mas pode defini-lo como uma aproximação em vez disso.  
  
 Se o arquivo descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceFileName, string destFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceFileName, string destFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Move(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O nome do arquivo a ser movido. Pode incluir um caminho relativo ou absoluto.</param>
        <param name="destFileName">O novo caminho e nome do arquivo.</param>
        <summary>Move um arquivo especificado para um novo local, oferecendo a opção de especificar um novo nome de arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona em volumes de disco, e não gerará uma exceção se a origem e destino são os mesmos. Observe que, se você tentar substituir um arquivo movendo um arquivo de mesmo nome no diretório, você receberá um <xref:System.IO.IOException>. Você não pode usar o método Move para substituir um arquivo existente.  
  
 O `sourceFileName` e `destFileName` argumentos podem incluir informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Se você tentar mover um arquivo em volumes de disco e se o arquivo está em uso, o arquivo é copiado para o destino, mas ele não é excluído da origem.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir move um arquivo.  
  
 [!code-cpp[File Move#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Move/CPP/file move.cpp#1)]
 [!code-csharp[File Move#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Move/CS/file move.cs#1)]
 [!code-vb[File Move#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Move/VB/file move.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O arquivo de destino já existe.  
  
 -ou-  
  
 <paramref name="sourceFileName" /> não foi encontrado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou caracteres inválidos, conforme definido em <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado em <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="sourceFileName" /> ou <paramref name="destFileName" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler de <paramref name="sourceFileName" /> e gravar em <paramref name="destFileName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto.</param>
        <param name="mode">Um valor <see cref="T:System.IO.FileMode" /> que especifica se um arquivo deve ser criado caso não haja um e determina se o conteúdo dos arquivos existentes é mantido ou substituído.</param>
        <summary>Abre um <see cref="T:System.IO.FileStream" /> no caminho especificado com acesso de leitura/gravação.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> aberto no modo e caminho especificado, com acesso de leitura/gravação e não compartilhado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um arquivo temporário e grava um texto nela. O exemplo, em seguida, abre o arquivo, usando T:System.IO.FileMode.Open; ou seja, se o arquivo ainda não existia, ele seria não criado.  
  
 [!code-cpp[File Open1#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open1/CPP/file open1.cpp#1)]
 [!code-csharp[File Open1#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open1/CS/file open1.cs#1)]
 [!code-vb[File Open1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open1/VB/file open1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="mode" /> é <see cref="F:System.IO.FileMode.Create" /> e o arquivo especificado é um arquivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> especificou um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar no arquivo especificado. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto.</param>
        <param name="mode">Um valor <see cref="T:System.IO.FileMode" /> que especifica se um arquivo deve ser criado caso não haja um e determina se o conteúdo dos arquivos existentes é mantido ou substituído.</param>
        <param name="access">Um valor <see cref="T:System.IO.FileAccess" /> que especifica as operações que podem ser executadas no arquivo.</param>
        <summary>Abre um <see cref="T:System.IO.FileStream" /> no caminho especificado, com o modo e o acesso especificados.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> com compartilhamento cancelado que fornece acesso ao arquivo especificado, com o modo e o acesso especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo com acesso somente leitura.  
  
 [!code-cpp[file open2#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open2/CPP/file open2.cpp#1)]
 [!code-csharp[file open2#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open2/CS/file open2.cs#1)]
 [!code-vb[file open2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open2/VB/file open2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="access" /> especificou <see langword="Read" /> e <paramref name="mode" /> especificou <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> ou <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura e <paramref name="access" /> não é <see langword="Read" />.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="mode" /> é <see cref="F:System.IO.FileMode.Create" /> e o arquivo especificado é um arquivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" /> ou <paramref name="access" /> especificou um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar no arquivo especificado. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Open">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream Open (string path, System.IO.FileMode mode, System.IO.FileAccess access, System.IO.FileShare share);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream Open(string path, valuetype System.IO.FileMode mode, valuetype System.IO.FileAccess access, valuetype System.IO.FileShare share) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Open(System.String,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="mode" Type="System.IO.FileMode" />
        <Parameter Name="access" Type="System.IO.FileAccess" />
        <Parameter Name="share" Type="System.IO.FileShare" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto.</param>
        <param name="mode">Um valor <see cref="T:System.IO.FileMode" /> que especifica se um arquivo deve ser criado caso não haja um e determina se o conteúdo dos arquivos existentes é mantido ou substituído.</param>
        <param name="access">Um valor <see cref="T:System.IO.FileAccess" /> que especifica as operações que podem ser executadas no arquivo.</param>
        <param name="share">Um valor <see cref="T:System.IO.FileShare" /> que especifica o tipo de acesso que outros threads têm ao arquivo.</param>
        <summary>Abre um <see cref="T:System.IO.FileStream" /> no caminho especificado, tendo o modo especificado com acesso de leitura, gravação ou leitura/gravação e a opção de compartilhamento especificada.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> no caminho especificado, tendo o modo especificado com acesso de leitura, gravação ou leitura/gravação e a opção de compartilhamento especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo com acesso somente leitura e com o compartilhamento de arquivo não permitido.  
  
 [!code-cpp[file open3#1](~/samples/snippets/cpp/VS_Snippets_CLR/File Open3/CPP/file open3.cpp#1)]
 [!code-csharp[file open3#1](~/samples/snippets/csharp/VS_Snippets_CLR/File Open3/CS/file open3.cs#1)]
 [!code-vb[file open3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File Open3/VB/file open3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="access" /> especificou <see langword="Read" /> e <paramref name="mode" /> especificou <see langword="Create" />, <see langword="CreateNew" />, <see langword="Truncate" /> ou <see langword="Append" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura e <paramref name="access" /> não é <see langword="Read" />.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="mode" /> é <see cref="F:System.IO.FileMode.Create" /> e o arquivo especificado é um arquivo oculto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="mode" />, <paramref name="access" /> ou <paramref name="share" /> especificou um valor inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar no arquivo especificado. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenRead">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenRead (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenRead(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenRead(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo existente para leitura.</summary>
        <returns>Um <see cref="T:System.IO.FileStream" /> somente leitura no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente ao <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> sobrecarga de construtor com um <xref:System.IO.FileMode> valor <xref:System.IO.FileMode.Open>, um <xref:System.IO.FileAccess> valor <xref:System.IO.FileAccess.Read> e um <xref:System.IO.FileShare> valor de <xref:System.IO.FileShare.Read>.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo para leitura.  
  
 [!code-cpp[file openread#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenRead/CPP/file openread.cpp#1)]
 [!code-csharp[file openread#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenRead/CS/file openread.cs#1)]
 [!code-vb[file openread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenRead/VB/file openread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenText">
      <MemberSignature Language="C#" Value="public static System.IO.StreamReader OpenText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.StreamReader OpenText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo de texto com codificação UTF-8 existente para leitura.</summary>
        <returns>Um <see cref="T:System.IO.StreamReader" /> no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.IO.StreamReader.%23ctor%28System.String%29> sobrecarga de construtor.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo de texto para leitura.  
  
 [!code-cpp[file opentext#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenText/CPP/file opentext.cpp#1)]
 [!code-csharp[file opentext#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenText/CS/file opentext.cs#1)]
 [!code-vb[file opentext#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenText/VB/file opentext.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para leitura do arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenWrite">
      <MemberSignature Language="C#" Value="public static System.IO.FileStream OpenWrite (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.FileStream OpenWrite(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.OpenWrite(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para gravação.</param>
        <summary>Abre um arquivo existente ou cria um novo arquivo para gravação.</summary>
        <returns>Um objeto <see cref="T:System.IO.FileStream" /> não compartilhado no caminho especificado com acesso <see cref="F:System.IO.FileAccess.Write" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é equivalente a <xref:System.IO.FileStream.%23ctor%28System.String%2CSystem.IO.FileMode%2CSystem.IO.FileAccess%2CSystem.IO.FileShare%29> sobrecarga de construtor com modo de arquivo definido como <xref:System.IO.FileMode.OpenOrCreate>, o acesso definido como <xref:System.IO.FileAccess.Write>e o modo de compartilhamento definido como <xref:System.IO.FileShare.None>.  
  
 O <xref:System.IO.File.OpenWrite%2A> método abre um arquivo, se um já existe para o caminho do arquivo ou cria um novo arquivo caso não exista. Para um arquivo existente, ele não anexa o novo texto para o texto existente. Em vez disso, ele substitui os caracteres existentes com os novos caracteres. Se você substituir uma cadeia de caracteres mais longa (como "Este é um teste do método OpenWrite") com uma cadeia de caracteres mais curto (por exemplo, "segunda execução"), o arquivo conterá uma mistura de cadeias de caracteres ("segundo runtest do método OpenWrite").  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, use o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 Retornado <xref:System.IO.FileStream> não suporta leitura. Para abrir um arquivo para leitura e gravação, use <xref:System.IO.File.Open%2A>.

 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir abre um arquivo para leitura e gravação.  
  
 [!code-cpp[file openwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File OpenWrite/CPP/file openwrite.cpp#1)]
 [!code-csharp[file openwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File OpenWrite/CS/file openwrite.cs#1)]
 [!code-vb[file openwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File OpenWrite/VB/file openwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.  
  
 -ou-  
  
 <paramref name="path" /> especificou um arquivo ou diretório somente leitura.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytes">
      <MemberSignature Language="C#" Value="public static byte[] ReadAllBytes (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] ReadAllBytes(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytes(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo binário, lê o conteúdo do arquivo em uma matriz de bytes e, em seguida, fecha o arquivo.</summary>
        <returns>Uma matriz de bytes que contém o conteúdo do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado um caminho de arquivo, este método abre o arquivo, lê o conteúdo do arquivo em uma matriz de bytes e, em seguida, fecha o arquivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;byte[]&gt; ReadAllBytesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;unsigned int8[]&gt; ReadAllBytesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllBytesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Byte[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo de texto, lê todas as linhas dele e o fecha.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma matriz de cadeia de caracteres. Ele, em seguida, fecha o arquivo. Alimentação de uma linha é definido como uma cadeia de caracteres, seguido por um retorno de carro ('\r'), uma alimentação de linha ("\n") ou um retorno de carro imediatamente seguido por uma linha. A cadeia de caracteres resultante não contém o encerramento retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta detectar automaticamente a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllLines%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLines">
      <MemberSignature Language="C#" Value="public static string[] ReadAllLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] ReadAllLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLines(System.String,System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <param name="encoding">A codificação aplicada ao conteúdo do arquivo.</param>
        <summary>Abre um arquivo, lê todas as linhas do arquivo com a codificação especificada e fecha o arquivo.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma matriz de cadeia de caracteres. Ele, em seguida, fecha o arquivo. Alimentação de uma linha é definido como uma cadeia de caracteres, seguido por um retorno de carro ('\r'), uma alimentação de linha ("\n") ou um retorno de carro imediatamente seguido por uma linha. A cadeia de caracteres resultante não contém o encerramento retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta detectar automaticamente a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllLines%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string[]&gt; ReadAllLinesAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string[]&gt; ReadAllLinesAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllLinesAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String[]&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <summary>Abre um arquivo de texto, lê todas as linhas dele e o fecha.</summary>
        <returns>Uma cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma cadeia de caracteres. Ele, em seguida, fecha o arquivo. Alimentação de uma linha é definido como uma cadeia de caracteres, seguido por um retorno de carro ('\r'), uma alimentação de linha ("\n") ou um retorno de carro imediatamente seguido por uma linha. A cadeia de caracteres resultante não contém o encerramento retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta detectar automaticamente a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectado.  
  
 Use o <xref:System.IO.File.ReadAllText%28System.String%2CSystem.Text.Encoding%29> sobrecarga de método quando ler arquivos que podem conter texto importado, pois não reconhecida caracteres pode não ser lidos corretamente.  
  
 O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllText%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllText">
      <MemberSignature Language="C#" Value="public static string ReadAllText (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadAllText(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllText(System.String,System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser aberto para leitura.</param>
        <param name="encoding">A codificação aplicada ao conteúdo do arquivo.</param>
        <summary>Abre um arquivo, lê todas as linhas do arquivo com a codificação especificada e fecha o arquivo.</summary>
        <returns>Uma cadeia de caracteres que contém todas as linhas do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método abre um arquivo, lê cada linha do arquivo e, em seguida, adiciona cada linha como um elemento de uma cadeia de caracteres. Ele, em seguida, fecha o arquivo. Alimentação de uma linha é definido como uma cadeia de caracteres, seguido por um retorno de carro ('\r'), uma alimentação de linha ("\n") ou um retorno de carro imediatamente seguido por uma linha. A cadeia de caracteres resultante não contém o encerramento retorno de carro e/ou alimentação de linha.  
  
 Esse método tenta detectar automaticamente a codificação de um arquivo com base na presença de marcas de ordem de byte. Formatos de codificação UTF-8 e UTF-32 (big-endian e little endian) pode ser detectado.  
  
 O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
 Para usar as configurações de codificação, conforme configurado para o sistema operacional, especifique o <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propriedade para o `encoding` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.ReadAllText%2A> método para exibir o conteúdo de um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso de leitura de um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task&lt;string&gt; ReadAllTextAsync (string path, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task`1&lt;string&gt; ReadAllTextAsync(string path, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadAllTextAsync(System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser lido.</param>
        <summary>Lê as linhas de um arquivo.</summary>
        <returns>Todas as linhas do arquivo, ou as linhas que são resultado de uma consulta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.ReadLines%2A> e <xref:System.IO.File.ReadAllLines%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.File.ReadLines%2A>, você pode começar ao enumerar a coleção de cadeias de caracteres antes da coleção inteira será retornada; quando você usa <xref:System.IO.File.ReadAllLines%2A>, você deve esperar para a matriz inteira de cadeias de caracteres retornados antes de você pode acessar a matriz. Portanto, quando você estiver trabalhando com arquivos muito grandes, <xref:System.IO.File.ReadLines%2A> pode ser mais eficiente.  
  
 Você pode usar o <xref:System.IO.File.ReadLines%2A> método para fazer o seguinte:  
  
-   Executar [objetos LINQ to](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultas em um arquivo para obter um conjunto filtrado de suas linhas.  
  
-   Gravar a coleção retornada de linhas em um arquivo com o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> método, ou acrescentá-las para um arquivo existente com o <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29?displayProperty=nameWithType> método.  
  
-   Criar uma instância imediatamente populada de uma coleção que usa um <xref:System.Collections.Generic.IEnumerable%601> coleção de cadeias de caracteres para seu construtor, como um <xref:System.Collections.Generic.IList%601> ou <xref:System.Collections.Generic.Queue%601>.  
  
 Esse método usa <xref:System.Text.Encoding.UTF8%2A> para o valor de codificação.  
  
   
  
## Examples  
 O exemplo a seguir lê as linhas de um arquivo para localizar linhas que contêm cadeias de caracteres especificadas.  
  
 [!code-csharp[System.IO.File.ReadLines#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.readlines/cs/program.cs#1)]
 [!code-vb[System.IO.File.ReadLines#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.readlines/vb/program.vb#1)]  
  
 O exemplo a seguir usa o <xref:System.IO.File.ReadLines%2A> método em uma consulta LINQ que enumera todos os diretórios para arquivos que têm uma extensão. txt, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> é um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLines">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; ReadLines (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; ReadLines(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.ReadLines(System.String,System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo a ser lido.</param>
        <param name="encoding">A codificação aplicada ao conteúdo do arquivo.</param>
        <summary>Leia as linhas de um arquivo que tem uma codificação especificada.</summary>
        <returns>Todas as linhas do arquivo, ou as linhas que são resultado de uma consulta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para especificar uma codificação para usar o arquivo de leitura.  
  
 O <xref:System.IO.File.ReadLines%2A> e <xref:System.IO.File.ReadAllLines%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.File.ReadLines%2A>, você pode começar ao enumerar a coleção de cadeias de caracteres antes da coleção inteira será retornada. Quando você usa <xref:System.IO.File.ReadAllLines%2A>, você deve esperar para a matriz inteira de cadeias de caracteres retornados antes de você pode acessar a matriz. Portanto, quando você estiver trabalhando com arquivos muito grandes, <xref:System.IO.File.ReadLines%2A> pode ser mais eficiente.  
  
 Você pode usar o <xref:System.IO.File.ReadLines%2A> método para fazer o seguinte:  
  
-   Executar [objetos LINQ to](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultas em um arquivo para obter um conjunto filtrado de suas linhas.  
  
-   Gravar a coleção retornada de linhas em um arquivo com o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> método, ou acrescentá-las para um arquivo existente com o <xref:System.IO.File.AppendAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29?displayProperty=nameWithType> método.  
  
-   Criar uma instância imediatamente populada de uma coleção que usa um <xref:System.Collections.Generic.IEnumerable%601> coleção de cadeias de caracteres para seu construtor, como um <xref:System.Collections.Generic.IList%601> ou <xref:System.Collections.Generic.Queue%601>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de tamanho zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado por <paramref name="path" /> não foi encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> é um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Substitui o conteúdo de um arquivo especificado pelo conteúdo de outro arquivo, excluindo o arquivo original e criando um backup do arquivo substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Replace%2A> métodos substituem o conteúdo de um arquivo especificado com o conteúdo de outro arquivo.  Eles também criar um backup do arquivo que foi substituído.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O nome de um arquivo que substitui o arquivo especificado por <c>destinationFileName</c>.</param>
        <param name="destinationFileName">O nome do arquivo que está sendo substituído.</param>
        <param name="destinationBackupFileName">O nome do arquivo de backup.</param>
        <summary>Substitui o conteúdo de um arquivo especificado pelo conteúdo de outro arquivo, excluindo o arquivo original e criando um backup do arquivo substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Replace%2A> método substitui o conteúdo de um arquivo especificado com o conteúdo de outro arquivo.  Ele também cria um backup do arquivo que foi substituído.  
  
 Se o `sourceFileName` e `destinationFileName` estão em diferentes volumes, esse método gerará uma exceção. Se o `destinationBackupFileName` está em um volume diferente do arquivo de origem, o arquivo de backup será excluído.  
  
 Passar `null` para o `destinationBackupFileName` parâmetro se você não deseja criar um backup do arquivo que está sendo substituído.  

 Se o `destinationBackupFileName` já existir, será substituído pelo conteúdo do `destinationFileName` arquivo.
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Replace%2A> método para substituir um arquivo por outro arquivo e criar um backup do arquivo substituído.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho descrito pelo parâmetro <paramref name="destinationFileName" /> tinha um formato inválido.  
  
 -ou-  
  
 O caminho descrito pelo parâmetro <paramref name="destinationBackupFileName" /> tinha um formato inválido.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="destinationFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo objeto <see cref="T:System.IO.FileInfo" /> atual não pôde ser encontrado.  
  
 -ou-  
  
 O arquivo descrito pelo parâmetro <paramref name="destinationBackupFileName" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.  
  
 \- ou -  
  
 Os parâmetros <paramref name="sourceFileName" /> e <paramref name="destinationFileName" /> especificam o mesmo arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional é Windows 98 Second Edition ou anterior e o sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="sourceFileName" /> ou <paramref name="destinationFileName" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 Os parâmetros de origem e de destino especificam um diretório em vez de um arquivo.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Permissão Gravar em arquivo descrito pelo <paramref name="destinationBackupFileName" /> parâmetro se um for especificado. Ação de segurança: demanda. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public static void Replace (string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.Replace(System.String,System.String,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFileName" Type="System.String" />
        <Parameter Name="destinationFileName" Type="System.String" />
        <Parameter Name="destinationBackupFileName" Type="System.String" />
        <Parameter Name="ignoreMetadataErrors" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="sourceFileName">O nome de um arquivo que substitui o arquivo especificado por <c>destinationFileName</c>.</param>
        <param name="destinationFileName">O nome do arquivo que está sendo substituído.</param>
        <param name="destinationBackupFileName">O nome do arquivo de backup.</param>
        <param name="ignoreMetadataErrors">
          <see langword="true" /> para ignorar erros de mesclagem (como atributos e listas de controle de acesso (ACLs)) do arquivo substituído para o arquivo de substituição; caso contrário, <see langword="false" />.</param>
        <summary>Substitui o conteúdo de um arquivo especificado pelo conteúdo de outro arquivo, excluindo o arquivo original, criando um backup do arquivo substituído e, opcionalmente, ignora erros de mesclagem.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.Replace%2A> método substitui o conteúdo de um arquivo especificado com o conteúdo de outro arquivo.  Ele também cria um backup do arquivo que foi substituído.  
  
 Se o `sourceFileName` e `destinationFileName` estão em diferentes volumes, esse método gerará uma exceção. Se o `destinationBackupFileName` está em um volume diferente do arquivo de origem, o arquivo de backup será excluído.  
  
 Passar `null` para o `destinationBackupFileName` parâmetro se você não deseja criar um backup do arquivo que está sendo substituído.  

 Se o `destinationBackupFileName` já existir, será substituído pelo conteúdo do `destinationFileName` arquivo.
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.Replace%2A> método para substituir um arquivo por outro arquivo e criar um backup do arquivo substituído.  
  
 [!code-cpp[IO.File.Replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.Replace/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.Replace/CS/sample.cs#1)]
 [!code-vb[IO.File.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.Replace/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O caminho descrito pelo parâmetro <paramref name="destinationFileName" /> tinha um formato inválido.  
  
 -ou-  
  
 O caminho descrito pelo parâmetro <paramref name="destinationBackupFileName" /> tinha um formato inválido.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="destinationFileName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DriveNotFoundException">Uma unidade inválida foi especificada.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo descrito pelo objeto <see cref="T:System.IO.FileInfo" /> atual não pôde ser encontrado.  
  
 -ou-  
  
 O arquivo descrito pelo parâmetro <paramref name="destinationBackupFileName" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.  
  
 \- ou -  
  
 Os parâmetros <paramref name="sourceFileName" /> e <paramref name="destinationFileName" /> especificam o mesmo arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional é Windows 98 Second Edition ou anterior e o sistema de arquivos não é NTFS.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="sourceFileName" /> ou <paramref name="destinationFileName" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 Os parâmetros de origem e de destino especificam um diretório em vez de um arquivo.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Permissão Gravar em arquivo descrito pelo <paramref name="destinationBackupFileName" /> parâmetro se um for especificado. Ação de segurança: demanda. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.FileSecurity fileSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.FileSecurity fileSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAccessControl(System.String,System.Security.AccessControl.FileSecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileSecurity" Type="System.Security.AccessControl.FileSecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um arquivo ao qual adicionar ou remover entradas de ACL (lista de controle de acesso).</param>
        <param name="fileSecurity">Um <see cref="T:System.Security.AccessControl.FileSecurity" /> objeto que descreve uma entrada ACL para aplicar ao arquivo descrito pelo <c>caminho</c> parâmetro.</param>
        <summary>Aplica entradas de ACL (lista de controle de acesso) descritas por um objeto <see cref="T:System.Security.AccessControl.FileSecurity" /> ao arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.File.SetAccessControl%2A> método se aplica a entradas ACL (lista) de controle de acesso a um arquivo que representa a lista ACL noninherited.  
  
> [!CAUTION]
>  A ACL especificado para o `fileSecurity` parâmetro substitui a ACL existente para o arquivo. Para adicionar permissões para um novo usuário, use o <xref:System.IO.File.GetAccessControl%2A> método para obter a ACL existente, modificá-lo e, em seguida, usar <xref:System.IO.File.SetAccessControl%2A> para aplicá-lo de volta para o arquivo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas sobre o arquivo especificado. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 O <xref:System.IO.File.SetAccessControl%2A> método persiste apenas <xref:System.Security.AccessControl.FileSecurity> objetos que foram modificados após a criação do objeto.  Se um <xref:System.Security.AccessControl.FileSecurity> objeto não tiver sido modificado, não serão mantido para um arquivo.  Portanto, não é possível recuperar um <xref:System.Security.AccessControl.FileSecurity> de um arquivo de objeto e reaplicar o mesmo objeto para outro arquivo.  
  
 Para copiar informações de ACL de um arquivo para outro:  
  
1.  Use o <xref:System.IO.File.GetAccessControl%2A> método para recuperar o <xref:System.Security.AccessControl.FileSecurity> objeto do arquivo de origem.  
  
2.  Criar um novo <xref:System.Security.AccessControl.FileSecurity> objeto para o arquivo de destino.  
  
3.  Use o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método da fonte de <xref:System.Security.AccessControl.FileSecurity> objeto para recuperar as informações de ACL.  
  
4.  Use o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar as informações recuperadas na etapa 3 para o destino <xref:System.Security.AccessControl.FileSecurity> objeto.  
  
5.  Definir o destino <xref:System.Security.AccessControl.FileSecurity> objeto para o arquivo de destino usando o <xref:System.IO.File.SetAccessControl%2A> método.  
  
 Em ambientes de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.IO.File.GetAccessControl%2A> e <xref:System.IO.File.SetAccessControl%2A> métodos para adicionar e remover um acesso de entrada ACL (lista) de um arquivo de controle.  Você deve fornecer uma conta de grupo ou de usuário válido para executar este exemplo.  
  
 [!code-cpp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.File.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.File.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.Runtime.InteropServices.SEHException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.SystemException">Não foi possível encontrar o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O parâmetro <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="fileSecurity" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">Permissão acessar o arquivo. Ação de segurança: demanda. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" />, <see cref="F:System.Security.AccessControl.AccessControlActions.Change" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAttributes">
      <MemberSignature Language="C#" Value="public static void SetAttributes (string path, System.IO.FileAttributes fileAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAttributes(string path, valuetype System.IO.FileAttributes fileAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetAttributes(System.String,System.IO.FileAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileAttributes" Type="System.IO.FileAttributes" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo.</param>
        <param name="fileAttributes">Um combinação bit a bit dos valores de enumeração.</param>
        <summary>Define o <see cref="T:System.IO.FileAttributes" /> especificado do arquivo no caminho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Atributos, certos arquivos como <xref:System.IO.FileAttributes.Hidden> e <xref:System.IO.FileAttributes.ReadOnly>, podem ser combinados. Outros atributos, como <xref:System.IO.FileAttributes.Normal>, deve ser usado sozinho.  
  
 Não é possível alterar o status de compactação de um <xref:System.IO.File> objeto usando o <xref:System.IO.File.SetAttributes%2A> método.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o `GetAttributes` e `SetAttributes` métodos aplicando o `Archive` e `Hidden` atributos para um arquivo.  
  
 [!code-cpp[File GetAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/File GetAttributes/CPP/file getattributes.cpp#1)]
 [!code-csharp[File GetAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/File GetAttributes/CS/file getattributes.cs#1)]
 [!code-vb[File GetAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File GetAttributes/VB/file getattributes.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> está vazio, contém somente espaços em branco, contém caracteres inválidos ou o atributo de arquivo é inválido.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora de criação.</param>
        <param name="creationTime">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a data de criação e a hora de <c>caminho</c>. Esse valor é expresso no horário local.</param>
        <summary>Define a data e a hora em que o arquivo foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Unidades formatadas como NTFS podem armazenar em cache informações-metadados do arquivo, como a hora de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituir um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao realizar a operação.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas ou ambos permitidos para esta operação.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora de criação.</param>
        <param name="creationTimeUtc">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a data de criação e a hora de <c>caminho</c>. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, em vez de universal coordenado (UTC), que o arquivo foi criado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Unidades formatadas como NTFS podem armazenar em cache informações-metadados do arquivo, como a hora de criação do arquivo, por um curto período de tempo. Como resultado, pode ser necessário definir explicitamente a hora de criação de um arquivo, se você estiver substituindo ou substituir um arquivo existente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao realizar a operação.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas ou ambos permitidos para esta operação.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo cujas informações de data e hora serão definidas.</param>
        <param name="lastAccessTime">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para o acesso de data e hora da última <c>caminho</c>. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora em que o arquivo especificado foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir verifica se o sistema de arquivos para o arquivo especificado, criá-lo se necessário e, em seguida, define e obtém a hora do último acesso.  
  
 [!code-cpp[file setlastaccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastAccess/CPP/file setlastaccess.cpp#1)]
 [!code-csharp[file setlastaccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastAccess/CS/file setlastaccess.cs#1)]
 [!code-vb[file setlastaccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastAccess/VB/file setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo cujas informações de data e hora serão definidas.</param>
        <param name="lastAccessTimeUtc">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para o acesso de data e hora da última <c>caminho</c>. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, em vez de universal coordenado (UTC), que o arquivo especificado foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora.</param>
        <param name="lastWriteTime">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a gravação de data e hora da última <c>caminho</c>. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora em que o arquivo especificado foi usado para gravação pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir verifica se o sistema de arquivos para o arquivo especificado, a criação do arquivo, se necessário e, em seguida, define e obtém o último tempo de gravação do arquivo.  
  
 [!code-cpp[file setlastwrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/File SetLastWrite/CPP/file setlastwrite.cpp#1)]
 [!code-csharp[file setlastwrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/File SetLastWrite/CS/file setlastwrite.cs#1)]
 [!code-vb[file setlastwrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/File SetLastWrite/VB/file setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para o qual obter as informações de data e hora.</param>
        <param name="lastWriteTimeUtc">Um <see cref="T:System.DateTime" /> que contém o valor a ser definido para a gravação de data e hora da última <c>caminho</c>. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, em UTC (Tempo Universal Coordenado), em que o arquivo especificado foi gravado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no arquivo especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytes">
      <MemberSignature Language="C#" Value="public static void WriteAllBytes (string path, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllBytes(string path, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytes(System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="bytes">Os bytes a serem gravados no arquivo.</param>
        <summary>Cria um novo arquivo, grava a matriz de bytes especificada no arquivo e fecha o arquivo. Se o arquivo de destino já existir, ele será substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dada uma matriz de bytes e um caminho de arquivo, este método abre o arquivo especificado, grava o conteúdo da matriz de bytes no arquivo e, em seguida, fecha o arquivo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" /> ou a matriz de bytes está vazia.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso para gravar um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllBytesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllBytesAsync (string path, byte[] bytes, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllBytesAsync(string path, unsigned int8[] bytes, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllBytesAsync(System.String,System.Byte[],System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="bytes">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">As linhas a serem gravadas no arquivo.</param>
        <summary>Cria um novo arquivo, grava uma coleção de cadeias de caracteres no arquivo e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento padrão do <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método é gravar os dados usando a codificação UTF-8 sem uma marca de ordem de byte (BOM). Se for necessário incluir um identificador de UTF-8, como uma marca de ordem de byte no início de um arquivo, use o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.Text.Encoding%29> sobrecarga de método com <xref:System.Text.Encoding.UTF8%2A> codificação.  
  
 Se o arquivo de destino já existir, ele será substituído.  
  
 Você pode usar esse método para criar o conteúdo de uma classe de coleção que usa um <xref:System.Collections.Generic.IEnumerable%601> em seu construtor, como um <xref:System.Collections.Generic.List%601.%23ctor%2A>, <xref:System.Collections.Generic.HashSet%601.%23ctor%2A>, ou um <xref:System.Collections.Generic.SortedSet%601.%23ctor%2A> classe.  
  
   
  
## Examples  
 O exemplo a seguir grava linhas selecionadas de um arquivo de dados de exemplo em um arquivo.  
  
 [!code-csharp[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.file.writeallappendall/cs/program.cs#1)]
 [!code-vb[System.IO.File.WriteAllAppendAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.file.writeallappendall/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> é um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A matriz de cadeia de caracteres a ser gravada no arquivo.</param>
        <summary>Cria um novo arquivo, grava a matriz de cadeia de caracteres especificada no arquivo e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo de destino já existir, ele será substituído.  
  
 O comportamento padrão do <xref:System.IO.File.WriteAllLines%2A> método é gravar os dados usando a codificação UTF-8 sem uma marca de ordem de byte (BOM). Se for necessário incluir um identificador de UTF-8, como uma marca de ordem de byte no início de um arquivo, use o <xref:System.IO.File.WriteAllLines%28System.String%2CSystem.String%5B%5D%2CSystem.Text.Encoding%29> sobrecarga de método com <xref:System.Text.Encoding.UTF8%2A> codificação.  
  
 Dada uma matriz de cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a matriz de cadeia de caracteres para o arquivo e, em seguida, fecha o arquivo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllLines%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllLines#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso para gravar um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">As linhas a serem gravadas no arquivo.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Cria um novo arquivo usando a codificação especificada, grava uma coleção de cadeias de caracteres no arquivo e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo de destino já existir, ele será substituído.  
  
 Você pode usar esse método para criar um arquivo que contém o seguinte:  
  
-   Os resultados de uma [objetos LINQ to](http://msdn.microsoft.com/library/73cafe73-37cf-46e7-bfa7-97c7eea7ced9) consultar as linhas de um arquivo, como obtida usando o <xref:System.IO.File.ReadLines%2A> método.  
  
-   O conteúdo de uma coleção que implementa um <xref:System.Collections.Generic.IEnumerable%601> de cadeias de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou contém um ou mais caracteres inválidos definidos pelo método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" />, <paramref name="contents" />, ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido (por exemplo, está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">
          <paramref name="path" /> excede o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especifica um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> é um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLines">
      <MemberSignature Language="C#" Value="public static void WriteAllLines (string path, string[] contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllLines(string path, string[] contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLines(System.String,System.String[],System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String[]" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A matriz de cadeia de caracteres a ser gravada no arquivo.</param>
        <param name="encoding">Um objeto <see cref="T:System.Text.Encoding" /> que representa a codificação de caracteres aplicada à matriz de cadeia de caracteres.</param>
        <summary>Cria um novo arquivo, grava a matriz de cadeia de caracteres especificada no arquivo usando a codificação especificada e fecha o arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo de destino já existir, ele será substituído.  
  
 Dada uma matriz de cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a matriz de cadeia de caracteres para o arquivo usando a codificação especificada e, em seguida, fecha o arquivo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllLines%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllLines_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/cs/AllText_Encoding.cs#00)]
 [!code-vb[System.IO.File.AllLines_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllLines_Encoding/vb/AllText_Encoding.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">O <paramref name="path" /> ou <paramref name="contents" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso para gravar um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllLinesAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllLinesAsync (string path, System.Collections.Generic.IEnumerable&lt;string&gt; contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllLinesAsync(string path, class System.Collections.Generic.IEnumerable`1&lt;string&gt; contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllLinesAsync(System.String,System.Collections.Generic.IEnumerable{System.String},System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A cadeia de caracteres a ser gravada no arquivo.</param>
        <summary>Cria um novo arquivo, grava a cadeia de caracteres especificada no arquivo e fecha o arquivo. Se o arquivo de destino já existir, ele será substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa UTF-8 codificação sem uma marca de ordem de Byte (BOM), portanto, usar o <xref:System.Text.Encoding.GetPreamble%2A> método retornará uma matriz de bytes vazia. Se for necessário incluir um identificador de UTF-8, como uma marca de ordem de byte no início de um arquivo, use o <xref:System.IO.File.WriteAllText%28System.String%2CSystem.String%2CSystem.Text.Encoding%29> sobrecarga de método com <xref:System.Text.Encoding.UTF8%2A> codificação.  
  
 Devido a uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a cadeia de caracteres para o arquivo e, em seguida, fecha o arquivo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllText%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" /> ou <paramref name="contents" /> está vazio.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso para gravar um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllText">
      <MemberSignature Language="C#" Value="public static void WriteAllText (string path, string contents, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteAllText(string path, string contents, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo para gravação.</param>
        <param name="contents">A cadeia de caracteres a ser gravada no arquivo.</param>
        <param name="encoding">A codificação a ser aplicada à cadeia de caracteres.</param>
        <summary>Cria um novo arquivo, grava a cadeia de caracteres especificada no arquivo usando a codificação especificada e fecha o arquivo. Se o arquivo de destino já existir, ele será substituído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Devido a uma cadeia de caracteres e um caminho de arquivo, este método abre o arquivo especificado, grava a cadeia de caracteres para o arquivo usando a codificação especificada e, em seguida, fecha o arquivo. O identificador de arquivo é garantido para ser fechada por esse método, mesmo se as exceções são geradas.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.IO.File.WriteAllText%2A> método para gravar texto em um arquivo. Neste exemplo um arquivo é criado, caso ainda não existir, e o texto é adicionado a ele.  
  
 [!code-csharp[System.IO.File.AllText_Encoding#00](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/cs/AllText.cs#00)]
 [!code-vb[System.IO.File.AllText_Encoding#00](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.File.AllText_Encoding/vb/AllText.vb#00)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" /> ou <paramref name="contents" /> está vazio.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="path" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="path" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acesso para gravar um arquivo ou diretório. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteAllTextAsync">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.Task WriteAllTextAsync (string path, string contents, System.Text.Encoding encoding, System.Threading.CancellationToken cancellationToken = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.Task WriteAllTextAsync(string path, string contents, class System.Text.Encoding encoding, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.File.WriteAllTextAsync(System.String,System.String,System.Text.Encoding,System.Threading.CancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="contents" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" />
      </Parameters>
      <Docs>
        <param name="path">To be added.</param>
        <param name="contents">To be added.</param>
        <param name="encoding">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
