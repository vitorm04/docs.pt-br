<Type Name="StreamReader" FullName="System.IO.StreamReader">
  <TypeSignature Language="C#" Value="public class StreamReader : System.IO.TextReader" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit StreamReader extends System.IO.TextReader" />
  <TypeSignature Language="DocId" Value="T:System.IO.StreamReader" />
  <AssemblyInfo>
    <AssemblyName>System.IO</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.IO.TextReader</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa um <see cref="T:System.IO.TextReader" /> que lê caracteres de um fluxo de bytes em uma codificação específica.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/io/streamreader.cs#b5fe1efcec14de32). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 <xref:System.IO.StreamReader>foi projetada para entrada de caractere em uma codificação específica, enquanto o <xref:System.IO.Stream> classe destina-se a entrada e saída em bytes. Use <xref:System.IO.StreamReader> para ler as linhas de informações de um arquivo de texto padrão.  
  
> [!IMPORTANT]
>  Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
 <xref:System.IO.StreamReader>o padrão é a codificação UTF-8, a menos que especificado o contrário, em vez de como padrão para a página de código ANSI do sistema atual. UTF-8 trata os caracteres Unicode corretamente e fornece resultados consistentes em versões localizadas do sistema operacional. Se você receber a atual codificação de caracteres usando o <xref:System.IO.StreamReader.CurrentEncoding%2A> propriedade, o valor não é confiável até após a primeira <xref:System.IO.StreamReader.Read%2A> método, desde que a detecção automática de codificação não é feita até que a primeira chamada para um <xref:System.IO.StreamReader.Read%2A> método.  
  
 Por padrão, um <xref:System.IO.StreamReader> não é thread-safe. Consulte <xref:System.IO.TextReader.Synchronized%2A?displayProperty=nameWithType> para um wrapper thread-safe.  
  
 O <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.IO.StreamWriter.Write%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecargas do método de leitura e gravação o número de caracteres especificado pelo `count` parâmetro. Eles devem ser distinguidos <xref:System.IO.BufferedStream.Read%2A?displayProperty=nameWithType> e <xref:System.IO.BufferedStream.Write%2A?displayProperty=nameWithType>, qual ler e gravar o número de bytes especificado pelo `count` parâmetro. Use o <xref:System.IO.BufferedStream> métodos somente para leitura e gravação a um número integral de byte elementos da matriz.  
  
> [!NOTE]
>  Durante a leitura de um <xref:System.IO.Stream>, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância de <xref:System.IO.StreamReader> para ler texto de um arquivo. Não há suporte para o construtor usado neste exemplo para uso em [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos.  
  
 [!code-cpp[readtextfile#1](~/samples/snippets/cpp/VS_Snippets_CLR/ReadTextFile/CPP/readtextfile.cpp#1)]
 [!code-csharp[readtextfile#1](~/samples/snippets/csharp/VS_Snippets_CLR/ReadTextFile/CS/readtextfile.cs#1)]
 [!code-vb[readtextfile#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ReadTextFile/VB/readtextfile.vb#1)]  
  
 O exemplo a seguir cria um <xref:System.IO.StreamReader> objeto e chama seu <xref:System.IO.StreamReader.ReadAsync%2A> método para ler um arquivo de forma assíncrona.  
  
 [!code-csharp[System.IO.StreamReader#51](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/asyncex1.cs#51)]
 [!code-vb[System.IO.StreamReader#51](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/asyncex1.vb#51)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação para <xref:System.Text.UTF8Encoding>, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno a 1024 bytes.  
  
 O <xref:System.IO.StreamReader> objeto chamadas <xref:System.IO.Stream.Dispose> em fornecidos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[strmreader ctor1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor1/CPP/strmreader ctor1.cpp#1)]
 [!code-csharp[strmreader ctor1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor1/CS/strmreader ctor1.cs#1)]
 [!code-vb[strmreader ctor1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor1/VB/strmreader ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caminho completo do arquivo é especificado pelo `path` parâmetro. Este construtor inicializa a codificação para <xref:System.Text.UTF8Encoding> e o tamanho do buffer a 1024 bytes.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado em disco; pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[strmreader ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Ctor2/CPP/strmreader ctor2.cpp#1)]
 [!code-csharp[strmreader ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Ctor2/CS/strmreader ctor2.cs#1)]
 [!code-vb[strmreader ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Ctor2/VB/strmreader ctor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a opção de detecção da marca da ordem de byte especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação para <xref:System.Text.UTF8Encoding>, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno a 1024 bytes.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> objeto chamadas <xref:System.IO.Stream.Dispose> em fornecidos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a codificação de caractere especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A codificação de caracteres é definida pelo `encoding` parâmetro e o tamanho do buffer é definida como 1024 bytes. O <xref:System.IO.StreamReader> objeto tenta detectar a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário será usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> objeto chamadas <xref:System.IO.Stream.Dispose> em fornecidos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> do nome do arquivo especificado, com a opção de detecção de marca de ordem de byte especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação para <xref:System.Text.UTF8Encoding>, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno a 1024 bytes.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado em disco; pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, o <xref:System.Text.UTF8Encoding> é usado. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado, com a codificação de caractere especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro e o tamanho do buffer interno a 1024 bytes. O <xref:System.IO.StreamReader> objeto tenta detectar a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário será usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado em disco; pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a codificação de caracteres e a opção de detecção de marca de ordem de byte especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro, o <xref:System.IO.StreamReader.BaseStream%2A> propriedade usando o `stream` parâmetro e o tamanho do buffer interno a 1024 bytes.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário será usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> objeto chamadas <xref:System.IO.Stream.Dispose> em fornecidos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="stream" /> não dá suporte à leitura.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado, com a codificação de caractere e opção de detecção da marca da ordem de byte especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro e o tamanho do buffer interno a 1024 bytes.  
  
 O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário será usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado em disco; pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <param name="bufferSize">O tamanho mínimo do buffer.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado, com a codificação de caracteres, a opção de detecção de marca de ordem de byte e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho do buffer, no número de caracteres de 16 bits, é definido pelo `bufferSize` parâmetro. Se `bufferSize` é menor que o tamanho mínimo permitido (128 caracteres), o tamanho mínimo permitido é usado.  
  
 Este construtor permite que você altere a codificação na primeira vez que você leia o <xref:System.IO.StreamReader> objeto. O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário será usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O <xref:System.IO.StreamReader> objeto chamadas <xref:System.IO.Stream.Dispose> em fornecidos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
> [!NOTE]
>  Durante a leitura de um <xref:System.IO.Stream>, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Não há suporte para leitura no fluxo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stream" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bufferSize" /> é menor que ou igual a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (string path, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.String,System.Text.Encoding,System.Boolean,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="path">O caminho completo do arquivo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">Indica se é necessário procurar marcas de ordem de byte no início do arquivo.</param>
        <param name="bufferSize">O tamanho do buffer mínimo, em número de caracteres de 16 bits.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o nome de arquivo especificado, com a codificação de caracteres, a opção de detecção de marca de ordem de byte e o tamanho do buffer especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor inicializa a codificação conforme especificado pelo `encoding` parâmetro.  
  
 Este construtor permite que você altere a codificação na primeira vez que você leia o <xref:System.IO.StreamReader> objeto. O `detectEncodingFromByteOrderMarks` parâmetro detecta a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário será usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
 O tamanho do buffer, no número de caracteres de 16 bits, é definido pelo `bufferSize` parâmetro. Se `bufferSize` é menor que o tamanho mínimo permitido (128 caracteres), o tamanho mínimo permitido é usado.  
  
 O `path` parâmetro pode ser um nome de arquivo, incluindo um arquivo em um compartilhamento de convenção de nomenclatura Universal (UNC).  
  
 O `path` parâmetro não é necessário ser um arquivo armazenado em disco; pode ser qualquer parte de um sistema que dá suporte ao acesso usando fluxos.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres podem não ser pode ser interpretados e podem causar uma exceção seja lançada.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra isso <xref:System.IO.StreamReader> construtor.  
  
 [!code-cpp[System.IO.StreamReader#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.StreamReader/CPP/streamreadersample.cpp#2)]
 [!code-csharp[System.IO.StreamReader#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/streamreadersample.cs#2)]
 [!code-vb[System.IO.StreamReader#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/streamreadersample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de caracteres vazia ("").</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="encoding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo não pode ser encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido, por exemplo, ele está em uma unidade não mapeada.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" /> inclui uma sintaxe incorreta ou inválida para o nome do arquivo, nome do diretório ou rótulo do volume.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffersize" /> é menor que ou igual a zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream stream, class System.Text.Encoding encoding, bool detectEncodingFromByteOrderMarks, int32 bufferSize, bool leaveOpen) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.#ctor(System.IO.Stream,System.Text.Encoding,System.Boolean,System.Int32,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="encoding" Type="System.Text.Encoding" />
        <Parameter Name="detectEncodingFromByteOrderMarks" Type="System.Boolean" />
        <Parameter Name="bufferSize" Type="System.Int32" />
        <Parameter Name="leaveOpen" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="stream">O fluxo a ser lido.</param>
        <param name="encoding">A codificação de caracteres a ser usada.</param>
        <param name="detectEncodingFromByteOrderMarks">
          <see langword="true" /> para procurar marcas de ordem de byte no início do arquivo; caso contrário, <see langword="false" />.</param>
        <param name="bufferSize">O tamanho mínimo do buffer.</param>
        <param name="leaveOpen">
          <see langword="true" /> para deixar o fluxo aberto após o objeto <see cref="T:System.IO.StreamReader" /> ser descartado; caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.IO.StreamReader" /> para o fluxo especificado com base na codificação de caractere especificada, na opção de detecção de marca de ordem de byte, no tamanho do buffer e, opcionalmente, deixa o fluxo aberto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menos que você defina o `leaveOpen` parâmetro `true`, o <xref:System.IO.StreamReader> objeto chamadas <xref:System.IO.Stream.Dispose> em fornecidos <xref:System.IO.Stream> objeto quando <xref:System.IO.StreamReader.Dispose%2A?displayProperty=nameWithType> é chamado.  
  
 O tamanho do buffer, no número de caracteres de 16 bits, é definido pelo `bufferSize` parâmetro. Se `bufferSize` é menor que o tamanho mínimo permitido (128 caracteres), o tamanho mínimo permitido é usado.  
  
 Este construtor permite que você altere a codificação na primeira vez que você leia o <xref:System.IO.StreamReader> objeto. Se o `detectEncodingFromByteOrderMarks` parâmetro é `true`, o construtor detecta a codificação, observando os três primeiros bytes do fluxo. Reconhece automaticamente Unicode UTF-8, little endian e marca de texto Unicode big-endian se o arquivo começa com a ordem de byte apropriado. Caso contrário, a codificação fornecida pelo usuário será usada. Consulte o método <xref:System.Text.Encoding.GetPreamble%2A?displayProperty=nameWithType> para obter mais informações.  
  
> [!NOTE]
>  Durante a leitura de um <xref:System.IO.Stream>, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo.  
  
> [!CAUTION]
>  Quando você compila um conjunto de caracteres com uma determinada configuração cultural e recuperar os mesmos caracteres com uma configuração de cultura diferente, os caracteres não podem ser interpretados corretamente e podem causar uma exceção seja lançada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream BaseStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream BaseStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.BaseStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o fluxo subjacente.</summary>
        <value>O fluxo subjacente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para acessar o fluxo subjacente. O <xref:System.IO.StreamReader> classe entrada de buffers do fluxo subjacente quando você chama um do <xref:System.IO.StreamReader.Read%2A> métodos. Se você pode manipular a posição do fluxo subjacente depois de ler dados no buffer, a posição do fluxo subjacente não pode corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado apenas quando absolutamente necessário. O <xref:System.IO.StreamReader> construtores que têm o `detectEncodingFromByteOrderMarks` parâmetro pode alterar a codificação na primeira vez que você leia o <xref:System.IO.StreamReader> objeto.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha o objeto <see cref="T:System.IO.StreamReader" /> e o fluxo subjacente e libera os recursos do sistema associados ao leitor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método substitui o <xref:System.IO.TextWriter.Close%2A?displayProperty=nameWithType> método.  
  
 Essa implementação de <xref:System.IO.StreamReader.Close%2A> chama o <xref:System.IO.StreamReader.Dispose%2A> método passando um `true` valor.  
  
 Liberando o fluxo não liberar seu codificador subjacente, a menos que você chamar explicitamente <xref:System.IO.StreamReader.Close%2A>. Configuração <xref:System.IO.StreamWriter.AutoFlush%2A> para `true` significa que os dados serão liberados do buffer no fluxo, mas o estado de codificador não será liberado. Isso permite que o codificador deve manter o estado (parcial caracteres) para que ele pode codificar o próximo bloco de caracteres corretamente. Este cenário afeta UTF8 e UTF7, onde alguns caracteres podem ser codificados somente depois que o codificador recebe adjacentes ou mais caracteres.  
  
 Após uma chamada para <xref:System.IO.StreamReader.Close%2A>, todas as operações do leitor podem gerar exceções.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentEncoding">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoding CurrentEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding CurrentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.CurrentEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a codificação de caracteres atual que está sendo usada pelo objeto <see cref="T:System.IO.StreamReader" /> atual.</summary>
        <value>A codificação de caracteres atual usada pelo leitor atual. O valor pode ser diferente após a primeira chamada para qualquer método <see cref="Overload:System.IO.StreamReader.Read" /> de <see cref="T:System.IO.StreamReader" />, pois a detecção automática de codificação só é feita após a primeira chamada a um método <see cref="Overload:System.IO.StreamReader.Read" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir obtém a codificação especificada <xref:System.IO.StreamReader> objeto.  
  
 [!code-cpp[strmreader currentencoding#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader CurrentEncoding/CPP/strmreader currentencoding.cpp#1)]
 [!code-csharp[strmreader currentencoding#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader CurrentEncoding/CS/strmreader currentencoding.cs#1)]
 [!code-vb[strmreader currentencoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader CurrentEncoding/VB/strmreader currentencoding.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DiscardBufferedData">
      <MemberSignature Language="C#" Value="public void DiscardBufferedData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DiscardBufferedData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.DiscardBufferedData" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Limpa o buffer interno.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método para redefinir o buffer interno para o <xref:System.IO.StreamReader> objeto. Você precisa chamar este método somente quando a posição do buffer interno e o <xref:System.IO.StreamReader.BaseStream%2A> não coincidem. Essas posições podem se tornar incompatíveis ao ler os dados no buffer e, em seguida, busca de uma nova posição no fluxo subjacente. Esse método reduz o desempenho e deve ser usado apenas quando absolutamente necessário, como quando você deseja ler uma parte do conteúdo de um <xref:System.IO.StreamReader> do objeto mais de uma vez.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra um cenário em que o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método deve ser chamado para sincronizar o buffer interno e o fluxo subjacente. O arquivo de exemplo é usado para ilustrar a posição e consiste no texto `abcdefghijklmnopqrstuvwxyz`. Chamando <xref:System.IO.StreamReader.DiscardBufferedData%2A> depois que os dados são lidos, o exemplo funciona conforme o esperado. Depois que os primeiros 15 caracteres são lidos, a posição é redefinida para o valor de deslocamento de 2 e todos os caracteres restantes são lidos. Se você remover a chamada para <xref:System.IO.StreamReader.DiscardBufferedData%2A>, o exemplo não funcionar conforme o esperado. Os primeiros 15 caracteres são lidos, mas apenas a posição do fluxo subjacente é redefinida. O buffer interno do <xref:System.IO.StreamReader> objeto ainda está a 16 caracteres. Portanto, <xref:System.IO.StreamReader.ReadToEnd%2A> retorna todos os caracteres no buffer de mais os caracteres no fluxo subjacente desde a posição de redefinição.  
  
 [!code-csharp[System.IO.StreamReader#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/program.cs#30)]
 [!code-vb[System.IO.StreamReader#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/module1.vb#30)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Fecha o fluxo subjacente, libera os recursos não gerenciados usados pelo <see cref="T:System.IO.StreamReader" /> e, opcionalmente, libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público <xref:System.IDisposable.Dispose%2A> e pelo método <xref:System.Object.Finalize%2A>. <xref:System.IDisposable.Dispose%2A>invoca o protegido <xref:System.IO.StreamReader.Dispose%2A> método com o `disposing` como verdadeiro. <xref:System.Object.Finalize%2A>invoca <xref:System.IO.StreamReader.Dispose%2A> com `disposing` definido como false.  
  
 Quando o `disposing` parâmetro é `true`, esse método versões todos os recursos mantidos por qualquer gerenciados objetos que o <xref:System.IO.StreamReader> referências de objeto. Este método invoca o método <xref:System.IDisposable.Dispose%2A> de cada objeto referenciado.  
  
 .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Dispose pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" />, tenha cuidado em não para referenciar objetos que têm foi descartados anteriormente em uma chamada anterior para Dispose [cref...]. Para obter mais informações sobre como implementar <see cref="M:System.IO.StreamReader.Dispose(System.Boolean)" /> consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see cref="M:System.IDisposable.Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="EndOfStream">
      <MemberSignature Language="C#" Value="public bool EndOfStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfStream" />
      <MemberSignature Language="DocId" Value="P:System.IO.StreamReader.EndOfStream" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a posição do fluxo atual está no final do fluxo.</summary>
        <value>
          <see langword="true" /> se a posição do fluxo atual estiver no final do fluxo; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ObjectDisposedException">O fluxo subjacente foi descartado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Null">
      <MemberSignature Language="C#" Value="public static readonly System.IO.StreamReader Null;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.IO.StreamReader Null" />
      <MemberSignature Language="DocId" Value="F:System.IO.StreamReader.Null" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Um objeto <see cref="T:System.IO.StreamReader" /> em torno de um fluxo vazio.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao ler os métodos são chamados em <xref:System.IO.StreamReader.Null>, sempre será retornado zero. Quando <xref:System.IO.StreamReader.ReadLine%2A> é chamado em <xref:System.IO.StreamReader.Null>, `null` será retornado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public override int Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o próximo caractere disponível, mas não o consome.</summary>
        <returns>Um inteiro que representa o próximo caractere a ser lido, ou -1, se não houver nenhum caractere a ser lido ou se o fluxo não der suporte para busca.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.StreamReader.Peek%2A> método retorna um valor inteiro para determinar se o final do arquivo ou outro erro ocorreu. Isso permite que um usuário pela primeira vez, verifique se o valor retornado será -1 antes de convertê-la para um <xref:System.Char> tipo.  
  
 Este método substitui <xref:System.IO.TextReader.Peek%2A?displayProperty=nameWithType>.  
  
 A posição atual do <xref:System.IO.StreamReader> objeto não é alterado pela <xref:System.IO.StreamReader.Peek%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir lê linhas de um arquivo até o final do arquivo for atingido.  
  
 [!code-cpp[strmreader peek#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Peek/CPP/strmreader peek.cpp#1)]
 [!code-csharp[strmreader peek#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Peek/CS/strmreader peek.cs#1)]
 [!code-vb[strmreader peek#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Peek/VB/strmreader peek.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o próximo caractere do fluxo de entrada e avança a posição do caractere em um caractere.</summary>
        <returns>O próximo caractere do fluxo de entrada representado como um objeto <see cref="T:System.Int32" />, ou -1, se não houver mais caracteres disponíveis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Esse método retorna um inteiro para que ele pode retornar -1 se o fim do fluxo foi atingido. Se você pode manipular a posição do fluxo subjacente depois de ler dados no buffer, a posição do fluxo subjacente não pode corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado apenas quando absolutamente necessário.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de um simples de <xref:System.IO.StreamReader.Read%2A> método.  
  
 [!code-cpp[strmreader read1#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read1/CPP/strmreader read1.cpp#1)]
 [!code-csharp[strmreader read1#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read1/CS/strmreader read1.cs#1)]
 [!code-vb[strmreader read1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read1/VB/strmreader read1.vb#1)]  
  
 O exemplo de código a seguir demonstra a leitura de um único caractere usando o <xref:System.IO.StreamReader.Read> sobrecarga do método, formatação de inteiro de ASCII de saída como decimal e hexadecimal.  
  
 [!code-cpp[StrmRdrRead#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmRdrRead/CPP/strmrdrread.cpp#1)]
 [!code-csharp[StrmRdrRead#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmRdrRead/CS/strmrdrread.cs#1)]
 [!code-vb[StrmRdrRead#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmRdrRead/VB/strmrdrread.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override int Read (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 Read([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.Read(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando este método retorna, contém a matriz de caractere especificado com os valores entre <c>índice</c> e (<c>índice + contagem - 1</c>) substituídos pelos caracteres lidos da origem atual.</param>
        <param name="index">O índice do <c>buffer</c> no qual começar a escrever.</param>
        <param name="count">O número máximo de caracteres a serem lidos.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual em um buffer, começando no índice especificado.</summary>
        <returns>O número de caracteres que foram lidos, ou 0, se estiver no final do fluxo e nenhum dado foi lido. O número será menor ou igual ao parâmetro <paramref name="count" />, dependendo se os dados estão disponíveis no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.TextReader.Read%2A?displayProperty=nameWithType>.  
  
 Esse método retorna um inteiro para que ele pode retornar 0 se o fim do fluxo foi atingido.  
  
 Ao usar o <xref:System.IO.StreamReader.Read%2A> método, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno de fluxo, em que o buffer interno é definido como o tamanho do bloco desejado e leia sempre menor que o tamanho do bloco. Se o tamanho do buffer interno foi especificado quando o fluxo foi construído, o tamanho padrão é 4 KB (4096 bytes). Se você pode manipular a posição do fluxo subjacente depois de ler dados no buffer, a posição do fluxo subjacente não pode corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado apenas quando absolutamente necessário.  
  
 Este método retorna após um número de caracteres especificado pelo `count` parâmetro são lidas ou o final do arquivo for atingido. <xref:System.IO.TextReader.ReadBlock%2A>é uma versão de bloqueio de <xref:System.IO.StreamReader.Read%2A>.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir lê cinco caracteres de cada vez até o final do arquivo for atingido.  
  
 [!code-cpp[strmreader read2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader Read2/CPP/strmreader read2.cpp#1)]
 [!code-csharp[strmreader read2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader Read2/CS/strmreader read2.cs#1)]
 [!code-vb[strmreader read2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader Read2/VB/strmreader read2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho do buffer menos <paramref name="index" /> é menor que <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.IO.IOException">Erro de E/S, por exemplo, o fluxo está fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando este método retorna, contém a matriz de caractere especificado com os valores entre <c>índice</c> e (<c>índice</c> + <c>contagem</c> - 1) substituídos pelos caracteres ler da origem atual.</param>
        <param name="index">A posição na <c>buffer</c> no qual começar a escrever.</param>
        <param name="count">O número máximo de caracteres a serem lidos. Se o final do fluxo for atingido antes que o número especificado de caracteres seja gravado no buffer, o método atual será retornado.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual de forma assíncrona e grava os dados em um buffer, começando no índice especificado.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de caracteres lidos no buffer. O valor do resultado poderá ser menor que o número de caracteres solicitados se o número de caracteres disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa é concluída após um número de caracteres especificado pelo `count` parâmetro são lidas ou o fim do fluxo for atingido.  
  
   
  
## Examples  
 O exemplo a seguir mostra como ler todos os caracteres em um arquivo usando o <xref:System.IO.StreamReader.ReadAsync%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método. Ele verifica se cada caractere é uma letra, dígito ou espaço em branco antes de adicionar o caractere a uma instância do <xref:System.Text.StringBuilder> classe.  
  
 [!code-csharp[System.IO.StreamReader#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example42.cs#42)]
 [!code-vb[System.IO.StreamReader#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example42.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="index" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlock">
      <MemberSignature Language="C#" Value="public override int ReadBlock (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadBlock([out] char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlock(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando este método retorna, contém a matriz de caractere especificado com os valores entre <c>índice</c> e (<c>índice + contagem - 1</c>) substituídos pelos caracteres lidos da origem atual.</param>
        <param name="index">A posição na <c>buffer</c> no qual começar a escrever.</param>
        <param name="count">O número máximo de caracteres a serem lidos.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual e grava os dados em um buffer, começando no índice especificado.</summary>
        <returns>O número de caracteres que foram lidos. O número será menor ou igual a <paramref name="count" />, dependendo se todos os caracteres de entrada tiverem sido lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A posição do fluxo subjacente é avançada, o número de caracteres que foram lidas em `buffer`.  
  
 Os blocos de método até que o `count` caracteres são lidas ou o fim do fluxo foi atingido. Esta é uma versão de bloqueio de <xref:System.IO.StreamReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O tamanho do buffer menos <paramref name="index" /> é menor que <paramref name="count" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.IO.StreamReader" /> está fechado.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadBlockAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;int&gt; ReadBlockAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadBlockAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadBlockAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Quando este método retorna, contém a matriz de caractere especificado com os valores entre <c>índice</c> e (<c>índice</c> + <c>contagem</c> - 1) substituídos pelos caracteres ler da origem atual.</param>
        <param name="index">A posição na <c>buffer</c> no qual começar a escrever.</param>
        <param name="count">O número máximo de caracteres a serem lidos. Se o final do fluxo for atingido antes que o número especificado de caracteres seja gravado no buffer, o método será retornado.</param>
        <summary>Lê um máximo especificado de caracteres do fluxo atual de forma assíncrona e grava os dados em um buffer, começando no índice especificado.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém o número total de caracteres lidos no buffer. O valor do resultado poderá ser menor que o número de caracteres solicitados se o número de caracteres disponíveis no momento for menor que o número solicitado ou poderá ser 0 (zero) se o final do fluxo for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tarefa não for concluída até que o número de caracteres especificado pelo `count` parâmetro são lidas ou o fim do fluxo foi atingido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException">A soma de <paramref name="index" /> e <paramref name="count" /> é maior que o tamanho do buffer.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public override string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê uma linha de caracteres do fluxo atual e retorna os dados como uma cadeia de caracteres.</summary>
        <returns>A próxima linha do fluxo de entrada, ou <see langword="null" />, se o final do fluxo de entrada for atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma linha é definida como uma cadeia de caracteres, seguido por uma linha de feed ("\n"), um retorno ("\r") ou um retorno de carro imediatamente seguido por uma linha de alimentação ("\r\n"). A cadeia de caracteres que é retornada não contém o retorno de carro de terminação ou uma alimentação de linha. O valor retornado é `null` se o final do fluxo de entrada é atingido.  
  
 Este método substitui <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType>.  
  
 Se o método atual gera um <xref:System.OutOfMemoryException>, posição do leitor subjacente <xref:System.IO.Stream> objeto avança pelo número de caracteres que o método foi capaz de ler, mas os caracteres já lidos no interno <xref:System.IO.StreamReader.ReadLine%2A> buffer são descartadas. Se você pode manipular a posição do fluxo subjacente depois de ler dados no buffer, a posição do fluxo subjacente não pode corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado apenas quando absolutamente necessário.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir lê linhas de um arquivo até o final do arquivo for atingido.  
  
 [!code-cpp[strmreader readline#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadLine/CPP/strmreader readline.cpp#1)]
 [!code-csharp[strmreader readline#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadLine/CS/strmreader readline.cs#1)]
 [!code-vb[strmreader readline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadLine/VB/strmreader readline.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para alocar um buffer à cadeia de caracteres retornada.</exception>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadLineAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadLineAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadLineAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadLineAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê uma linha de caracteres assincronamente do fluxo atual e retorna os dados como uma cadeia de caracteres.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém a próxima linha do fluxo ou <see langword="null" /> se todos os caracteres tiverem sido lidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como ler a primeira linha de um arquivo usando o <xref:System.IO.StreamReader.ReadLineAsync> método.  
  
 [!code-csharp[System.IO.StreamReader#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example41.cs#41)]
 [!code-vb[System.IO.StreamReader#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example41.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de caracteres na próxima linha é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEnd">
      <MemberSignature Language="C#" Value="public override string ReadToEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadToEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEnd" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê todos os caracteres da posição atual até o final do fluxo.</summary>
        <returns>O restante do fluxo como uma cadeia de caracteres, da posição atual até o final. Se a posição atual estiver no final do fluxo, será retornada uma cadeia de caracteres vazia ("").</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método substitui <xref:System.IO.TextReader.ReadToEnd%2A?displayProperty=nameWithType>.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A>funciona melhor quando você precisa ler todas as entradas da posição atual até o final do fluxo. Se for necessário mais controle sobre o número de caracteres é lidos do fluxo, use o <xref:System.IO.StreamReader.Read%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga de método, que geralmente resulta em um melhor desempenho.  
  
 <xref:System.IO.StreamReader.ReadToEnd%2A>pressupõe-se de que o fluxo sabe quando atingiu um final. Para protocolos interativos no qual o servidor envia dados somente quando você pede a ele e não fecha a conexão, <xref:System.IO.StreamReader.ReadToEnd%2A> pode ser bloqueado indefinidamente porque ela não chegar a um término e deve ser evitada.  
  
 Observe que ao usar o <xref:System.IO.StreamReader.Read%2A> método, é mais eficiente usar um buffer que é o mesmo tamanho que o buffer interno do fluxo. Se o tamanho do buffer foi especificado quando o fluxo foi construído, o tamanho padrão é 4 KB (4096 bytes).  
  
 Se o método atual gera um <xref:System.OutOfMemoryException>, posição do leitor subjacente <xref:System.IO.Stream> objeto avança pelo número de caracteres que o método foi capaz de ler, mas os caracteres já lidos no interno <xref:System.IO.StreamReader.ReadLine%2A> buffer são descartadas. Se você pode manipular a posição do fluxo subjacente depois de ler dados no buffer, a posição do fluxo subjacente não pode corresponder a posição do buffer interno. Para redefinir o buffer interno, chame o <xref:System.IO.StreamReader.DiscardBufferedData%2A> método; no entanto, esse método reduz o desempenho e deve ser chamado apenas quando absolutamente necessário.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo de código a seguir lê até o final de um arquivo em uma única operação.  
  
 [!code-cpp[strmreader readtoend#1](~/samples/snippets/cpp/VS_Snippets_CLR/StrmReader ReadToEnd/CPP/strmreader readtoend.cpp#1)]
 [!code-csharp[strmreader readtoend#1](~/samples/snippets/csharp/VS_Snippets_CLR/StrmReader ReadToEnd/CS/strmreader readtoend.cs#1)]
 [!code-vb[strmreader readtoend#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StrmReader ReadToEnd/VB/strmreader readtoend.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OutOfMemoryException">Não há memória suficiente para alocar um buffer à cadeia de caracteres retornada.</exception>
        <exception cref="T:System.IO.IOException">Ocorre um erro de E/S.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToEndAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task&lt;string&gt; ReadToEndAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadToEndAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.StreamReader.ReadToEndAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê todos os caracteres da posição atual até o final do fluxo de forma assíncrona e os retorna como uma cadeia de caracteres.</summary>
        <returns>Uma tarefa que representa a operação de leitura assíncrona. O valor do parâmetro <paramref name="TResult" /> contém uma cadeia de caracteres da posição atual até o final do fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como ler o conteúdo de um arquivo usando o <xref:System.IO.StreamReader.ReadToEndAsync> método.  
  
 [!code-csharp[System.IO.StreamReader#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.StreamReader/CS/example40.cs#40)]
 [!code-vb[System.IO.StreamReader#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.StreamReader/VB/example40.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de caracteres é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O fluxo foi descartado.</exception>
        <exception cref="T:System.InvalidOperationException">O leitor está sendo usado no momento por uma operação de leitura anterior.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
