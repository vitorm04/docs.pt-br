<Type Name="Directory" FullName="System.IO.Directory">
  <TypeSignature Language="C#" Value="public static class Directory" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Directory extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IO.Directory" />
  <AssemblyInfo>
    <AssemblyName>System.IO.FileSystem</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Expõe métodos estáticos para criar, mover e enumerar em diretórios e subdiretórios. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/io/directory.cs#b3ad5f0ba800bb28). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Use o <xref:System.IO.Directory> classe para operações comuns, como copiar, mover, renomear, criar e excluir diretórios.  
  
-   Para criar um diretório, use uma da <xref:System.IO.Directory.CreateDirectory%2A> métodos.  
  
-   Para excluir um diretório, use uma da <xref:System.IO.Directory.Delete%2A> métodos.  
  
-   Para obter ou definir o diretório atual para um aplicativo, use o <xref:System.IO.Directory.GetCurrentDirectory%2A> ou <xref:System.IO.Directory.SetCurrentDirectory%2A> método.  
  
-   Para manipular <xref:System.DateTime> informações relacionadas à criação, acesso e a gravação de um diretório, usam os métodos como <xref:System.IO.Directory.SetLastAccessTime%2A> e <xref:System.IO.Directory.SetCreationTime%2A>.  
  
 Os métodos estáticos do <xref:System.IO.Directory> classe executar verificações de segurança em todos os métodos. Se você for reutilizar um objeto várias vezes, considere a possibilidade de usar o método de instância correspondente do <xref:System.IO.DirectoryInfo> em vez disso, como a segurança verificar será nem sempre ser necessárias.  
  
 Se você estiver executando apenas uma ação relacionada ao diretório, pode ser mais eficiente usar estático <xref:System.IO.Directory> método em vez de um correspondente <xref:System.IO.DirectoryInfo> método de instância. A maioria dos <xref:System.IO.Directory> métodos requerem o caminho para o diretório que você estiver manipulando.  
  
> [!NOTE]
>  Em membros que aceitam uma cadeia de caracteres `path` parâmetro, esse caminho deve ser bem formado ou uma exceção é gerada. Por exemplo, se um caminho é totalmente qualificado, mas começa com um espaço ("c:\temp"), a cadeia de caracteres de caminho não está cortada, portanto, o caminho é considerado malformado e uma exceção é gerada. Além disso, um caminho ou uma combinação de caminhos não pode ser totalmente qualificada duas vezes. Por exemplo, "c:\temp c:\windows" também gera uma exceção. Certifique-se de que seus caminhos são formados ao usar os métodos que aceitam uma cadeia de caracteres de caminho. Para obter mais informações, consulte <xref:System.IO.Path>.  
  
 Membros que aceitam um caminho, o caminho pode se referir a um arquivo ou um diretório. Você pode usar um caminho completo, um caminho relativo ou um caminho de convenção de nomenclatura Universal (UNC) para um nome de compartilhamento e servidor. Por exemplo, todos os seguintes são aceitáveis caminhos:  
  
-   "c:\\\MyDir" em c# ou "c:\MyDir" no Visual Basic.  
  
-   "MyDir\\\MySubdir" em c# ou "MyDir\MySubDir" no Visual Basic.  
  
-   "\\\\\\\MyServer\\\MyShare" em c#, ou "\\\MyServer\MyShare" no Visual Basic.  
  
 Por padrão, o acesso de leitura/gravação completa para novos diretórios é concedido a todos os usuários. No entanto, o aplicativo deve ter a segurança correta para acessar os diretórios existentes.  
  
 Permissões de demanda de um diretório e seus subdiretórios, a fim de cadeia de caracteres de caminho com o caractere separador de diretório. (Por exemplo, "C:\Temp\\" concede acesso ao C:\Temp\ e seus subdiretórios.) Permissões de demanda somente de um diretório específico, a cadeia de caracteres de caminho com um período de término. (Por exemplo, "C:\Temp\\." concede acesso apenas a C:\Temp\\, não em seus subdiretórios.)  
  
 Em membros que aceitam um `searchPattern` parâmetro, a cadeia de caracteres pode ser qualquer combinação de caracteres literais e dois caracteres-curinga; \* e?. Esse parâmetro não reconhece expressões regulares. Para obter mais informações, consulte o <xref:System.IO.Directory.EnumerateDirectories%28System.String%2CSystem.String%29> método ou qualquer outro método que usa o `searchPattern` parâmetro.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 <xref:System.IO.Directory>e <xref:System.IO.DirectoryInfo> não há suporte para uso em [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos. Para obter informações sobre como acessar arquivos e pastas em [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] aplicativos, consulte [acesso a dados e arquivos (aplicativos da Windows Store)](http://msdn.microsoft.com/library/windows/apps/hh758319.aspx).  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos de texto de um diretório e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais na pasta original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 O exemplo a seguir demonstra como usar o <xref:System.IO.Directory.EnumerateFiles%2A> método para recuperar uma coleção de arquivos de texto de um diretório e, em seguida, usar essa coleção em uma consulta para localizar todas as linhas que contêm "Exemplo".  
  
 [!code-csharp[System.IO.Directory#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class3.cs#11)]
 [!code-vb[System.IO.Directory#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class3.vb#11)]  
  
 O exemplo a seguir demonstra como mover um diretório e todos os seus arquivos para um novo diretório. O diretório original não existe mais depois que ela foi movida.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O diretório a ser criado.</param>
        <summary>Cria todos os diretórios e subdiretórios no caminho especificado, a menos que eles já existam.</summary>
        <returns>Um objeto que representa o diretório no caminho especificado. Esse objeto é retornado, independentemente se já existir um diretório no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os diretórios especificados em `path` são criados, a menos que elas já existem ou a menos que alguma parte do `path` é inválido. Se o diretório já existe, esse método não cria um novo diretório, mas ela retorna um <xref:System.IO.DirectoryInfo> objeto para o diretório existente.  
  
 O `path` parâmetro especifica um caminho de diretório, não um caminho de arquivo.  
  
 Os espaços à direita são removidos do final do `path` parâmetro antes de criar o diretório.  
  
 Você pode criar um diretório em um computador remoto, em um compartilhamento que você tem acesso de gravação. Há suporte para caminhos UNC; Por exemplo, você pode especificar o seguinte para `path`: `\\2009\Archives\December` no Visual Basic, e `\\\\2009\\Archives\\December` em c#.  
  
 Criar um diretório com somente o caractere dois-pontos (:) não tem suporte e fará com que um `NotSupportedException` seja gerada.  
  
   
  
## Examples  
 O exemplo a seguir cria e exclui o diretório especificado.  
  
 [!code-cpp[Dir_CreateDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_CreateDir/CPP/dir_createdir.cpp#1)]
 [!code-csharp[Dir_CreateDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_CreateDir/CS/dir_createdir.cs#1)]
 [!code-vb[Dir_CreateDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_CreateDir/VB/dir_createdir.vb#1)]  
  
 Para criar o diretório C:\Users\User1\Public\Html quando o diretório atual é C:\Users\User1, use qualquer uma das seguintes chamadas para garantir que a barra invertida é interpretada corretamente.  
  
 No Visual Basic:  
  
```  
Directory.CreateDirectory("Public\Html")   
    Directory.CreateDirectory("\Users\User1\Public\Html")   
    Directory.CreateDirectory("c:\Users\User1\Public\Html")  
```  
  
 No C#:  
  
```  
Directory.CreateDirectory("Public\\Html");  
    Directory.CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory.CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 Em C++:  
  
```  
Directory::CreateDirectory("Public\\Html");  
    Directory::CreateDirectory("\\Users\\User1\\Public\\Html");  
    Directory::CreateDirectory("c:\\Users\\User1\\Public\\Html");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O diretório especificado por <paramref name="path" /> é um arquivo.  
  
 -ou-  
  
 O nome da rede não é conhecido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="path" /> é prefixado ou contém somente um caractere de dois-pontos (:).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />contém um caractere de dois-pontos (:) que não faz parte de um rótulo de unidade ("c:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos ou diretórios. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDirectory">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo CreateDirectory (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo CreateDirectory(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.CreateDirectory(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">O diretório a ser criado.</param>
        <param name="directorySecurity">O controle de acesso a ser aplicado ao diretório.</param>
        <summary>Cria todos os diretórios no caminho especificado, a menos que o já existir, aplicando a segurança do Windows especificada.</summary>
        <returns>Um objeto que representa o diretório no caminho especificado. Esse objeto é retornado, independentemente se já existir um diretório no caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga de método para criar um diretório com controle de acesso, portanto, não há nenhuma possibilidade do que diretório pode ser acessado antes que a segurança é aplicada.  
  
 Todos os diretórios especificados no `path` parâmetro são criados, a menos que elas já existem ou a menos que alguma parte do `path` é inválido. O `path` parâmetro especifica um caminho de diretório, não um caminho de arquivo. Se o diretório já existe, esse método não cria um novo diretório, mas ela retorna um <xref:System.IO.DirectoryInfo> objeto para o diretório existente.  
  
 Os espaços à direita são removidos do final do `path` parâmetro antes de criar o diretório.  
  
 Você pode criar um diretório em um computador remoto, em um compartilhamento que você tem acesso de gravação. Há suporte para caminhos UNC; Por exemplo, você pode especificar o seguinte para `path`: `\\2009\Archives\December` no Visual Basic, e `\\\\2009\\Archives\\December` em c#.  
  
 Criar um diretório com somente o caractere dois-pontos (:) não é suportado e faz com que um `NotSupportedException` seja gerada.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo diretório com as regras de acesso para duas contas de usuário.  
  
 [!code-csharp[System.IO.Directory#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class7.cs#15)]
 [!code-vb[System.IO.Directory#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class7.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O diretório especificado por <paramref name="path" /> é um arquivo.  
  
 -ou-  
  
 O nome da rede não é conhecido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="path" /> é prefixado ou contém somente um caractere de dois-pontos (:).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="path" />contém um caractere de dois-pontos (:) que não faz parte de um rótulo de unidade ("c:\\").</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler e gravar arquivos e diretórios e para acessar o diretório de destino. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /> ação de segurança:<see cref="F:System.Security.Permissions.SecurityAction.Demand" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O nome do diretório vazio a ser removido. Este diretório deve estar vazio e ser gravável.</param>
        <summary>Exclui um diretório vazio de um caminho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método se comporta de forma idêntica ao <xref:System.IO.Directory.Delete%28System.String%2CSystem.Boolean%29> com `false` especificado para o segundo parâmetro.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Os espaços à direita são removidos do final do `path` parâmetro antes de excluir o diretório.  
  
 Este método lança um <xref:System.IO.IOException> se o diretório especificado no `path` parâmetro contém arquivos ou subpastas.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Em alguns casos, se você tiver o diretório especificado abrir no Explorador de arquivos, o <xref:System.IO.Directory.Delete%2A> método não poderá excluí-lo.  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo diretório e o subdiretório e, em seguida, exclua apenas a subpasta.  
  
 [!code-csharp[System.IO.Directory.Delete#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class1.cs#1)]
 [!code-vb[System.IO.Directory.Delete#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Já existe um arquivo com o mesmo nome e local especificado pelo <paramref name="path" />.  
  
 -ou-  
  
 O diretório é o diretório de trabalho atual do aplicativo.  
  
 -ou-  
  
 O diretório especificado por <paramref name="path" /> não está vazio.  
  
 -ou-  
  
 O diretório é somente leitura ou contém um arquivo somente leitura.  
  
 -ou-  
  
 O diretório está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> não existe ou não pôde ser encontrado.  
  
 -ou-  
  
 O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Delete">
      <MemberSignature Language="C#" Value="public static void Delete (string path, bool recursive);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Delete(string path, bool recursive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Delete(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="recursive" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="path">O nome do diretório a ser removido.</param>
        <param name="recursive">
          <see langword="true" />Para remover pastas, subpastas e arquivos <c>caminho</c>; caso contrário, <see langword="false" />.</param>
        <summary>Exclui o diretório especificado e, se indicado, todos os subdiretórios e arquivos no diretório.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Os espaços à direita são removidos do final do `path` parâmetro antes de excluir o diretório.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Se o `recursive` parâmetro é `true`, o usuário deve ter permissão de gravação para o diretório atual, bem como para todos os subdiretórios.  
  
 O comportamento desse método difere ligeiramente ao excluir um diretório que contém um ponto de nova análise, como um link simbólico ou um ponto de montagem. Se o ponto de nova análise é um diretório, como um ponto de montagem é desmontado e o ponto de montagem é excluído. Esse método não é recursivo através do ponto de nova análise. Se o ponto de nova análise é um link simbólico para um arquivo, o ponto de nova análise é excluído e não o destino do link simbólico.  
  
 Em alguns casos, se você tiver o diretório especificado abrir no Explorador de arquivos, o <xref:System.IO.Directory.Delete%2A> método não poderá excluí-lo.  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar um novo diretório, o subdiretório e o arquivo no subdiretório e, em seguida, recursivamente excluir todos os itens novos.  
  
 [!code-csharp[System.IO.Directory.Delete#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.delete/cs/class2.cs#2)]
 [!code-vb[System.IO.Directory.Delete#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.delete/vb/class2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Já existe um arquivo com o mesmo nome e local especificado pelo <paramref name="path" />.  
  
 -ou-  
  
 O diretório especificado por <paramref name="path" /> é somente leitura, ou <paramref name="recursive" /> é <see langword="false" /> e <paramref name="path" /> não é um diretório vazio.  
  
 -ou-  
  
 O diretório é o diretório de trabalho atual do aplicativo.  
  
 -ou-  
  
 O diretório contém um arquivo somente leitura.  
  
 -ou-  
  
 O diretório está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> não existe ou não pôde ser encontrado.  
  
 -ou-  
  
 O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar no diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna uma coleção enumerável de nomes de diretório em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os diretórios no diretório especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar informações de caminho relativo ou absoluto no `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Os nomes de diretório retornados são prefixados com o valor fornecido no `path` parâmetro. Por exemplo, se você fornecer um caminho relativo no `path` parâmetro, os nomes de diretório retornada conterá um caminho relativo.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir enumera os diretórios de nível superior em um caminho especificado.  
  
 [!code-csharp[System.IO.EnumDirs1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs1/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs1/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes de diretórios em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <summary>Retorna uma coleção enumerável de nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os diretórios no diretório especificado por <paramref name="path" /> e que correspondem ao padrão de pesquisa especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo ou absoluto no `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Os nomes de diretório retornados são prefixados com o valor fornecido no `path` parâmetro. Por exemplo, se você fornecer um caminho relativo no `path` parâmetro, os nomes de diretório retornada conterá um caminho relativo.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir enumera os diretórios de nível superior em um caminho especificado que correspondem a um padrão de pesquisa especificados.  
  
 [!code-csharp[System.IO.EnumDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs2/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs2/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 \- ou -  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateDirectories">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes de diretórios em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
 O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma coleção enumerável de nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os diretórios no diretório especificado por <paramref name="path" /> e que correspondem à opção e ao padrão de pesquisa especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Exatamente um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo ou absoluto no `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método. Os nomes de diretório retornados são prefixados com o valor fornecido no `path` parâmetro. Por exemplo, se você fornecer um caminho relativo no `path` parâmetro, os nomes de diretório retornada conterá um caminho relativo.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir enumera os diretórios que correspondem a um padrão de pesquisa especificada em um caminho especificado. Ele usa o `searchOption` parâmetro para especificar que todas as subpastas devem ser incluídas na pesquisa.  
  
 [!code-csharp[System.IO.EnumDirs3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.enumdirs3/cs/program.cs#1)]
 [!code-vb[System.IO.EnumDirs3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.enumdirs3/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 \- ou -  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os arquivos no diretório especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos em um diretório e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais na pasta original.  
  
 [!code-csharp[System.IO.Directory#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class4.cs#12)]
 [!code-vb[System.IO.Directory#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class4.vb#12)]  
  
 O exemplo a seguir enumera os arquivos no diretório especificado, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os arquivos no diretório especificado por <paramref name="path" /> e que correspondem ao padrão de pesquisa especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos de texto em um diretório e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais na pasta original.  
  
 [!code-csharp[System.IO.Directory#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class2.cs#10)]
 [!code-vb[System.IO.Directory#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class2.vb#10)]  
  
 O exemplo a seguir enumera os arquivos no diretório especificado que têm uma extensão. txt, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Europa".  
  
 [!code-csharp[System.IO.Directory.EnumFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumfiles2/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumfiles2/vb/module1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 \- ou -  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFiles">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
 O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma coleção enumerável de nomes completos (incluindo caminhos) para os arquivos no diretório especificado por <paramref name="path" /> e que correspondem à opção e ao padrão de pesquisa especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
   
  
## Examples  
 O exemplo a seguir mostra como recuperar todos os arquivos de texto em um diretório e seus subdiretórios e movê-los para um novo diretório. Depois que os arquivos são movidos, eles não existem mais nos diretórios originais.  
  
 [!code-csharp[System.IO.Directory#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class5.cs#13)]
 [!code-vb[System.IO.Directory#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class5.vb#13)]  
  
 O seguinte exemplo de forma recursiva enumera todos os arquivos que têm uma extensão. txt, lê cada linha do arquivo e exibe a linha se ela contém a cadeia de caracteres "Microsoft".  
  
 [!code-csharp[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/cs/program.cs#1)]
 [!code-vb[System.IO.Directory.EnumerateFiles#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.io.directory.enumeratefiles/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 \- ou -  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo e de diretório em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de entradas de sistema de arquivos no diretório especificado por <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar ao enumerar a coleção de entradas antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes das entradas do sistema de arquivos em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo e nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma coleção enumerável de entradas do sistema de arquivos no diretório especificado por <paramref name="path" /> e que correspondem ao padrão de pesquisa especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar ao enumerar a coleção de entradas antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 \- ou -  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnumerateFileSystemEntries">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;string&gt; EnumerateFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;string&gt; EnumerateFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.EnumerateFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para corresponder com as entradas no sistema de arquivos <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
 O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma coleção enumerável de nomes de arquivo e nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma coleção enumerável de entradas do sistema de arquivos no diretório especificado por <paramref name="path" /> e que corresponde à opção e ao padrão de pesquisa especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar ao enumerar a coleção de entradas antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Não é armazenado em cache a coleção retornada; cada chamada para o <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> na coleção de iniciará uma nova enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 \- ou -  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="Exists">
      <MemberSignature Language="C#" Value="public static bool Exists (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Exists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho a ser testado.</param>
        <summary>Determina se o caminho especificado se refere a um diretório existente em disco.</summary>
        <returns>
          <see langword="true" /> se <paramref name="path" /> se referir a um diretório existente; <see langword="false" /> se o diretório não existir ou ocorrer um erro ao tentar determinar se o diretório especificado existe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual.  
  
 Os espaços à direita são removidos do final do `path` parâmetro antes de verificar se o diretório existe.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Se você não tiver uma permissão mínima de somente leitura para o diretório de <xref:System.IO.Directory.Exists%2A> método retornará `false`.  
  
 O <xref:System.IO.Directory.Exists%2A> método retorna `false` se ocorrer algum erro durante a tentativa de determinar se o arquivo especificado existe. Isso pode ocorrer em situações que geram exceções como passar um nome de arquivo com caracteres inválidos ou número excessivo de caracteres, um disco ausente ou falhando, ou se o chamador não tem permissão para ler o arquivo.  
  
   
  
## Examples  
 O exemplo a seguir usa uma matriz de nomes de arquivo ou diretório na linha de comando, determina que tipo de nome é e processa-a adequadamente.  
  
 [!code-cpp[Recursive file finder#2](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#2)]
 [!code-csharp[Recursive file finder#2](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#2)]
 [!code-vb[Recursive file finder#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler arquivos. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um diretório que contém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que descreve as informações da ACL (lista de controle de acesso) do arquivo.</param>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula as entradas da ACL (lista de controle de acesso) para um diretório especificado.</summary>
        <returns>Um objeto que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar as entradas de ACL (lista) de controle de acesso para um diretório.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas em um determinado arquivo ou diretório. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetAccessControl%2A> e <xref:System.IO.Directory.SetAccessControl%2A> métodos para adicionar um acesso de entrada ACL (lista) de controle e, em seguida, remover uma entrada ACL de um diretório.  Você deve fornecer uma conta de grupo ou de usuário válido para executar este exemplo.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao abrir o diretório.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows 2000 ou posterior.</exception>
        <exception cref="T:System.SystemException">Ocorreu um erro no nível do sistema, por exemplo, não foi possível encontrar o diretório. A exceção específica pode ser uma subclasse de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um diretório somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão enumerar a lista de controle de acesso (ACL) para um diretório. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 Ação de segurança: demanda.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public static System.Security.AccessControl.DirectorySecurity GetAccessControl (string path, System.Security.AccessControl.AccessControlSections includeSections);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.AccessControl.DirectorySecurity GetAccessControl(string path, valuetype System.Security.AccessControl.AccessControlSections includeSections) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetAccessControl(System.String,System.Security.AccessControl.AccessControlSections)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.DirectorySecurity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="includeSections" Type="System.Security.AccessControl.AccessControlSections" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para um diretório que contém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que descreve as informações da ACL (lista de controle de acesso) do arquivo.</param>
        <param name="includeSections">Um dos valores <see cref="T:System.Security.AccessControl.AccessControlSections" /> que especifica o tipo de informações de ACL (lista de controle de acesso) a serem recebidas.</param>
        <summary>Obtém um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> que encapsula o tipo especificado de entradas ACL (lista de controle de acesso) para um diretório especificado.</summary>
        <returns>Um objeto que encapsula as regras de controle de acesso para o arquivo descrito pelo parâmetro <paramref name="path" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar as entradas de ACL (lista) de controle de acesso para um diretório.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas em um determinado arquivo ou diretório. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 Em ambientes de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S ao abrir o diretório.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows 2000 ou posterior.</exception>
        <exception cref="T:System.SystemException">Ocorreu um erro no nível do sistema, por exemplo, não foi possível encontrar o diretório. A exceção específica pode ser uma subclasse de <see cref="T:System.SystemException" />.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O parâmetro <paramref name="path" /> especificou um diretório somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão enumerar a lista de controle de acesso (ACL) para um diretório. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 Ação de segurança: demanda.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTime">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <summary>Obtém a data e a hora de criação de um diretório.</summary>
        <returns>Uma estrutura que é definida como a data e a hora de criação para o diretório especificado. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Esse método é equivalente a <xref:System.IO.File.GetCreationTime%2A?displayProperty=nameWithType>.  
  
 Se o diretório é descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir obtém a hora de criação do diretório especificado.  
  
 [!code-cpp[Dir_GetCreation#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCreation/CPP/dir_getcreation.cpp#1)]
 [!code-csharp[Dir_GetCreation#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCreation/CS/dir_getcreation.cs#1)]
 [!code-vb[Dir_GetCreation#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCreation/VB/dir_getcreation.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetCreationTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetCreationTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCreationTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <summary>Obtém a data e hora, no formato Tempo Universal Coordenado (UTC), de um diretório.</summary>
        <returns>Uma estrutura que é definida como a data e a hora de criação para o diretório especificado. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório é descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Use esse método para obter a hora de criação de um diretório com base no tempo Universal Coordenado (UTC).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static string GetCurrentDirectory ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetCurrentDirectory() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetCurrentDirectory" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o diretório de trabalho atual do aplicativo.</summary>
        <returns>Uma cadeia de caracteres que contém o caminho do diretório de trabalho atual e não termina com uma barra invertida (\\).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O diretório atual é diferente do diretório original, que é a partir do qual o processo foi iniciado.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o `GetCurrentDirectory` método.  
  
 [!code-cpp[Dir_GetCurDir#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetCurDir/CPP/dir_getcurdir.cpp#1)]
 [!code-csharp[Dir_GetCurDir#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetCurDir/CS/dir_getcurdir.cs#1)]
 [!code-vb[Dir_GetCurDir#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetCurDir/VB/dir_getcurdir.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.NotSupportedException">O sistema operacional é Windows CE, que não tem a funcionalidade de diretório atual.  
  
 Esse método está disponível no .NET Compact Framework, mas não tem suporte no momento.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna os nomes de subdiretórios (inclusive os caminhos) no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) dos subdiretórios no caminho especificado, ou uma matriz vazia, se nenhum diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é idêntico ao <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%29> com o asterisco (\*) especificado como o padrão de pesquisa, portanto ele retorna todos os subdiretórios. Se você precisar Pesquisar subpastas, use o <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método, que permite que você especifique uma pesquisa de subpastas com o `searchOption` parâmetro.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Os nomes retornados por esse método são prefixados com as informações do diretório fornecidas no `path`.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa uma matriz de nomes de arquivo ou diretório na linha de comando, determina que tipo de nome é e processa-a adequadamente.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes de subpastas em <c>caminho</c>. Esse parâmetro pode conter uma combinação de caracteres curinga e literal válido, mas ele não oferece suporte a expressões regulares.</param>
        <summary>Retorna os nomes de subdiretórios (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) dos subdiretórios que correspondem ao padrão de pesquisa no diretório especificado, ou uma matriz vazia, se nenhum diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna todos os subdiretórios diretamente sob o diretório especificado que correspondem ao padrão de pesquisa especificados. Se o diretório especificado não tem nenhum subdiretório, ou não corresponde a nenhum subdiretório o `searchPattern` parâmetro, esse método retorna uma matriz vazia. Somente o diretório superior é pesquisado. Se você deseja pesquisar também os subdiretórios, use o <xref:System.IO.Directory.GetDirectories%28System.String%2CSystem.String%2CSystem.IO.SearchOption%29> método e especifique <xref:System.IO.SearchOption.AllDirectories> no `searchOption` parâmetro.  
  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto e não diferencia maiusculas de minúsculas.  As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir conta o número de diretórios em um caminho que começam com a letra especificada.  
  
 [!code-cpp[Dir_GetDirs2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetDirs2/CPP/dir_getdirs2.cpp#1)]
 [!code-csharp[Dir_GetDirs2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs2.cs#1)]
 [!code-vb[Dir_GetDirs2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. É possível consultar caracteres inválidos usando <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectories">
      <MemberSignature Language="C#" Value="public static string[] GetDirectories (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetDirectories(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectories(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes de subpastas em <c>caminho</c>. Esse parâmetro pode conter uma combinação de caracteres curinga e literal válido, mas ele não oferece suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir todos os subdiretórios ou apenas o diretório atual.</param>
        <summary>Retorna os nomes dos subdiretórios (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado e, opcionalmente, subdiretórios de pesquisas.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) dos subdiretórios que correspondem aos critérios especificados, ou uma matriz vazia, se nenhum diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto e não diferencia maiusculas de minúsculas. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
 O <xref:System.IO.Directory.EnumerateDirectories%2A> e <xref:System.IO.Directory.GetDirectories%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateDirectories%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetDirectories%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateDirectories%2A> pode ser mais eficiente.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir conta o número de diretórios que começam com a letra especificada em um caminho. Somente o diretório de nível superior é pesquisado.  
  
 [!code-csharp[Dir_GetDirs2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetDirs2/CS/dir_getdirs3.cs#2)]
 [!code-vb[Dir_GetDirs2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetDirs2/VB/dir_getdirs3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetDirectoryRoot">
      <MemberSignature Language="C#" Value="public static string GetDirectoryRoot (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetDirectoryRoot(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetDirectoryRoot(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho de um arquivo ou diretório.</param>
        <summary>Retorna as informações de volume, raiz ou ambas para o caminho especificado.</summary>
        <returns>Uma cadeia de caracteres que contém as informações de volume, de raiz ou ambas do caminho especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método obtém o nome de caminho totalmente qualificado do `path`, conforme retornado por <xref:System.IO.Path.GetFullPath%2A>, e retorna informações de diretório de raiz. O caminho especificado não deve existir.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra como definir o diretório atual e exibir o diretório raiz.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna os nomes de arquivos (inclusive os caminhos) no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) para os arquivos no diretório especificado, ou uma matriz vazia se nenhum arquivo foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Os nomes de arquivos retornados são anexados ao fornecido `path` parâmetro.  
  
 Esse método é idêntico ao <xref:System.IO.Directory.GetFiles%28System.String%2CSystem.String%29> com o asterisco (\*) especificado como o padrão de pesquisa.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 A ordem dos nomes de arquivo retornado não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica é necessária.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.IO.Directory.GetFiles%2A> método para retornar nomes de arquivo de um local especificado pelo usuário. O exemplo é configurado para captura todos os erros comuns para este método.  
  
 [!code-cpp[Recursive file finder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Recursive file finder/CPP/directorylisting.cpp#1)]
 [!code-csharp[Recursive file finder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Recursive file finder/CS/directorylisting.cs#1)]
 [!code-vb[Recursive file finder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Recursive file finder/VB/directorylisting.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.  
  
 -ou-  
  
 Erro de rede.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado ou é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <summary>Retorna os nomes de arquivo (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) para os arquivos no diretório especificado que correspondem ao padrão de pesquisa especificada, ou uma matriz vazia, se nenhum arquivo foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nomes de arquivos retornados são anexados ao fornecido `path` parâmetro e a ordem dos nomes de arquivo retornado não é garantida; use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica é necessária.  
  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
> [!NOTE]
>  Como esse método verifica com os nomes de arquivo com o formato de nome de 8.3 arquivo e o formato de nome de arquivo longo, uma pesquisa padrão semelhante ao "\*1\*. txt" pode retornar os nomes de arquivo inesperado. Por exemplo, usando um padrão de pesquisa de "\*1\*. txt" retorna "nomearquivolongo" porque o formato de nome de 8.3 arquivo equivalente é "LONGFI~1.TXT".  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir conta o número de arquivos que começam com a letra especificada.  
  
 [!code-cpp[Dir_GetFiles2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetFiles2/CPP/dir_getfiles2.cpp#1)]
 [!code-csharp[Dir_GetFiles2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetFiles2/CS/dir_getfiles2.cs#1)]
 [!code-vb[Dir_GetFiles2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetFiles2/VB/dir_getfiles2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.  
  
 -ou-  
  
 Erro de rede.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. É possível consultar caracteres inválidos usando <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado ou é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public static string[] GetFiles (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFiles(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFiles(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir todos os subdiretórios ou apenas o diretório atual.</param>
        <summary>Retorna os nomes de arquivo (incluindo os caminhos) que correspondem ao padrão de pesquisa especificado no diretório especificado, usando um valor para determinar se as subpastas devem ser pesquisadas.</summary>
        <returns>Uma matriz de nomes completos (incluindo caminhos) para os arquivos no diretório especificado que correspondem ao padrão e à opção de pesquisa especificada, ou uma matriz vazia, se nenhum arquivo foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nomes de arquivos retornados são anexados para o parâmetro fornecido `path` e a ordem dos nomes de arquivo retornado não é garantida; use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica é necessária.  
  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de"file*.txt"retorna os dois arquivos.  
  
> [!NOTE]
>  Como esse método verifica com os nomes de arquivo com o formato de nome de 8.3 arquivo e o formato de nome de arquivo longo, uma pesquisa padrão semelhante ao "\*1\*. txt" pode retornar os nomes de arquivo inesperado. Por exemplo, usando um padrão de pesquisa de "\*1\*. txt" retorna "nomearquivolongo" porque o formato de nome de 8.3 arquivo equivalente é "LONGFI~1.TXT".  
  
 O <xref:System.IO.Directory.EnumerateFiles%2A> e <xref:System.IO.Directory.GetFiles%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFiles%2A>, você pode começar ao enumerar a coleção de nomes antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFiles%2A>, você deve aguardar a matriz inteira de nomes a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Os nomes de arquivo incluem o caminho completo.  
  
 O `path` parâmetro pode especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="searchpattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado ou é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.  
  
 -ou-  
  
 Erro de rede.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <summary>Retorna os nomes de todos os arquivos e subdiretórios em um caminho especificado.</summary>
        <returns>Uma matriz de nomes de arquivos e subdiretórios no diretório especificado ou uma matriz vazia se nenhum arquivo ou subdiretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos nomes de diretório do arquivo retornado e não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica é necessária.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar ao enumerar a coleção de entradas antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Esse método é idêntico ao <xref:System.IO.Directory.GetFileSystemEntries%2A> com o asterisco (\*) especificado como o padrão de pesquisa.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetFileSystemEntries%2A> método para preencher uma matriz de cadeias de caracteres com os nomes de todos os arquivos e subpastas em um local especificado pelo usuário e imprime cada cadeia de caracteres na matriz para o console. O exemplo é configurado para captura todos os erros comuns para este método.  
  
 [!code-cpp[System.IO.Directory#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#1)]
 [!code-csharp[System.IO.Directory#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#1)]
 [!code-vb[System.IO.Directory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes dos arquivos e diretórios em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <summary>Retorna uma matriz de nomes de arquivo e nomes de diretório que correspondem a um padrão de pesquisa em um caminho especificado.</summary>
        <returns>Uma matriz de nomes de arquivo e nomes de diretório que correspondem aos critérios de pesquisa especificados ou uma matriz vazia se nenhum arquivo ou diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos nomes de diretório do arquivo retornado e não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica é necessária.  
  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetFileSystemEntries%2A> método para preencher uma matriz de cadeias de caracteres com os nomes de todos os arquivos que correspondam a um filtro especificado pelo usuário em um local específico e imprime cada cadeia de caracteres na matriz para o console. O exemplo é configurado para captura todos os erros comuns para este método.  
  
 [!code-cpp[System.IO.Directory#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#2)]
 [!code-csharp[System.IO.Directory#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#2)]
 [!code-vb[System.IO.Directory#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> ou <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para acessar informações de caminho para o diretório atual. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFileSystemEntries">
      <MemberSignature Language="C#" Value="public static string[] GetFileSystemEntries (string path, string searchPattern, System.IO.SearchOption searchOption);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetFileSystemEntries(string path, string searchPattern, valuetype System.IO.SearchOption searchOption) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetFileSystemEntries(System.String,System.String,System.IO.SearchOption)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="searchPattern" Type="System.String" />
        <Parameter Name="searchOption" Type="System.IO.SearchOption" />
      </Parameters>
      <Docs>
        <param name="path">O caminho relativo ou absoluto para o diretório a ser pesquisado. Esta cadeia de caracteres não diferencia maiúsculas de minúsculas.</param>
        <param name="searchPattern">A cadeia de caracteres de pesquisa para correspondência com os nomes de arquivos e diretórios em <c>caminho</c>.  Esse parâmetro pode conter uma combinação de caminho literal válido e o caractere curinga (* e?) caracteres, mas ele não oferece suporte a expressões regulares.</param>
        <param name="searchOption">Um dos valores de enumeração que especifica se a operação de pesquisa deve incluir somente o diretório atual ou todos os subdiretórios.  
  
 O valor padrão é <see cref="F:System.IO.SearchOption.TopDirectoryOnly" />.</param>
        <summary>Retorna uma matriz de todos os nomes de arquivo e nomes de diretórios que correspondem a um padrão de pesquisa em um caminho especificado e, opcionalmente, pesquisa subdiretórios.</summary>
        <returns>Uma matriz de nomes de arquivo e nomes de diretório que correspondem aos critérios de pesquisa especificados ou uma matriz vazia se nenhum arquivo ou diretório for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A ordem dos nomes de diretório do arquivo retornado e não é garantida; Use o <xref:System.Array.Sort%2A> método se a ordem de classificação específica é necessária.  
  
 `searchPattern`pode ser uma combinação de literal e caracteres curinga, mas ele não oferece suporte a expressões regulares. Os seguintes especificadores de curinga são permitidos em `searchPattern`.  
  
|Especificador de curinga|Correspondências|  
|------------------------|-------------|  
|\*(com asterisco)|Zero ou mais caracteres naquela posição.|  
|? (ponto de interrogação)|Zero ou um caractere na posição.|  
  
 Caracteres que não seja o caractere curinga são caracteres literais. Por exemplo, o `searchPattern` cadeia de caracteres "\*t" procura todos os nomes de `path` terminam com a letra "t". O `searchPattern` cadeia de caracteres "s\*" procura todos os nomes de `path` começando com a letra "s".  
  
 `searchPattern`não pode terminar com dois pontos ("...") ou conter dois pontos ("...") seguido por <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>, nem pode conter caracteres inválidos. Consulte caracteres inválidos usando o método <xref:System.IO.Path.GetInvalidPathChars%2A>.  
  
> [!NOTE]
>  Quando você usa o caractere curinga de asterisco em um `searchPattern` , como "\*. txt", o número de caracteres a extensão especificada afeta a pesquisa da seguinte maneira:  
>   
>  -   Se a extensão especificada é exatamente três caracteres, o método retorna os arquivos com extensões que começam com a extensão especificada. Por exemplo, "\*. xls" retorna "book.xls" e "book.xlsx".  
> -   Em todos os outros casos, o método retorna os arquivos que correspondem exatamente a extensão especificada. Por exemplo, "\*. AI" retorna "file.ai", mas não "file.aif".  
>   
>  Quando você usa o caractere curinga de ponto de interrogação, esse método retorna apenas os arquivos que correspondem a extensão de arquivo especificado. Por exemplo, considerando dois arquivos: "file1.txt" e "file1.txtother", em um diretório, um padrão de pesquisa de "arquivo?. txt"retorna apenas o primeiro arquivo, enquanto um padrão de pesquisa de" arquivo\*. txt "retorna os dois arquivos.  
  
 O <xref:System.IO.Directory.EnumerateFileSystemEntries%2A> e <xref:System.IO.Directory.GetFileSystemEntries%2A> métodos diferem da seguinte maneira: quando você usa <xref:System.IO.Directory.EnumerateFileSystemEntries%2A>, você pode começar ao enumerar a coleção de entradas antes da coleção inteira será retornada; quando você usa <xref:System.IO.Directory.GetFileSystemEntries%2A>, você deve aguardar a matriz inteira de entradas a serem retornadas antes de poder acessar a matriz. Portanto, quando você estiver trabalhando com vários arquivos e diretórios, <xref:System.IO.Directory.EnumerateFiles%2A> pode ser mais eficiente.  
  
 Você pode especificar informações de caminho relativo com o `path` parâmetro. Informações de caminho relativo serão interpretadas como relativo ao diretório de trabalho atual, você pode determinar usando o <xref:System.IO.Directory.GetCurrentDirectory%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" />é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou contém caracteres inválidos. Consulte caracteres inválidos usando o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.  
  
 \- ou -  
  
 <paramref name="searchPattern" /> não contém um padrão válido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="searchPattern" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="searchOption" /> não é um valor <see cref="T:System.IO.SearchOption" /> válido.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">
          <paramref name="path" /> é inválido, como referenciar uma unidade não mapeada.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="path" /> é um nome de arquivo.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora em que o arquivo ou o diretório foi acessado pela última vez.</summary>
        <returns>Uma estrutura definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Esse método é idêntico ao <xref:System.IO.File.GetLastAccessTime%2A?displayProperty=nameWithType>.  
  
 Se o diretório é descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `GetLastAccessTime`.  
  
 [!code-cpp[Dir_GetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastAccess/CPP/dir_getlastaccess.cpp#1)]
 [!code-csharp[Dir_GetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastAccess/CS/dir_getlastaccess.cs#1)]
 [!code-vb[Dir_GetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastAccess/VB/dir_getlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastAccessTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastAccessTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastAccessTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de acesso serão obtidas.</param>
        <summary>Retorna a data e hora, no formato Tempo Universal Coordenado (UTC), que o arquivo ou diretório especificado foi acessado pela última vez.</summary>
        <returns>Uma estrutura definida como a data e hora em que o arquivo ou diretório especificado foi acessado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório é descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="path" /> está em um formato inválido.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTime">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTime (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTime(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTime(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora da modificação.</param>
        <summary>Retorna a data e hora em que o arquivo ou diretório especificado foi usado para gravação pela última vez.</summary>
        <returns>Uma estrutura que está definida para a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso no horário local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório é descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC), ajustado para horário local.  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `GetLastWriteTime`.  
  
 [!code-cpp[Dir_GetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_GetLastWrite/CPP/dir_getlastwrite.cpp#1)]
 [!code-csharp[Dir_GetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_GetLastWrite/CS/dir_getlastwrite.cs#1)]
 [!code-vb[Dir_GetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_GetLastWrite/VB/dir_getlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static DateTime GetLastWriteTimeUtc (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.DateTime GetLastWriteTimeUtc(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLastWriteTimeUtc(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual obter informações de data e hora da modificação.</param>
        <summary>Retorna a data e hora, no formato Tempo Universal Coordenado (UTC), que o arquivo ou diretório especificado foi gravado pela última.</summary>
        <returns>Uma estrutura que está definida para a data e hora em que o arquivo ou diretório especificado foi gravado pela última vez. Esse valor é expresso em horário UTC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esse método pode retornar um valor, pois ela usa funções nativas cujos valores não podem ser atualizados continuamente pelo sistema operacional.  
  
 Se o diretório é descrito no `path` parâmetro não existe, este método retorna 12:00 meia-noite de 1º de janeiro de 1601 D.C. (C.E.) Tempo Universal Coordenado (UTC).  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetLogicalDrives" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera os nomes das unidades lógicas no computador no formato "&lt;letra da unidade&gt;:\\".</summary>
        <returns>As unidades lógicas neste computador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 GetLogicalDrives retorna todas as unidades acessíveis em um computador específico, incluindo a unidade de disquete e quaisquer unidades de mídia ópticas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetLogicalDrives%2A> método para atribuir o nome de cada unidade no computador de chamada para uma matriz de cadeias de caracteres. Cada membro dessa matriz de cadeia de caracteres, em seguida, é impressa no console. O exemplo é configurado para captura todos os erros comuns para este método.  
  
 [!code-cpp[System.IO.Directory#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#3)]
 [!code-csharp[System.IO.Directory#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#3)]
 [!code-vb[System.IO.Directory#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S (por exemplo, um erro de disco).</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado, como chamar código nativo com interop PInvoke ou COM. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetParent">
      <MemberSignature Language="C#" Value="public static System.IO.DirectoryInfo GetParent (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.DirectoryInfo GetParent(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.GetParent(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.DirectoryInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho no qual o diretório pai deve ser recuperado.</param>
        <summary>Recupera o diretório pai do caminho especificado, incluindo caminhos absolutos e relativos.</summary>
        <returns>O diretório pai, ou <see langword="null" />, se <paramref name="path" /> for o diretório raiz, incluindo a raiz de um nome do compartilhamento ou de servidor UNC.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Os espaços à direita são removidos do final do `path` parâmetro antes de obter o diretório.  
  
 A cadeia de caracteres retornada por este método consiste em todos os caracteres no caminho até, mas não incluindo, a última <xref:System.IO.Path.DirectorySeparatorChar> ou <xref:System.IO.Path.AltDirectorySeparatorChar>. Por exemplo, passando o caminho "C:\Directory\SubDirectory\test.txt" para <xref:System.IO.Directory.GetParent%2A> retorna "C:\Directory\SubDirectory". Passar "C:\Directory\SubDirectory" retorna "C:\Directory". No entanto, passando "C:\Directory\SubDirectory\\" retorna "C:\Directory\SubDirectory", porque é o separador de diretório final após "Subdiretório".  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.IO.Directory.GetParent%2A> método para recuperar o diretório pai de um local especificado pelo usuário, "path". O valor retornado pelo <xref:System.IO.Directory.GetParent%2A> método é impresso no console. O exemplo é configurado para captura todos os erros comuns para este método.  
  
 [!code-cpp[System.IO.Directory#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.Directory/CPP/class1.cpp#4)]
 [!code-csharp[System.IO.Directory#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class1.cs#4)]
 [!code-vb[System.IO.Directory#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O diretório especificado por <paramref name="path" /> é somente leitura.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado não foi encontrado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para a leitura de arquivos ou diretórios. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public static void Move (string sourceDirName, string destDirName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Move(string sourceDirName, string destDirName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.Move(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceDirName" Type="System.String" />
        <Parameter Name="destDirName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceDirName">O caminho do arquivo ou diretório a ser movido.</param>
        <param name="destDirName">O caminho para o novo local para <c>sourceDirName</c>. Se <c>sourceDirName</c> é um arquivo, em seguida, <c>destDirName</c> também deve ser um nome de arquivo.</param>
        <summary>Move um arquivo ou um diretório e seu conteúdo para um novo local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma nova pasta com o nome especificado pelo `destDirName` e move o conteúdo de `sourceDirName` para o diretório de destino criado recentemente. Se você tentar mover uma pasta para um diretório que já existe, um <xref:System.IO.IOException> ocorrerá. Por exemplo, uma exceção ocorrerá se você tenta mover c:\mydir para c:\public e c:\public já existe. Como alternativa, você pode especificar "c:\\\public\\\mydir" como o `destDirName` parâmetro fornecido "mydir" não existe em "c:\\\public", ou especifique um novo nome de diretório, como "c:\\\newdir".  
  
 O `sourceDirName` e `destDirName` argumentos são permitidos para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Espaços à direita são removidos do final do caminho parâmetros antes de mover o diretório.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como mover um diretório e todos os seus arquivos para um novo diretório. O diretório original não existe mais depois que ela foi movida.  
  
 [!code-csharp[System.IO.Directory#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.Directory/CS/class6.cs#14)]
 [!code-vb[System.IO.Directory#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.Directory/VB/class6.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Tentativa de mover um diretório para um volume diferente.  
  
 -ou-  
  
 <paramref name="destDirName" /> já existe.  
  
 -ou-  
  
 Os parâmetros <paramref name="sourceDirName" /> e <paramref name="destDirName" /> se referem ao mesmo arquivo ou diretório.  
  
 -ou-  
  
 O diretório ou um arquivo nele está sendo usado por outro processo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceDirName" /> ou <paramref name="destDirName" /> é uma cadeia de caracteres de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceDirName" /> ou <paramref name="destDirName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado por <paramref name="sourceDirName" /> é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para ler de <paramref name="sourceDirName" /> e gravar <paramref name="sourceDirName" /> e <paramref name="destDirName" />. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public static void SetAccessControl (string path, System.Security.AccessControl.DirectorySecurity directorySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetAccessControl(string path, class System.Security.AccessControl.DirectorySecurity directorySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetAccessControl(System.String,System.Security.AccessControl.DirectorySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="directorySecurity" Type="System.Security.AccessControl.DirectorySecurity" />
      </Parameters>
      <Docs>
        <param name="path">Um diretório ao qual adicionar ou remover entradas de ACL (lista de controle de acesso).</param>
        <param name="directorySecurity">Um <see cref="T:System.Security.AccessControl.DirectorySecurity" /> objeto que descreve uma entrada ACL para aplicar ao diretório descrito pelo <c>caminho</c> parâmetro.</param>
        <summary>Aplica entradas de ACL (lista de controle de acesso) descritas por um objeto <see cref="T:System.Security.AccessControl.DirectorySecurity" /> ao diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.IO.Directory.SetAccessControl%2A> método se aplica a entradas ACL (lista) de controle de acesso a um arquivo que representa a lista ACL noninherited.  
  
> [!CAUTION]
>  A ACL especificado para o `directorySecurity` parâmetro substitui a ACL existente para o diretório. Para adicionar permissões para um novo usuário, use o <xref:System.IO.Directory.GetAccessControl%2A> método para obter a ACL existente e modificá-lo.  
  
 Uma ACL descreve indivíduos e/ou grupos que têm ou não tem direitos para ações específicas em um determinado arquivo ou diretório. Para saber mais, confira [Como adicionar ou remover entradas da lista de controle de acesso](~/docs/standard/io/how-to-add-or-remove-access-control-list-entries.md).  
  
 O <xref:System.IO.Directory.SetAccessControl%2A> método persiste apenas <xref:System.Security.AccessControl.DirectorySecurity> objetos que foram modificados após a criação do objeto.  Se um <xref:System.Security.AccessControl.DirectorySecurity> objeto não tiver sido modificado, não serão mantido para um arquivo.  Portanto, não é possível recuperar um <xref:System.Security.AccessControl.DirectorySecurity> de um arquivo de objeto e reaplicar o mesmo objeto para outro arquivo.  
  
 Para copiar informações de ACL de um arquivo para outro:  
  
1.  Use o <xref:System.IO.Directory.GetAccessControl%2A> método para recuperar o <xref:System.Security.AccessControl.DirectorySecurity> objeto do arquivo de origem.  
  
2.  Criar um novo <xref:System.Security.AccessControl.DirectorySecurity> objeto para o arquivo de destino.  
  
3.  Use o <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.GetSecurityDescriptorSddlForm%2A> método da fonte de <xref:System.Security.AccessControl.DirectorySecurity> objeto para recuperar as informações de ACL.  
  
4.  Use o <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorBinaryForm%2A> ou <xref:System.Security.AccessControl.ObjectSecurity.SetSecurityDescriptorSddlForm%2A> método para copiar as informações recuperadas na etapa 3 para o destino <xref:System.Security.AccessControl.DirectorySecurity> objeto.  
  
5.  Definir o destino <xref:System.Security.AccessControl.DirectorySecurity> objeto para o arquivo de destino usando o <xref:System.IO.Directory.SetAccessControl%2A> método.  
  
 Em ambientes de NTFS, <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes> são concedidas ao usuário se o usuário tiver <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> direitos na pasta pai. Negar <xref:System.Security.AccessControl.FileSystemRights.ReadAttributes> e <xref:System.Security.AccessControl.FileSystemRights.ReadExtendedAttributes>, negar <xref:System.Security.AccessControl.FileSystemRights.ListDirectory> no diretório pai.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.Directory.GetAccessControl%2A> e <xref:System.IO.Directory.SetAccessControl%2A> métodos para adicionar um acesso de entrada ACL (lista) de controle e, em seguida, remover uma entrada ACL de um diretório.  Você deve fornecer uma conta de grupo ou de usuário válido para executar este exemplo.  
  
 [!code-cpp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/cpp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/cpp/sample.cpp#1)]
 [!code-csharp[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/csharp/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/CS/sample.cs#1)]
 [!code-vb[IO.DiretoryInfo.GetAccessControl-SetAccessControl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/IO.DiretoryInfo.GetAccessControl-SetAccessControl/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="directorySecurity" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Não foi possível encontrar o diretório.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="path" /> era inválido.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O processo atual não tem acesso ao diretório especificado por <paramref name="path" />.  
  
 -ou-  
  
 O processo atual não tem privilégios suficientes para configurar a entrada de ACL.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows 2000 ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">permissão enumerar a lista de controle de acesso (ACL) para um diretório. Enumerações associadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.NoAccess" /> ,<see cref="F:System.Security.AccessControl.AccessControlActions.View" />  
  
 Ação de segurança: demanda.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTime">
      <MemberSignature Language="C#" Value="public static void SetCreationTime (string path, DateTime creationTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTime(string path, valuetype System.DateTime creationTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de criação serão definidas.</param>
        <param name="creationTime">A data e hora em que o arquivo ou diretório foi usado para gravação pela última vez. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora de criação do arquivo ou diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCreationTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetCreationTimeUtc (string path, DateTime creationTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCreationTimeUtc(string path, valuetype System.DateTime creationTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCreationTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="creationTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual as informações de data e hora de criação serão definidas.</param>
        <param name="creationTimeUtc">A data e hora no diretório ou arquivo foi criado. Esse valor é expresso no horário local.</param>
        <summary>Define a data de criação e a hora, no formato Tempo Universal Coordenado (UTC), para o arquivo ou diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="creationTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCurrentDirectory">
      <MemberSignature Language="C#" Value="public static void SetCurrentDirectory (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCurrentDirectory(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetCurrentDirectory(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o qual o diretório de trabalho atual é definido.</param>
        <summary>Define o atual diretório de trabalho do aplicativo como o diretório especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o aplicativo termina, o diretório de trabalho é restaurado para seu local original (o diretório em que o processo foi iniciado).  
  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 Os espaços à direita são removidos do final do `path` parâmetro antes de configurar o diretório.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Se você estiver configurando o diretório para uma unidade com uma mídia removível, por exemplo, para ("r:" para uma unidade de disquete) ou "E" para uma unidade de CD-ROM, você pode determinar se a unidade está pronta usando o <xref:System.IO.DriveInfo.IsReady%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como definir o diretório atual e exibir o diretório raiz.  
  
 [!code-cpp[System.IO.DirectoryRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CPP/example.cpp#1)]
 [!code-csharp[System.IO.DirectoryRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.DirectoryRoot/CS/example.cs#1)]
 [!code-vb[System.IO.DirectoryRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.DirectoryRoot/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ocorreu um erro de E/S.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária para acessar código não gerenciado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O diretório especificado não foi encontrado.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar em arquivos ou diretórios. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTime">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTime (string path, DateTime lastAccessTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTime(string path, valuetype System.DateTime lastAccessTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual definir as informações de data e hora de acesso.</param>
        <param name="lastAccessTime">Um objeto que contém o valor para definir o acesso de data e hora do <c>caminho</c>. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora do arquivo ou diretório foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `SetLastAccessTime`.  
  
 [!code-cpp[Dir_SetLastAccess#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastAccess/CPP/dir_setlastaccess.cpp#1)]
 [!code-csharp[Dir_SetLastAccess#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastAccess/CS/dir_setlastaccess.cs#1)]
 [!code-vb[Dir_SetLastAccess#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastAccess/VB/dir_setlastaccess.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastAccessTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastAccessTimeUtc (string path, DateTime lastAccessTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastAccessTimeUtc(string path, valuetype System.DateTime lastAccessTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastAccessTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastAccessTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O arquivo ou diretório para o qual definir as informações de data e hora de acesso.</param>
        <param name="lastAccessTimeUtc">Um objeto que contém o valor para definir o acesso de data e hora do <c>caminho</c>. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, no formato Tempo Universal Coordenado (UTC), que o arquivo ou diretório especificado foi acessado pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastAccessTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTime">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTime (string path, DateTime lastWriteTime);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTime(string path, valuetype System.DateTime lastWriteTime) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTime(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTime" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <param name="lastWriteTime">A data e hora em que o diretório foi usado para gravação pela última vez. Esse valor é expresso no horário local.</param>
        <summary>Define a data e hora em que um diretório foi usado para gravação pela última vez.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar `SetLastWriteTime`.  
  
 [!code-cpp[Dir_SetLastWrite#1](~/samples/snippets/cpp/VS_Snippets_CLR/Dir_SetLastWrite/CPP/dir_setlastwrite.cpp#1)]
 [!code-csharp[Dir_SetLastWrite#1](~/samples/snippets/csharp/VS_Snippets_CLR/Dir_SetLastWrite/CS/dir_setlastwrite.cs#1)]
 [!code-vb[Dir_SetLastWrite#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Dir_SetLastWrite/VB/dir_setlastwrite.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTime" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetLastWriteTimeUtc">
      <MemberSignature Language="C#" Value="public static void SetLastWriteTimeUtc (string path, DateTime lastWriteTimeUtc);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetLastWriteTimeUtc(string path, valuetype System.DateTime lastWriteTimeUtc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IO.Directory.SetLastWriteTimeUtc(System.String,System.DateTime)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IO.FileSystem</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="lastWriteTimeUtc" Type="System.DateTime" />
      </Parameters>
      <Docs>
        <param name="path">O caminho do diretório.</param>
        <param name="lastWriteTimeUtc">A data e hora em que o diretório foi usado para gravação pela última vez. Esse valor é expresso em horário UTC.</param>
        <summary>Define a data e hora, no formato Tempo Universal Coordenado (UTC), um diretório foi gravado pela última.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `path` parâmetro tem permissão para especificar informações de caminho relativo ou absoluto. As informações do caminho relativo são interpretadas como relativas ao diretório de trabalho atual. Para obter o diretório de trabalho atual, consulte <xref:System.IO.Directory.GetCurrentDirectory%2A>.  
  
 O `path` parâmetro não diferencia maiusculas de minúsculas.  
  
 Para obter uma lista de tarefas comuns de e/s, consulte [tarefas comuns de e/s](~/docs/standard/io/common-i-o-tasks.md).  
  
   
  
## Examples  
 O exemplo a seguir ilustra as diferenças na saída ao usar a saída de tempo Universal Coordenado (UTC).  
  
 [!code-cpp[System.IO.UTCExample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IO.UTCExample/CPP/example.cpp#1)]
 [!code-csharp[System.IO.UTCExample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IO.UTCExample/CS/example.cs#1)]
 [!code-vb[System.IO.UTCExample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IO.UTCExample/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O caminho especificado não foi encontrado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos. Consulte caracteres inválidos com o método <see cref="M:System.IO.Path.GetInvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="path" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas baseadas no Windows, os caminhos devem ter menos de 248 caracteres e os nomes de arquivo devem ter menos de 260 caracteres.</exception>
        <exception cref="T:System.UnauthorizedAccessException">O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O sistema operacional atual não é o Windows NT ou posterior.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="lastWriteTimeUtc" /> especifica um valor fora do intervalo de datas, horas permitido para esta operação.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">para gravar o arquivo ou diretório especificado. Enumeração associada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Write" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
