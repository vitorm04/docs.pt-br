<Type Name="HwndSource" FullName="System.Windows.Interop.HwndSource">
  <TypeSignature Language="C#" Value="public class HwndSource : System.Windows.PresentationSource, IDisposable, System.Windows.Interop.IKeyboardInputSink, System.Windows.Interop.IWin32Window" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi HwndSource extends System.Windows.PresentationSource implements class System.IDisposable, class System.Windows.Interop.IKeyboardInputSink, class System.Windows.Interop.IWin32Window" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Interop.HwndSource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.PresentationSource</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Interop.IKeyboardInputSink</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Interop.IWin32Window</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Apresenta o conteúdo do Windows Presentation Foundation (WPF) em uma janela do Win32.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Todos os membros dessa classe não estão disponíveis na zona de segurança da Internet.  
  
 Um <xref:System.Windows.Interop.HwndSource> implementa um [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] janela pode conter [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] conteúdo. O [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] o conteúdo na janela é organizado, medidas e renderizado; e é interativo de entrada. Porque o <xref:System.Windows.Interop.HwndSource> é especificamente projetado para interoperar com [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)], essa classe expõe várias baixo nível [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] recursos. Você pode usar essa classe para fazer o seguinte:  
  
-   Especifique estilos da janela, estilos de classe de janela, e estendidos estilos da janela.  
  
-   Conecte-se com o procedimento de janela.  
  
-   Fornece acesso para o identificador de janela (HWND).  
  
-   Destrua a janela.  
  
 O <xref:System.Windows.Interop.HwndSource> classe foi projetada para interoperabilidade geral e não foi projetada como um wrapper HWND gerenciado. Em geral, ele não fornece gerenciados métodos para manipular a janela Propriedades ou para inspecionar o estado. Em vez disso, o <xref:System.Windows.Interop.HwndSource> classe fornece acesso ao [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] o identificador de janela (HWND) por meio de <xref:System.Windows.Interop.HwndSource.Handle%2A> propriedade, que pode ser passada por meio de técnicas de PInvoke para [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] para manipular a janela.  
  
 **Construção**  
  
 Muitos aspectos do <xref:System.Windows.Interop.HwndSource> só pode ser especificado em tempo de construção. Para criar um <xref:System.Windows.Interop.HwndSource>, primeiro crie um <xref:System.Windows.Interop.HwndSourceParameters> estrutura e preenchê-la com os parâmetros desejados. Esses parâmetros incluem o seguinte:  
  
-   A classe de janela e estilos de janela estendidos. Você deve usar PInvoke para alterar os estilos depois que a janela é criada. Nem todos os estilos podem ser alterados após a janela é criada. Consulte o [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] documentação antes de alterar os estilos da janela.  
  
-   A posição inicial da janela.  
  
-   O tamanho inicial da janela, que inclui o tamanho é especificado, ou deve ser determinado a partir de determinado tamanho do [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] conteúdo.  
  
-   A janela pai.  
  
-   O <xref:System.Windows.Interop.HwndSourceHook> para incluir na cadeia de procedimento de janela. Se você especificar um gancho no tempo de construção, ele recebe todas as mensagens da janela. Você pode usar <xref:System.Windows.Interop.HwndSource.AddHook%2A> para adicionar um gancho depois que a janela é criada.  
  
-   As configurações de transparência. Uma janela de nível superior pode ser configurada para mesclar com outras janelas na área de trabalho de acordo com a transparência por pixel do [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] conteúdo. Para habilitar isso, defina o <xref:System.Windows.Interop.HwndSourceParameters.UsesPerPixelOpacity%2A> propriedade o <xref:System.Windows.Interop.HwndSourceParameters> para `true`. Essa propriedade só pode ser especificada em tempo de construção e somente com o <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29> assinatura de construtor e ele impõe várias limitações.  
  
 Depois de preencher o <xref:System.Windows.Interop.HwndSourceParameters> estrutura, passá-lo para o <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29> construtor para o <xref:System.Windows.Interop.HwndSource>.  
  
 **Vida útil do objeto**  
  
 Um <xref:System.Windows.Interop.HwndSource> é uma expressão [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] objeto e seu tempo de vida é gerenciado pelo coletor de lixo. Porque o <xref:System.Windows.Interop.HwndSource> representa um recurso não gerenciado, <xref:System.Windows.Interop.HwndSource> implementa <xref:System.IDisposable>. Chamada síncrona <xref:System.Windows.Interop.HwndSource.Dispose%2A> imediatamente destrói o [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] janela se chamado do thread proprietário. Se a chamada de outro thread, o [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] janela é destruída de forma assíncrona. Chamando <xref:System.Windows.Interop.HwndSource.Dispose%2A> explicitamente no código interoperacionais pode ser necessário para determinados cenários de interoperabilidade.  
  
 **Procedimentos de janela**  
  
 O <xref:System.Windows.Interop.HwndSource> classe implementa seu próprio procedimento de janela. Este procedimento de janela é usado para processar mensagens de janela importantes, como aquelas relacionadas ao layout, processamento e de entrada. No entanto, você também pode utilizar o procedimento de janela para seu próprio uso. Você pode especificar seu próprio gancho durante a construção definindo o <xref:System.Windows.Interop.HwndSourceParameters.HwndSourceHook%2A?displayProperty=nameWithType> propriedade, você também pode usar <xref:System.Windows.Interop.HwndSource.AddHook%2A> e <xref:System.Windows.Interop.HwndSource.RemoveHook%2A> para adicionar e remover ganchos depois que a janela é criada. Ganchos de são chamados pela ordem na última fila, que permite que seu ganchos executar antes do processamento interno. Ganchos de reais são mantidos por uma referência fraca. Portanto, certifique-se de que você gerencia o tempo de vida do seu representante de interceptação.  
  
 Para obter mais informações sobre <xref:System.Windows.Interop.HwndSource> e outras classes de interoperabilidade, consulte [WPF e Win32 interoperação](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md).  
  
 Observe como os construtores de <xref:System.Windows.Interop.HwndSource> usam parâmetros que se parecem com os parâmetros para [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] funções como [CreateWindowEx](http://go.microsoft.com/fwlink/?LinkID=98462).  
  
 Transformações de escala não devem ser aplicadas para o <xref:System.Windows.Interop.HwndSource.RootVisual%2A> de um <xref:System.Windows.Interop.HwndSource>. Consulte os comentários para <xref:System.Windows.Interop.HwndSource.RootVisual%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (System.Windows.Interop.HwndSourceParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Interop.HwndSourceParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Windows.Interop.HwndSourceParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="parameters" Type="System.Windows.Interop.HwndSourceParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Uma estrutura que contém os parâmetros necessários para criar a janela.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Interop.HwndSource" /> usando uma estrutura que contém as configurações iniciais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 Essa assinatura de construtor pode ser mais conveniente em determinadas situações, porque a estrutura padrão contém alguns valores padrão inicial apropriado.  
  
> [!IMPORTANT]
>  Se você usar essa assinatura, não use o padrão <xref:System.Windows.Interop.HwndSourceParameters> construtor para construir o <xref:System.Windows.Interop.HwndSourceParameters> estrutura o `parameters` valor. Você deve usar o <xref:System.Windows.Interop.HwndSourceParameters> construtor que permite que você especifique um nome de janela inicial. Se você usar o padrão <xref:System.Windows.Interop.HwndSourceParameters> construtor e criar um <xref:System.Windows.Interop.HwndSource> com ele, que <xref:System.Windows.Interop.HwndSource> não exibe porque um nome de janela inicial é um requisito de construção para o HWND representado.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para criar as instâncias dessa classe. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, string name, IntPtr parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, string name, native int parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="classStyle">O [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] classe estilos da janela.</param>
        <param name="style">O [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] estilos da janela.</param>
        <param name="exStyle">Estendido [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] estilos da janela.</param>
        <param name="x">Margem esquerda a posição da janela.</param>
        <param name="y">A posição da borda superior da janela.</param>
        <param name="name">O nome da janela.</param>
        <param name="parent">O identificador da janela do pai da janela.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Windows.Interop.HwndSource" /> classe com um estilo de classe especificada, estilo, estendido estilo, posição x-y, nome e janela pai.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para criar as instâncias dessa classe. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, int32 width, int32 height, string name, native int parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="classStyle">O [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] classe estilos da janela.</param>
        <param name="style">O [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] estilos da janela.</param>
        <param name="exStyle">Estendido [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] estilos da janela.</param>
        <param name="x">Margem esquerda a posição da janela.</param>
        <param name="y">A posição da borda superior da janela.</param>
        <param name="width">A largura da janela.</param>
        <param name="height">A altura da janela.</param>
        <param name="name">O nome da janela.</param>
        <param name="parent">O identificador da janela do pai da janela.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Windows.Interop.HwndSource" /> classe com um estilo de classe especificada, estilo, estendido estilo, posição x-y, largura, altura, nome e janela pai.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para criar as instâncias dessa classe. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HwndSource (int classStyle, int style, int exStyle, int x, int y, int width, int height, string name, IntPtr parent, bool adjustSizingForNonClientArea);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 classStyle, int32 style, int32 exStyle, int32 x, int32 y, int32 width, int32 height, string name, native int parent, bool adjustSizingForNonClientArea) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.String,System.IntPtr,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="classStyle" Type="System.Int32" />
        <Parameter Name="style" Type="System.Int32" />
        <Parameter Name="exStyle" Type="System.Int32" />
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="parent" Type="System.IntPtr" />
        <Parameter Name="adjustSizingForNonClientArea" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="classStyle">O [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] classe estilos da janela.</param>
        <param name="style">O [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] estilos da janela.</param>
        <param name="exStyle">Estendido [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] estilos da janela.</param>
        <param name="x">Margem esquerda a posição da janela.</param>
        <param name="y">A posição da borda superior da janela.</param>
        <param name="width">A largura da janela.</param>
        <param name="height">A altura da janela.</param>
        <param name="name">O nome da janela.</param>
        <param name="parent">O identificador da janela do pai da janela.</param>
        <param name="adjustSizingForNonClientArea">
          <see langword="true" />para que o Gerenciador de layout incluem a área não cliente dimensionamento; Caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Windows.Interop.HwndSource" /> classe com um estilo de classe especificada, estilo, estendido estilo, posição x-y, largura, altura, nome e janela pai e especificando se a janela é dimensionado automaticamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para criar as instâncias dessa classe. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AcquireHwndFocusInMenuMode">
      <MemberSignature Language="C#" Value="public bool AcquireHwndFocusInMenuMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AcquireHwndFocusInMenuMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor que determina se é necessário adquirir o foco do Win32 para WPF contendo a janela para este <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>
          <see langword="true" />para adquirir o foco do Win32 para WPF contendo a janela quando o usuário interagisse com menus; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse valor é definido quando você cria o <xref:System.Windows.Interop.HwndSource> definindo o <xref:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode%2A> parâmetro.  
  
 O valor padrão é determinado pelo <xref:System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHook">
      <MemberSignature Language="C#" Value="public void AddHook (System.Windows.Interop.HwndSourceHook hook);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHook(class System.Windows.Interop.HwndSourceHook hook) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hook" Type="System.Windows.Interop.HwndSourceHook" />
      </Parameters>
      <Docs>
        <param name="hook">A implementação do manipulador (com base no delegado <see cref="T:System.Windows.Interop.HwndSourceHook" />) que recebe as mensagens da janela.</param>
        <summary>Adiciona um manipulador de eventos que recebe todas as mensagens da janela.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 A maioria dos [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)] mensagens que alcance o <xref:System.Windows.Interop.HwndSource> tem um aproximado [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] equivalente. Você usa <xref:System.Windows.Interop.HwndSource.AddHook%2A> para lidar com casos em que a mensagem tem não [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] equivalente.  
  
 O <xref:System.Windows.Interop.HwndSourceHook> delegado se parece com o perfil de parâmetro de um [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] procedimento da janela principal. Janela todas as mensagens que o procedimento da janela principal do <xref:System.Windows.Interop.HwndSource> janela pai recebe também são encaminhados para o <xref:System.Windows.Interop.HwndSourceHook> delegados.  
  
 Ganchos são chamados na ordem em que eles foram adicionados. Se qualquer um gancho retorna `handled` = `true` para uma mensagem, ganchos depois na ordem de chamada não forem chamados para essa mensagem.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para adicionar o tratamento. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="AutoResized">
      <MemberSignature Language="C#" Value="public event System.Windows.AutoResizedEventHandler AutoResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.AutoResizedEventHandler AutoResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.AutoResized" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.AutoResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o layout faz com que o <see cref="T:System.Windows.Interop.HwndSource" /> para redimensionar automaticamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento nativo <xref:System.Windows.Interop.HwndSource> é redimensionado automaticamente o conteúdo e a região da janela com base nas alterações relatadas por meio de [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de layout. A janela não redimensionar se ele está atualmente minimizado ou se <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> é definido como <xref:System.Windows.SizeToContent.Manual>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildKeyboardInputSinks">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Interop.IKeyboardInputSink&gt; ChildKeyboardInputSinks { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Interop.IKeyboardInputSink&gt; ChildKeyboardInputSinks" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.ChildKeyboardInputSinks" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Windows.Interop.HwndSource/&lt;get_ChildKeyboardInputSinks&gt;d__29))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Interop.IKeyboardInputSink&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma sequência de Coletores de entrada registrados.</summary>
        <value>Coletores de uma enumeração de entrada do teclado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompositionTarget">
      <MemberSignature Language="C#" Value="public System.Windows.Interop.HwndTarget CompositionTarget { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.HwndTarget CompositionTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.CompositionTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.HwndTarget</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o Gerenciador de visual para a janela hospedada.</summary>
        <value>O Gerenciador de visual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substituir <xref:System.Windows.Interop.HwndSource.GetCompositionTargetCore%2A> para substituir o valor que <xref:System.Windows.Interop.HwndSource.CompositionTarget%2A> retorna.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHandleRef">
      <MemberSignature Language="C#" Value="public System.Runtime.InteropServices.HandleRef CreateHandleRef ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.InteropServices.HandleRef CreateHandleRef() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.CreateHandleRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.HandleRef</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o identificador de janela para o <see cref="T:System.Windows.Interop.HwndSource" />. O identificador de janela é empacotado como parte de um <see cref="T:System.Runtime.InteropServices.HandleRef" /> estrutura.</summary>
        <returns>Uma estrutura que contém o identificador de janela para este <see cref="T:System.Windows.Interop.HwndSource" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o identificador que é obtido do <xref:System.Windows.Interop.HwndSource.CreateHandleRef%2A> a referência a <xref:System.Windows.Interop.HwndSource> de [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] código. Use o identificador para operações como o comportamento de tratamento e a janela de mensagem.  
  
 Para obter apenas o identificador, use <xref:System.Windows.Interop.HwndSource.Handle%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultAcquireHwndFocusInMenuMode">
      <MemberSignature Language="C#" Value="public static bool DefaultAcquireHwndFocusInMenuMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool DefaultAcquireHwndFocusInMenuMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.DefaultAcquireHwndFocusInMenuMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o padrão <see cref="P:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode" /> valor para novas instâncias de <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>
          <see langword="true" />para adquirir o foco do Win32 para WPF contendo a janela quando o usuário interagisse com menus; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Novas instâncias de <xref:System.Windows.Interop.HwndSource> ter <xref:System.Windows.Interop.HwndSource.AcquireHwndFocusInMenuMode%2A> definido para esse valor padrão, a menos que um valor diferente é passado como um parâmetro para o <xref:System.Windows.Interop.HwndSource> construtor para uma instância específica, usando o <xref:System.Windows.Interop.HwndSourceParameters.AcquireHwndFocusInMenuMode%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">Para obter essa propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera recursos todas gerenciados que são usados pelo <see cref="T:System.Windows.Interop.HwndSource" />e gera o <see cref="E:System.Windows.Interop.HwndSource.Disposed" /> evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 <xref:System.Windows.Interop.HwndSource.Dispose%2A>Inicia relacionados ao trabalho de limpeza para o HWND. Se <xref:System.Windows.Interop.HwndSource.Dispose%2A> é chamado por meio de um thread diferente do thread da interface do usuário principal, o trabalho de limpeza pode ser adiado até que ele pode ser lançado para o thread de interface do usuário principal.  
  
 Chamando <xref:System.Windows.Interop.HwndSource.Dispose%2A> explicitamente no código interoperacionais pode ser necessário para determinados cenários de interoperabilidade, pois um <xref:System.Windows.Interop.HwndSource> em alguns cenários de interoperação pode gerar várias referências a ele entre os limites de interoperação que podem impedir que a coleta de lixo em tempo hábil.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.Disposed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o método <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> é chamado neste objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Interop.HwndSource.Disposed> evento é gerado antes de todos os recursos são liberados o <xref:System.Windows.Interop.HwndSource>. O <xref:System.Windows.Interop.HwndSource.Disposed> evento indica que o objeto que gera o evento está prestes a ter todas as referências para removê-la.  
  
 Use <xref:System.Windows.Interop.HwndSource.Disposed> e <xref:System.Windows.Interop.HwndSource.IsDisposed%2A> propriedade para evitar a chamada <xref:System.Windows.Interop.HwndSource.Dispose%2A> duas vezes (que gera uma exceção).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.HwndDpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.HwndDpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.DpiChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HwndDpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o DPI do monitor deste HWND foi alterado ou o Hwnd é movido para um monitor com um DPI diferente.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromHwnd">
      <MemberSignature Language="C#" Value="public static System.Windows.Interop.HwndSource FromHwnd (IntPtr hwnd);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Interop.HwndSource FromHwnd(native int hwnd) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.FromHwnd(System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.HwndSource</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hwnd" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="hwnd">O identificador da janela fornecido.</param>
        <summary>Retorna o objeto <see cref="T:System.Windows.Interop.HwndSource" /> da janela especificada.</summary>
        <returns>O objeto <see cref="T:System.Windows.Interop.HwndSource" /> para a janela especificada pelo identificador de janela <paramref name="hwnd" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet ou de confiança parcial em geral.  
  
 Você pode usar esse método para retornar um <xref:System.Windows.Interop.HwndSource> para uma janela que não seja explicitamente uma janela de interoperação. Esse procedimento é:  
  
1.  Criar um <xref:System.Windows.Interop.WindowInteropHelper> instância (fornecendo principal <xref:System.Windows.Window> como um parâmetro de construtor).  
  
2.  Obter o valor da <xref:System.Windows.Interop.WindowInteropHelper.Handle%2A> propriedade daquele <xref:System.Windows.Interop.WindowInteropHelper> instância.  
  
3.  Passe esse valor HWND como um parâmetro para <xref:System.Windows.Interop.HwndSource.FromHwnd%2A>.  
  
 Essa técnica pode ser útil se você quiser adicionar geral <xref:System.Windows.Interop.HwndSource.AddHook%2A> processamento para a janela de mensagem. No entanto, sempre que você criar um <xref:System.Windows.Interop.HwndSource>, você também é responsável por destruí-lo. Isso é verdadeiro mesmo se o <xref:System.Windows.Application> objeto para um aplicativo <xref:System.Windows.Interop.HwndSource> é descartado. Para obter mais informações, consulte comentários em <xref:System.Windows.Interop.HwndSource>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCompositionTargetCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.CompositionTarget GetCompositionTargetCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.CompositionTarget GetCompositionTargetCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.GetCompositionTargetCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.CompositionTarget</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o destino visual da janela.</summary>
        <returns>Retorna o destino visual da janela.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação padrão retorna o mesmo resultado como <xref:System.Windows.Interop.HwndSource.CompositionTarget%2A>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Implemente esse método para retornar um tipo específico de destino visual. <see cref="T:System.Windows.Interop.HwndSource" />implementa este método para retornar <see cref="T:System.Windows.Interop.HwndTarget" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de janela para este <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>O identificador da janela.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Essa propriedade não está disponível na zona de segurança da Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para acessar esse ponteiro. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasFocusWithinCore">
      <MemberSignature Language="C#" Value="protected virtual bool HasFocusWithinCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasFocusWithinCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.HasFocusWithinCore" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se o coletor ou um de seus componentes independentes tem foco.</summary>
        <returns>
          <see langword="true" />Se o coletor ou um de seus componentes independentes tem foco. Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public override bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> foi chamado neste <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <value>
          <see langword="true" />Se o objeto tiver sido <see cref="M:System.Windows.Interop.HwndSource.Dispose" /> chamado nela; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Interop.HwndSource.Dispose%2A>Inicia relacionados ao trabalho de limpeza para o HWND. Se <xref:System.Windows.Interop.HwndSource.Dispose%2A> é chamado por meio de um thread diferente do thread da interface do usuário principal, o trabalho de limpeza pode ser adiado até que ele pode ser lançado para o thread de interface do usuário principal. O <xref:System.Windows.Interop.HwndSource.Disposed> é gerado e o valor de <xref:System.Windows.Interop.HwndSource.IsDisposed%2A> se torna `false` assim <xref:System.Windows.Interop.HwndSource.Dispose%2A> é chamado. Durante esse tempo, se você chamar <xref:System.Windows.Interop.HwndSource.Dispose%2A> novamente, <xref:System.Windows.Interop.HwndSource.Dispose%2A> gera uma exceção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyboardInputSiteCore">
      <MemberSignature Language="C#" Value="protected System.Windows.Interop.IKeyboardInputSite KeyboardInputSiteCore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.IKeyboardInputSite KeyboardInputSiteCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.KeyboardInputSiteCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma referência ao contêiner do componente <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> interface.</summary>
        <value>Uma referência para o contêiner <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> interface; ou <see langword="null" /> não se for atribuído a nenhum site. O padrão é <see langword="null" />.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para definir essa propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.HwndDpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.HwndDpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.OnDpiChanged(System.Windows.HwndDpiChangedEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.HwndDpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Os argumentos do evento</param>
        <summary>Chamado quando o DPI será alterado para a janela.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o usuário manipula esse evento, WPF não se expandir qualquer elemento visual.  
  
> [!IMPORTANT]
>  Esse método acessa dados críticos <xref:System.Windows.Interop.HwndTarget>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMnemonicCore">
      <MemberSignature Language="C#" Value="protected virtual bool OnMnemonicCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnMnemonicCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.OnMnemonicCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem para os dados associados e mnemônicos.</param>
        <param name="modifiers">Teclas modificadoras.</param>
        <summary>Chamado quando um o mnemônico (chaves de acesso) para esse coletor é invocado.</summary>
        <returns>
          <see langword="true" />Se a mensagem foi tratada; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="msg" />não é WM_KEYDOWN, WM_SYSKEYDOWN, WM_CHAR ou WM_DEADCHAR.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RegisterKeyboardInputSinkCore">
      <MemberSignature Language="C#" Value="protected System.Windows.Interop.IKeyboardInputSite RegisterKeyboardInputSinkCore (System.Windows.Interop.IKeyboardInputSink sink);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Interop.IKeyboardInputSite RegisterKeyboardInputSinkCore(class System.Windows.Interop.IKeyboardInputSink sink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.RegisterKeyboardInputSinkCore(System.Windows.Interop.IKeyboardInputSink)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sink" Type="System.Windows.Interop.IKeyboardInputSink" />
      </Parameters>
      <Docs>
        <param name="sink">O <see cref="T:System.Windows.Interop.IKeyboardInputSink" /> coletor do componente independente.</param>
        <summary>Registra o <see cref="T:System.Windows.Interop.IKeyboardInputSink" /> interface de um componente independente.</summary>
        <returns>O <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> site do componente independente.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveHook">
      <MemberSignature Language="C#" Value="public void RemoveHook (System.Windows.Interop.HwndSourceHook hook);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveHook(class System.Windows.Interop.HwndSourceHook hook) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.RemoveHook(System.Windows.Interop.HwndSourceHook)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hook" Type="System.Windows.Interop.HwndSourceHook" />
      </Parameters>
      <Docs>
        <param name="hook">O manipulador de eventos a ser removido.</param>
        <summary>Remove os manipuladores de eventos que foram adicionados por <see cref="M:System.Windows.Interop.HwndSource.AddHook(System.Windows.Interop.HwndSourceHook)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Este método não está disponível na zona de segurança da Internet.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para remover manipuladores. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="RestoreFocusMode">
      <MemberSignature Language="C#" Value="public System.Windows.Input.RestoreFocusMode RestoreFocusMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Input.RestoreFocusMode RestoreFocusMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.RestoreFocusMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.RestoreFocusMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Windows.Input.RestoreFocusMode" /> para a janela.</summary>
        <value>O <see cref="T:System.Windows.Input.RestoreFocusMode" /> para a janela.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade pode ser definida apenas no <xref:System.Windows.Interop.HwndSource.%23ctor%28System.Windows.Interop.HwndSourceParameters%29?displayProperty=nameWithType> construtor usando o <xref:System.Windows.Interop.HwndSourceParameters.RestoreFocusMode%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RootVisual">
      <MemberSignature Language="C#" Value="public override System.Windows.Media.Visual RootVisual { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Visual RootVisual" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.RootVisual" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="P:System.Windows.Media.CompositionTarget.RootVisual" /> da janela.</summary>
        <value>O objeto visual raiz da janela.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esta propriedade para conectar-se um <xref:System.Windows.Controls.Page> ou outra raiz visual para o <xref:System.Windows.Interop.HwndSource>.  
  
 Transformações de escala não devem ser aplicadas para o <xref:System.Windows.Interop.HwndSource.RootVisual%2A> de um <xref:System.Windows.Interop.HwndSource> porque isso pode desabilitar <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> comportamento. O conteúdo será dimensionado, mas não a janela de delimitador. Em vez de aplicar a transformação ao objeto que é o <xref:System.Windows.Interop.HwndSource.RootVisual%2A>, aplicar a transformação a um objeto que é um elemento filho de <xref:System.Windows.Interop.HwndSource.RootVisual%2A>. Talvez seja necessário adicionar um elemento delimitador extra para o [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] conteúdo, como um painel, para fornecer um objeto escalonável.  
  
 Você pode adicionar um <xref:System.Windows.Window> como o visual raiz, mas apenas como uma janela de nível superior (com WS_OVERLAPPED), e não como uma janela filho.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Para definir essa propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.SizeToContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se e como a janela é dimensionada para seu conteúdo.</summary>
        <value>Um dos valores de enumeração. O valor padrão é <see cref="F:System.Windows.SizeToContent.Manual" />, que especifica que a janela não é dimensionada para seu conteúdo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os usuários finais podem indiretamente definir essa propriedade por meio da interface do usuário, do aplicativo se que a funcionalidade é exposta pelo aplicativo.  
  
 Transformações de escala não devem ser aplicadas para o <xref:System.Windows.Interop.HwndSource.RootVisual%2A> de um <xref:System.Windows.Interop.HwndSource>, pois isso pode desabilitar <xref:System.Windows.Interop.HwndSource.SizeToContent%2A> comportamento. Consulte os comentários para <xref:System.Windows.Interop.HwndSource.RootVisual%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContentChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SizeToContentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SizeToContentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Interop.HwndSource.SizeToContentChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o valor da propriedade <see cref="P:System.Windows.Interop.HwndSource.SizeToContent" /> muda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Interop.HwndSource.SizeToContentChanged> evento é gerado apenas quando a interação do usuário faz com que a alteração. Se você definir <xref:System.Windows.Window.SizeToContent%2A> no código, o <xref:System.Windows.Interop.HwndSource.SizeToContentChanged> não é gerado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.HasFocusWithin">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.HasFocusWithin ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#HasFocusWithin" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Media.FamilyTypefaceCollection.System#Collections#IList#Remove(System.Object)" />.</summary>
        <returns>
          <see langword="true" />Se o coletor ou um de seus componentes independentes tem foco. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Interop.HwndSource> é convertida em uma interface de <xref:System.Windows.Interop.IKeyboardInputSink>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite">
      <MemberSignature Language="C#" Value="System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#KeyboardInputSite" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite" />.</summary>
        <value>Uma referência para o contêiner <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> interface.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Interop.HwndSource> é convertida em uma interface de <xref:System.Windows.Interop.IKeyboardInputSink>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para definir essa propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.OnMnemonic">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.OnMnemonic (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem para os dados associados e mnemônicos. Não modifique esta estrutura de mensagem. Ele é passado por referência por razões de desempenho apenas.</param>
        <param name="modifiers">Teclas modificadoras.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns>
          <see langword="true" />Se a mensagem foi tratada; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Interop.HwndSource> é convertida em uma interface de <xref:System.Windows.Interop.IKeyboardInputSink>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink">
      <MemberSignature Language="C#" Value="System.Windows.Interop.IKeyboardInputSite IKeyboardInputSink.RegisterKeyboardInputSink (System.Windows.Interop.IKeyboardInputSink sink);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Windows.Interop.IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(class System.Windows.Interop.IKeyboardInputSink sink) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Interop.IKeyboardInputSite</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sink" Type="System.Windows.Interop.IKeyboardInputSink" />
      </Parameters>
      <Docs>
        <param name="sink">O <see cref="T:System.Windows.Interop.IKeyboardInputSink" /> coletor do componente independente.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(System.Windows.Interop.IKeyboardInputSink)" />.</summary>
        <returns>O <see cref="T:System.Windows.Interop.IKeyboardInputSite" /> site do componente independente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Interop.HwndSource> é convertida em uma interface de <xref:System.Windows.Interop.IKeyboardInputSink>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TabInto">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TabInto (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TabInto(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TabInto(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Especifica se o foco deve ser definido para a primeira ou a última parada de tabulação.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Interop.IKeyboardInputSink.TabInto(System.Windows.Input.TraversalRequest)" />.</summary>
        <returns>
          <see langword="true" /> se o foco tiver sido definido como solicitado; <see langword="false" />, se não houver nenhuma parada de tabulação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Interop.HwndSource> é convertida em uma interface de <xref:System.Windows.Interop.IKeyboardInputSink>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateAccelerator (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem e dados associados. Não modifique esta estrutura. Ele é passado por referência por razões de desempenho apenas.</param>
        <param name="modifiers">Teclas modificadoras.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns>
          <see langword="true" />Se a mensagem foi tratada pela implementação de método; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Interop.HwndSource> é convertida em uma interface de <xref:System.Windows.Interop.IKeyboardInputSink>.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Interop.IKeyboardInputSink.TranslateChar">
      <MemberSignature Language="C#" Value="bool IKeyboardInputSink.TranslateChar (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.System#Windows#Interop#IKeyboardInputSink#TranslateChar(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem e dados associados. Não modifique esta estrutura. Ele é passado por referência por razões de desempenho apenas.</param>
        <param name="modifiers">Teclas modificadoras.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Windows.Interop.IKeyboardInputSink.TranslateChar(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />.</summary>
        <returns>
          <see langword="true" />Se a mensagem foi processada e <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> não deve ser chamado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Windows.Interop.HwndSource> é convertida em uma interface de <xref:System.Windows.Interop.IKeyboardInputSink>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIntoCore">
      <MemberSignature Language="C#" Value="protected virtual bool TabIntoCore (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TabIntoCore(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TabIntoCore(System.Windows.Input.TraversalRequest)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Especifica se o foco deve ser definido para a primeira ou a última parada de tabulação.</param>
        <summary>Define se o foco estará na primeira parada de tabulação ou na última parada de tabulação do coletor.</summary>
        <returns>
          <see langword="true" /> se o foco tiver sido definido como solicitado; <see langword="false" />, se não houver nenhuma parada de tabulação.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="request" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TranslateAcceleratorCore">
      <MemberSignature Language="C#" Value="protected virtual bool TranslateAcceleratorCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TranslateAcceleratorCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TranslateAcceleratorCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem e dados associados. Não modifique esta estrutura. Ele é passado por referência por razões de desempenho apenas.</param>
        <param name="modifiers">Teclas modificadoras.</param>
        <summary>Processa a entrada do teclado no nível da mensagem de chave para baixo.</summary>
        <returns>
          <see langword="true" />Se a mensagem foi tratada pela implementação de método; Caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TranslateCharCore">
      <MemberSignature Language="C#" Value="protected virtual bool TranslateCharCore (ref System.Windows.Interop.MSG msg, System.Windows.Input.ModifierKeys modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TranslateCharCore(valuetype System.Windows.Interop.MSG&amp; msg, valuetype System.Windows.Input.ModifierKeys modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Interop.HwndSource.TranslateCharCore(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Interop.MSG&amp;" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Windows.Input.ModifierKeys" />
      </Parameters>
      <Docs>
        <param name="msg">A mensagem e dados associados. Não modifique esta estrutura. Ele é passado por referência por razões de desempenho apenas.</param>
        <param name="modifiers">Teclas modificadoras.</param>
        <summary>Processa mensagens de entrada WM_CHAR, WM_SYSCHAR, WM_DEADCHAR e WM_SYSDEADCHAR antes do <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> método é chamado.</summary>
        <returns>
          <see langword="true" />Se a mensagem foi processada e <see cref="M:System.Windows.Interop.IKeyboardInputSink.OnMnemonic(System.Windows.Interop.MSG@,System.Windows.Input.ModifierKeys)" /> não deve ser chamado; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">para chamar esse método. Enumeração associada: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="UsesPerPixelOpacity">
      <MemberSignature Language="C#" Value="public bool UsesPerPixelOpacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UsesPerPixelOpacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Interop.HwndSource.UsesPerPixelOpacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que declara se a opacidade por pixel a janela do conteúdo de origem é respeitada.</summary>
        <value>
          <see langword="true" />Se o sistema usa opacidade por pixel; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você habilita a opacidade por pixel, o sistema não desenha a área não cliente. Isso ocorre porque a finalidade do <xref:System.Windows.Interop.HwndSource.UsesPerPixelOpacity%2A> é mostrar a IU de nível superior não retangular que funciona em cenários de interoperabilidade. Portanto, mostrando contraria a área retangular de cliente não essa finalidade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
