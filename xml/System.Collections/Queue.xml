<Type Name="Queue" FullName="System.Collections.Queue">
  <TypeSignature Language="C#" Value="public class Queue : ICloneable, System.Collections.ICollection" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Queue extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Queue" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.NonGeneric</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Queue/QueueDebugView))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma coleção primeiro a entrar, primeiro a sair de objetos.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa classe implementa uma fila como uma matriz circular. Objetos armazenados em um <xref:System.Collections.Queue> são inseridas em uma extremidade e removido da outra.  
  
 Pilhas e filas são úteis quando você precisa de armazenamento temporário para informações. ou seja, quando você quiser descartar um elemento após recuperar seu valor. Use <xref:System.Collections.Queue> se você precisar acessar as informações na mesma ordem em que ela está armazenada na coleção. Use <xref:System.Collections.Stack> se você precisar acessar as informações na ordem inversa. Use <xref:System.Collections.Concurrent.ConcurrentQueue%601> ou <xref:System.Collections.Concurrent.ConcurrentStack%601> se você precisar acessar a coleção de vários threads simultaneamente.  
  
 Três operações principais podem ser executadas em um <xref:System.Collections.Queue> e seus elementos:  
  
-   <xref:System.Collections.Queue.Enqueue%2A>Adiciona um elemento ao final do <xref:System.Collections.Queue>.  
  
-   <xref:System.Collections.Queue.Dequeue%2A>Remove o elemento mais antigo do início do <xref:System.Collections.Queue>.  
  
-   <xref:System.Collections.Queue.Peek%2A>Retorna o elemento mais antigo que está no início do <xref:System.Collections.Queue> mas não removê-lo a <xref:System.Collections.Queue>.  
  
 A capacidade de um <xref:System.Collections.Queue> é o número de elementos de <xref:System.Collections.Queue> pode conter. Como os elementos são adicionados a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue> é construído. O fator de crescimento padrão é 2.0. A capacidade do <xref:System.Collections.Queue> sempre será aumentado em um mínimo de quatro, independentemente do fator de crescimento. Por exemplo, um <xref:System.Collections.Queue> com um fator de crescimento de 1.0 sempre aumentará de capacidade por quatro quando for necessária uma maior capacidade.  
  
 <xref:System.Collections.Queue> aceita `null` como um valor válido e permite elementos duplicados.  
  
 Para obter a versão genérica dessa coleção, consulte<xref:System.Collections.Generic.Queue%601?displayProperty=nameWithType>  
  
   
  
## Examples  
 O exemplo a seguir mostra como criar e adicionar valores para um <xref:System.Collections.Queue> e como imprimir seus valores.  
  
 [!code-cpp[Classic Queue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.  
  
 Para garantir a segurança de thread do <see cref="T:System.Collections.Queue" />, todas as operações devem ser feitas por meio do wrapper retornado pelo <see cref="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" /> método.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Queue" /> que está vazia, tem a capacidade inicial padrão e usa o fator de crescimento padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Queue> é o número de elementos de <xref:System.Collections.Queue> pode conter.  Como os elementos são adicionados a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue> é construído.  
  
 Este construtor é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (System.Collections.ICollection col);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.ICollection col) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Collections.ICollection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="col" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="col">A <see cref="T:System.Collections.ICollection" /> da qual copiar elementos.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Queue" /> que contém os elementos copiados da coleção especificada, tem a mesma capacidade inicial que o número de elementos copiados e usa o fator de crescimento padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Queue> é o número de elementos de <xref:System.Collections.Queue> pode conter.  Como os elementos são adicionados a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue> é construído.  
  
 Os elementos são copiados para o <xref:System.Collections.Queue> na mesma ordem em que são lidas pelo <xref:System.Collections.IEnumerator> do <xref:System.Collections.ICollection>.  
  
 Este construtor é um O (`n`) operação, onde `n` é o número de elementos em `col`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="col" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">O número inicial de elementos que o <see cref="T:System.Collections.Queue" /> pode conter.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Queue" /> que está vazia, tem a capacidade inicial especificada e usa o fator de crescimento padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Queue> é o número de elementos de <xref:System.Collections.Queue> pode conter.  Como os elementos são adicionados a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue> é construído.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Queue>.  
  
 Este construtor é um O (`n`) operação, onde `n` é `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Queue (int capacity, float growFactor);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, float32 growFactor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.#ctor(System.Int32,System.Single)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="growFactor" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="capacity">O número inicial de elementos que o <see cref="T:System.Collections.Queue" /> pode conter.</param>
        <param name="growFactor">O fator pelo qual a capacidade da <see cref="T:System.Collections.Queue" /> é expandida.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Collections.Queue" /> que está vazia, tem a capacidade inicial especificada e usa o fator de crescimento especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Queue> é o número de elementos de <xref:System.Collections.Queue> pode conter.  Como os elementos são adicionados a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue> é construído. A capacidade do <xref:System.Collections.Queue> sempre será aumentado em um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não impedirá o <xref:System.Collections.Queue> de aumentarem de tamanho.  
  
 Se o tamanho da coleção pode ser estimado, especificando a capacidade inicial elimina a necessidade de executar um número de operações de redimensionamento durante a adição de elementos para o <xref:System.Collections.Queue>.  
  
 Este construtor é um O (`n`) operação, onde `n` é `capacity`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="growFactor" /> é menor que 1,0 ou maior que 10,0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public virtual void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os objetos da <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Collections.Queue.Count%2A>é definido como zero, e referências a outros objetos de elementos da coleção também são liberadas.  
  
 A capacidade permanece inalterada. Para redefinir a capacidade do <xref:System.Collections.Queue>, chame <xref:System.Collections.Queue.TrimToSize%2A>. Cortar vazio <xref:System.Collections.Queue> define a capacidade do <xref:System.Collections.Queue> à capacidade padrão.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como limpar os valores de <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Clear Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Clear Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Clear Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Clear Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Clear Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Clear Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia superficial do <see cref="T:System.Collections.Queue" />.</summary>
        <returns>Uma cópia superficial do <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma cópia superficial de uma coleção copia apenas os elementos da coleção, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a. As referências na nova coleção apontam para os mesmos objetos que as referências na coleção original apontem para.  
  
 Em contraste, uma cópia profunda de uma coleção copia os elementos e tudo direta ou indiretamente referenciado por elementos.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Queue.Count%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O <see cref="T:System.Object" /> a ser localizado no <see cref="T:System.Collections.Queue" />. O valor pode ser <see langword="null" />.</param>
        <summary>Determina se um elemento está no <see cref="T:System.Collections.Queue" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> for encontrado no <see cref="T:System.Collections.Queue" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método determina a igualdade chamando <xref:System.Object.Equals%2A?displayProperty=nameWithType>.  
  
 Este método executa uma pesquisa linear; por isso, esse método é uma operação O(`n`), em que `n` é <xref:System.Collections.Queue.Count%2A>.  
  
 Começando com o .NET Framework 2.0, esse método usa objetos da coleção <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> métodos em `obj` para determinar se `item` existe. Em versões anteriores do .NET Framework, essa decisão era tomada usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do parâmetro `obj` nos objetos na coleção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public virtual void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional que é o destino dos elementos copiados de <see cref="T:System.Collections.Queue" />. O <see cref="T:System.Array" /> deve ter indexação com base em zero.</param>
        <param name="index">O índice de base zero em <c>matriz</c> no qual a cópia começa.</param>
        <summary>Copia os elementos <see cref="T:System.Collections.Queue" /> em um <see cref="T:System.Array" /> unidimensional existente, começando no índice da matriz especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos são copiados para o <xref:System.Array> na mesma ordem em que o enumerador que itera por meio de <xref:System.Collections.Queue>.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como copiar um <xref:System.Collections.Queue> em uma matriz unidimensional.  
  
 [!code-cpp[Classic Queue.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> é multidimensional.  
  
 - ou -  
  
 O número de elementos na origem <see cref="T:System.Collections.Queue" /> é maior do que o espaço disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">O tipo do <see cref="T:System.Collections.Queue" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos contidos no <see cref="T:System.Collections.Queue" />.</summary>
        <value>O número de elementos contidos no <see cref="T:System.Collections.Queue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Queue> é o número de elementos que o <xref:System.Collections.Queue> pode armazenar. <xref:System.Collections.Queue.Count%2A>é o número de elementos que estão realmente no <xref:System.Collections.Queue>.  
  
 A capacidade de um <xref:System.Collections.Queue> é sempre maior que ou igual a <xref:System.Collections.Queue.Count%2A>. Se <xref:System.Collections.Queue.Count%2A> excede a capacidade durante a adição de elementos, a capacidade é aumentada automaticamente realocando a matriz interna antes de copiar os elementos antigos e adição de novos elementos. A nova capacidade é determinada multiplicando a capacidade atual pelo fator de crescimento, o que é determinado quando o <xref:System.Collections.Queue> é construído. A capacidade do <xref:System.Collections.Queue> sempre será aumentado em um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não impedirá o <xref:System.Collections.Queue> de aumentarem de tamanho.  
  
 A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dequeue">
      <MemberSignature Language="C#" Value="public virtual object Dequeue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Dequeue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Dequeue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove e retorna o objeto no início do <see cref="T:System.Collections.Queue" />.</summary>
        <returns>O objeto removido do início do <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é semelhante do <xref:System.Collections.Queue.Peek%2A> método, mas <xref:System.Collections.Queue.Peek%2A> não modifica o <xref:System.Collections.Queue>.  
  
 `null`podem ser adicionados para o <xref:System.Collections.Queue> como um valor. Para distinguir entre um valor nulo e o término do <xref:System.Collections.Queue>, verifique o <xref:System.Collections.Queue.Count%2A> propriedade ou catch o <xref:System.InvalidOperationException>, que é gerado quando o <xref:System.Collections.Queue> está vazio.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir mostra como adicionar elementos para o <xref:System.Collections.Queue>, remover elementos do <xref:System.Collections.Queue>, ou exibir o elemento no início do <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Queue" /> está vazio.</exception>
      </Docs>
    </Member>
    <Member MemberName="Enqueue">
      <MemberSignature Language="C#" Value="public virtual void Enqueue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Enqueue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Enqueue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser adicionado ao <see cref="T:System.Collections.Queue" />. O valor pode ser <see langword="null" />.</param>
        <summary>Adiciona um objeto ao final do <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade de um <xref:System.Collections.Queue> é o número de elementos de <xref:System.Collections.Queue> pode conter.  Como os elementos são adicionados a um <xref:System.Collections.Queue>, a capacidade é aumentada automaticamente conforme necessário por meio de realocação.  A capacidade pode ser diminuída chamando <xref:System.Collections.Queue.TrimToSize%2A>.  
  
 O fator de crescimento é o número pelo qual a capacidade atual é multiplicada quando for necessária uma maior capacidade.  O fator de crescimento é determinado quando o <xref:System.Collections.Queue> é construído. A capacidade do <xref:System.Collections.Queue> sempre será aumentado em um valor mínimo, independentemente do fator de crescimento; um fator de crescimento de 1.0 não impedirá o <xref:System.Collections.Queue> de aumentarem de tamanho.  
  
 Se <xref:System.Collections.Queue.Count%2A> é menor que a capacidade da matriz interna, esse método é uma operação de (1). Se a matriz interna precisa ser realocada para acomodar o novo elemento, esse método se torna um O (`n`) operação, onde `n` é <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como adicionar elementos para o <xref:System.Collections.Queue>, remover elementos do <xref:System.Collections.Queue>, ou exibir o elemento no início do <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera por meio do <see cref="T:System.Collections.Queue" />.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `foreach` instrução de linguagem c# (`for each` no Visual Basic) oculta a complexidade dos enumeradores.  Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.  Nesta posição, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Por isso, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> ser chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.  
  
 O enumerador não tem acesso exclusivo à coleção; por isso, a enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public virtual bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Collections.Queue" /> é sincronizado (thread-safe).</summary>
        <value>
          <see langword="true" /> caso o acesso ao <see cref="T:System.Collections.Queue" /> seja sincronizado (thread-safe); do contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para garantir a segurança de thread do <xref:System.Collections.Queue>, todas as operações devem ser feitas por meio do wrapper retornado pelo <xref:System.Collections.Queue.Synchronized%2A> método.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Queue.SyncRoot%2A> durante toda a enumeração. A recuperação do valor dessa propriedade é uma operação O(1).  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 O exemplo a seguir mostra como sincronizar um <xref:System.Collections.Queue>, determinar se um <xref:System.Collections.Queue> está sincronizado e usar um sincronizado <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Peek">
      <MemberSignature Language="C#" Value="public virtual object Peek ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Peek() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Peek" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o objeto ao início da <see cref="T:System.Collections.Queue" /> sem removê-lo.</summary>
        <returns>O objeto no início da <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é semelhante do <xref:System.Collections.Queue.Dequeue%2A> método, mas <xref:System.Collections.Queue.Peek%2A> não modifica o <xref:System.Collections.Queue>.  
  
 `null`podem ser adicionados para o <xref:System.Collections.Queue> como um valor. Para distinguir entre um valor nulo e o término do <xref:System.Collections.Queue>, verifique o <xref:System.Collections.Queue.Count%2A> propriedade ou catch o <xref:System.InvalidOperationException>, que é gerado quando o <xref:System.Collections.Queue> está vazio.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir mostra como adicionar elementos para o <xref:System.Collections.Queue>, remover elementos do <xref:System.Collections.Queue>, ou exibir o elemento no início do <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.Enqueue Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.Enqueue Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.Enqueue Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.Enqueue Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Collections.Queue" /> está vazio.</exception>
      </Docs>
    </Member>
    <Member MemberName="Synchronized">
      <MemberSignature Language="C#" Value="public static System.Collections.Queue Synchronized (System.Collections.Queue queue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Queue Synchronized(class System.Collections.Queue queue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.Synchronized(System.Collections.Queue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Queue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="queue" Type="System.Collections.Queue" />
      </Parameters>
      <Docs>
        <param name="queue">O <see cref="T:System.Collections.Queue" /> a ser sincronizado.</param>
        <summary>Retorna um novo <see cref="T:System.Collections.Queue" /> que encapsula a fila original e é thread-safe.</summary>
        <returns>Um wrapper <see cref="T:System.Collections.Queue" /> sincronizado (thread-safe).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O wrapper retornado por este método bloqueia a fila antes de uma operação é executada de forma que ele é executado em uma forma thread-safe.  
  
 Para garantir a segurança de thread do <xref:System.Collections.Queue>, todas as operações devem ser feitas por meio de apenas esse wrapper.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Queue.SyncRoot%2A> durante toda a enumeração. Este método é uma operação O(1).  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 O exemplo a seguir mostra como sincronizar um <xref:System.Collections.Queue>, determinar se um <xref:System.Collections.Queue> é sincronizado e usar um sincronizado <xref:System.Collections.Queue>.  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.IsSynchronized Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.IsSynchronized Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="queue" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public virtual object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Queue.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.Queue" />.</summary>
        <value>Um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Collections.Queue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma versão sincronizada do <xref:System.Collections.Queue>, use o <xref:System.Collections.Queue.Synchronized%2A> método. No entanto, as classes derivadas podem fornecer sua própria versão sincronizada de <xref:System.Collections.Queue> usando o <xref:System.Collections.Queue.SyncRoot%2A> propriedade. O código de sincronização necessário realizar operações no <xref:System.Collections.Queue.SyncRoot%2A> do <xref:System.Collections.Queue>, não diretamente no <xref:System.Collections.Queue>. Isso garante a operação apropriada das coleções que são derivadas de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificando o <xref:System.Collections.Queue> objeto.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear a coleção usando o <xref:System.Collections.Queue.SyncRoot%2A> durante toda a enumeração. A recuperação do valor dessa propriedade é uma operação O(1).  
  
 [!code-cpp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Queue.IsSynchronized Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/CS/source2.cs#2)]
 [!code-vb[Classic Queue.IsSynchronized Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.IsSynchronized Example/VB/source2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public virtual object[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.ToArray" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia os elementos do <see cref="T:System.Collections.Queue" /> em uma nova matriz.</summary>
        <returns>Uma nova matriz que contém os elementos copiados de <see cref="T:System.Collections.Queue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Collections.Queue> não é modificado. A ordem dos elementos na nova matriz é igual à ordem dos elementos do início do <xref:System.Collections.Queue> até o fim.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Queue.Count%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como copiar um <xref:System.Collections.Queue> em uma matriz unidimensional.  
  
 [!code-cpp[Classic Queue.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Queue.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Queue.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Queue.CopyTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimToSize">
      <MemberSignature Language="C#" Value="public virtual void TrimToSize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void TrimToSize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Queue.TrimToSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.NonGeneric</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define a capacidade para o número real de elementos em <see cref="T:System.Collections.Queue" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para minimizar a memória de uma fila sobrecarga se nenhum elemento novo será adicionado à fila.  
  
 Para redefinir um <xref:System.Collections.Queue> para seu estado inicial, chame o <xref:System.Collections.Queue.Clear%2A> método antes de chamar <xref:System.Collections.Queue.TrimToSize%2A>. Cortar vazio <xref:System.Collections.Queue> define a capacidade do <xref:System.Collections.Queue> à capacidade padrão.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Collections.Queue.Count%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.Queue" /> é somente leitura.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
