<Type Name="Control" FullName="System.Web.UI.Control">
  <TypeSignature Language="C#" Value="public class Control : IDisposable, System.ComponentModel.IComponent, System.Web.UI.IControlBuilderAccessor, System.Web.UI.IControlDesignerAccessor, System.Web.UI.IDataBindingsAccessor, System.Web.UI.IExpressionsAccessor, System.Web.UI.IParserAccessor, System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Control extends System.Object implements class System.ComponentModel.IComponent, class System.IDisposable, class System.Web.UI.IControlBuilderAccessor, class System.Web.UI.IControlDesignerAccessor, class System.Web.UI.IDataBindingsAccessor, class System.Web.UI.IExpressionsAccessor, class System.Web.UI.IParserAccessor, class System.Web.UI.IUrlResolutionService" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Control" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.IComponent</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlBuilderAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IControlDesignerAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IDataBindingsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IExpressionsAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IParserAccessor</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Web.UI.IUrlResolutionService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("ID")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.ControlCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.CodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Web.UI.Design.ControlDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Code")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem("System.Web.UI.Design.WebControlToolboxItem, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Web.UI", System.ComponentModel.ToolboxItemFilterType.Require)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define as propriedades, os métodos e os eventos compartilhados por todos os controles de servidor ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta é a classe principal que é derivado de quando você desenvolve controles de servidor ASP.NET. <xref:System.Web.UI.Control>não tem nenhum recurso específico do usuário (IU) da interface. Se você estiver criando um controle que não tem uma interface de usuário ou combina outros controles que processam sua própria interface do usuário, derivam <xref:System.Web.UI.Control>. Se você estiver criando um controle que tem uma interface do usuário, derivam <xref:System.Web.UI.WebControls.WebControl> ou qualquer controle no <xref:System.Web.UI.WebControls> ponto de namespace que fornece um começando apropriado para seu controle personalizado.  
  
 O <xref:System.Web.UI.Control> classe é a classe base para todos os controles de servidor ASP.NET, incluindo páginas, controles personalizados e controles de usuário. Páginas ASP.NET são instâncias do <xref:System.Web.UI.Page> classe que herde o <xref:System.Web.UI.Control> classe e que manipulam solicitações para arquivos que têm uma extensão.  
  
 O <xref:System.Web.UI.Control> classe pode direta ou indiretamente ser usada como parte da interface do usuário para sua Web, aplicativo e como tal, deve ser examinado para tornar-se de que as práticas recomendadas para escrever código seguro e proteger aplicativos são seguidas.  
  
 Para obter informações gerais sobre esses tópicos, consulte [visão geral da Web aplicativo contra ameaças à segurança](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: práticas recomendadas de política de segurança](http://msdn.microsoft.com/en-us/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), e [conceitos de segurança de chave](~/docs/standard/security/key-security-concepts.md). Para obter informações mais específicas, consulte [protegendo controles padrão](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [como: exibir mensagens de erro de segurança](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [como: proteger contra scripts maliciosos em um aplicativo da Web aplicando codificação HTML a cadeias de caracteres](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), e [Introdução aos controles de validação](http://msdn.microsoft.com/en-us/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 O exemplo a seguir demonstra um controle de servidor personalizado que deriva de <xref:System.Web.UI.Control> classe. O `InnerContent` substituições de classe a <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método, verifica se a classe tem os controles filho da página e determina se o primeiro filho do controle é um controle literal. Se essas duas condições forem atendidas, o método substituído grava a cadeia de caracteres HTML \<H2 > sua mensagem:, o conteúdo do controle literal e um fechamento \</H2 > marca para a página de Web Forms.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Classic Control Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control Example/CS/source.cs#1)]
 [!code-vb[Classic Control Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Control ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Adapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.ControlAdapter Adapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.ControlAdapter Adapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Adapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o adaptador específico de navegador para o controle.</summary>
        <value>Um <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> para esse controle. Se o navegador de destino não exigir um adaptador, retornará <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas da Web ASP.NET são úteis em uma ampla variedade de dispositivos e navegadores que podem solicitar informações da Web. O <xref:System.Web.UI.Control.Adapter%2A> propriedade retorna o <xref:System.Web.UI.Adapters.ControlAdapter> objeto que renderiza o controle na tela do navegador ou do dispositivo solicitante.  
  
 Para obter mais informações sobre os adaptadores, consulte [arquitetura visão geral do controle comportamento adaptável](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddedControl">
      <MemberSignature Language="C#" Value="protected virtual void AddedControl (System.Web.UI.Control control, int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void AddedControl(class System.Web.UI.Control control, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddedControl(System.Web.UI.Control,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="control">O <see cref="T:System.Web.UI.Control" /> que foi adicionado.</param>
        <param name="index">O índice do controle na coleção <see cref="P:System.Web.UI.Control.Controls" />.</param>
        <summary>Chamado após um controle filho ser adicionado à coleção <see cref="P:System.Web.UI.Control.Controls" /> do objeto <see cref="T:System.Web.UI.Control" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.AddedControl%2A> método é chamado imediatamente depois que um controle é adicionado para o <xref:System.Web.UI.Control.Controls%2A> coleção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="control" />é um <see cref="T:System.Web.UI.WebControls.Substitution" /> controle.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddParsedSubObject">
      <MemberSignature Language="C#" Value="protected virtual void AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.AddParsedSubObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Um <see cref="T:System.Object" /> que representa o elemento analisado.</param>
        <summary>Notifica o controle de servidor de que um elemento, XML ou HTML, foi analisado e adiciona o elemento ao objeto <see cref="T:System.Web.UI.ControlCollection" /> do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A menos que você substituí-la, este método adiciona automaticamente <xref:System.Web.UI.LiteralControl> objetos para o controle de servidor <xref:System.Web.UI.ControlCollection> objeto. Essa coleção está acessível por meio de <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir é um controle de servidor personalizado que usa o <xref:System.Web.UI.Control.AddParsedSubObject%2A> método para determinar se os elementos declarados entre as marcas de abertura e fechamento deste controle são <xref:System.Web.UI.WebControls.TextBox> controles de servidor Web. Se elas forem, eles são adicionados a um <xref:System.Collections.ArrayList> objeto `items`. Quando substituído <xref:System.Web.UI.Control.CreateChildControls%2A> método é chamado, ele itera por meio de <xref:System.Collections.ArrayList> e adiciona-o para cada objeto de <xref:System.Web.UI.ControlCollection> do controle de servidor personalizado.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Control_AddParsedSubObject#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_AddParsedSubObject/CS/control_addparsedsubobject.cs#1)]
 [!code-vb[Control_AddParsedSubObject#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_AddParsedSubObject/VB/control_addparsedsubobject.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyStyleSheetSkin">
      <MemberSignature Language="C#" Value="public virtual void ApplyStyleSheetSkin (System.Web.UI.Page page);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyStyleSheetSkin(class System.Web.UI.Page page) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ApplyStyleSheetSkin(System.Web.UI.Page)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="page" Type="System.Web.UI.Page" />
      </Parameters>
      <Docs>
        <param name="page">O <see cref="T:System.Web.UI.Page" /> que contém o controle.</param>
        <summary>Aplica as propriedades de estilo definidas na folha de estilos da página ao controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método define propriedades de estilo do controle com base nas propriedades de aparência definidas em um diretório do tema. A capa aplicada é a capa padrão para o controle ou a capa especificado no <xref:System.Web.UI.Control.SkinID%2A> propriedade. O <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método é chamado pelo ASP.NET para declarativos controles colocados em uma página. Você deve chamar o <xref:System.Web.UI.Control.ApplyStyleSheetSkin%2A> método em controles de criada programaticamente no tempo de execução para estilo de capas de folha para aplicar ao controle. Capas de tema são aplicadas automaticamente. Para obter mais informações sobre a diferença entre os temas e folhas de estilo em cascata, consulte [capas e temas do ASP.NET](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A folha de estilos já está aplicada.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppRelativeTemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public string AppRelativeTemplateSourceDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AppRelativeTemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.AppRelativeTemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o diretório virtual relativo de aplicativo do objeto <see cref="T:System.Web.UI.Page" /> ou <see cref="T:System.Web.UI.UserControl" /> que contém este controle.</summary>
        <value>O diretório virtual relativo de aplicativo da página ou do controle de usuário que contém este controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriedade contém o caminho relativo de aplicativo para o página ou controle de usuário que contém o controle atual. Por exemplo, se a página da Web reside no http://www.contoso.com/application/subdirectory, o <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriedade retorna "~ / subdiretório".  
  
 Para retornar o caminho virtual ("application/subdiretório"), use o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginRenderTracing">
      <MemberSignature Language="C#" Value="protected void BeginRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BeginRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BeginRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto que grava dados de rastreamento.</param>
        <param name="traceObject">O objeto de rastreamento.</param>
        <summary>Inicia o rastreamento de tempo de design de dados de renderização.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control BindingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control BindingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.BindingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o controle que contém a vinculação de dados desse controle.</summary>
        <value>O <see cref="T:System.Web.UI.Control" /> que contém a vinculação de dados desse controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.BindingContainer%2A> propriedade contém uma referência para o <xref:System.Web.UI.Control> objeto que contém as informações de associação de dados para o controle atual.  
  
 O <xref:System.Web.UI.Control.BindingContainer%2A> propriedade é o mesmo que o <xref:System.Web.UI.Control.NamingContainer%2A> propriedade, exceto quando o controle é parte de um modelo. Nesse caso, o <xref:System.Web.UI.Control.BindingContainer%2A> está definida como o <xref:System.Web.UI.Control> que define o modelo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildProfileTree">
      <MemberSignature Language="C#" Value="protected void BuildProfileTree (string parentId, bool calcViewState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void BuildProfileTree(string parentId, bool calcViewState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.BuildProfileTree(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parentId" Type="System.String" />
        <Parameter Name="calcViewState" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="parentId">O identificador do pai do controle.</param>
        <param name="calcViewState">Um booliano que indica se o tamanho do estado de exibição é calculado.</param>
        <summary>Reúne informações sobre o controle de servidor e enviá-lo para o <see cref="P:System.Web.UI.Page.Trace" /> propriedade a ser exibida quando o rastreamento está habilitado para a página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade reúne as informações necessárias sobre a hierarquia de interface do usuário da página e passa para a página [ &lt;rastreamento&gt; ](~/docs/framework/configure-apps/file-schema/trace-debug/trace-element.md) propriedade. Quando você ativa o rastreamento, para uma página ou para seu aplicativo, essas informações são exibidas no `Control Tree` seção da saída de rastreamento. Saída de rastreamento para uma página é acrescentada ao final da página; enquanto a saída de rastreamento para um aplicativo pode ser exibida no Visualizador de rastreamento (Trace. axd arquivo) que é armazenado no diretório raiz do aplicativo. Para obter mais informações sobre rastreamento, consulte [visão geral de rastreamento ASP.NET](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ChildControlsCreated">
      <MemberSignature Language="C#" Value="protected bool ChildControlsCreated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ChildControlsCreated" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ChildControlsCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os controles filho do controle de servidor foram criados.</summary>
        <value>
          <see langword="true" /> se os controles filho tiverem sido criados; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra uma substituição do <xref:System.Web.UI.Control.OnDataBinding%2A> método de um personalizado <xref:System.Web.UI.WebControls.Repeater> controle. Para garantir que os controles filho não são criados até que a associação de dados ocorre novamente, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> está definida como `true` depois que o <xref:System.Web.UI.WebControls.RepeaterItem> objetos são criados e adicionados ao controle de <xref:System.Web.UI.ControlCollection> objeto.  
  
 [!code-csharp[TemplatedDataBoundControl3#1](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/customrepeater.cs#1)]
 [!code-vb[TemplatedDataBoundControl3#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/customrepeater.vb#1)]  
  
 O exemplo a seguir demonstra como usar o controle repetidor personalizado em uma página da Web.  
  
 [!code-aspx-csharp[TemplatedDataBoundControl3#2](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl3/cs/default.aspx#2)]
 [!code-aspx-vb[TemplatedDataBoundControl3#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl3/vb/default.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearCachedClientID">
      <MemberSignature Language="C#" Value="protected void ClearCachedClientID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearCachedClientID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearCachedClientID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o valor <see cref="P:System.Web.UI.Control.ClientID" /> armazenado em cache como <see langword="null" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildControlState">
      <MemberSignature Language="C#" Value="protected void ClearChildControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui as informações de estado de controle para controles do filho do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ClearChildControlState%2A> método é usado quando informações de estado do controle filho gravadas para o estado de controle do controle pai são substituídas conforme novos controles filho são criados, como quando controles de associação de dados filho em um controle de modelo de associação de dados de servidor. Chamando o <xref:System.Web.UI.Control.ClearChildControlState%2A> método para controles filho vazio antes de chamar o <xref:System.Web.UI.Control.SaveControlState%2A> método reduz o tamanho das informações de estado de controle que devem ser transmitidos ou armazenados.  
  
 Ao recriar controles filho de um <xref:System.Web.UI.Control> de objeto, use o <xref:System.Web.UI.Control.ClearChildControlState%2A> método para limpar o estado do controle filho para que ele não é aplicado a novos controles inadvertidamente.  
  
 Para limpar tanto o estado do controle filho e o estado de exibição, use o <xref:System.Web.UI.Control.ClearChildState%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildState">
      <MemberSignature Language="C#" Value="protected void ClearChildState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui as informações de estado de controle e estado de exibição para controles filho de todo o controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ClearChildState%2A> método limpa todas as informações de estado de controle e estado de exibição para controles filho. É equivalente a chamar tanto o <xref:System.Web.UI.Control.ClearChildViewState%2A> método e o <xref:System.Web.UI.Control.ClearChildControlState%2A> método.  
  
 Ao recriar controles filho de um <xref:System.Web.UI.Control> de objeto, use o <xref:System.Web.UI.Control.ClearChildState%2A> método Limpar estado filho para que ele não é aplicado a novos controles inadvertidamente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como substituir o <xref:System.Web.UI.Control.OnDataBinding%2A> método para um controle associado a dados modelo. Se a fonte de dados que vincula o controle à estiver preenchida, o controle <xref:System.Web.UI.ControlCollection> coleção é esvaziada usando o <xref:System.Web.UI.ControlCollection.Clear%2A> método e o <xref:System.Web.UI.Control.ClearChildState%2A> método é usado para remover qualquer informação de estado salvo para os controles filho.  
  
 [!code-csharp[TemplatedDataBoundControl2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl2/cs/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl2/vb/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChildViewState">
      <MemberSignature Language="C#" Value="protected void ClearChildViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChildViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearChildViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui as informações de estado de exibição para todos os controles filho do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é geralmente usado quando você substituir o <xref:System.Web.UI.Control.DataBind%2A> método durante o desenvolvimento de controles de modelo de associação de dados de servidor. Se você não chama esse método, as informações de estado de exibição – controle filho podem ser gravadas para um controle de servidor pai, apenas a ser substituído quando os dados serão associados.  
  
 Ao recriar controles filho de um <xref:System.Web.UI.Control>, use o <xref:System.Web.UI.Control.ClearChildViewState%2A> método limpar o estado de exibição filho para que ele não é aplicado a novos controles inadvertidamente.  
  
 Para obter mais informações sobre como usar esse método, consulte [como: criar controles de usuário ASP.NET modelos](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearEffectiveClientIDMode">
      <MemberSignature Language="C#" Value="protected void ClearEffectiveClientIDMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearEffectiveClientIDMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ClearEffectiveClientIDMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Conjuntos de <see cref="P:System.Web.UI.Control.ClientIDMode" /> propriedade da instância atual de controle e de quaisquer controles filho para <see cref="F:System.Web.UI.ClientIDMode.Inherit" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientID">
      <MemberSignature Language="C#" Value="public virtual string ClientID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a ID de controle de marcação HTML gerada pelo ASP.NET.</summary>
        <value>A ID do controle de marcação HTML gerada pelo ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um controle de servidor Web é renderizado como um elemento HTML, o `id` atributo do elemento HTML é definido como o valor de <xref:System.Web.UI.Control.ClientID%2A> propriedade. O <xref:System.Web.UI.Control.ClientID%2A> valor geralmente é usado para acessar o elemento HTML no script de cliente usando o `document.getElementById` método. A ID também geralmente é usada nas regras CSS para especificar os elementos de estilo. Por exemplo, a regra de estilo CSS a seguir seleciona todos os `span` elementos que têm o `id` valor de atributo `ProductIDLabel` e define suas `background-color` atributo `white`:  
  
```  
span#ProductIDLabel { background-color: white; }  
```  
  
 O ASP.NET fornece vários algoritmos para como gerar o <xref:System.Web.UI.Control.ClientID%2A> o valor da propriedade. Selecione qual algoritmo será usado para um controle definindo seu <xref:System.Web.UI.Control.ClientIDMode%2A> propriedade. Os algoritmos são identificados pelo <xref:System.Web.UI.ClientIDMode> valores de enumeração que estão listados na tabela a seguir.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|O valor <xref:System.Web.UI.Control.ClientID%2A> é gerado concatenando os valores <xref:System.Web.UI.Control.ID%2A> de cada contêiner de nomenclatura pai com o valor <xref:System.Web.UI.Control.ID%2A> do controle. Em cenários de associação de dados em que várias instâncias de um controle são processadas, um valor incrementado é inserido na frente do controle <xref:System.Web.UI.Control.ID%2A> valor. Cada segmento é separado por um caractere de sublinhado (_). Esse algoritmo foi usado em versões anteriores ao ASP.NET 4 do ASP.NET.|  
|<xref:System.Web.UI.ClientIDMode.Static>|O valor <xref:System.Web.UI.Control.ClientID%2A> é definido como o valor da propriedade <xref:System.Web.UI.Control.ID%2A>. Se o controle for um contêiner de nomenclatura, ele será usado como a parte superior da hierarquia de contêineres de nomenclatura para todos os controles que contiver.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Esse algoritmo é usado para controles que estão em controles com associação de dados. O <xref:System.Web.UI.Control.ClientID%2A> valor é gerado pela concatenação do <xref:System.Web.UI.Control.ClientID%2A> valor do contêiner de nomenclatura pai com o <xref:System.Web.UI.Control.ID%2A> valor do controle. Se o controle for um controle associado a dados que gera várias linhas, o valor do campo de dados especificado no <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriedade é adicionada ao final. Para o <xref:System.Web.UI.WebControls.GridView> controlar dados de vários campos podem ser especificados. Se o <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriedade estiver em branco, um número sequencial é adicionado ao final, em vez de um valor de campo de dados. Cada segmento é separado por um caractere de sublinhado (_).|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|O controle herda a configuração <xref:System.Web.UI.ClientIDMode> de seu controle <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para uma página é <xref:System.Web.UI.ClientIDMode.Predictable>. O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para um controle é <xref:System.Web.UI.ClientIDMode.Inherit>. Como o padrão para controles é <xref:System.Web.UI.ClientIDMode.Inherit>, a geração de padrão é o modo <xref:System.Web.UI.ClientIDMode.Predictable>. (No entanto, se você usar o Visual Studio para converter um projeto da Web em ASP.NET 4 de uma versão anterior, o Visual Studio define automaticamente o padrão do site <xref:System.Web.UI.ClientIDMode.AutoID> no arquivo Web. config.)  
  
 Para obter mais informações, consulte [ASP.NET Web Server Control Identification](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7) (Identificação de controles do servidor Web do ASP.NET).  
  
   
  
## Examples  
 Os exemplos a seguir mostram um controle de usuário da Web que está dentro de uma página de conteúdo para uma página mestra. O controle de usuário contém um <xref:System.Web.UI.WebControls.DropDownList> controle e um <xref:System.Web.UI.WebControls.Label> controle. O texto que é exibido no <xref:System.Web.UI.WebControls.Label> controle é determinado pelo valor que o usuário seleciona o <xref:System.Web.UI.WebControls.DropDownList> controle. O valor de texto é definido por meio de script de cliente para que a página da Web não tem a postar de volta para o servidor para definir esse valor. Para obter uma referência ao elemento HTML que é renderizado para o <xref:System.Web.UI.WebControls.Label> controle no script de cliente, você deve saber o valor do controle do <xref:System.Web.UI.Control.ClientID%2A> propriedade. No entanto, como o controle de usuário pode ser colocado em qualquer lugar em uma página da Web, é impossível saber com antecedência quais contêineres de nomenclatura contém os controles. Para certificar-se de que o <xref:System.Web.UI.Control.ClientID%2A> valor será igual a <xref:System.Web.UI.Control.ID%2A> de valor, o código define o <xref:System.Web.UI.Control.ClientIDMode%2A> valor <xref:System.Web.UI.WebControls.ValidatorDisplay.Static>.  
  
 O exemplo a seguir mostra o controle de usuário.  
  
  
  
 O exemplo a seguir mostra a página de conteúdo que contém o controle de usuário.  
  
  
  
 O exemplo a seguir mostra a página mestra que contém a página de conteúdo.  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientIDMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ClientIDMode ClientIDMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ClientIDMode ClientIDMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientIDMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o algoritmo usado para gerar o valor da propriedade <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Um valor que indica como a propriedade <see cref="P:System.Web.UI.Control.ClientID" /> é gerada. O padrão é <see cref="F:System.Web.UI.ClientIDMode.Inherit" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET fornece vários algoritmos para como gerar o <xref:System.Web.UI.Control.ClientID%2A> o valor da propriedade. Selecione qual algoritmo será usado para um controle definindo seu <xref:System.Web.UI.Control.ClientIDMode%2A> propriedade. Os algoritmos são identificados pelo <xref:System.Web.UI.ClientIDMode> valores de enumeração que estão listados na tabela a seguir.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|<xref:System.Web.UI.ClientIDMode.AutoID>|O valor <xref:System.Web.UI.Control.ClientID%2A> é gerado concatenando os valores <xref:System.Web.UI.Control.ID%2A> de cada contêiner de nomenclatura pai com o valor <xref:System.Web.UI.Control.ID%2A> do controle. Em cenários de associação de dados em que várias instâncias de um controle são processadas, um valor incrementado é inserido na frente do controle <xref:System.Web.UI.Control.ID%2A> valor. Cada segmento é separado por um caractere de sublinhado (_). Esse algoritmo foi usado em versões anteriores ao ASP.NET 4 do ASP.NET.|  
|<xref:System.Web.UI.ClientIDMode.Static>|O valor <xref:System.Web.UI.Control.ClientID%2A> é definido como o valor da propriedade <xref:System.Web.UI.Control.ID%2A>. Se o controle for um contêiner de nomenclatura, ele será usado como a parte superior da hierarquia de contêineres de nomenclatura para todos os controles que contiver.|  
|<xref:System.Web.UI.ClientIDMode.Predictable>|Esse algoritmo é usado para controles que estão em controles com associação de dados. O <xref:System.Web.UI.Control.ClientID%2A> valor é gerado pela concatenação do <xref:System.Web.UI.Control.ClientID%2A> valor do contêiner de nomenclatura pai com o <xref:System.Web.UI.Control.ID%2A> valor do controle. Se o controle for um controle associado a dados que gera várias linhas, o valor do campo de dados especificado no <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriedade é adicionada ao final. Para o <xref:System.Web.UI.WebControls.GridView> controlar dados de vários campos podem ser especificados. Se o <xref:System.Web.UI.WebControls.IDataBoundListControl.ClientIDRowSuffix%2A> propriedade estiver em branco, um número sequencial é adicionado ao final, em vez de um valor de campo de dados. Esse número começa em zero e é incrementado em 1 para cada linha. Cada segmento é separado por um caractere de sublinhado (_).|  
|<xref:System.Web.UI.ClientIDMode.Inherit>|O controle herda a configuração <xref:System.Web.UI.ClientIDMode> de seu controle <xref:System.Web.UI.Control.NamingContainer%2A>.|  
  
 O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para uma página é <xref:System.Web.UI.ClientIDMode.Predictable>. O valor padrão de <xref:System.Web.UI.Control.ClientIDMode%2A> para um controle é <xref:System.Web.UI.ClientIDMode.Inherit>. Como o padrão para controles é <xref:System.Web.UI.ClientIDMode.Inherit>, a geração de padrão é o modo <xref:System.Web.UI.ClientIDMode.Predictable>. (No entanto, se você usar o Visual Studio para converter um projeto da Web em ASP.NET 4 de uma versão anterior, o Visual Studio define automaticamente o padrão do site <xref:System.Web.UI.ClientIDMode.AutoID> no arquivo Web. config.)  
  
 Para obter mais informações, consulte [ASP.NET Web Server Control Identification](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7) (Identificação de controles do servidor Web do ASP.NET).  
  
   
  
## Examples  
 A exemplo a seguir mostra <xref:System.Web.UI.WebControls.Label> controles que estão contidos em um <xref:System.Web.UI.WebControls.ListView> controle. No <xref:System.Web.UI.WebControls.ListView> controle, o <xref:System.Web.UI.Control.ClientIDMode%2A> está definida como <xref:System.Web.UI.ClientIDMode.Predictable> e o <xref:System.Web.UI.WebControls.ListView.ClientIDRowSuffix%2A> está definida como `ProductID`. No HTML renderizado, isso cria três `span` elementos que correspondem aos três `ProductIDLabel` controles. Quando a página é executada, o `id` atributos para o `span` elementos são definidos para os seguintes valores:  
  
-   `ListView1_ProductIDLabel_1`  
  
-   `ListView1_ProductIDLabel_34`  
  
-   `ListView1_ProductIDLabel_43`  
  
  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientIDSeparator">
      <MemberSignature Language="C#" Value="protected char ClientIDSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char ClientIDSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ClientIDSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor de caractere que representa o caractere separador usado na propriedade <see cref="P:System.Web.UI.Control.ClientID" />.</summary>
        <value>Sempre retorna o caractere de sublinhado (_).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.ClientID%2A> valor é gerado pela concatenação do <xref:System.Web.UI.Control.ID%2A> valor do controle e o <xref:System.Web.UI.Control.UniqueID%2A> valor do controle pai. Cada parte da gerado <xref:System.Web.UI.Control.ID%2A> propriedade é separada pelo <xref:System.Web.UI.Control.ClientIDSeparator%2A> o valor da propriedade. O valor sempre retorna um caractere de sublinhado (_).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected virtual System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpContext" /> associado ao controle de servidor para a solicitação da Web atual.</summary>
        <value>O objeto <see cref="T:System.Web.HttpContext" /> especificado associado à solicitação atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade fornece acesso para o <xref:System.Web.HttpContext> objeto para a solicitação da Web atual. O objeto fornece propriedades que acessam o <xref:System.Web.HttpContext.Application%2A>, <xref:System.Web.HttpContext.Session%2A>, <xref:System.Web.HttpContext.Request%2A>, <xref:System.Web.HttpContext.Response%2A> e outros objetos que contêm informações sobre a solicitação HTTP atual. Ele também fornece métodos que permitem que você obtenha informações de configuração e definir ou limpar erros para a solicitação.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#1)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Controls">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ControlCollection Controls { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlCollection Controls" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Controls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Web.UI.ControlCollection" /> que representa os controles filho para um controle de servidor especificado na hierarquia de interface do usuário.</summary>
        <value>A coleção de controles filho para o controle de servidor especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em uma página ASP.NET, quando controles são adicionados declarativamente entre as marcas de abertura e fechamento de um controle de servidor, ASP.NET adiciona automaticamente os controles para o controle de servidor que contém <xref:System.Web.UI.ControlCollection>. Quaisquer marcas HTML ou cadeias de caracteres de texto que não são processadas no servidor são tratadas como <xref:System.Web.UI.LiteralControl> objetos. Eles são adicionados à coleção, como outros controles de servidor.  
  
 O <xref:System.Web.UI.Control.Controls%2A> propriedade permite acesso programático à instância do <xref:System.Web.UI.ControlCollection> classe para qualquer controle de servidor. Você pode adicionar controles à coleção, remova os controles da coleção ou percorrer os controles do servidor na coleção.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como adicionar controles filho a um controle de servidor <xref:System.Web.UI.ControlCollection> objeto por meio de seu <xref:System.Web.UI.Control.Controls%2A> propriedade.  
  
 [!code-csharp[Classic Control.Controls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Controls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Controls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Controls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir o <see cref="P:System.Web.UI.Control.Controls" /> propriedade, certifique-se de chamar o <see cref="M:System.Web.UI.Control.EnsureChildControls" /> método. Além disso, se você planeja adicionar controles à coleção controls programaticamente, considere adicionar os controles em um substituído <see cref="M:System.Web.UI.Control.CreateChildControls" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateChildControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamado pela estrutura de página do ASP.NET para notificar os controles do servidor que usam a implementação baseada em composição para criar os controles filho para preparar-se para um postback ou renderização.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você desenvolve um controle composto ou modelo de servidor, você deve substituir esse método. Controla essa substituição de <xref:System.Web.UI.Control.CreateChildControls%2A> método deve implementar o <xref:System.Web.UI.INamingContainer> interface para evitar conflitos de nomenclatura.  
  
 Para obter mais informações, consulte [Web Server Controls Templates](http://msdn.microsoft.com/library/f769d290-fd04-4084-85fc-4ea30dd2e8ae) e [Developing Custom ASP.NET Server Controls](http://msdn.microsoft.com/library/fbe26c16-cff4-4089-b3dd-877411f0c0ef).  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma versão de substituição de <xref:System.Web.UI.Control.CreateChildControls%2A> método. Nessa implementação, o controle composto exibe um <xref:System.Web.UI.WebControls.TextBox> controle entre dois controles literal que renderizam HTML.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#2)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateControlCollection">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.ControlCollection CreateControlCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.ControlCollection CreateControlCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.CreateControlCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo objeto <see cref="T:System.Web.UI.ControlCollection" /> para manter os controles filho (literal e servidor) do controle do servidor.</summary>
        <returns>Um objeto <see cref="T:System.Web.UI.ControlCollection" /> para conter controles de servidor filho do controle de servidor atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método em um controle de servidor personalizado, se você tiver criado um objeto de coleção que é derivado de <xref:System.Web.UI.ControlCollection> classe. Em seguida, você pode instanciar dessa classe de coleção na substituição desse método.  
  
   
  
## Examples  
 Substituições de exemplo de código a seguir a <xref:System.Web.UI.Control.CreateControlCollection%2A> método para criar uma instância de um `CustomControlCollection` classe que herde o <xref:System.Web.UI.ControlCollection> classe.  
  
 [!code-csharp[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/cs/controlcollection_7.cs#2)]
 [!code-vb[System.Web.UI.ControlCollection_CTor_Owner#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ControlCollection_CTor_Owner/VB/controlcollection_7.vb#2)]  
  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Control.CreateControlCollection%2A> substituição de método em um controle de servidor personalizado do <xref:System.Web.UI.Control.CreateChildControls%2A> método. A nova coleção é criada e populada com dois controles filho, `firstControl` e `secondControl`.  
  
 [!code-csharp[Control_Sample_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#1)]
 [!code-vb[Control_Sample_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="public virtual void DataBind ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DataBind() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Associa uma fonte de dados ao controle de servidor chamado e a todos os seus controles filho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para associar os dados de uma fonte para um controle de servidor. Normalmente, esse método é usado depois de recuperar um conjunto de dados por meio de uma consulta de banco de dados. A maioria dos controles executar associação de dados do automaticamente, que significa que você normalmente não precisa chamar este método explicitamente.  
  
 Esse método normalmente é substituído quando você cria um controle de associação de dados de modelo personalizado. Para obter mais informações, consulte [como: criar controles de usuário ASP.NET modelos](http://msdn.microsoft.com/library/07664410-02dd-4494-af53-a9259741d4f2) e [Developing Custom Data-Bound Web Server Controls](http://msdn.microsoft.com/library/88fe02a3-957f-4ff7-84f5-2d7ab78db4c1). Quando chamado em um controle de servidor, esse método resolve todas as expressões de associação de dados no controle de servidor e em qualquer um dos seus controles filhos.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.DataBind%2A> método em um controle de servidor ASP.NET personalizado. Ele começa com a chamada a base de <xref:System.Web.UI.Control.OnDataBinding%2A> método e, em seguida, usa o <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType> método para excluir todos os controles filho e o <xref:System.Web.UI.Control.ClearChildViewState%2A> método para excluir qualquer salva as configurações de estado de exibição para os controles filho. Por fim, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> está definida como `true` e o controle é instruído para controlar as alterações para o estado de exibição dos controles recém-criado com o <xref:System.Web.UI.Control.TrackViewState%2A> método. Isso é uma técnica comum quando a associação de dados a um controle para garantir que os novos dados não está em conflito com os dados armazenados do anterior <xref:System.Web.UI.Control.DataBind%2A> chamada de método.  
  
 [!code-csharp[Control_StateManagement#6](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#6)]
 [!code-vb[Control_StateManagement#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBind">
      <MemberSignature Language="C#" Value="protected virtual void DataBind (bool raiseOnDataBinding);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBind(bool raiseOnDataBinding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBind(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="raiseOnDataBinding" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="raiseOnDataBinding">
          <see langword="true" /> se o evento <see cref="E:System.Web.UI.Control.DataBinding" /> for gerado; caso contrário, <see langword="false" />.</param>
        <summary>Associa uma fonte de dados ao controle de servidor invocado e todos os seus controles filho com uma opção para gerar o evento <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método em um cenário de quando o controle personalizado substitui o <xref:System.Web.UI.Control.DataBind%2A> método e implementa o <xref:System.Web.UI.IDataItemContainer> interface. Nesse cenário, o controle personalizado chama o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método com `raiseOnDataBinding` definida como `false` para garantir que a classe base <xref:System.Web.UI.Control.DataBind%2A> método é chamado.  
  
 O <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> método invoca o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método com `raiseOnDataBinding` definido como `true`.  
  
> [!NOTE]
>  Chamando o <xref:System.Web.UI.Control.DataBind%28System.Boolean%29?displayProperty=nameWithType> método com `raiseOnDataBinding` definida como `false` faz com que qualquer filho controla como os dados associados com o <xref:System.Web.UI.Control.DataBind?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBindChildren">
      <MemberSignature Language="C#" Value="protected virtual void DataBindChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void DataBindChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.DataBindChildren" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Associa uma fonte de dados para os controles filho do controle de servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.DataBindChildren%2A> método para vincular a uma fonte de dados para os controles filho de um controle de servidor.  
  
> [!NOTE]
>  Quando chamado em um controle de servidor, esse método não associar dados ao controle. Para associar um controle de servidor e todos os seus controles filhos, chame o <xref:System.Web.UI.Control.DataBind%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataBinding">
      <MemberSignature Language="C#" Value="public event EventHandler DataBinding;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DataBinding" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.DataBinding" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é associado a uma fonte de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento notifica o controle de servidor para executar qualquer lógica de associação de dados que foi gravada para ele.  
  
   
  
## Examples  
 [!code-csharp[ITemplate_Interface#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ITemplate_Interface/CS/itemplate.cs#1)]
 [!code-vb[ITemplate_Interface#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ITemplate_Interface/VB/itemplate.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataItemContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataItemContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataItemContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataItemContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao contêiner de nomenclatura se o contêiner de nomenclatura implementa o <see cref="T:System.Web.UI.IDataItemContainer" />.</summary>
        <value>O contêiner de nomenclatura. Em uma hierarquia de contêineres de nomenclatura que implementa <see cref="T:System.Web.UI.IDataItemContainer" />, essa propriedade retorna o contêiner de nomenclatura na parte superior da hierarquia ou <see langword="null" /> se o objeto <see cref="T:System.Web.UI.Control" /> atual não for um contêiner de nomenclatura que implementa <see cref="T:System.Web.UI.IDataItemContainer" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataKeysContainer">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control DataKeysContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control DataKeysContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DataKeysContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao contêiner de nomenclatura se o contêiner de nomenclatura implementa o <see cref="T:System.Web.UI.IDataKeysControl" />.</summary>
        <value>O contêiner de nomenclatura. Em uma hierarquia de contêineres de nomenclatura que implementa <see cref="T:System.Web.UI.IDataKeysControl" />, a propriedade retorna o contêiner de nomenclatura na parte superior da hierarquia ou <see langword="null" /> se o objeto <see cref="T:System.Web.UI.Control" /> atual não for um contêiner de nomenclatura que implementa <see cref="T:System.Web.UI.IDataKeysControl" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignMode">
      <MemberSignature Language="C#" Value="protected bool DesignMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DesignMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.DesignMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um controle está sendo usado em uma superfície de design.</summary>
        <value>
          <see langword="true" /> se o controle estiver sendo usado em um designer. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.DesignMode%2A> propriedade retorna `true` para indicar que o controle está sendo usado no contexto de um designer. Os controles personalizados podem usar essa propriedade ao comportamento de tempo de design é diferente do comportamento de tempo de execução.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public virtual void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Permite que um controle de servidor execute a limpeza final antes do lançamento da memória.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar <xref:System.Web.UI.Control.Dispose%2A> quando tiver terminado de usar o <xref:System.Web.UI.Control>. O <xref:System.Web.UI.Control.Dispose%2A> método deixa o <xref:System.Web.UI.Control> em um estado inutilizável. Depois de chamar esse método, você deve liberar todas as referências para o controle para a memória estava ocupando pode ser recuperada pela coleta de lixo.  
  
   
  
## Examples  
 Substituições de exemplo de código a seguir a <xref:System.Web.UI.Control.Dispose%2A> método para fechar o <xref:System.Web.UI.HtmlTextWriter> objeto associado a um controle e chame o <xref:System.Web.UI.Control.Dispose%2A> método em um <xref:System.Web.UI.WebControls.Button> controle, chamado `myButton`. Se um <xref:System.Exception> é lançada quando esta versão do <xref:System.Web.UI.Control.Dispose%2A> método é chamado, o controle grava uma mensagem atual <xref:System.Web.HttpResponse> objeto.  
  
 [!code-csharp[Control_Dispose#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Dispose/CS/control_disposemethod.cs#1)]
 [!code-vb[Control_Dispose#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Dispose/VB/control_disposemethod.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disposed">
      <MemberSignature Language="C#" Value="public event EventHandler Disposed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Disposed" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Disposed" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um controle de servidor é liberado da memória, que é o último estágio do ciclo de vida de controle de servidor quando uma página ASP.NET é solicitada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recursos que exigem muito tempo do processador, como conexões de banco de dados, devem ser liberados com esse evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableTheming">
      <MemberSignature Language="C#" Value="public virtual bool EnableTheming { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableTheming" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableTheming" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os temas se aplicam a esse controle.</summary>
        <value>
          <see langword="true" /> para usar temas; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.EnableTheming%2A> propriedade indica se os temas estão habilitados para um controle especificado. Quando o <xref:System.Web.UI.Control.EnableTheming%2A> é de propriedade `true`, diretório de tema do aplicativo é pesquisado capas de controle aplicar. Se nenhuma capa de controle específico existe no diretório do tema, capas não são aplicadas.  
  
 Quando o <xref:System.Web.UI.Control.EnableTheming%2A> é de propriedade `false`, o diretório de tema não é pesquisado e o conteúdo do <xref:System.Web.UI.Control.SkinID%2A> propriedade não é usada.  
  
 Temas podem ser habilitados na página, o contêiner ou o nível de controle. Um controle pode substituir o <xref:System.Web.UI.Control.EnableTheming%2A> valor conjunto seu controle pai ou o conteúdo da página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O evento <see langword="Page_PreInit" /> já ocorreu.  
  
 \- ou -  
  
 O controle já foi adicionado à coleção <see langword="Controls" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public virtual bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle de servidor persiste seu estado de exibição e o estado de exibição de quaisquer controles filho que ele contém, para o cliente solicitante.</summary>
        <value>
          <see langword="true" /> se o controle de servidor mantiver seu estado de exibição; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição permite um controle de servidor manter seu estado em solicitações HTTP. Estado de exibição para um controle estará habilitado se todas as seguintes condições forem atendidas:  
  
-   O <xref:System.Web.UI.Control.EnableViewState%2A> propriedade para a página é definida como `true`.  
  
-   O <xref:System.Web.UI.Control.EnableViewState%2A> propriedade para o controle é definida como `true`.  
  
-   O <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade para o controle é definida como <xref:System.Web.UI.ViewStateMode.Enabled> ou herda o <xref:System.Web.UI.ViewStateMode.Enabled> configuração.  
  
 Para obter mais informações, consulte a propriedade <xref:System.Web.UI.Control.ViewStateMode%2A>.  
  
 Estado de exibição de um controle de servidor é o acúmulo de todos os seus valores de propriedade. Para preservar a esses valores em solicitações HTTP, o ASP.NET usa uma instância do <xref:System.Web.UI.StateBag> classe para armazenar os valores de propriedade. Os valores são passados como uma variável para um campo oculto quando solicitações subsequentes são processadas. Para obter mais informações sobre o estado de exibição, consulte [visão geral sobre o estado de exibição ASP.NET](http://msdn.microsoft.com/library/19d2a6ed-9a77-4c7c-a7f5-74dd4b6c3818).  
  
 Há ocasiões em que é apropriado para desabilitar o estado de exibição, particularmente para melhorar o desempenho do aplicativo. Por exemplo, se você estiver carregando uma solicitação de banco de dados em um controle de servidor, defina essa propriedade como `false`. Se você não fizer isso, o tempo de processador será desperdiçado carregamento do estado de exibição para o controle de servidor que só será substituído pela consulta de banco de dados. Se <xref:System.Web.UI.Control.EnableViewState%2A> é `false`, você pode usar o estado de controle para manter informações de propriedade que é específica para o controle e não podem ser desativadas como a propriedade de estado de exibição. Para obter mais informações sobre a diferença entre o estado de controle e estado de exibição, consulte [vs de estado do controle. Exemplo de estado de exibição](http://msdn.microsoft.com/library/9e98c7de-a888-48df-b14e-02ec8bef7681).  
  
 Para obter informações sobre como habilitar ou desabilitar o estado de exibição declarativamente para uma página ASP.NET, consulte.  
  
   
  
## Examples  
 O exemplo a seguir define o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade `false`.  
  
 [!code-csharp[Control_StateManagement#7](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_statemanagement.cs.aspx#7)]
 [!code-vb[Control_StateManagement#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_statemanagement.vb.aspx#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndRenderTracing">
      <MemberSignature Language="C#" Value="protected void EndRenderTracing (System.IO.TextWriter writer, object traceObject);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EndRenderTracing(class System.IO.TextWriter writer, object traceObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EndRenderTracing(System.IO.TextWriter,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
        <Parameter Name="traceObject" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto que grava dados de rastreamento.</param>
        <param name="traceObject">O objeto de rastreamento.</param>
        <summary>Termina o rastreamento de tempo de design de dados de renderização.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureChildControls">
      <MemberSignature Language="C#" Value="protected virtual void EnsureChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void EnsureChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureChildControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determinará se o controle de servidor contiver controles filho. Se ele não contiver, ele criará controles filho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método primeiro verifica o valor atual de <xref:System.Web.UI.Control.ChildControlsCreated%2A> propriedade. Se esse valor for `false`, o <xref:System.Web.UI.Control.CreateChildControls%2A> método é chamado.  
  
 O <xref:System.Web.UI.Control.EnsureChildControls%2A> método normalmente é usado em controles compostos, que são controles que usam os controles filho para algumas ou todas as suas funcionalidades. O <xref:System.Web.UI.Control.EnsureChildControls%2A> método é chamado para certificar-se de que os controles filho foram criados e estão prontos para processar a entrada, para realizar a associação de dados ou executar outras tarefas.  
  
 O <xref:System.Web.UI.WebControls.GridView> controle é um exemplo de um controle composto. Ele cria filho controles, como <xref:System.Web.UI.WebControls.Table>, <xref:System.Web.UI.WebControls.TableRow>, <xref:System.Web.UI.WebControls.TableCell>, <xref:System.Web.UI.WebControls.Label>, e <xref:System.Web.UI.WebControls.TextBox> controles, que são usados para renderizar HTML da tabela que o <xref:System.Web.UI.WebControls.GridView> gera.  
  
 Na maioria dos casos, os desenvolvedores de controle de servidor personalizado é preciso substituir este método. Se você substituir esse método, você deve usá-lo de forma semelhante ao comportamento padrão.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.EnsureChildControls%2A> método para garantir que o controle de servidor atual tem controles filho. Em seguida, obtém ou define um <xref:System.Web.UI.WebControls.TextBox.Text%2A> propriedade para uma criança <xref:System.Web.UI.WebControls.TextBox> controle no controle atual servidor do Web <xref:System.Web.UI.ControlCollection> objeto.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/csharp/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/CS/compositecontrolsample1.cs#1)]
 [!code-vb[SystemWebUIControl CreateChildControls and EnsureChildControls#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SystemWebUIControl CreateChildControls and EnsureChildControls/VB/compositecontrolsample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureID">
      <MemberSignature Language="C#" Value="protected void EnsureID ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void EnsureID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.EnsureID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um identificador para controles que não têm um identificador atribuído.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.EnsureID%2A> método gera um identificador para controles que estão contidos em um outro controle. Identificadores são gerados somente para controles que não têm um valor atribuído ao <xref:System.Web.UI.Control.ID%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Events">
      <MemberSignature Language="C#" Value="protected System.ComponentModel.EventHandlerList Events { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.EventHandlerList Events" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Events" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.EventHandlerList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de delegados de manipulador de eventos para o controle. Esta propriedade é somente para leitura.</summary>
        <value>A lista de delegados de manipulador de eventos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é do tipo <xref:System.ComponentModel.EventHandlerList>, que usa um algoritmo de pesquisa linear para localizar as entradas na lista de delegados. Um algoritmo de pesquisa linear é ineficiente ao trabalhar com um grande número de entradas. Portanto, quando você tiver uma lista grande, localizando entradas com essa propriedade será lentas.  
  
   
  
## Examples  
 O exemplo a seguir cria um evento chamado `Click`, que adiciona e remove manipuladores do controle <xref:System.ComponentModel.EventHandlerList> coleção quando o evento é chamado de uma página.  
  
 **Observação** Este exemplo otimiza como um controle adiciona e remove os eventos da lista deles que mantém o controle. Se você cria um controle personalizado e deseja definir um evento, use o código semelhante a este. Essa técnica pode ser usada em c#, mas não no Visual Basic.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O identificador do controle a ser encontrado.</param>
        <summary>Procura o atual contêiner de nomenclatura de um controle de servidor com o parâmetro <paramref name="id" /> especificado.</summary>
        <returns>O controle especificado, ou <see langword="null" />, se o controle especificado não existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Web.UI.Control.FindControl%2A> para um controle de acesso de uma função em uma página code-behind, para acessar um controle que está dentro de outro contêiner, ou em outras circunstâncias em que o controle de destino não é diretamente acessível para o chamador. Esse método encontrará um controle somente se o controle será contido diretamente pelo contêiner especificado; ou seja, o método de pesquisa em uma hierarquia de controles nos controles. Para obter informações sobre como localizar um controle quando você não souber seu contêiner imediata, consulte [como: controles de servidor de acesso por ID](http://msdn.microsoft.com/library/59964ef8-72ef-4159-9f1a-5b230ff46fb3).  
  
   
  
## Examples  
 O exemplo a seguir define um `Button1_Click` manipulador de eventos. Quando chamado, esse manipulador utiliza o <xref:System.Web.UI.Control.FindControl%2A> método para localizar um controle com um <xref:System.Web.UI.Control.ID%2A> propriedade `TextBox2` no conteúdo da página. Se o controle for encontrado, seu pai é determinado com o <xref:System.Web.UI.Control.Parent%2A> propriedade e do controle pai <xref:System.Web.UI.Control.ID%2A> é gravado para a página. Se `TextBox2` não for encontrado, "Controle não encontrado" é gravado para a página.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Control FindControl (string id, int pathOffset);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Control FindControl(string id, int32 pathOffset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.FindControl(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
        <Parameter Name="pathOffset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="id">O identificador do controle a ser encontrado.</param>
        <param name="pathOffset">O número de controles da hierarquia de controle de página necessário para alcançar um contêiner de nomenclatura.</param>
        <summary>Procura o contêiner de nomenclatura atual para um controle de servidor com o <paramref name="id" /> especificado e um inteiro especificado no parâmetro <paramref name="pathOffset" />, que auxilia na pesquisa. Você não deve substituir esta versão do método <see cref="Overload:System.Web.UI.Control.FindControl" />.</summary>
        <returns>O controle especificado, ou <see langword="null" />, se o controle especificado não existir.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public virtual void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Focus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o foco de entrada para um controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.Focus%2A> método para definir o foco inicial da página da Web para o controle. A página será aberta no navegador com o controle selecionado.  
  
 O <xref:System.Web.UI.Control.Focus%2A> método faz com que uma chamada para o script de foco de página a ser emitido na página renderizada. Se a página não contém um controle com uma marca HTML `ID` atributo que coincide com o controle que o <xref:System.Web.UI.Control.Focus%2A> método foi chamado em, em seguida, o foco de página não será definido. Um exemplo em que isso pode ocorrer é quando você definir o foco em um controle de usuário em vez de definir o foco em um controle filho do controle de usuário. Nesse cenário, você pode usar o <xref:System.Web.UI.Control.FindControl%2A> método para localizar o controle filho do controle de usuário e invocar sua <xref:System.Web.UI.Control.Focus%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IDictionary GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IDictionary GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetDesignModeState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém os dados de tempo de design para um controle.</summary>
        <returns>Um <see cref="T:System.Collections.IDictionary" /> que contém os dados de tempo de design para o controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.GetDesignModeState%2A> método retorna dados de tempo de design para um controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O <see cref="M:System.Web.UI.Control.GetDesignModeState" /> método retorna <see langword="null" /> por padrão. Você deve substituir esse método para fornecer os dados de tempo de design que requer que seu controle.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRouteUrl">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota e, opcionalmente, para um nome de rota.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. É equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. É equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método. Este método converte o objeto que é transmitido `routeParameters` para um <xref:System.Web.Routing.RouteValueDictionary> objeto usando o <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> construtor.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar o <xref:System.Web.UI.Control.GetRouteUrl%2A?displayProperty=nameWithType> método para obter a URL de uma rota que tem parâmetros que são nomeados `productid` e `category`. Este exemplo supõe que você tenha criado um <xref:System.Web.UI.WebControls.HyperLink> controle chamado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. É equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar esse método para obter a URL de uma rota que tem parâmetros que são nomeados `productid` e `category`. Este exemplo supõe que você tenha criado um <xref:System.Web.UI.WebControls.HyperLink> controle chamado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, object routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, object routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">O nome da rota.</param>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota e um nome de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota e ao nome de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. É equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método. Este método converte o objeto que é transmitido `routeParameters` para um <xref:System.Web.Routing.RouteValueDictionary> objeto usando o <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> construtor.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar esse método para obter a URL de uma rota denominada `Product` e parâmetros que são nomeados `productid` e `category`. Este exemplo supõe que você tenha criado um <xref:System.Web.UI.WebControls.HyperLink> controle chamado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRouteUrl">
      <MemberSignature Language="C#" Value="public string GetRouteUrl (string routeName, System.Web.Routing.RouteValueDictionary routeParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetRouteUrl(string routeName, class System.Web.Routing.RouteValueDictionary routeParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetRouteUrl(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeParameters" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">O nome da rota.</param>
        <param name="routeParameters">Os valores de rota.</param>
        <summary>Obtém a URL que corresponde a um conjunto de parâmetros de rota e um nome de rota.</summary>
        <returns>A URL que corresponde aos parâmetros de rota e ao nome de rota especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é fornecido para a conveniência de codificação. É equivalente a chamar o <xref:System.Web.Routing.RouteCollection.GetVirtualPath%28System.Web.Routing.RequestContext%2CSystem.String%2CSystem.Web.Routing.RouteValueDictionary%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar esse método para obter a URL de uma rota denominada `Product` e parâmetros que são nomeados `productid` e `category`. Este exemplo supõe que você tenha criado um <xref:System.Web.UI.WebControls.HyperLink> controle chamado `HyperLink1`.  
  
```vb  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
HyperLink1.NavigateUrl = HyperLink1.GetRouteUrl("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUniqueIDRelativeTo">
      <MemberSignature Language="C#" Value="public string GetUniqueIDRelativeTo (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetUniqueIDRelativeTo(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.GetUniqueIDRelativeTo(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">Um controle que está em um contêiner de nomenclatura.</param>
        <summary>Retorna a parte prefixada da propriedade <see cref="P:System.Web.UI.Control.UniqueID" /> do controle especificado.</summary>
        <returns>A parte prefixada da propriedade <see cref="P:System.Web.UI.Control.UniqueID" /> do controle especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.UniqueID%2A> propriedade de um controle é gerada, adicionando um prefixo para o controle <xref:System.Web.UI.Control.ID%2A> propriedade. O prefixo é composto de <xref:System.Web.UI.Control.UniqueID%2A> propriedade do controle de contêiner de nomeação concatenado com um caractere separador. Se o contêiner de nomenclatura é a página, não há nenhum prefixo. Esse método retorna a cadeia de caracteres de prefixo. Se não houver nenhuma cadeia de caracteres de prefixo, ele retorna o <xref:System.Web.UI.Control.UniqueID%2A> valor do controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.Control.NamingContainer" /> de <paramref name="control" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasChildViewState">
      <MemberSignature Language="C#" Value="protected bool HasChildViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChildViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.HasChildViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os controles filho do controle de servidor atual tem as configurações de exibição de estado salvas.</summary>
        <value>
          <see langword="true" />Se os controles filho salvar informações de estado de exibição; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode evitar o desnecessárias chamadas para o <xref:System.Web.UI.Control.ClearChildViewState%2A> método usando essa propriedade para verificar se os controles filho do controle de servidor estão armazenando informações de estado de exibição.  
  
   
  
## Examples  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasControls">
      <MemberSignature Language="C#" Value="public virtual bool HasControls ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasControls" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se o controle de servidor contém algum controle filho.</summary>
        <returns>
          <see langword="true" /> se o controle contiver outros controles; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Desde que este método simplesmente determina se os controles filho existirem, ele pode aumentar o desempenho, permitindo que você evite um desnecessários <xref:System.Web.UI.ControlCollection.Count%2A> chamada de propriedade. Chamadas para essa propriedade requerem um <xref:System.Web.UI.ControlCollection> objeto a ser instanciado. Se não houver nenhum filho, a criação de objeto desperdiça recursos do servidor.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.HasControls%2A> método para determinar se existem quaisquer controles antes de usar o <xref:System.Web.UI.ControlCollection.Count%2A> propriedade para iterar por meio de um <xref:System.Web.UI.ControlCollection> objeto.  
  
 [!code-csharp[Classic Control.HasControls Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.HasControls Example/CS/source.cs#1)]
 [!code-vb[Classic Control.HasControls Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.HasControls Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O <see cref="M:System.Web.UI.Control.HasControls" /> método deve ser substituído somente para alterar os atributos de metadados, como <see cref="T:System.ComponentModel.EditorBrowsableAttribute" />. Para obter mais informações sobre o uso de atributos, consulte [atributos](~/docs/standard/attributes/index.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasEvents">
      <MemberSignature Language="C#" Value="protected bool HasEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool HasEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.HasEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se os eventos são registrados para o controle ou qualquer controle filho.</summary>
        <returns>
          <see langword="true" /> se os eventos forem registrados; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public virtual string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.ParenthesizePropertyName(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o identificador programático atribuído ao controle de servidor.</summary>
        <value>O identificador programático atribuído ao controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A definição dessa propriedade em um controle de servidor fornece acesso programático aos métodos, eventos e propriedades do controle de servidor. Essa propriedade pode ser definida por desenvolvedores da Web, declarando um <xref:System.Web.UI.Control.ID%2A> atributo na marca de abertura de um controle de servidor ASP.NET.  
  
 Se essa propriedade não for especificada para um controle de servidor, declarativamente ou por meio de programação, você pode obter uma referência para o controle por meio do controle pai <xref:System.Web.UI.Control.Controls%2A> propriedade.  
  
> [!NOTE]
>  Apenas as combinações de caracteres alfanuméricos e o caractere de sublinhado (_) são valores válidos para essa propriedade. Incluindo espaços ou outros caracteres inválidos causará um erro de análise de página do ASP.NET.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs.aspx#2)]
 [!code-vb[Control_Sample#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="protected char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caractere usado para separar identificadores de controle.</summary>
        <value>O caractere separador. O padrão é “$”.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caractere dentro de <xref:System.Web.UI.Control.IdSeparator%2A> propriedade é usada para separar os identificadores de controle para controles filho. O caractere separador de ID é acrescentado ao <xref:System.Web.UI.Control.ID%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Init">
      <MemberSignature Language="C#" Value="public event EventHandler Init;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Init" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Init" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é inicializado, que é a primeira etapa do ciclo de vida.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor devem executar as etapas de inicialização que são necessárias para criar e configurar uma instância. Você não pode usar as informações de estado de exibição dentro desse evento; não é populada ainda. Você não deve acessar outro controle de servidor durante este evento, independentemente de ser um filho ou pai para este controle. Outros controles de servidor não tem certeza ser criado e está pronto para acesso. Para obter mais informações sobre eventos de controle de servidor, consulte [modelo de evento de controle do ASP.NET Web Forms Server](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
   
  
## Examples  
 O exemplo a seguir atribui um manipulador de eventos personalizados `Calendar_Init`, para o `Init` eventos de um <xref:System.Web.UI.WebControls.Calendar> controle.  
  
 [!code-aspx-csharp[Control_Sample#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples2.cs.aspx#4)]
 [!code-aspx-vb[Control_Sample#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples2.vb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsChildControlStateCleared">
      <MemberSignature Language="C#" Value="protected bool IsChildControlStateCleared { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsChildControlStateCleared" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsChildControlStateCleared" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se os controles contidos dentro deste controle têm estado de controle.</summary>
        <value>
          <see langword="true" />Se os filhos deste controle não usar o estado de controle; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLiteralContent">
      <MemberSignature Language="C#" Value="protected bool IsLiteralContent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool IsLiteralContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.IsLiteralContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determina se o controle de servidor contém apenas o conteúdo literal.</summary>
        <returns>
          <see langword="true" />Se o controle de servidor contiver somente conteúdo literal; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando este método retorna `true`, coleção do controle do servidor contém um único controle literal.  
  
   
  
## Examples  
 O exemplo a seguir verifica se a página que contém os controles de servidor foi enviada de volta. Em caso afirmativo, ele chama o <xref:System.Web.UI.Control.IsLiteralContent%2A> método para determinar se o controle contiver conteúdo literal apenas, ou é um controle pai para outros controles de servidor. Se ele contém apenas conteúdo literal, o <xref:System.Web.UI.Control.UniqueID%2A> propriedade o <xref:System.Web.UI.LiteralControl> que representa o conteúdo gravado para a resposta.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#1)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTrackingViewState">
      <MemberSignature Language="C#" Value="protected bool IsTrackingViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTrackingViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsTrackingViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o controle de servidor está salvando alterações no estado de exibição.</summary>
        <value>
          <see langword="true" /> se o controle estiver marcado para salvar seu estado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para um controle de servidor personalizado de exemplo que usa essa propriedade, consulte [modelo exemplo de controle de servidor](http://msdn.microsoft.com/library/986f63b8-6b50-42b9-a62d-a2f13cafa88b)  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.DataBind%2A> método em um controle de servidor ASP.NET personalizado. Ele começa com a chamada a base de <xref:System.Web.UI.Control.OnDataBinding%2A> método e, em seguida, usa o `ControlCollection` objeto. <xref:System.Web.UI.ControlCollection.Clear%2A?displayProperty=nameWithType>método para excluir todos os controles filho e o <xref:System.Web.UI.Control.ClearChildViewState%2A> método para excluir qualquer salva as configurações de estado de exibição para os controles filho. Por fim, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> está definida como `true`. O controle, em seguida, usa o <xref:System.Web.UI.Control.IsTrackingViewState%2A> propriedade para determinar se o estado de exibição de controle de alterações está habilitada para o controle. Se não estiver habilitado, o <xref:System.Web.UI.Control.TrackViewState%2A> método é chamado.  
  
 [!code-csharp[Control_StateManagement#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#4)]
 [!code-vb[Control_StateManagement#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsViewStateEnabled">
      <MemberSignature Language="C#" Value="protected bool IsViewStateEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsViewStateEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.IsViewStateEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o estado de exibição está habilitado para esse controle.</summary>
        <value>
          <see langword="true" /> se o estado de exibição estiver habilitado para o controle; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição pode ser habilitado na página, o contêiner ou o nível de controle. Quando o estado de exibição está desabilitado no nível de página ou contêiner, o estado de exibição está desabilitado para todos os controles contidos por página ou contêiner. O <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propriedade indica se o estado de exibição é habilitado por páginas, contêineres ou controles.  
  
 É possível que o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade e o <xref:System.Web.UI.Control.IsViewStateEnabled%2A> propriedade seja diferente. Por exemplo, se o <xref:System.Web.UI.Page> que contém o controle tem o estado de exibição desabilitado, o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade pode ser `true` enquanto o <xref:System.Web.UI.Control.IsViewStateEnabled%2A> é de propriedade `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Os desenvolvedores de páginas definirá o <see cref="P:System.Web.UI.Control.EnableViewState" /> propriedade e o <see cref="P:System.Web.UI.Control.ViewStateMode" /> propriedade para indicar se eles estão usando o estado de exibição com o controle. Use o <see cref="P:System.Web.UI.Control.IsViewStateEnabled" /> propriedade e o <see cref="P:System.Web.UI.Control.ViewStateMode" /> propriedade em seu código para determinar se o estado de exibição é habilitado para o controle e para todos os contêineres.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Load" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é carregado no objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Notifica o controle de servidor para executar as etapas de processamento que estiverem configuradas para ocorrer em cada solicitação de página. Você pode acessar informações de estado de exibição e os dados de POSTAGEM de formulário de Web desse evento. Você também pode acessar outros controles de servidor na hierarquia de controle da página.  
  
> [!NOTE]
>  Se você definir um modelo personalizado em um controle durante o `Page_Load` eventos, os valores de texto de controles filho no modelo personalizado serão perdidos. Isso ocorre porque os valores de formulário já foram carregados.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Load#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Load/CS/control_load.cs#2)]
 [!code-vb[System.Web.UI.Control_Load#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Load/VB/control_load.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadControlState">
      <MemberSignature Language="C#" Value="protected virtual void LoadControlState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadControlState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadControlState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Um <see cref="T:System.Object" /> que representa o estado de controle a ser restaurado.</param>
        <summary>Restaura informações de estado de controle de uma solicitação de página anterior que foi salva pelo método <see cref="M:System.Web.UI.Control.SaveControlState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método quando você precisa especificar como um controle de servidor personalizado restaura o estado de controle. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).  
  
   
  
## Examples  
 O código a seguir exemplo substitui o <xref:System.Web.UI.Control.LoadControlState%2A> método em um controle personalizado do ASP.NET. Quando esse método é chamado, ele determina se o estado do controle foi salva anteriormente para o controle e, nesse caso, define a propriedade interna `currentIndex` para o valor salvo.  
  
 O <xref:System.Web.UI.Control.OnInit%2A> método é substituído para chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método o <xref:System.Web.UI.Control.Page%2A> para indicar que o controle personalizado utiliza o estado do controle.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewState">
      <MemberSignature Language="C#" Value="protected virtual void LoadViewState (object savedState);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void LoadViewState(object savedState) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.LoadViewState(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="savedState" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="savedState">Um <see cref="T:System.Object" /> que representa o estado de controle a ser restaurado.</param>
        <summary>Restaura informações de estado de exibição de uma solicitação de página anterior salva pelo método <see cref="M:System.Web.UI.Control.SaveViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado basicamente pela infraestrutura do .NET Framework e não se destina a ser usado diretamente no seu código. No entanto, os desenvolvedores de controle podem substituir este método para especificar como um controle de servidor personalizado restaura o estado de exibição. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.LoadViewState%2A> método para um controle de servidor ASP.NET personalizado. Ele cria um <xref:System.Object> matriz para conter as informações de estado de exibição passadas a `savedState` parâmetro e, em seguida, chama a implementação base do <xref:System.Web.UI.Control.LoadViewState%2A> método para o primeiro local de índice da matriz. Ele atribui os valores armazenados nos dois locais índice para variáveis denominadas `UserText` e `PasswordText`, respectivamente.  
  
 [!code-csharp[Control_StateManagement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#1)]
 [!code-vb[Control_StateManagement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadViewStateByID">
      <MemberSignature Language="C#" Value="protected bool LoadViewStateByID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LoadViewStateByID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.LoadViewStateByID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o controle participa do carregamento do estado de exibição por <see cref="P:System.Web.UI.Control.ID" /> em vez do índice.</summary>
        <value>
          <see langword="true" /> se o controle carregar seu estado de exibição pelo <see cref="P:System.Web.UI.Control.ID" />; caso contrário, <see langword="false" />. O valor padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, quando um controle pai carrega o estado de exibição em controles filho que ele cria, ele faz isso por posição de cada controle filho no controle do pai <xref:System.Web.UI.Control.Controls%2A> coleção. Quando o estado de exibição é aplicado inicialmente, todos os controles filho podem não ter sido criados. Nesse caso, o estado de exibição para controles que ainda não foi criado é salvo e aplicado quando os controles filho são criados posteriormente.  
  
 Para um controle pai aplicar o estado de exibição para seus controles filhos, duas condições devem ser atendidas:  
  
-   Em um postback, o controle pai deve criar os controles filho em exatamente na mesma ordem que a solicitação anterior para que a ordem dos controles permaneça consistente.  
  
-   Depois de postback, os controles filho criados devem ser adicionados ao final do controle pai <xref:System.Web.UI.Control.Controls%2A> coleção.  
  
 Se estas duas condições não podem ser atendidas, como no caso de criação de um controle filho atrasada, o controle pai pode carregar o estado de exibição usando <xref:System.Web.UI.Control.ID%2A>. Para definir o <xref:System.Web.UI.Control.LoadViewStateByID%2A> propriedade `true`, use o <xref:System.Web.UI.ViewStateModeByIdAttribute> atributo de metadados para o controle pai.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPathSecure">
      <MemberSignature Language="C#" Value="protected string MapPathSecure (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance string MapPathSecure(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.MapPathSecure(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Relativo ou a URL relativa da raiz.</param>
        <summary>Recupera o caminho físico que é mapeado para um caminho virtual, absoluto ou relativo.</summary>
        <returns>O caminho físico para o arquivo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método só pode ser usado por controles de servidor que tem permissões para ler arquivos e que fazem parte dos arquivos. dll totalmente confiáveis, como System.Web.dll. Isso ajuda a impedir violações de segurança.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.MapPathSecure%2A> método para obter o caminho físico de um diretório virtual do que contém <xref:System.Web.UI.Page> ou <xref:System.Web.UI.UserControl> objeto.  
  
 [!code-csharp[Control_MapPathSecure#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_MapPathSecure/CS/control_templatesourcedirectory.cs#1)]
 [!code-vb[Control_MapPathSecure#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_MapPathSecure/VB/control_templatesourcedirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="virtualPath" /> é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</exception>
      </Docs>
    </Member>
    <Member MemberName="NamingContainer">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control NamingContainer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control NamingContainer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.NamingContainer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao contêiner de nomenclatura do controle do servidor, que cria um namespace exclusivo para diferenciar entre os controles de servidor com o mesmo valor da propriedade <see cref="P:System.Web.UI.Control.ID" />.</summary>
        <value>O controle de servidor do contêiner de nomenclatura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada página em um aplicativo Web ASP.NET contém uma hierarquia de controles. Essa hierarquia não é dependente de se um controle gera da interface do usuário visível para o usuário. O contêiner de nomeação para um determinado controle é o controle pai acima na hierarquia que implementa o <xref:System.Web.UI.INamingContainer> interface. Um controle de servidor que implementa essa interface cria um namespace exclusivo para o <xref:System.Web.UI.Control.ID%2A> valores de propriedade de controles de servidor seu filho. Você pode usar o <xref:System.Web.UI.Control.NamingContainer%2A> propriedade de controle de filho de um contêiner de nomenclatura para obter uma referência ao seu contêiner pai.  
  
 Criar um namespace exclusivo para controles de servidor é particularmente importante quando você associa os controles de servidor Web para dados, como o <xref:System.Web.UI.WebControls.Repeater> e <xref:System.Web.UI.WebControls.DataList> controles de servidor. Quando várias entradas na fonte de dados criam várias instâncias de um controle de servidor que é um filho do controle de repetição, o contêiner de nomeação garante que cada instância desses controles filho <xref:System.Web.UI.Control.UniqueID%2A> valores de propriedade que não estão em conflito. O contêiner de nomeação padrão para uma página é a instância do <xref:System.Web.UI.Page> classe que é gerado quando a página é solicitada.  
  
 O <xref:System.Web.UI.Control.ClientID%2A> propriedade contém o valor que é processado como o elemento `id` atributo na marcação HTML. Dependendo do valor que você atribui ao <xref:System.Web.UI.Control.ClientIDMode%2A> propriedade, o valor que é gerado para o <xref:System.Web.UI.Control.ClientID%2A> propriedade pode incluir a ID do <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Quando você define <xref:System.Web.UI.Control.ClientIDMode%2A> para <xref:System.Web.UI.ClientIDMode.Static>, o <xref:System.Web.UI.Control.ClientID%2A> valor não inclui a ID do <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Quando você define <xref:System.Web.UI.Control.ClientIDMode%2A> como <xref:System.Web.UI.ClientIDMode.AutoID> ou <xref:System.Web.UI.ClientIDMode.Predictable>, o <xref:System.Web.UI.Control.ClientID%2A> valor incluirá a ID do <xref:System.Web.UI.Control.NamingContainer%2A> objeto. Para obter mais informações, consulte [ASP.NET Web Server Control Identification](http://msdn.microsoft.com/library/45a8c3ef-5ac7-48f1-862a-0cd5073742e7) (Identificação de controles do servidor Web do ASP.NET).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Web.UI.Control.NamingContainer%2A> propriedade.  
  
 [!code-aspx-csharp[Control_NamingContainer#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_NamingContainer/CS/control_namingcontainer.cs.aspx#1)]
 [!code-aspx-vb[Control_NamingContainer#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_NamingContainer/VB/control_namingcontainer.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBubbleEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnBubbleEvent(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">A fonte do evento.</param>
        <param name="args">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Determina se o evento do controle de servidor é passado um nível acima da hierarquia de controle de servidor da interface do usuário da página.</summary>
        <returns>
          <see langword="true" />Se o evento foi cancelado; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor ASP.NET, como o <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> e <xref:System.Web.UI.WebControls.GridView> da Web podem conter controles filho que geram eventos. Por exemplo, cada linha em um <xref:System.Web.UI.WebControls.GridView> controle pode conter um ou mais botões criados dinamicamente por modelos. Em vez de cada botão disparar um evento individualmente, eventos dos controles aninhados são "transferidos" — ou seja, eles são enviados para o contêiner de nomenclatura. O contêiner de nomenclatura por sua vez gera um evento genérico chamado <xref:System.Web.UI.WebControls.GridView.RowCommand> com valores de parâmetro. Esses valores permitem que você determine qual controle individual que disparou o evento original. Respondendo a este evento único, você pode evitar a necessidade de escrever os métodos de manipulação de eventos individuais para controles filho.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.OnBubbleEvent%2A> método em um controle personalizado de servidor ASP.NET, `ParentControl`. Esse método é chamado quando um controle filho `ParentControl` chama o <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método. Quando isso acontece, o `ParentControl` classe grava duas cadeias de caracteres que contém a página ASP.NET, a primeira informando que seu <xref:System.Web.UI.Control.OnBubbleEvent%2A> método foi chamado, a segunda que identifica o controle de origem do <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#1)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDataBinding">
      <MemberSignature Language="C#" Value="protected virtual void OnDataBinding (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDataBinding(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnDataBinding(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.DataBinding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método notifica um controle de servidor para executar qualquer lógica de associação de dados que está associados ele.  
  
 Se você desejar tratar o <xref:System.Web.UI.Control.DataBinding> evento, você deve substituir esse método de manipulação de eventos. Isso garante que todos os delegados anexado para o <xref:System.Web.UI.Control.DataBinding> evento são invocados.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como substituir o <xref:System.Web.UI.Control.OnDataBinding%2A> método para adicionar controles filho para o controle pai de uma fonte de dados.  
  
 [!code-csharp[TemplatedDataBoundControl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/TemplatedDataBoundControl/CS/templatedataboundcontrol.cs#3)]
 [!code-vb[TemplatedDataBoundControl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/TemplatedDataBoundControl/VB/templatedataboundcontrol.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Init" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.Init> evento. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnInit%2A> método para notificar os assinantes do evento.  
  
   
  
## Examples  
 [!code-csharp[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/CS/control1.cs#3)]
 [!code-vb[System.Web.UI.Control_Context_OnInit_ResolveUrl#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_Context_OnInit_ResolveUrl/VB/control1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Load" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.Load> evento. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnLoad%2A> método para notificar os assinantes do evento.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#3)]
 [!code-vb[Control_OnUnload#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.PreRender" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.PreRender> evento. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnPreRender%2A> método para notificar os assinantes do evento.  
  
   
  
## Examples  
 [!code-csharp[Control_Sample_1_snipper#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1_snipper/CS/control_sample_1.cs#1)]
 [!code-vb[Control_Sample_1_snipper#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1_snipper/VB/control_sample_1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Unload" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET chama esse método para gerar o <xref:System.Web.UI.Control.Unload> evento. Se você estiver desenvolvendo um controle personalizado, você pode substituir esse método para fornecer processamento adicional. Se você substituir esse método, chame o controle base <xref:System.Web.UI.Control.OnUnload%2A> método para notificar os assinantes do evento.  
  
   
  
## Examples  
 [!code-csharp[Control_OnUnload#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_OnUnload/CS/control_onunload.cs#2)]
 [!code-vb[Control_OnUnload#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_OnUnload/VB/control_onunload.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenFile">
      <MemberSignature Language="C#" Value="protected System.IO.Stream OpenFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.IO.Stream OpenFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.OpenFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O caminho para o arquivo desejado.</param>
        <summary>Obtém um <see cref="T:System.IO.Stream" /> usado para ler um arquivo.</summary>
        <returns>Um <see cref="T:System.IO.Stream" /> que referencia o arquivo desejado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.OpenFile%2A> método retorna um <xref:System.IO.Stream> que pode ser usado para ler o conteúdo do arquivo especificado no objeto de `path` parâmetro. O parâmetro de caminho pode ser qualquer relativa ou URL raiz sem um protocolo (como "~ / mySite/myFile.txt), ou um caminho físico, local ("c:\mySite\myFile.txt") ou UNC ("\\\myServer\myFile.txt ").  
  
 O <xref:System.Web.UI.Control.OpenFile%2A> método usa segurança de acesso ao arquivo para controlar o acesso ao arquivo especificado. Se o usuário atual do ASP.NET não tem acesso ao arquivo, em seguida, o arquivo não está aberto e um <xref:System.Web.HttpException> exceção é gerada para indicar que o acesso foi negado. Se o `path` parâmetro especificado um caminho relativo, a exceção não inclui informações sobre o caminho físico para o arquivo solicitado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Acesso negado ao arquivo especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Page Page { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência para a instância <see cref="T:System.Web.UI.Page" /> que contém o controle de servidor.</summary>
        <value>A instância <see cref="T:System.Web.UI.Page" /> que contém o controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Valor desta propriedade reflete o nome do arquivo. aspx que contém o controle de servidor.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método. Ele usa o <xref:System.Web.UI.Page> propriedade para acessar o <xref:System.Web.UI.Page.IsPostBack%2A?displayProperty=nameWithType> propriedade e determinar se a página que contém este controle apenas foi carregada pela primeira vez ou se o resultado de um postback.  
  
 [!code-csharp[Control_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample/CS/controlclass_samples.cs#1)]
 [!code-vb[Control_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample/VB/controlclass_samples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle é um controle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.Control Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Parent" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma referência ao controle pai do controle de servidor na hierarquia de controle da página.</summary>
        <value>Uma referência ao controle pai do controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sempre que uma página é solicitada, uma hierarquia de controles de servidor em que a página é criada. Essa propriedade permite que você determine o controle pai do controle do servidor atual na hierarquia e programa em relação a ela.  
  
   
  
## Examples  
 O exemplo a seguir define um novo <xref:System.Web.UI.Control> objeto em uma página, `myControl1`, para o controle especificado em um <xref:System.Web.UI.Control.FindControl%2A> chamada de método. Se a chamada retorna um controle, o código usa o <xref:System.Web.UI.Control.Parent%2A> propriedade para identificar o controle que contém `myControl1`. Se o controle pai existir, a cadeia de caracteres "o pai da caixa de texto é" é concatenado com o <xref:System.Web.UI.Control.ID%2A> propriedade do controle pai e gravados para o <xref:System.Web.UI.Control.Page%2A>. Se nenhum controle pai for encontrado, a cadeia de caracteres "controle não encontrado" será gravado.  
  
 [!code-csharp[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/CS/control_parent.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Parent_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Parent_FindControl/VB/control_parent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRender">
      <MemberSignature Language="C#" Value="public event EventHandler PreRender;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRender" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.PreRender" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que o objeto <see cref="T:System.Web.UI.Control" /> é carregado, mas antes da renderização.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este evento para executar todas as atualizações antes do controle de servidor é renderizado para a página. As alterações no estado de exibição do controle de servidor podem ser salvo durante esse evento. Essas alterações feitas na fase de renderização não serão salvas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseBubbleEvent">
      <MemberSignature Language="C#" Value="protected void RaiseBubbleEvent (object source, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RaiseBubbleEvent(object source, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RaiseBubbleEvent(System.Object,System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="source">A fonte do evento.</param>
        <param name="args">Um objeto <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Atribui quaisquer fontes de evento e suas informações para o pai do controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor ASP.NET, como o <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList> e <xref:System.Web.UI.WebControls.GridView> da Web podem conter controles filho que geram eventos. Por exemplo, cada linha em um <xref:System.Web.UI.WebControls.GridView> controle pode conter um ou mais botões criados dinamicamente por modelos. Em vez de cada botão disparar um evento individualmente, eventos dos controles aninhados são "transferidos" — ou seja, elas são enviadas para o pai do controle. O pai por sua vez gera um evento genérico chamado <xref:System.Web.UI.WebControls.GridView.RowCommand> com valores de parâmetro. Esses valores permitem que você determine qual controle individual que disparou o evento original. Respondendo a este evento único, você pode evitar a necessidade de escrever os métodos de manipulação de eventos individuais para controles filho.  
  
 Enquanto você não pode substituir esse método, controles que você criar podem tratar ou levantar eventos borbulhados, substituindo o <xref:System.Web.UI.Control.OnBubbleEvent%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstram como criar uma classe personalizada, `ChildControl`, substituindo o <xref:System.Web.UI.WebControls.Button.OnClick%2A?displayProperty=nameWithType> método para chamar o <xref:System.Web.UI.Control.RaiseBubbleEvent%2A> método envia o <xref:System.Web.UI.WebControls.Button.Click?displayProperty=nameWithType> evento com o pai do controle de servidor ASP.NET. Quando o usuário clica no botão em uma página ASP.NET que inclui uma instância de `ChildControl`, ele gera o <xref:System.Web.UI.Control.OnBubbleEvent%2A> método no controle pai que contém a instância de `ChildControl` e grava a cadeia de caracteres "ChildControl classe OnClick método é chamado"para a página.  
  
 [!code-csharp[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/CS/bubble.cs#2)]
 [!code-vb[System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control.RaiseBubbleEvent_OnBubbleEvent/VB/bubble.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemovedControl">
      <MemberSignature Language="C#" Value="protected virtual void RemovedControl (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RemovedControl(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RemovedControl(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O <see cref="T:System.Web.UI.Control" /> que foi removido.</param>
        <summary>Chamado após a remoção de um controle filho de <see cref="P:System.Web.UI.Control.Controls" /> coleção do <see cref="T:System.Web.UI.Control" /> objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.RemovedControl%2A> método é chamado imediatamente após a remoção de um controle de <xref:System.Web.UI.Control.Controls%2A> coleção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle é um controle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo do controle do servidor.</param>
        <summary>Envia o conteúdo do controle de servidor para um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido, que grava o conteúdo a ser renderizado no cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durante o desenvolvimento de controles personalizados de servidor, você pode substituir esse método para gerar o conteúdo de uma página ASP.NET.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra substituindo o <xref:System.Web.UI.Control.Render%2A> método. O <xref:System.Web.UI.Control.HasControls%2A> método é usado para determinar se o controle de servidor tem os controles filho armazenados no seu <xref:System.Web.UI.ControlCollection> objeto, que pode ser acessado por meio de <xref:System.Web.UI.Control.Controls%2A?displayProperty=nameWithType> propriedade. Se <xref:System.Web.UI.Control.HasControls%2A> retorna true e o primeiro controle de servidor na coleção é texto literal, em seguida, o texto literal é anexado a uma cadeia de caracteres HTML.  
  
 [!code-csharp[Classic Control.Render Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic Control.Render Example/CS/source.cs#1)]
 [!code-vb[Classic Control.Render Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic Control.Render Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo renderizado.</param>
        <summary>Gera o conteúdo de filhos de um controle de servidor a um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido, que grava o conteúdo a ser renderizado no cliente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método notifica o ASP.NET para processar qualquer código de Active Server Pages (ASP) na página. Se nenhum código ASP existir na página, este método renderiza qualquer filho controles para o controle de servidor. Este método é chamado pelo <xref:System.Web.UI.Control.Render%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.RenderChildren%2A> método em um controle de servidor personalizado. Determina se o controle atual possui os controles filho em sua <xref:System.Web.UI.ControlCollection> objeto. Em caso afirmativo, ele usa o <xref:System.Web.UI.ControlCollection.Count%2A> propriedade para iterar pela coleção. Como encontrar cada controle filho, ele usa o <xref:System.Web.UI.Control.RenderControl%2A> método para renderizar o pai de controle e todos os seus controles filhos, a página.  
  
 Substituído <xref:System.Web.UI.Control.Render%2A> método chama substituído <xref:System.Web.UI.Control.RenderChildren%2A> método.  
  
 [!code-csharp[Control_Sample_1#4](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#4)]
 [!code-vb[Control_Sample_1#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="public virtual void RenderControl (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RenderControl(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo do controle.</param>
        <summary>Gera o conteúdo do controle de servidor para um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido e armazena informações de rastreamento sobre o controle caso o rastreamento esteja habilitado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um controle de servidor <xref:System.Web.UI.Control.Visible%2A> está definida como `true`, este método determina se o rastreamento está habilitado para a página. Nesse caso, ele armazena informações de rastreamento associadas ao controle e renderiza o conteúdo do controle de servidor para a página.  
  
 Esse método é chamado automaticamente pela página durante o processamento, mas pode ser substituído por desenvolvedores de controle personalizado.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.RenderChildren%2A> método em um controle de servidor personalizado. Determina se o controle atual possui os controles filho em sua <xref:System.Web.UI.ControlCollection> objeto. Em caso afirmativo, ele usa o <xref:System.Web.UI.ControlCollection.Count%2A> propriedade para iterar pela coleção. Como encontrar cada controle filho, ele usa o <xref:System.Web.UI.Control.RenderControl%2A> método para renderizar o filho de controle e todos os seus controles filhos, a página. O <xref:System.Web.UI.XhtmlTextWriter> objeto que é passado para este método é instanciado pelo <xref:System.Web.UI.Page.Render%2A> método.  
  
 [!code-csharp[Control_Sample_1#3](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_Sample_1/CS/control_sample.cs#3)]
 [!code-vb[Control_Sample_1#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_Sample_1/VB/control_sample.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RenderControl">
      <MemberSignature Language="C#" Value="protected void RenderControl (System.Web.UI.HtmlTextWriter writer, System.Web.UI.Adapters.ControlAdapter adapter);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RenderControl(class System.Web.UI.HtmlTextWriter writer, class System.Web.UI.Adapters.ControlAdapter adapter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
        <Parameter Name="adapter" Type="System.Web.UI.Adapters.ControlAdapter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo do controle.</param>
        <param name="adapter">O <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> que define a renderização.</param>
        <summary>Gera o conteúdo do controle de servidor a um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> fornecido usando um objeto <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas da Web ASP.NET são úteis em uma ampla variedade de dispositivos e navegadores que podem solicitar informações da Web. O <xref:System.Web.UI.Control.Adapter%2A> propriedade retorna o <xref:System.Web.UI.Adapters.ControlAdapter> objeto que renderiza o controle na tela do navegador ou do dispositivo solicitante.  
  
 Para obter mais informações sobre os adaptadores, consulte [arquitetura visão geral do controle comportamento adaptável](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff).  
  
 Se um controle de servidor <xref:System.Web.UI.Control.Visible%2A> está definida como `true` rastreamento está habilitado para a página e informações de rastreamento associadas ao controle são capturadas.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir o <see cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" /> método em controles personalizados, chame o método de classe base para garantir que as informações de rastreamento são capturadas corretamente.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RenderingCompatibility">
      <MemberSignature Language="C#" Value="public virtual Version RenderingCompatibility { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Version RenderingCompatibility" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.RenderingCompatibility" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que especifica a versão do ASP.NET com a qual o HTML renderizado será compatível.</summary>
        <value>A versão do ASP.NET com a qual um HTML renderizado será compatível.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET define essa propriedade como o valor da `controlRenderingCompatibilityVersion` atributo do `pages` elemento no arquivo Web. config. Se o `controlRenderingCompatibilityVersion` atributo não está definido no arquivo Web. config, o valor padrão é a versão atual do ASP.NET.  
  
> [!CAUTION]
>  Há um acessador set público para essa propriedade, mas o acessador set dá suporte à infraestrutura .NET Framework e não se destina a ser usado diretamente no seu código. Se você definir esse valor em seu código, o efeito é imprevisível.  
  
 Cada versão do ASP.NET pode renderizar HTML de forma diferente de versões anteriores. Por exemplo, no ASP.NET 3.5, se o <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> propriedade de um <xref:System.Web.UI.WebControls.Label> controle é `false`, por padrão, o ASP.NET processa uma `span` elemento cujo `disabled` atributo é definido como "desativado". No ASP.NET 4, por padrão, o `span` elemento é processado com uma folha de estilo em cascata (CSS) `class` de atributo, em vez do `disabled` atributo. Isso permite que você especifique a aparência desativada do controle e evita a renderização HTML inválido. (Em HTML 4.0 e XHTML 1.1, o `span` elemento não oferece suporte a `disabled` atributo.)  
  
 Um aplicativo Web pode incluir o código que seria não funcionará corretamente se altera de renderização HTML. Para evitar esse problema, você pode definir o `controlRenderingCompatibilityVersion` atributo o `pages` elemento no arquivo Web. config para indicar qual versão anterior que você deseja manter a compatibilidade com. Por exemplo, se você definir o <xref:System.Web.UI.Control.RenderingCompatibility%2A> propriedade `3.5`, um desabilitado <xref:System.Web.UI.WebControls.Label> controle processe um `disabled` atributo e não uma classe CSS.  
  
> [!NOTE]
>  É a versão mais antiga que você pode definir essa propriedade para `3.5`.  
  
 Para manter a compatibilidade com versões anteriores, quando você usa o Visual Studio para atualizar um projeto da Web para ASP.NET 4 de uma versão anterior, o Visual Studio define automaticamente o `controlRenderingCompatibilityVersion` atributos no arquivo Web. config para `3.5`. Se você quiser um site atualizado para renderizar HTML usando o algoritmo que foi introduzido no ASP.NET 4, você pode alterar ou remover o `controlRenderingCompatibilityVersion` atributo.  
  
 Na maioria das vezes, o comportamento controlado por essa propriedade é automático e não é necessário verificar o <xref:System.Web.UI.Control.RenderingCompatibility%2A> propriedade em seu código. No entanto, se você estiver programando um controle personalizado, você precisa incluir o código que altera o comportamento do controle com base na configuração desta propriedade. Por exemplo, um controle personalizado para ASP.NET 4 pode ser composto de <xref:System.Web.UI.WebControls.Label> e o controle personalizado podem especificar a aparência desativada do controle por meio da geração de código JavaScript que altera o `aspNetDisabled` classe. Isso funcionará como esperado se <xref:System.Web.UI.Control.RenderingCompatibility%2A> é `4.0` ou posterior. Mas, para obter o mesmo efeito quando <xref:System.Web.UI.Control.RenderingCompatibility%2A> é `3.5`, código do controle personalizado deve definir o controle `CssClass` propriedade como "aspNetDisabled" quando o <xref:System.Web.UI.WebControls.WebControl.IsEnabled%2A> é de propriedade `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveAdapter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.Adapters.ControlAdapter ResolveAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Web.UI.Adapters.ControlAdapter ResolveAdapter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveAdapter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.ControlAdapter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o adaptador de controle responsável por processar o controle especificado.</summary>
        <returns>Um <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> que processará o controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Páginas da Web ASP.NET são visíveis em uma grande variedade de dispositivos que são capazes de solicitando páginas da Web. O <xref:System.Web.UI.Control.ResolveAdapter%2A> método retorna o adaptador de controle responsável para renderizar o controle no navegador específico ou dispositivo que solicitou a página ASP.NET.  
  
 O tipo de adaptador específico retornado depende do tipo de descendente do <xref:System.Web.UI.Control> classe que está sendo processado.  
  
 Para obter mais informações sobre os adaptadores, consulte [arquitetura visão geral do controle comportamento adaptável](http://msdn.microsoft.com/library/4ff05ae9-4109-4352-929e-ad893895dbff).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveClientUrl">
      <MemberSignature Language="C#" Value="public string ResolveClientUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ResolveClientUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveClientUrl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">Uma URL relativa à da atual.</param>
        <summary>Obtém uma URL que pode ser usada pelo navegador.</summary>
        <returns>Uma URL totalmente qualificada para o recurso especificado adequada para uso no navegador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.ResolveClientUrl%2A> método para retornar uma cadeia de caracteres de URL adequada para uso pelo cliente para acessar recursos no servidor Web, como arquivos de imagem, links para páginas adicionais e assim por diante.  
  
> [!NOTE]
>  A URL retornada por este método é relativo à pasta que contém o arquivo de origem no qual o controle é instanciado. Controles que herdam essa propriedade, como <xref:System.Web.UI.UserControl> e <xref:System.Web.UI.MasterPage>, retornará uma URL totalmente qualificada relativos ao controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="relativeUrl" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveUrl">
      <MemberSignature Language="C#" Value="public string ResolveUrl (string relativeUrl);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ResolveUrl(string relativeUrl) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.ResolveUrl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="relativeUrl" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="relativeUrl">A URL associada à propriedade <see cref="P:System.Web.UI.Control.TemplateSourceDirectory" />.</param>
        <summary>Converte uma URL em uma que possa ser usada no cliente solicitante.</summary>
        <returns>A URL convertida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `relativeUrl` parâmetro contém uma URL absoluta, a URL é retornada inalterada. Se o `relativeUrl` parâmetro contém uma URL relativa, que a URL é alterada para uma URL relativa que está correta para o caminho da solicitação atual, para que o navegador pode resolver a URL.  
  
 Por exemplo, considere o seguinte cenário:  
  
-   Um cliente solicitou uma página ASP.NET que contém um controle de usuário que tem uma imagem associada a ele.  
  
-   A página ASP.NET está localizada em /Store/page1.aspx.  
  
-   O controle de usuário está localizado em /Store/UserControls/UC1.ascx.  
  
-   O arquivo de imagem está localizado em /UserControls/Images/Image1.jpg.  
  
 Se o controle de usuário passa o caminho relativo para a imagem (ou seja, /Store/UserControls/Images/Image1.jpg) para o <xref:System.Web.UI.Control.ResolveUrl%2A> método, o método retornará o valor /imagens/Imagem1.jpg.  
  
 Esse método usa o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade resolver para a URL absoluta. A URL retornada é para uso do cliente.  
  
 Para obter mais informações sobre caminhos de recurso em um site da Web, consulte [caminhos de projetos Web ASP.NET](http://msdn.microsoft.com/library/2447f50c-b849-483c-8093-85ed53e7a5bd).  
  
> [!NOTE]
>  Para páginas da Web móveis somente se seu aplicativo depende de sessões sem cookies ou pode receber solicitações de navegadores móveis que requerem sessões sem cookies, usar um til ("~") em um caminho pode resultar em inadvertidamente criando uma nova sessão e a potencial perda de dados da sessão. Para definir uma propriedade com um caminho, como "~ /*caminho"*, resolver o caminho chamando o <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> com um argumento, como "~ /*caminho"* antes de atribuí-la à propriedade.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Web.UI.WebControls.Image> Web objeto de controle de servidor e usa o <xref:System.Web.UI.Control.ResolveUrl%2A> método para definir o caminho para a imagem, que é armazenada pelo <xref:System.Web.UI.WebControls.Image.ImageUrl%2A> propriedade.  
  
 [!code-csharp[Control_ResolveUrl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_ResolveUrl/CS/control_resolveurl.cs#1)]
 [!code-vb[Control_ResolveUrl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_ResolveUrl/VB/control_resolveurl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Ocorrerá se o parâmetro <paramref name="relativeUrl" /> contiver <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveControlState">
      <MemberSignature Language="C#" Value="protected virtual object SaveControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveControlState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva as alterações de estado do controle de servidor que ocorreram desde a hora em que ocorreu o postback da página no servidor.</summary>
        <returns>Retorna o servidor de estado atual do controle. Se não houver nenhum estado associado ao controle, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Control.SaveControlState%2A> método para salvar informações de estado necessárias para a operação de um controle específico. Esses dados de estado de controle são armazenados separadamente dos dados de estado de exibição do controle.  
  
 Controles personalizados usando o estado do controle devem chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método o <xref:System.Web.UI.Control.Page%2A> antes de salvar o estado do controle.  
  
   
  
## Examples  
 O código a seguir exemplo substitui o <xref:System.Web.UI.Control.SaveControlState%2A> método em um controle personalizado do ASP.NET. Quando esse método é chamado, ele determina se a propriedade interna `currentIndex` é definido como um valor não padrão e, nesse caso, salva o valor para o estado de controle.  
  
 O <xref:System.Web.UI.Control.OnInit%2A> método é substituído para chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método o <xref:System.Web.UI.Control.Page%2A> para indicar que o controle personalizado utiliza o estado do controle.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Quando o estado do controle é salvo, um objeto de cadeia de caracteres é retornado ao cliente como uma variável que é armazenada em um HTML <see langword="HIDDEN" /> elemento. Substitua este método para extrair as informações de estado para usar no seu controle.  
  
 Estado de controle se destina a pequenas quantidades de dados críticos, como um índice de página ou uma palavra-chave. Usando o estado de controle para grandes quantidades de dados pode afetar adversamente o desempenho da página. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SaveViewState">
      <MemberSignature Language="C#" Value="protected virtual object SaveViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object SaveViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SaveViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Salva alterações de estado de exibição do controle de servidor que ocorreram desde a hora em que ocorreu o postback da página no servidor.</summary>
        <returns>Retorna o estado de exibição atual do controle de servidor. Se não houver um estado de exibição associado ao controle, esse método retornará <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição é o acúmulo dos valores de propriedades de um controle de servidor. Esses valores são colocados automaticamente no controle do servidor <xref:System.Web.UI.Control.ViewState%2A> propriedade, que é uma ocorrência da <xref:System.Web.UI.StateBag> classe. Valor desta propriedade é mantido, em seguida, para um objeto de cadeia de caracteres depois de salvar o estágio do ciclo de vida de controle do servidor de estado. Para obter mais informações, consulte [visão geral do ciclo de vida de página ASP.NET](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 Quando o estado de exibição for salvo, esse objeto de cadeia de caracteres é retornado ao cliente como uma variável que é armazenada em um HTML `HIDDEN` elemento. Quando você cria um controle de servidor personalizado com um estado de exibição personalizado, o estado de exibição pode ser gerenciado explicitamente com o <xref:System.Web.UI.Control.SaveViewState%2A> e <xref:System.Web.UI.Control.LoadViewState%2A> métodos. Para obter mais informações, consulte [visão geral do gerenciamento de estado ASP.NET](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce). Para obter informações sobre como implementar um provedor de estado de sessão personalizado, consulte [implementando um provedor de armazenamento de estado de sessão](http://msdn.microsoft.com/library/baadfec5-c881-468a-9681-7d8796b05a66).  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.SaveViewState%2A> método em um controle de servidor ASP.NET personalizado. Quando esse método é chamado, ele determina se o controle tem os controles filho e se o contendo <xref:System.Web.UI.Page> objeto é o resultado de um postback. Se ambos forem true, ele altera o <xref:System.Web.UI.WebControls.Label.Text%2A> propriedade de um <xref:System.Web.UI.WebControls.Label> controle de servidor para ler Web `Custom Control Has Saved State`. Ele salva o estado de exibição do controle como uma matriz de objetos, denominado `allStates`.  
  
 [!code-csharp[Control_StateManagement#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#2)]
 [!code-vb[Control_StateManagement#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetDesignModeState">
      <MemberSignature Language="C#" Value="protected virtual void SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetDesignModeState(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">Um <see cref="T:System.Collections.IDictionary" /> que contém os dados de tempo de design para o controle.</param>
        <summary>Define os dados de tempo de design para um controle.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.SetDesignModeState%2A> método salva dados de tempo de design para um controle.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Você deve substituir este método para salvar os dados de tempo de design que requer que seu controle.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SetRenderMethodDelegate">
      <MemberSignature Language="C#" Value="public void SetRenderMethodDelegate (System.Web.UI.RenderMethod renderMethod);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRenderMethodDelegate(class System.Web.UI.RenderMethod renderMethod) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetRenderMethodDelegate(System.Web.UI.RenderMethod)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="renderMethod" Type="System.Web.UI.RenderMethod" />
      </Parameters>
      <Docs>
        <param name="renderMethod">As informações necessárias para passar para o delegado para que ele possa renderizar o controle de servidor.</param>
        <summary>Atribui um delegado do manipulador de eventos para renderizar o controle de servidor e seu conteúdo em seu controle pai.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é fornecido para fins de implementação. Você deve nunca chamá-lo diretamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="traceDataKey">A chave de dados de rastreamento.</param>
        <param name="traceDataValue">O valor de dados de rastreamento.</param>
        <summary>Conjuntos de dados de rastreamento de dados de renderização, usando a chave de dados de rastreamento e o valor de dados de rastreamento de tempo de design de rastreamento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTraceData">
      <MemberSignature Language="C#" Value="public void SetTraceData (object tracedObject, object traceDataKey, object traceDataValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetTraceData(object tracedObject, object traceDataKey, object traceDataValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.SetTraceData(System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tracedObject" Type="System.Object" />
        <Parameter Name="traceDataKey" Type="System.Object" />
        <Parameter Name="traceDataValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="tracedObject">O objeto de rastreamento.</param>
        <param name="traceDataKey">A chave de dados de rastreamento.</param>
        <param name="traceDataValue">O valor de dados de rastreamento.</param>
        <summary>Conjuntos de dados de rastreamento de dados de renderização, usando o objeto de rastreamento, a chave de dados de rastreamento e o valor de dados de rastreamento de tempo de design de rastreamento.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Site">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISite Site { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISite Site" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Site" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISite</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém informações sobre o contêiner que hospeda o controle atual quando renderizados em uma superfície de design.</summary>
        <value>Um <see cref="T:System.ComponentModel.ISite" /> que contém informações sobre o contêiner em que o controle é hospedado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Associa um site de um <xref:System.ComponentModel.Component> o objeto para um <xref:System.ComponentModel.Container> do objeto e permite a comunicação entre os dois. Ele também fornece uma maneira para o contêiner gerenciar seus componentes.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O controle é um controle <see cref="T:System.Web.UI.WebControls.Substitution" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkinID">
      <MemberSignature Language="C#" Value="public virtual string SkinID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SkinID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.SkinID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a capa a ser aplicada ao controle.</summary>
        <value>O nome da capa para aplicar ao controle. O padrão é <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Capas disponíveis para um controle estão contidas em um ou mais arquivos de capa em um diretório do tema. O <xref:System.Web.UI.Control.SkinID%2A> propriedade especifica qual essas capas para aplicar ao controle. Uma capa é específica para um determinado controle; Você não pode compartilhar configurações de aparência entre os controles de tipos diferentes.  
  
 Se você não definir o <xref:System.Web.UI.Control.SkinID%2A> propriedade, um controle usa a capa padrão se um for definido. Por exemplo, se uma capa sem uma ID é definida para um <xref:System.Web.UI.WebControls.Image> de controle, em seguida, aquela aparência se aplica a todos os <xref:System.Web.UI.WebControls.Image> controles que fazem referência explicitamente uma capa por ID e que não estão definidas para desativar temas. Se uma capa com uma ID é definida para um <xref:System.Web.UI.WebControls.Image> controlar, e que aparência se aplica somente ao <xref:System.Web.UI.WebControls.Image> controla cujo <xref:System.Web.UI.Control.SkinID%2A> propriedade é definida para essa ID.  
  
 Se os arquivos de capa em um diretório de tema não contêm uma capa com especificado <xref:System.Web.UI.Control.SkinID%2A> propriedade, um <xref:System.ArgumentException> exceção em tempo de execução.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A folha de estilos já foi aplicada.  
  
 \- ou -  
  
 O evento <see langword="Page_PreInit" /> já ocorreu.  
  
 \- ou -  
  
 O controle já foi adicionado à coleção <see langword="Controls" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlBuilderAccessor.ControlBuilder">
      <MemberSignature Language="C#" Value="System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ControlBuilder System.Web.UI.IControlBuilderAccessor.ControlBuilder" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlBuilderAccessor#ControlBuilder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ControlBuilder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IControlBuilderAccessor.ControlBuilder" />.</summary>
        <value>O <see cref="T:System.Web.UI.ControlBuilder" /> que tiver criado o controle; caso contrário, <see langword="null" /> se nenhum construtor foi usado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlBuilderAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.GetDesignModeState">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary IControlDesignerAccessor.GetDesignModeState ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.GetDesignModeState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#GetDesignModeState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IControlDesignerAccessor.GetDesignModeState" />.</summary>
        <returns>Um <see cref="T:System.Collections.IDictionary" /> do estado do controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetDesignModeState">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetDesignModeState (System.Collections.IDictionary data);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetDesignModeState(class System.Collections.IDictionary data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetDesignModeState(System.Collections.IDictionary)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Collections.IDictionary" />
      </Parameters>
      <Docs>
        <param name="data">Um <see cref="T:System.Collections.IDictionary" /> que contém os dados de tempo de design para o controle.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IControlDesignerAccessor.SetDesignModeState(System.Collections.IDictionary)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.SetOwnerControl">
      <MemberSignature Language="C#" Value="void IControlDesignerAccessor.SetOwnerControl (System.Web.UI.Control owner);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IControlDesignerAccessor.SetOwnerControl(class System.Web.UI.Control owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#SetOwnerControl(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="owner">O proprietário do controle.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IControlDesignerAccessor.SetOwnerControl(System.Web.UI.Control)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 O <xref:System.Web.UI.IControlDesignerAccessor> interface é usada por um designer de controle para executar ações de tempo de design no controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="owner" />é definido para o controle atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IControlDesignerAccessor.UserData">
      <MemberSignature Language="C#" Value="System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary System.Web.UI.IControlDesignerAccessor.UserData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IControlDesignerAccessor#UserData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IControlDesignerAccessor.UserData" />.</summary>
        <value>Um <see cref="T:System.Collections.IDictionary" /> que contém informações sobre o controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IControlDesignerAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.DataBindings">
      <MemberSignature Language="C#" Value="System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.DataBindingCollection System.Web.UI.IDataBindingsAccessor.DataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#DataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.DataBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IDataBindingsAccessor.DataBindings" />.</summary>
        <value>A coleção de associações de dados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IDataBindingsAccessor.HasDataBindings">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IDataBindingsAccessor.HasDataBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IDataBindingsAccessor.HasDataBindings" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IDataBindingsAccessor#HasDataBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IDataBindingsAccessor.HasDataBindings" />.</summary>
        <value>
          <see langword="true" />Se o controle contém a lógica de associação de dados; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IDataBindingsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.Expressions">
      <MemberSignature Language="C#" Value="System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ExpressionBindingCollection System.Web.UI.IExpressionsAccessor.Expressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#Expressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ExpressionBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IExpressionsAccessor.Expressions" />.</summary>
        <value>Um <see cref="T:System.Web.UI.ExpressionBindingCollection" /> contendo <see cref="T:System.Web.UI.ExpressionBinding" /> objetos que representam as propriedades e expressões para um controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IExpressionsAccessor.HasExpressions">
      <MemberSignature Language="C#" Value="bool System.Web.UI.IExpressionsAccessor.HasExpressions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Web.UI.IExpressionsAccessor.HasExpressions" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.System#Web#UI#IExpressionsAccessor#HasExpressions" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Para obter uma descrição desse membro, consulte <see cref="P:System.Web.UI.IExpressionsAccessor.HasExpressions" />.</summary>
        <value>
          <see langword="true" />Se o controle tiver propriedades definidas por expressões; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IExpressionsAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Web.UI.IParserAccessor.AddParsedSubObject">
      <MemberSignature Language="C#" Value="void IParserAccessor.AddParsedSubObject (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Web.UI.IParserAccessor.AddParsedSubObject(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.System#Web#UI#IParserAccessor#AddParsedSubObject(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a adicionar.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.Web.UI.IParserAccessor.AddParsedSubObject(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Web.UI.Control> é convertida em uma interface de <xref:System.Web.UI.IParserAccessor>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.TemplateControl TemplateControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.TemplateControl TemplateControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.TemplateControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define uma referência ao modelo que contém este controle.</summary>
        <value>A instância <see cref="T:System.Web.UI.TemplateControl" /> que contém esse controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Web.UI.Control> instância faz parte de um modelo de controle, o <xref:System.Web.UI.Control.TemplateControl%2A> propriedade contém uma referência para o controle recipiente. Para obter mais informações, consulte o <xref:System.Web.UI.TemplateControl?displayProperty=nameWithType> documentação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TemplateSourceDirectory">
      <MemberSignature Language="C#" Value="public virtual string TemplateSourceDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TemplateSourceDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.TemplateSourceDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o diretório virtual do <see cref="T:System.Web.UI.Page" /> ou <see cref="T:System.Web.UI.UserControl" /> que contém o controle do servidor atual.</summary>
        <value>O diretório virtual do controle de usuário ou página que contém o controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade especifica o caminho para o página ou controle de usuário que contém o controle atual. Por exemplo, se a página da Web reside no http://www.contoso.com/application/subdirectory, o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade retorna "application/subdiretório".  
  
 Para retornar o caminho virtual relativo de aplicativo ("~ / subdiretório"), use o <xref:System.Web.UI.Control.AppRelativeTemplateSourceDirectory%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Control.TemplateSourceDirectory%2A> propriedade duas vezes. Na primeira vez que ele é usado em um <xref:System.Web.UI.Control.MapPathSecure%2A?displayProperty=nameWithType> chamada de método para obter o caminho para o diretório no qual reside o controle. Na segunda vez que ele está em um <xref:System.IO.Directory.GetFiles%2A?displayProperty=nameWithType> chamada de método para obter a lista de todos os arquivos contidos nessa pasta.  
  
 [!code-csharp[Control_TemplateSourceDirectory#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_TemplateSourceDirectory/CS/control_templatesourcedirectory.cs#2)]
 [!code-vb[Control_TemplateSourceDirectory#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_TemplateSourceDirectory/VB/control_templatesourcedirectory.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrackViewState">
      <MemberSignature Language="C#" Value="protected virtual void TrackViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void TrackViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Control.TrackViewState" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Causa o acompanhamento das alterações de estado de exibição para o controle de servidor, para que elas possam ser armazenadas no objeto <see cref="T:System.Web.UI.StateBag" /> do controle de servidor. Esse objeto é acessível por meio da propriedade <see cref="P:System.Web.UI.Control.ViewState" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado automaticamente no final de <xref:System.Web.UI.Control.Init> eventos no ciclo de vida do controle de servidor.  
  
 Chame este método quando você desenvolve controles de associação de dados de modelo. Esse método alertas ASP.NET para monitorar alterações de estado de exibição de um controle de servidor, que é necessário quando você substituir o <xref:System.Web.UI.Control.DataBind%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir substitui o <xref:System.Web.UI.Control.DataBind%2A> método em um controle de servidor ASP.NET personalizado. Ele começa com a chamada a base de <xref:System.Web.UI.Control.OnDataBinding%2A> método e, em seguida, usa o <xref:System.Web.UI.ControlCollection.Clear%2A> método para excluir todos os controles filho e o <xref:System.Web.UI.Control.ClearChildViewState%2A> método para excluir qualquer salva as configurações de estado de exibição para os controles filho. Por fim, o <xref:System.Web.UI.Control.ChildControlsCreated%2A> está definida como `true`. O controle, em seguida, usa o <xref:System.Web.UI.Control.IsTrackingViewState%2A> propriedade para determinar se o estado de exibição de controle de alterações está habilitada para o controle. Se não estiver habilitado, o <xref:System.Web.UI.Control.TrackViewState%2A> método é chamado.  
  
 [!code-csharp[Control_StateManagement#5](~/samples/snippets/csharp/VS_Snippets_WebNet/Control_StateManagement/CS/control_state.cs#5)]
 [!code-vb[Control_StateManagement#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Control_StateManagement/VB/control_state.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueID">
      <MemberSignature Language="C#" Value="public virtual string UniqueID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.UniqueID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador exclusivo, qualificado segundo a hierarquia, para o controle de servidor.</summary>
        <value>O identificador totalmente qualificado para o controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é diferente de <xref:System.Web.UI.Control.ID%2A> propriedade, em que o <xref:System.Web.UI.Control.UniqueID%2A> propriedade inclui o identificador para o controle de servidor do contêiner de nomeação. Esse identificador é gerado automaticamente quando uma solicitação de página é processada.  
  
 Essa propriedade é particularmente importante na diferenciação de controles de servidor contidos em um controle de servidor de associação de dados que se repete. O controle de repetição, que são <xref:System.Web.UI.WebControls.Repeater>, <xref:System.Web.UI.WebControls.DataList>, <xref:System.Web.UI.WebControls.DetailsView>, <xref:System.Web.UI.WebControls.FormView>, e <xref:System.Web.UI.WebControls.GridView> Web controles de servidor (ou os controles de servidor personalizado que você criar que incluem a funcionalidade de repetição quando os dados associados) serve como o contêiner de nomeação para seus controles filhos. Isso significa que ele cria um namespace exclusivo para seu filho controles para que seus <xref:System.Web.UI.Control.ID%2A> valores de propriedade não entrem em conflito.  
  
 Por exemplo, se você incluir um ASP.NET <xref:System.Web.UI.WebControls.Label> controle de servidor na Web um <xref:System.Web.UI.WebControls.Repeater> controle de servidor e atribuir a <xref:System.Web.UI.WebControls.Label> controle um <xref:System.Web.UI.Control.ID%2A> valor da propriedade `MyLabel`e o <xref:System.Web.UI.WebControls.Repeater> um <xref:System.Web.UI.Control.ID%2A> de `MyRepeater`. Se você vincular dados para o <xref:System.Web.UI.WebControls.Repeater> para um <xref:System.Collections.ArrayList> objeto com três entradas, resultante <xref:System.Web.UI.Control.UniqueID%2A> propriedades para cada instância do <xref:System.Web.UI.WebControls.Label> controles de servidor são `MyRepeater$ctl00$MyLabel`, `MyRepeater$ctl01$MyLabel`, e `MyRepeater$ctl02$MyLabel`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Collections.ArrayList> de objeto preenche com três cadeias de caracteres de texto e associa um <xref:System.Web.UI.WebControls.Repeater> controle de servidor para os dados na Web a <xref:System.Collections.ArrayList> quando a página for carregada. Obtém o código de <xref:System.Web.UI.Control.UniqueID%2A> propriedade para cada controle filho gerado durante a associação de dados. O código gera três versões do <xref:System.Web.UI.WebControls.Label> controle e grava seu `UniqueID` valores de propriedade para a página.  
  
 [!code-aspx-csharp[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/csharp/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/CS/WebFormsControlIdResolution12.aspx#2)]
 [!code-aspx-vb[AccessingAspNetControlsProgramaticallyConcepts#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/AccessingAspNetControlsProgramaticallyConcepts/VB/WebFormsControlIdResolution12.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public event EventHandler Unload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Unload" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Control.Unload" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o controle de servidor é descarregado da memória.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles de servidor devem executar qualquer limpeza final, como fechar arquivos, conexões de banco de dados e descartar objetos, durante esse estágio do ciclo de vida de controle antes da instância é descarregada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle verifica a entrada do cliente do navegador para valores potencialmente perigosos.</summary>
        <value>Um valor que determina se o controle verifica a entrada do cliente. Os valores podem incluir <see cref="F:System.Web.UI.ValidateRequestMode.Disabled" />, <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />, e <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />. O padrão é <see cref="F:System.Web.UI.ValidateRequestMode.Inherit" />, que significa que o controle obtém o valor de seu pai.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a validação de solicitação, consulte <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewState">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.StateBag ViewState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.StateBag ViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.StateBag</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um dicionário de informações de estado que permite salvar e restaurar o estado de exibição de um controle de servidor em várias solicitações para a mesma página.</summary>
        <value>Uma instância da classe <see cref="T:System.Web.UI.StateBag" /> que contém informações de estado de exibição do controle de servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de exibição de um controle de servidor é o acúmulo de todos os seus valores de propriedade. Para preservar a esses valores em solicitações HTTP, controles de servidor ASP.NET usam essa propriedade, o que é uma ocorrência da <xref:System.Web.UI.StateBag> classe para armazenar os valores de propriedade. Os valores são passados como uma variável para um elemento de entrada oculto HTML quando solicitações subsequentes são processadas. Para obter mais informações sobre como salvar o estado de exibição de controle de servidor, consulte [visão geral do gerenciamento de estado ASP.NET](http://msdn.microsoft.com/library/0218d965-5d30-445b-b6a6-8870e70e63ce).  
  
 Estado de exibição é habilitado para todos os controles de servidor por padrão, mas há circunstâncias em que deseja desabilitá-lo. Para obter mais informações, consulte [visão geral de desempenho do ASP.NET](http://msdn.microsoft.com/library/f882bf1b-a009-4312-ac06-74370ffabc0b).  
  
 Para obter informações sobre dicionários e como usá-los, consulte [coleções e estruturas de dados](http://msdn.microsoft.com/library/60cc581f-1db5-445b-ba04-a173396bf872).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como implementar um `Text` propriedade que armazena e recupera o valor de seu controle <xref:System.Web.UI.Control.ViewState%2A> propriedade.  
  
 [!code-csharp[SysWebUIControlViewState#2](~/samples/snippets/csharp/VS_Snippets_WebNet/SysWebUIControlViewState/CS/controlviewstate.cs#2)]
 [!code-vb[SysWebUIControlViewState#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/SysWebUIControlViewState/VB/controlviewstate.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewStateIgnoresCase">
      <MemberSignature Language="C#" Value="protected virtual bool ViewStateIgnoresCase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ViewStateIgnoresCase" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateIgnoresCase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o objeto <see cref="T:System.Web.UI.StateBag" /> não diferencia maiúsculas de minúsculas.</summary>
        <value>
          <see langword="true" /> se a instância <see cref="T:System.Web.UI.StateBag" /> não diferenciar maiúsculas de minúsculas; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Substitua este método se você criar um controle de servidor personalizado que salva seu estado de exibição sem considerando caso. Quando você faz para vários objetos com a mesma chave, mas com maiusculas e minúsculas diferentes, podem ser armazenados na <xref:System.Web.UI.StateBag> associados a <xref:System.Web.UI.Control.ViewState%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como substituir o <xref:System.Web.UI.Control.ViewStateIgnoresCase%2A> propriedade para retornar `true`.  
  
 [!code-csharp[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/cs/controlsample_7.cs#2)]
 [!code-vb[System.Web.UI.Control_ViewStateIgnoresCase#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Control_ViewStateIgnoresCase/VB/controlsample_7.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ViewStateMode">
      <MemberSignature Language="C#" Value="public virtual System.Web.UI.ViewStateMode ViewStateMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateMode ViewStateMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.ViewStateMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Themeable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modo de estado de exibição deste controle.</summary>
        <value>O modo de estado de exibição desse controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar o <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade para habilitar o estado de exibição para um controle individual, mesmo se o estado de exibição está desabilitado para a página. Para obter mais informações sobre o estado de exibição e o estado de controle, consulte o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade.  
  
 Para desativar o estado de exibição para uma página e habilitá-lo para um controle específico na página, defina o <xref:System.Web.UI.Control.EnableViewState%2A> propriedade da página e o controle `true`, defina o <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade da página para <xref:System.Web.UI.ViewStateMode.Disabled>e defina o <xref:System.Web.UI.Control.ViewStateMode%2A> propriedade do controle para <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 O valor padrão de <xref:System.Web.UI.Control.ViewStateMode%2A> é de propriedade para uma página <xref:System.Web.UI.ViewStateMode.Enabled>. O valor padrão de <xref:System.Web.UI.Control.ViewStateMode%2A> é de propriedade para um controle de servidor Web em uma página <xref:System.Web.UI.ViewStateMode.Inherit>. Como resultado, se você não definir essa propriedade na página ou o nível de controle, o valor de <xref:System.Web.UI.Control.EnableViewState%2A> propriedade determina o comportamento do estado de exibição.  
  
 O <xref:System.Web.UI.Control.ViewStateMode%2A> a propriedade de uma página ou um controle tem somente-se um efeito de <xref:System.Web.UI.Control.EnableViewState%2A> está definida como `true`. Se o <xref:System.Web.UI.Control.EnableViewState%2A> está definida como `false`, estado de exibição será desativado mesmo se o <xref:System.Web.UI.Control.ViewStateMode%2A> está definida como <xref:System.Web.UI.ViewStateMode.Enabled>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Tentativa de definir esta propriedade com um valor que não está na enumeração de <see cref="T:System.Web.UI.ViewStateMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public virtual bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Control.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se um controle de servidor é renderizado como uma interface do usuário na página.</summary>
        <value>
          <see langword="true" /> se o controle estiver visível na página; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade for `false`, o controle de servidor não é processado. Você deve levar isso em conta ao organizar o layout da página.  
  
> [!NOTE]
>  Se um controle de contêiner não é processado, os controles que ele contém não serão renderizados mesmo que você defina o <xref:System.Web.UI.Control.Visible%2A> propriedade de um controle individual para `true`. Nesse caso, o controle individual retorna `false` para o <xref:System.Web.UI.Control.Visible%2A> propriedade mesmo se você tiver definido-lo explicitamente `true`. (Ou seja, se o `Visible` propriedade do controle pai está definida como `false`, o controle filho herda a configuração e a configuração tem precedência sobre nenhuma configuração local.)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
