<Type Name="Page" FullName="System.Web.UI.Page">
  <TypeSignature Language="C#" Value="public class Page : System.Web.UI.TemplateControl, System.Web.IHttpHandler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Page extends System.Web.UI.TemplateControl implements class System.Web.IHttpHandler" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Page" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Web.UI.TemplateControl</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Web.IHttpHandler</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Design.Serialization.DesignerSerializer("Microsoft.VisualStudio.Web.WebForms.WebFormCodeDomSerializer, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.Serialization.TypeCodeDomSerializer, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Web.WebForms.WebFormDesigner, Microsoft.VisualStudio.Web, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("ASPXCodeBehind")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um arquivo .aspx, também conhecido como uma página do Web Forms, solicitado de um servidor que hospeda um aplicativo Web ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page> classe está associada a arquivos que têm uma extensão. Esses arquivos são compilados em tempo de execução como <xref:System.Web.UI.Page> objetos e armazenado em cache na memória do servidor.  
  
 Se você quiser criar uma página de Web Forms usando a técnica de lógica, derive dessa classe. Designers de desenvolvimento (RAD) rápido de aplicativos, como o Microsoft Visual Studio automaticamente usam esse modelo para criar páginas Web Forms.  
  
 O <xref:System.Web.UI.Page> objeto serve como o contêiner de nomeação para todos os controles de servidor em uma página, exceto aqueles que implementam o <xref:System.Web.UI.INamingContainer> interface ou controles filho de controles que implementam esta interface.  
  
 O <xref:System.Web.UI.Page> classe é um controle que atua como a interface do usuário para seu aplicativo da Web e como tal, deve ser inspecionado para tornar-se de que as práticas recomendadas para escrever código seguro e proteger aplicativos são seguidas. Para obter informações gerais sobre esses tópicos, consulte [visão geral da Web aplicativo contra ameaças à segurança](http://msdn.microsoft.com/library/88d61678-f84e-4622-ae80-53128821855a), [NIB: práticas recomendadas de política de segurança](http://msdn.microsoft.com/en-us/d49bc4d5-efb7-4caa-a2fe-e4d3cec63c05), e [conceitos de segurança de chave](~/docs/standard/security/key-security-concepts.md). Para obter informações mais específicas, consulte [protegendo controles padrão](http://msdn.microsoft.com/library/f3e7718f-63d0-44a3-bd5f-48cc2059c2a8), [como: exibir mensagens de erro de segurança](http://msdn.microsoft.com/library/6f70ac33-6e11-4e98-ab7d-bae9c0e7eefa), [como: proteger contra scripts maliciosos em um aplicativo da Web aplicando codificação HTML a cadeias de caracteres](http://msdn.microsoft.com/library/6f67973f-dda0-45a1-ba9d-e88532d7dc5b), e [Introdução aos controles de validação](http://msdn.microsoft.com/en-us/3c0e7514-cff2-4bed-936d-ee3f7b740190).  
  
   
  
## Examples  
 Um projeto de site da Web do Visual Studio com o código-fonte está disponível para acompanhar este tópico: [baixar](http://go.microsoft.com/fwlink/?LinkId=192425).  
  
 O exemplo de código a seguir demonstra como o <xref:System.Web.UI.Page> classe é usada no modelo de página de code-behind. Observe que o arquivo de origem do code-behind declara uma classe parcial que herda de uma classe de página de base. A classe base de página pode ser <xref:System.Web.UI.Page>, ou pode ser outra classe que deriva de <xref:System.Web.UI.Page>. Além disso, observe que a classe parcial permite que o arquivo de code-behind usar controles definidos na página sem a necessidade de defini-los como membros do campo.  
  
 [!code-csharp[System.Web.UI.Page_Overview#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx.cs#2)]
 [!code-vb[System.Web.UI.Page_Overview#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx.vb#2)]  
  
 O exemplo de código a seguir mostra o arquivo. aspx que corresponde ao arquivo de origem por trás do código anterior.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview/vb/pageexample.aspx#1)]  
  
 Você deve usar a diretiva e a `Inherits` e `CodeFile` atributos para vincular o arquivo code-behind para o arquivo. aspx. Neste exemplo, o `Inherits` atributo indica o `MyCodeBehind` classe e o `CodeFile` atributo indica o caminho para o arquivo de idioma específico que contém a classe.  
  
 O exemplo de código a seguir demonstra o modelo de página de arquivo único e como acessar o <xref:System.Web.UI.Page.IsPostBack%2A> propriedade e o <xref:System.Web.UI.Page.Response%2A> propriedade o <xref:System.Web.UI.Page>.  
  
 [!code-aspx-csharp[System.Web.UI.Page_Overview2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/cs/pageexample.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_Overview2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Overview2/vb/pageexample.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Page ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Web.UI.Page" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor padrão inicializa todos os campos com seus valores padrão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddContentTemplate">
      <MemberSignature Language="C#" Value="protected void AddContentTemplate (string templateName, System.Web.UI.ITemplate template);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddContentTemplate(string templateName, class System.Web.UI.ITemplate template) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddContentTemplate(System.String,System.Web.UI.ITemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="templateName" Type="System.String" />
        <Parameter Name="template" Type="System.Web.UI.ITemplate" />
      </Parameters>
      <Docs>
        <param name="templateName">O nome do modelo de conteúdo a adicionar.</param>
        <param name="template">O modelo de conteúdo</param>
        <summary>Chamado durante a inicialização da página para criar uma coleção de conteúdo (controles de conteúdo) que é entregue para uma página mestre, se a página atual ou a página mestra se refere a uma página mestra.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Web.HttpException">Um modelo de conteúdo com o mesmo nome já existe.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
      </Parameters>
      <Docs>
        <param name="beginHandler">O representante para a <see cref="T:System.Web.BeginEventHandler" /> método.</param>
        <param name="endHandler">O representante para a <see cref="T:System.Web.EndEventHandler" /> método.</param>
        <summary>Registra o início e fim delegados do manipulador de eventos que não exigem informações de estado para uma página assíncrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> método para adicionar manipuladores para uma página da Web assíncrona.  
  
 Você pode registrar vários manipuladores assíncronos; No entanto, apenas um manipulador é executado por vez. Se você quiser processar vários métodos assíncronos simultaneamente, você deve usar um único <xref:System.Web.BeginEventHandler> método e iniciar várias operações assíncronas desse manipulador.  
  
 Os manipuladores assíncronos são chamados entre o <xref:System.Web.UI.Control.PreRender> e <xref:System.Web.UI.Page.PreRenderComplete> eventos.  
  
 Primeiro, todos os <xref:System.Web.UI.Page> eventos (por meio de <xref:System.Web.UI.Control.PreRender> evento) executado e, em seguida, cada registrado <xref:System.Web.BeginEventHandler> método é chamado. Quando o manipulador é concluído, o correspondente <xref:System.Web.EndEventHandler> método é chamado. Se houver vários manipuladores assíncronos, o próximo manipulador é chamado.  
  
 Depois de tem sido chamados os manipuladores de eventos assíncrono registrado, o restante dos eventos de página são chamados, começando com o <xref:System.Web.UI.Page.PreRenderComplete> evento.  
  
   
  
## Examples  
 O exemplo de código a seguir usa uma solicitação assíncrona para exibir o código-fonte HTML da página do local do servidor Web padrão em um <xref:System.Web.UI.WebControls.TextBox> controle.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see langword="&lt;async&gt;" /> diretiva de página não está definida como <see langword="true" />.  
  
 \- ou -  
  
 O <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> método é chamado após o <see cref="E:System.Web.UI.Control.PreRender" /> evento.</exception>
        <exception cref="T:System.ArgumentNullException">O <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> ou <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOnPreRenderCompleteAsync">
      <MemberSignature Language="C#" Value="public void AddOnPreRenderCompleteAsync (System.Web.BeginEventHandler beginHandler, System.Web.EndEventHandler endHandler, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOnPreRenderCompleteAsync(class System.Web.BeginEventHandler beginHandler, class System.Web.EndEventHandler endHandler, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="beginHandler" Type="System.Web.BeginEventHandler" />
        <Parameter Name="endHandler" Type="System.Web.EndEventHandler" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="beginHandler">O representante para a <see cref="T:System.Web.BeginEventHandler" /> método.</param>
        <param name="endHandler">O representante para a <see cref="T:System.Web.EndEventHandler" /> método.</param>
        <param name="state">Um objeto que contém informações de estado para os manipuladores de eventos.</param>
        <summary>Registros de abertura e fechamento delegados de manipulador de eventos para uma página assíncrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.AddOnPreRenderCompleteAsync%2A> método para adicionar manipuladores que exigem informações de estado para uma página da Web assíncrona. O objeto passado a `state` parâmetro pode ser qualquer objeto que seu aplicativo requer para transferir informações entre os representantes de manipulador de eventos especificados no `beginHandler` e `endHandler` parâmetros.  
  
 Você pode registrar vários manipuladores assíncronos; No entanto, apenas um manipulador é executado por vez. Se você quiser processar vários métodos assíncronos simultaneamente, você deve usar um único <xref:System.Web.BeginEventHandler> método e iniciar várias operações assíncronas desse manipulador.  
  
 Os manipuladores assíncronos são chamados entre o <xref:System.Web.UI.Control.PreRender> e <xref:System.Web.UI.Page.PreRenderComplete> eventos.  
  
 Primeiro, todos os <xref:System.Web.UI.Page> eventos (por meio de <xref:System.Web.UI.Control.PreRender> evento) executado e, em seguida, cada registrado <xref:System.Web.BeginEventHandler> método é chamado. Quando o manipulador é concluído, o correspondente <xref:System.Web.EndEventHandler> método é chamado. Se houver vários manipuladores assíncronos, o próximo manipulador é chamado.  
  
 Depois de tem sido chamados os manipuladores de eventos assíncrono registrado, o restante dos eventos de página são chamados, começando com o <xref:System.Web.UI.Page.PreRenderComplete> evento.  
  
   
  
## Examples  
 O exemplo de código a seguir usa uma solicitação assíncrona para exibir o código-fonte HTML da página do local do servidor Web padrão em um <xref:System.Web.UI.WebControls.TextBox> controle.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/CS/pageaddonprerendercompleteasynccs.aspx#1)]
 [!code-aspx-vb[PageAddOnPreRenderCompleteAsync#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageAddOnPreRenderCompleteAsync/VB/pageaddonprerendercompleteasyncvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see langword="&lt;async&gt;" /> diretiva de página não está definida como <see langword="true" />.  
  
 \- ou -  
  
 O <see cref="M:System.Web.UI.Page.AddOnPreRenderCompleteAsync(System.Web.BeginEventHandler,System.Web.EndEventHandler)" /> método é chamado após o <see cref="E:System.Web.UI.Control.PreRender" /> evento.</exception>
        <exception cref="T:System.ArgumentNullException">O <see cref="P:System.Web.UI.PageAsyncTask.BeginHandler" /> ou <see cref="P:System.Web.UI.PageAsyncTask.EndHandler" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected void AddWrappedFileDependencies (object virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddWrappedFileDependencies(object virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AddWrappedFileDependencies(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Um <see cref="T:System.Object" /> que contém a lista de nomes de arquivo.</param>
        <summary>Adiciona uma lista de arquivos dependentes que compõem a página atual. Esse método é usado internamente pela estrutura de página ASP.NET e não se destina a ser usado diretamente no seu código.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.AddWrappedFileDependencies%2A> método adiciona uma lista de arquivos, como arquivos de controle de usuário, que compõem a página atual. Se qualquer uma dessas páginas for modificada, a página inteira é compilada na próxima vez que forem solicitados. Esse método oferece suporte a infraestrutura do .NET Framework e não se destina a ser usado diretamente do seu código.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Application">
      <MemberSignature Language="C#" Value="public System.Web.HttpApplicationState Application { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpApplicationState Application" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Application" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpApplicationState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpApplicationState" /> para a solicitação Web atual.</summary>
        <value>Os dados atuais na classe <see cref="T:System.Web.HttpApplicationState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page.Application_Sample1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Application_Sample1/CS/applicationcs.aspx#1)]
 [!code-vb[Page.Application_Sample1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Application_Sample1/VB/applicationvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AspCompatBeginProcessRequest (System.Web.HttpContext context, AsyncCallback cb, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AspCompatBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback cb, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="cb" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">Um <see cref="T:System.Web.HttpContext" /> com informações sobre a solicitação atual.</param>
        <param name="cb">O método de retorno de chamada.</param>
        <param name="extraData">Qualquer dado extra necessário para processar a solicitação da mesma maneira como uma solicitação ASP.</param>
        <summary>Inicia uma solicitação de recursos do Active Server Page (ASP). Este método é fornecido para compatibilidade com aplicativos herdados do ASP.</summary>
        <returns>Um objeto <see cref="T:System.IAsyncResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não chame este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AspCompatEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AspCompatEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AspCompatEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">A página ASP gerada pela solicitação.</param>
        <summary>Encerra uma solicitação para recursos do Active Server Page (ASP). Este método é fornecido para compatibilidade com aplicativos herdados do ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não chame este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AspCompatMode">
      <MemberSignature Language="C#" Value="protected bool AspCompatMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AspCompatMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AspCompatMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define um valor que indica se a página pode ser executada em um thread de single-threaded apartment (STA).</summary>
        <value>
          <see langword="true" />Se a página dá suporte a código de Active Server Pages (ASP); Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando definido como `true`, essa propriedade permite que a página a ser executada em um thread de single-threaded apartment (STA). Isso permite que a página chamar componentes do STA, como componentes desenvolvidos com o Visual Basic 6.0. Definir essa propriedade como `true` também permite que a página chamam componentes COM+ que exigem acesso a objetos interno do ASP não gerenciado. Eles são acessíveis por meio do ASP `ObjectContext` objeto ou o `OnStartPage` método.  
  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `aspcompat` atributo `true` usando a diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncMode">
      <MemberSignature Language="C#" Value="protected bool AsyncMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AsyncMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define um valor que indica se a página é processada de forma síncrona ou assíncrona.</summary>
        <value>
          <see langword="true" /> se a página for processada de forma assíncrona; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.AsyncMode%2A> propriedade é definida pelo <xref:System.Web.UI.Page> analisador quando o código para a página é gerado. Use o `Async` atributo na diretiva para definir esse valor.  
  
 Páginas assíncronas não funcionam quando o `AspCompat` atributo é definido como `true` ou `Transaction` atributo é definido como um valor diferente de `Disabled` na diretiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageBeginProcessRequest">
      <MemberSignature Language="C#" Value="protected IAsyncResult AsyncPageBeginProcessRequest (System.Web.HttpContext context, AsyncCallback callback, object extraData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.IAsyncResult AsyncPageBeginProcessRequest(class System.Web.HttpContext context, class System.AsyncCallback callback, object extraData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageBeginProcessRequest(System.Web.HttpContext,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="extraData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="context">O <see cref="T:System.Web.HttpContext" /> para a solicitação.</param>
        <param name="callback">O método de retorno de chamada para notificar quando o processo for concluído.</param>
        <param name="extraData">Dados de estado para o método assíncrono.</param>
        <summary>Começa a processar uma solicitação de página assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à solicitação assíncrona.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncPageEndProcessRequest">
      <MemberSignature Language="C#" Value="protected void AsyncPageEndProcessRequest (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void AsyncPageEndProcessRequest(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.AsyncPageEndProcessRequest(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="result" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">Um <see cref="T:System.IAsyncResult" /> fazendo referência a uma solicitação assíncrona pendente.</param>
        <summary>Extensão de processamento de uma solicitação de página assíncrona.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AsyncTimeout">
      <MemberSignature Language="C#" Value="public TimeSpan AsyncTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan AsyncTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AsyncTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica o intervalo de tempo limite usado durante o processamento de tarefas assíncronas.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que contém o intervalo de tempo permitido para a conclusão da tarefa assíncrona. O intervalo de tempo padrão é de 45 segundos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tempo limite assíncrono da página representa a quantidade de tempo que a página esperará para executar tarefas assíncronas. Na maioria das circunstâncias, não defina essa propriedade no código. Definir o intervalo de tempo limite assíncrono de página usando do arquivo de configuração da Web ou na diretiva. Valores definidos na seção de configuração da página são substituídos pela diretiva de página.  
  
 Definir sua tarefa assíncrona usando o <xref:System.Web.UI.PageAsyncTask> classe e registrar um manipulador de tempo limite de um início e um final. Se a tarefa assíncrona não for concluída no intervalo de tempo especificado, o manipulador de tempo limite será invocado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade com o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> e <xref:System.Web.UI.Page.RegisterAsyncTask%2A> métodos. Observe o uso de manipuladores de tempo limite de início e final. No exemplo, um atraso artificial é introduzido para demonstrar a situação de uma tarefa assíncrona excedeu o tempo alocado para a tarefa conforme especificado no <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade. Em um cenário do mundo real, uma tarefa assíncrona pode ser usada para realizar chamadas de banco de dados ou a geração de imagem, por exemplo, e o manipulador de tempo limite fornece degradação de forma suave se a tarefa não é executada em um período de tempo especificado. Observe que o <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade é definida na diretiva de página.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade foi definida com um valor negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="AutoPostBackControl">
      <MemberSignature Language="C#" Value="public System.Web.UI.Control AutoPostBackControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control AutoPostBackControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.AutoPostBackControl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o controle na página que é usado para executar postbacks.</summary>
        <value>O controle que é usado para executar postbacks.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define um valor que indica se a saída de página está armazenada em buffer.</summary>
        <value>
          <see langword="true" /> se a saída de página estiver armazenada em buffer; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o <xref:System.Web.UI.Page.Buffer%2A> atributo `true` usando a diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
> [!NOTE]
>  O <xref:System.Web.UI.Page.Buffer%2A> propriedade define e obtém o <xref:System.Web.HttpResponse.BufferOutput%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.Caching.Cache Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Caching.Cache Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Cache" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Caching.Cache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.Caching.Cache" /> associado ao aplicativo no qual a página reside.</summary>
        <value>O <see cref="T:System.Web.Caching.Cache" /> associado ao aplicativo da página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo <xref:System.Web.Caching.Cache> objeto permite que você armazene e recupere dados arbitrários em solicitações subsequentes. O cache não é especificamente associado uma sessão de usuário ou de página. Ele é usado principalmente para melhorar o desempenho do aplicativo. Para obter mais informações, consulte [cache de dados de aplicativo](http://msdn.microsoft.com/library/206f977d-7860-4d20-bdd5-c3b3d8479f3d). Para obter mais informações sobre a diferença entre o aplicativo em cache e cache de saída de página, consulte [visão geral de cache ASP.NET](http://msdn.microsoft.com/library/5ec28012-4972-4dc3-b3e8-9d20401fe11d).  
  
   
  
## Examples  
 O exemplo de código a seguir insere a soma de dois inteiros para o <xref:System.Web.Caching.Cache?displayProperty=nameWithType> objeto usando o <xref:System.Web.UI.Page.Cache%2A?displayProperty=nameWithType> propriedade. Em seguida, recupera o valor usando o <xref:System.Web.Caching.Cache.Get%2A?displayProperty=nameWithType> método e grava-o para um <xref:System.Web.UI.WebControls.Label> controle de servidor Web.  
  
 [!code-csharp[System.Web.Page.Cache_Replacement#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/CS/pagecachecs.aspx#1)]
 [!code-vb[System.Web.Page.Cache_Replacement#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Page.Cache_Replacement/VB/pagecachevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Uma instância de <see cref="T:System.Web.Caching.Cache" /> não foi criada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientQueryString">
      <MemberSignature Language="C#" Value="public string ClientQueryString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientQueryString" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientQueryString" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a parte da cadeia de caracteres de consulta da URL solicitada.</summary>
        <value>A parte da cadeia de caracteres de consulta da URL solicitada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.ClientQueryString%2A> propriedade contém a parte da cadeia de caracteres de consulta da URL solicitada pelo navegador. Por exemplo, se a URL solicitada é "http://www.contoso.com/default.aspx?id=100", o <xref:System.Web.UI.Page.ClientQueryString%2A> irá conter a propriedade "id = 100". O <xref:System.Web.UI.Page.ClientQueryString%2A> propriedade é codificada; use o <xref:System.Web.HttpServerUtility.UrlDecode%2A?displayProperty=nameWithType> método decodificar a cadeia de caracteres de consulta.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientScript">
      <MemberSignature Language="C#" Value="public System.Web.UI.ClientScriptManager ClientScript { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ClientScriptManager ClientScript" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientScript" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ClientScriptManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Web.UI.ClientScriptManager" /> usado para gerenciar, registrar e adicionar scripts à página.</summary>
        <value>Um objeto <see cref="T:System.Web.UI.ClientScriptManager" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.ClientScript%2A> propriedade para obter um <xref:System.Web.UI.ClientScriptManager> objeto que pode ser usado para registrar e adicionar script para uma página da Web. Para obter mais informações, consulte a classe <xref:System.Web.UI.ClientScriptManager>.  
  
 O <xref:System.Web.UI.ClientScriptManager> classe é nova no [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] e substitui <xref:System.Web.UI.Page> classe métodos para gerenciar scripts que agora são preteridos.  
  
   
  
## Examples  
 Para obter um exemplo, consulte o <xref:System.Web.UI.ClientScriptManager> tópico de visão geral da classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientTarget">
      <MemberSignature Language="C#" Value="public string ClientTarget { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ClientTarget" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ClientTarget" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que permite que você substitua a detecção automática dos recursos do navegador e especifique como uma página é processada para determinados clientes de navegador.</summary>
        <value>Um <see cref="T:System.String" /> que especifica os recursos do navegador que você deseja substituir.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não definir a <xref:System.Web.UI.Page.ClientTarget%2A> propriedade, o <xref:System.Web.HttpBrowserCapabilities> objeto associado a <xref:System.Web.UI.Page.Request%2A?displayProperty=nameWithType> propriedade reflete os recursos do navegador do cliente. Se você definir essa propriedade, detecção de navegador do cliente é desabilitada e a página irá usar recursos do navegador associados com o valor (alias) que você fornecer.  
  
 O arquivo de configuração de Web. config de raiz no computador do servidor Web define os seguintes aliases padrão que você pode usar como abreviada para cadeias de caracteres de agente de usuário comuns:  
  
-   `uplevel`, que especifica os recursos do navegador equivalentes para o Internet Explorer 6.0.  
  
-   `downlevel`, que especifica os recursos do navegador equivalentes para navegadores mais antigos que não oferecem suporte a script de cliente. Você pode usar este alias para determinar como páginas da Web funcionaria em um navegador que tem o script de cliente desabilitado.  
  
 Você pode definir o alias programaticamente usando essa propriedade, ou você pode defini-lo usando o `ClientTarget` atributo da diretiva.  
  
 Você pode definir um alias adicional no `clientTarget` seção do arquivo Web. config de nível de aplicativo. Para obter mais informações, consulte [clientTarget Element (ASP.NET Settings Schema)](http://msdn.microsoft.com/en-us/17a0fa6e-a065-49cc-b900-ef73eda6a922).  
  
   
  
## Examples  
 O exemplo de código a seguir define um `ie302` alias e inclui as seções necessárias para configurar seu aplicativo em seu arquivo Web. config. Usando este alias, você pode definir o <xref:System.Web.UI.Page.ClientTarget%2A> propriedade `ie302` e personalizar páginas especificamente para navegadores de Internet Explorer 3.02.  
  
```  
<configuration>  
  <system.web>  
   <clientTarget>  
    <add alias="ie302" useragent="Mozilla/2.0 (compatible; MSIE 3.02; Windows NT 3.5)" />  
   </clientTarget>  
  </system.web>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public int CodePage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define o identificador de página de código atual <see cref="T:System.Web.UI.Page" />.</summary>
        <value>Um inteiro que representa o identificador de página de código atual <see cref="T:System.Web.UI.Page" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `CodePage` de atributo para o valor desejado usando a diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ContentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define o tipo MIME HTTP para o objeto <see cref="T:System.Web.HttpResponse" /> associado à página.</summary>
        <value>O tipo MIME HTTP associado à página atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `ContentType` atributo usando a diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Context">
      <MemberSignature Language="C#" Value="protected override System.Web.HttpContext Context { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpContext Context" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Context" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpContext" /> associado à página.</summary>
        <value>Um objeto <see cref="T:System.Web.HttpContext" /> que contém informações associadas à página atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade fornece acesso programático para o contexto em que a página é executada, incluindo informações sobre a solicitação, resposta, sessão e aplicativo.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.Context%2A> propriedade para acessar o <xref:System.Web.HttpContext.AddError%2A?displayProperty=nameWithType> e <xref:System.Web.HttpContext.ClearError%2A?displayProperty=nameWithType> métodos e <xref:System.Web.HttpContext.AllErrors%2A?displayProperty=nameWithType> propriedade. O exemplo cria três exceções personalizadas usando o <xref:System.Web.HttpContext.AddError%2A> método e usa o <xref:System.Web.HttpContext.AllErrors%2A> propriedade ao carregar essas exceções em uma matriz. Em seguida, grava a matriz de conteúdo da página e usa o <xref:System.Web.HttpContext.ClearError%2A> método para limpar todos os erros do <xref:System.Web.UI.Page.Context%2A> propriedade.  
  
 [!code-csharp[System.Web.UI.Page.Context#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Context/CS/pagecontextcs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Context#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Context/VB/pagecontextvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriter">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.HtmlTextWriter CreateHtmlTextWriter (System.IO.TextWriter tw);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Web.UI.HtmlTextWriter CreateHtmlTextWriter(class System.IO.TextWriter tw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriter(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="tw">O <see cref="T:System.IO.TextWriter" /> usado para criar o <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <summary>Cria um <see cref="T:System.Web.UI.HtmlTextWriter" /> objeto para renderizar o conteúdo da página.</summary>
        <returns>Um <see cref="T:System.Web.UI.HtmlTextWriter" /> ou <see cref="T:System.Web.UI.Html32TextWriter" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método cria um <xref:System.IO.TextWriter> por meio de <xref:System.Web.HttpRequest.Browser%2A> propriedade do <xref:System.Web.HttpContext.Request%2A> objeto associado à solicitação de página. Você pode adicionar uma referência a um <xref:System.Web.UI.HtmlTextWriter> no `browserCaps` seção de configuração. Substituir o <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método para executar pesquisas personalizadas.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método para criar uma instância de um personalizado <xref:System.Web.UI.HtmlTextWriter> objeto chamado `MyHtmlTextWriter`. O <xref:System.Web.UI.Page.CreateHtmlTextWriter%2A> método é substituído o `MyPage` classe, que é derivado de <xref:System.Web.UI.Page>, de modo que `MyHtmlTextWriter` renderiza os controles de servidor ASP.NET quando a página é solicitada. Observe que este exemplo impedirão adaptador <xref:System.IO.TextWriter> comportamento.  
  
 [!code-csharp[Page_CreateHtmlTextWriter#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/CS/page_createhtmltextwriter.cs#2)]
 [!code-vb[Page_CreateHtmlTextWriter#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_CreateHtmlTextWriter/VB/page_createhtmltextwriter.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHtmlTextWriterFromType">
      <MemberSignature Language="C#" Value="public static System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType (System.IO.TextWriter tw, Type writerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Web.UI.HtmlTextWriter CreateHtmlTextWriterFromType(class System.IO.TextWriter tw, class System.Type writerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.CreateHtmlTextWriterFromType(System.IO.TextWriter,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlTextWriter</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tw" Type="System.IO.TextWriter" />
        <Parameter Name="writerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="tw">O <see cref="T:System.IO.TextWriter" /> usado para criar o <see cref="T:System.Web.UI.HtmlTextWriter" />.</param>
        <param name="writerType">O tipo de gravador de texto a ser criado.</param>
        <summary>Cria um objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> especificado para renderizar o conteúdo da página.</summary>
        <returns>Um <see cref="T:System.Web.UI.HtmlTextWriter" /> que renderiza o conteúdo da página.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado internamente em adaptadores de página.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O parâmetro <paramref name="writerType" /> está definido como um tipo inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public string Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Culture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Culture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define a ID de cultura para o objeto <see cref="T:System.Threading.Thread" /> associado à página.</summary>
        <value>Uma ID de cultura válida.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir o `Culture` atributo na diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define o valor dessa propriedade. Além disso, você pode definir explicitamente o valor de <xref:System.Web.UI.Page.Culture%2A> propriedade programaticamente ou no elemento do Web. config arquivo.  
  
 O <xref:System.Web.UI.Page.Culture%2A> propriedade é usada para ajudar a localizar conteúdo da página. Você pode configurá-lo para qualquer ID de cultura válida. Por exemplo, o `en-us` identificação da cultura define a página como American enquanto em inglês, o `fr` identificação da cultura define a página como francês. Você também pode definir o valor `auto` que realizará a detecção automática do navegador do idioma preferencial e defina-o. A detecção automática de idioma pode ser qualificada com um valor padrão como `auto:en-us`.  
  
 Para obter mais informações, consulte o <xref:System.Globalization.CultureInfo> visão geral da classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DesignerInitialize">
      <MemberSignature Language="C#" Value="public void DesignerInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DesignerInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DesignerInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Executa qualquer inicialização da instância do <see cref="T:System.Web.UI.Page" /> classe que é exigido pelos designers RAD. Esse método é usado somente em tempo de design.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackMode">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackMode ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Collections.Specialized.NameValueCollection" /> de dados enviados de volta para a página usando um POST ou um comando GET.</summary>
        <returns>Um <see cref="T:System.Collections.Specialized.NameValueCollection" /> objeto que contém os dados do formulário. Se o postback usado o comando POST, as informações do formulário são retornadas do <see cref="P:System.Web.UI.Page.Context" /> objeto. Se o postback usado o comando GET, as informações de cadeia de caracteres de consulta são retornadas. Se a página está sendo solicitada pela primeira vez, <see langword="null" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.DeterminePostBackMode%2A> método retorna um <xref:System.Collections.Specialized.NameValueCollection> lançadas de objeto que contém os dados de volta para a página. A presença da página oculta campos VIEWSTATE e EVENTTARGET é usado para ajudar a determinar se ocorreu um evento de postback. O <xref:System.Web.UI.Page.IsPostBack%2A> propriedade é definida quando o <xref:System.Web.UI.Page.DeterminePostBackMode%2A> método é chamado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeterminePostBackModeUnvalidated">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Collections.Specialized.NameValueCollection DeterminePostBackModeUnvalidated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.DeterminePostBackModeUnvalidated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma coleção de nome-valor de dados que foi lançadas para a página usando um POST ou um comando GET, sem executar a validação de solicitação do ASP.NET na solicitação.</summary>
        <returns>Um objeto que contém os dados de formulário invalidados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte a classe <xref:System.Web.UnvalidatedRequestValues>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableEventValidation">
      <MemberSignature Language="C#" Value="public virtual bool EnableEventValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableEventValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableEventValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a página valida eventos de postback e retorno de chamada.</summary>
        <value>
          <see langword="true" /> se a página validar eventos de postback e retorno de chamada; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Web.UI.Page.EnableEventValidation%2A> está definida como `true`, ASP.NET valida que um evento de controle proveniente da interface do usuário que foi processado pelo controle. Um controle registra seus eventos durante o processamento e, em seguida, valida os eventos durante o tratamento de postback ou de retorno de chamada. Por exemplo, se um controle de lista inclui opções numeradas de 1, 2 ou 3 quando a página é renderizada, e se é recebida uma solicitação de postback especificando o número de opção 4, o ASP.NET gera uma exceção. Todos os controles controlada por evento no ASP.NET usam esse recurso por padrão.  
  
 Se você gravar um script de cliente que altera um controle no cliente em tempo de execução, talvez você precise usar o <xref:System.Web.UI.ClientScriptManager.RegisterForEventValidation%2A> método para evitar erros de validação de evento false.  
  
> [!IMPORTANT]
>  Esse recurso reduz o risco de solicitações de postback não autorizadas ou mal-intencionados e retornos de chamada. É altamente recomendável que você não desabilitar a validação do evento.  
  
 Definir o <xref:System.Web.UI.Page.EnableEventValidation%2A> propriedade definindo o `enableEventValidation` atributo da diretiva ou `enableEventValidation` atributo do elemento no arquivo Web. config. Se você definir essa propriedade no código, você deve configurá-lo antes da página é inicializada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.Page.EnableEventValidation" /> foi definida após a página ter sido inicializada.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableViewState">
      <MemberSignature Language="C#" Value="public override bool EnableViewState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a página mantém seu estado de exibição e o estado de exibição de todos os controles de servidor contidos nela, quando encerra a solicitação da página atual.</summary>
        <value>
          <see langword="true" /> se a página mantiver seu estado de exibição; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre por que talvez você queira desativar o estado de exibição, consulte <xref:System.Web.UI.Control.EnableViewState%2A?displayProperty=nameWithType>.  
  
 Mesmo se <xref:System.Web.UI.Page.EnableViewState%2A> é `false`, a página pode conter um campo de estado de exibição oculto que é usado pelo ASP.NET para detectar um postback.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Web.UI.Page.EnableViewState%2A> propriedade `false` quando a página for carregada. Isso desativa o estado de exibição para o <xref:System.Web.UI.Page> objeto, o que significa que nem as informações de estado de exibição para a página nem quaisquer controles contidos pela página são salvas.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/CS/page_enableviewstate.cs#1)]
 [!code-vb[Page_EnableViewState_ReSubmit_1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_EnableViewState_ReSubmit_1/VB/page_enableviewstate.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableViewStateMac">
      <MemberSignature Language="C#" Value="public bool EnableViewStateMac { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableViewStateMac" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.EnableViewStateMac" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o ASP.NET deve verificar os MACs (Message Authentication Codes) no estado de exibição da página quando a página sofrer postback do cliente.</summary>
        <value>
          <see langword="true" /> para verificar o MAC do estado de exibição e codificá-lo; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um MAC de estado de exibição é uma versão criptografada da variável oculta o estado de exibição da página persiste quando a página é enviada para o navegador. Quando essa propriedade é definida como `true`, o estado de exibição criptografado é verificado para confirmar que ele não foi adulterado no cliente.  
  
 Não defina essa propriedade no código. Definir o `EnableViewStateMac` atributo usando a diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
> [!IMPORTANT]
>  Esse atributo nunca deve ser definido como `false` em um site de produção, mesmo se o aplicativo ou página não usar o estado de exibição. O estado de exibição MAC ajuda a garantir a segurança de outras funções ASP.NET além do estado de exibição.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ErrorPage">
      <MemberSignature Language="C#" Value="public string ErrorPage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ErrorPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ErrorPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a página de erro para a qual o navegador solicitante é redirecionado em caso de uma exceção de página sem tratamento.</summary>
        <value>A página de erro para a qual o navegador é redirecionado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[Page_ErrorPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_ErrorPage/CS/page_errorpage.cs.aspx#1)]
 [!code-vb[Page_ErrorPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_ErrorPage/VB/page_errorpage.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteRegisteredAsyncTasks">
      <MemberSignature Language="C#" Value="public void ExecuteRegisteredAsyncTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecuteRegisteredAsyncTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ExecuteRegisteredAsyncTasks" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia a execução de uma tarefa assíncrona.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir uma tarefa assíncrona usando o <xref:System.Web.UI.PageAsyncTask> classe. Depois que a tarefa está definida e está registrada com a página usando o <xref:System.Web.UI.Page.RegisterAsyncTask%2A> método, o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método pode ser chamado para iniciar a tarefa assíncrona.  
  
 O <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método é chamado automaticamente no ponto em que o processamento de página quando qualquer registrado tarefas assíncronas, se existirem, são invocados para uma página não pode ser assíncrona. Essa chamada automática para <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> ocorre imediatamente antes do <xref:System.Web.UI.Page.PreRenderComplete> evento. Chamar o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método para tarefas que você deseja às vezes chamado que não seja a chamada automática para esse método. Observe que tarefas assíncronas serão executadas apenas uma vez, embora <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> pode ser chamado mais de uma vez.  
  
 O <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade é redefinida em todas as chamadas para o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método. O último valor da <xref:System.Web.UI.Page.AsyncTimeout%2A> antes de chamar o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método terá precedência. Se uma tarefa assíncrona demorar mais do que o <xref:System.Web.UI.Page.AsyncTimeout%2A>, invocadas durante as tarefas subsequentes <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> chamada se esgotou imediatamente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade com o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> e <xref:System.Web.UI.Page.RegisterAsyncTask%2A> métodos. Observe o uso de manipuladores de tempo limite de início e final. No exemplo, um atraso artificial é introduzido para demonstrar a situação de uma tarefa assíncrona excedeu o tempo alocado para a tarefa conforme especificado no <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade. Em um cenário do mundo real, uma tarefa assíncrona pode ser usada para realizar chamadas de banco de dados ou a geração de imagem, por exemplo, e o manipulador de tempo limite fornece degradação de forma suave se a tarefa não é executada em um período de tempo especificado.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Há uma exceção na tarefa assíncrona.</exception>
      </Docs>
    </Member>
    <Member MemberName="FileDependencies">
      <MemberSignature Language="C#" Value="protected System.Collections.ArrayList FileDependencies { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ArrayList FileDependencies" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.FileDependencies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is HttpResponse.AddFileDependencies. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.ArrayList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define uma matriz de arquivos que atual <see cref="T:System.Web.HttpResponse" /> objeto depende.</summary>
        <value>A matriz de arquivos atual <see cref="T:System.Web.HttpResponse" /> objeto depende.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade foi substituída. Use o <xref:System.Web.HttpResponse.AddFileDependencies%2A> método ou o <xref:System.Web.HttpResponse.AddFileDependency%2A> método o <xref:System.Web.HttpResponse> classe em vez disso.  
  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `FileDependencies` atributo `true` usando a diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindControl">
      <MemberSignature Language="C#" Value="public override System.Web.UI.Control FindControl (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Web.UI.Control FindControl(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FindControl(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">O identificador do controle a ser encontrado.</param>
        <summary>Procura o contêiner de nomenclatura de página para um controle de servidor com o identificador especificado.</summary>
        <returns>O controle especificado, ou <see langword="null" />, se o controle especificado não existir.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.FindControl%2A> método pode ser usado para acessar um controle cujo <xref:System.Web.UI.Control.ID%2A> não está disponível em tempo de design. O método de pesquisa somente da página imediata ou de nível superior, contêiner; Isso é feito não a pesquisa recursivamente para controles em contêineres de nomenclatura contidos na página. Para acessar os controles em um contêiner de nomenclatura subordinado, chamar o `FindControl` método do contêiner.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.Page.FindControl%2A> método para localizar controles dentro de modelos. Neste exemplo, dois <xref:System.Web.UI.WebControls.Repeater> controles são definidos; cada mostra uma forma diferente para capturar o <xref:System.Web.UI.WebControls.LinkButton.Click> eventos de um <xref:System.Web.UI.WebControls.LinkButton> dentro do modelo de item do repetidor.  
  
 [!code-aspx-csharp[System.Web.UI.Page_FindControl#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/cs/pagefindcontrolcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page_FindControl#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_FindControl/vb/pagefindcontrolvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Form">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlForm Form { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlForm Form" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Form" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlForm</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o formulário HTML da página.</summary>
        <value>O objeto <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> associado à página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.Form%2A> propriedade para acessar os métodos e propriedades do <xref:System.Web.UI.HtmlControls.HtmlForm> objeto que é a base da hierarquia de controle na página.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FrameworkInitialize">
      <MemberSignature Language="C#" Value="protected override void FrameworkInitialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void FrameworkInitialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.FrameworkInitialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa a árvore de controle durante a geração de página de acordo com a natureza declarativa da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.FrameworkInitialize%2A> método inicializa o <xref:System.Web.UI.Page> de objeto e cria a árvore de controle com base na natureza declarativa da página. O <xref:System.Web.UI.Page.FrameworkInitialize%2A> método é substituído pela página de análise e geração de código para o <xref:System.Web.UI.Page> classe para uma página declarativa. Em geral, você deve não sobre a necessidade de substituir esse método. Se a substituição, certifique-se de chamar a classe base <xref:System.Web.UI.Page.FrameworkInitialize%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDataItem">
      <MemberSignature Language="C#" Value="public object GetDataItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetDataItem() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetDataItem" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o item de dados no topo da pilha de contexto de associação de dados.</summary>
        <returns>O objeto no topo da pilha de contexto de vinculação de dados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Não há contexto de associação de dados para a página.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientEvent">
      <MemberSignature Language="C#" Value="public string GetPostBackClientEvent (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientEvent(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientEvent(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle de servidor que recebe a postagem de eventos do cliente.</param>
        <param name="argument">Um <see cref="T:System.String" /> que é passado para <see cref="M:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent(System.String)" />.</param>
        <summary>Obtém uma referência que pode ser usada em um evento de cliente volta para o servidor para o controle especificado e com os argumentos do evento especificado.</summary>
        <returns>A cadeia de caracteres que representa o evento de cliente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte o <xref:System.Web.UI.ClientScriptManager> classe para alternativas para esse membro obsoleto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackClientHyperlink">
      <MemberSignature Language="C#" Value="public string GetPostBackClientHyperlink (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackClientHyperlink(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackClientHyperlink(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackClientHyperlink. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle de servidor para processar o postback.</param>
        <param name="argument">O parâmetro passado para o controle de servidor.</param>
        <summary>Obtém uma referência, com <see langword="javascript:" /> acrescentado ao início, que pode ser usada em um evento de cliente para postback ao servidor do controle especificado e com os argumentos de evento especificados.</summary>
        <returns>Uma cadeia de caracteres que representa uma chamada de JavaScript à função de postback, que inclui os argumentos de evento e de ID do controle de destino.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte o <xref:System.Web.UI.ClientScriptManager.GetPostBackClientHyperlink%2A> método para obter uma alternativa a esse membro preterido.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle de servidor para processar o postback no servidor.</param>
        <summary>Retorna uma cadeia de caracteres que pode ser usada em um evento de cliente para fazer postback no servidor. A cadeia de caracteres de referência é definida pelo objeto <see cref="T:System.Web.UI.Control" /> especificado.</summary>
        <returns>Uma cadeia de caracteres que, quando tratada como script no cliente, inicia o postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método o <xref:System.Web.UI.ClientScriptManager> classe em vez disso.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#2)]
 [!code-vb[Page_GetPostBackEventReference#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetPostBackEventReference">
      <MemberSignature Language="C#" Value="public string GetPostBackEventReference (System.Web.UI.Control control, string argument);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetPostBackEventReference(class System.Web.UI.Control control, string argument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetPostBackEventReference(System.Web.UI.Control,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.GetPostBackEventReference. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
        <Parameter Name="argument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="control">O controle de servidor para processar o postback.</param>
        <param name="argument">O parâmetro passado para o controle de servidor.</param>
        <summary>Retorna uma cadeia de caracteres que pode ser usada em um evento de cliente para fazer postback no servidor. A cadeia de caracteres de referência é definida pelo controle especificado que manipula o postback e um argumento de cadeia de caracteres de informações de evento adicionais.</summary>
        <returns>Uma cadeia de caracteres que, quando tratada como script no cliente, inicia o postback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.GetPostBackEventReference%2A> método o <xref:System.Web.UI.ClientScriptManager> classe em vez disso.  
  
   
  
## Examples  
 [!code-csharp[Page_GetPostBackEventReference#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_GetPostBackEventReference/CS/page_getpostbackeventreference.cs#1)]
 [!code-vb[Page_GetPostBackEventReference#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_GetPostBackEventReference/VB/page_getpostbackeventreference.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetTypeHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetTypeHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetTypeHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um código de hash que é gerado pelo <see cref="T:System.Web.UI.Page" /> objetos que são gerados em tempo de execução. Esse código de hash é exclusivo para o <see cref="T:System.Web.UI.Page" /> hierarquia de controle do objeto.</summary>
        <returns>O código de hash gerado em tempo de execução. O padrão é 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não substitua este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValidators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection GetValidators (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.UI.ValidatorCollection GetValidators(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetValidators(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">O grupo de validação a ser retornado ou <see langword="null" /> para retornar o grupo de validação padrão.</param>
        <summary>Retorna uma coleção de validadores de controle para um grupo de validação especificado.</summary>
        <returns>Um <see cref="T:System.Web.UI.ValidatorCollection" /> que contém os validadores de controle para o grupo de validação especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.GetValidators%2A> método retorna todos os objetos de validação associados a um grupo de validação específico. Você pode retornar o grupo de validação padrão (todos os controles de validação associados a controles sem o `ValidationGroup` conjunto de propriedades), definindo o `validationGroup` parâmetro `null`.  
  
 Para validar os membros do grupo de validação, você pode enumerar sobre a coleta e a chamada a <xref:System.Web.UI.IValidator.Validate%2A> retornado do método de cada validador.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.GetValidators%2A> método para retornar o grupo de validação padrão.  
  
 [!code-csharp[PageGetValidators#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageGetValidators/CS/pagegetvalidatorscs.aspx#1)]
 [!code-vb[PageGetValidators#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageGetValidators/VB/pagegetvalidatorsvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWrappedFileDependencies">
      <MemberSignature Language="C#" Value="protected object GetWrappedFileDependencies (string[] virtualFileDependencies);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object GetWrappedFileDependencies(string[] virtualFileDependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.GetWrappedFileDependencies(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualFileDependencies" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="virtualFileDependencies">Uma matriz de cadeia de caracteres de locais de arquivo virtual.</param>
        <summary>Retorna uma lista de nomes de arquivo físico que corresponde a uma lista de locais de arquivo virtual.</summary>
        <returns>Um objeto que contém uma lista de locais de arquivo físico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.GetWrappedFileDependencies%2A> método obtém uma lista de arquivos, como arquivos de controle de usuário, que compõem a página atual. Se qualquer uma dessas páginas são modificados, a página inteira é compilada na próxima vez que forem solicitados. Não substitua este método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Header">
      <MemberSignature Language="C#" Value="public System.Web.UI.HtmlControls.HtmlHead Header { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.HtmlControls.HtmlHead Header" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Header" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.HtmlControls.HtmlHead</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obterá o cabeçalho do documento da página se o <see langword="head" /> elemento for definido com um <see langword="runat=server" /> na declaração da página.</summary>
        <value>A <see cref="T:System.Web.UI.HtmlControls.HtmlHead" /> que contém o cabeçalho da página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.Header%2A> propriedade obtém uma referência a um <xref:System.Web.UI.HtmlControls.HtmlHead> que você pode usar para definir as informações de cabeçalho do documento para a página do objeto. O <xref:System.Web.UI.HtmlControls.HtmlHead> permite que você adicione informações como folhas de estilo, regras de estilo, um título e os metadados para o `head` elemento.  
  
> [!NOTE]
>  Adicionar estilos programaticamente usando os métodos do <xref:System.Web.UI.IStyleSheet> não há suporte para a interface durante postbacks assíncronos. Quando você adiciona recursos AJAX a uma página da Web, postbacks assíncronos atualizar regiões da página sem atualizar a página inteira. Para obter mais informações, consulte [visão geral do Microsoft Ajax](http://msdn.microsoft.com/library/be84d9b3-b7cd-47d7-8494-be4abfaad9cb).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como acessar o <xref:System.Web.UI.HtmlControls.HtmlHead> controlar programaticamente usando o <xref:System.Web.UI.Page.Header%2A> propriedade. Um `title` elemento e `style` elemento são adicionados para o `head` elemento da página.  
  
 [!code-aspx-csharp[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/CS/htmlheadclasscs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.HtmlControls.HtmlHeadClass#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.HtmlControls.HtmlHeadClass/VB/htmlheadclassvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ID">
      <MemberSignature Language="C#" Value="public override string ID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um identificador para uma instância específica da classe <see cref="T:System.Web.UI.Page" />.</summary>
        <value>O identificador para a instância da classe <see cref="T:System.Web.UI.Page" />. O valor padrão é “_Page”.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IdSeparator">
      <MemberSignature Language="C#" Value="public virtual char IdSeparator { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char IdSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IdSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caractere usado para separar os identificadores de controle ao criar uma ID exclusiva para um controle em uma página.</summary>
        <value>O caractere usado para separar os identificadores de controle. O padrão é definido pela <see cref="T:System.Web.UI.Adapters.PageAdapter" /> instância que processa a página. O <see cref="P:System.Web.UI.Page.IdSeparator" /> é um campo do lado do servidor e não deve ser modificado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitComplete">
      <MemberSignature Language="C#" Value="public event EventHandler InitComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler InitComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.InitComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorrerá quando a inicialização da página for concluída.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.InitComplete> evento é chamado no final do estágio de inicialização da página. Neste estágio do ciclo de vida da página, todos declarados controles na página são inicializados, mas o estado da página ainda não está preenchido. Você pode acessar os controles de servidor, mas eles ainda não conterá informações retornadas do usuário.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeCulture">
      <MemberSignature Language="C#" Value="protected virtual void InitializeCulture ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitializeCulture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitializeCulture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o <see cref="P:System.Web.UI.Page.Culture" /> e <see cref="P:System.Web.UI.Page.UICulture" /> para o thread atual da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.InitializeCulture%2A> método não contém nenhuma lógica de codificação. Controlar os desenvolvedores estender a funcionalidade do <xref:System.Web.UI.Page> classe pode substituir o <xref:System.Web.UI.Page.InitializeCulture%2A> método para inicializar o <xref:System.Web.UI.Page.Culture%2A> e <xref:System.Web.UI.Page.UICulture%2A> informações para a página.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InitOutputCache">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa o cache de saída para a solicitação de página atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não se destina a ser usado diretamente no seu código. Para habilitar e manipular o cache de saída para uma página, use uma destas abordagens:  
  
-   Definir opções declarativamente usando a diretiva no arquivo. aspx.  
  
-   Use os métodos e propriedades do <xref:System.Web.HttpCachePolicy> classe, que é exposto pelo `Response.Cache` objeto no código da página.  
  
 Para obter mais informações, consulte [Caching ASP.NET Pages](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (System.Web.UI.OutputCacheParameters cacheSettings);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void InitOutputCache(class System.Web.UI.OutputCacheParameters cacheSettings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Web.UI.OutputCacheParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheSettings" Type="System.Web.UI.OutputCacheParameters" />
      </Parameters>
      <Docs>
        <param name="cacheSettings">Um <see cref="T:System.Web.UI.OutputCacheParameters" /> que contém as configurações de cache.</param>
        <summary>Inicializa o cache de saída para a solicitação de página atual com base em um <see cref="T:System.Web.UI.OutputCacheParameters" /> objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não deve chamar esse método. Para habilitar e manipular o cache de saída para uma página, use ou a diretiva no arquivo. aspx, ou os métodos e propriedades da <xref:System.Web.HttpCachePolicy> classe. O segundo é acessível por meio de `Response.Cache` sintaxe no arquivo de bloco ou code-behind de declaração de código da página. Para obter mais informações, consulte [Caching ASP.NET Pages](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O perfil de cache não foi encontrado.  
  
 \- ou -  
  
 Atributo de perfil de uma diretiva ausente ou as definições de configuração.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O local de configurações de cache de saída é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">A quantidade de tempo que os objetos armazenados no cache de saída são válidos.</param>
        <param name="varyByHeader">Uma lista separada por ponto e vírgula de cabeçalhos de conteúdo do cache de saída variam por.</param>
        <param name="varyByCustom">O <see langword="Vary" /> cabeçalho HTTP.</param>
        <param name="location">Um dos valores de <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Uma lista separada por vírgulas de parâmetros recebidos por um método GET ou POST que o conteúdo do cache de saída variam por.</param>
        <summary>Inicializa o cache de saída para a solicitação de página atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não deve chamar esse método. Para habilitar e manipular o cache de saída para uma página, use ou a diretiva no arquivo. aspx, ou os métodos e propriedades da <xref:System.Web.HttpCachePolicy> classe. O segundo é acessível por meio de `Response.Cache` sintaxe no código da página. Para obter mais informações, consulte [Caching ASP.NET Pages](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor inválido é especificado para <paramref name="location" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InitOutputCache">
      <MemberSignature Language="C#" Value="protected virtual void InitOutputCache (int duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, System.Web.UI.OutputCacheLocation location, string varyByParam);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InitOutputCache(int32 duration, string varyByContentEncoding, string varyByHeader, string varyByCustom, valuetype System.Web.UI.OutputCacheLocation location, string varyByParam) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.InitOutputCache(System.Int32,System.String,System.String,System.String,System.Web.UI.OutputCacheLocation,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="duration" Type="System.Int32" />
        <Parameter Name="varyByContentEncoding" Type="System.String" />
        <Parameter Name="varyByHeader" Type="System.String" />
        <Parameter Name="varyByCustom" Type="System.String" />
        <Parameter Name="location" Type="System.Web.UI.OutputCacheLocation" />
        <Parameter Name="varyByParam" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="duration">A quantidade de tempo que os objetos armazenados no cache de saída são válidos.</param>
        <param name="varyByContentEncoding">Uma lista separada por ponto e vírgula-de conjuntos de caracteres (codificações de conteúdo) que o conteúdo do cache de saída variam por.</param>
        <param name="varyByHeader">Uma lista separada por ponto e vírgula de cabeçalhos de conteúdo do cache de saída variam por.</param>
        <param name="varyByCustom">O <see langword="Vary" /> cabeçalho HTTP.</param>
        <param name="location">Um dos valores de <see cref="T:System.Web.UI.OutputCacheLocation" />.</param>
        <param name="varyByParam">Uma lista separada por vírgulas de parâmetros recebidos por um método GET ou POST que o conteúdo do cache de saída variam por.</param>
        <summary>Inicializa o cache de saída para a solicitação de página atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não deve chamar esse método. Para habilitar e manipular o cache de saída para uma página, use a diretiva ou o arquivo. aspx, ou métodos e propriedades da <xref:System.Web.HttpCachePolicy> classe. O segundo é acessível por meio de `Response.Cache` sintaxe no código da página. Para obter mais informações, consulte [Caching ASP.NET Pages](http://msdn.microsoft.com/library/e9666a1b-88df-4931-af0b-a754fc65660b).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Um valor inválido é especificado para <paramref name="location" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAsync">
      <MemberSignature Language="C#" Value="public bool IsAsync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAsync" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsAsync" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a página é processada de forma assíncrona.</summary>
        <value>
          <see langword="true" /> se a página estiver no modo assíncrono. caso contrário, <see langword="false" />;</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.IsAsync%2A> propriedade para determinar se a página da Web está em execução no modo assíncrono. Essas informações são úteis se precisar de código na página ou controles modificar seu comportamento dependendo se a página é assíncrona. Para obter mais informações sobre a programação assíncrona, consulte [operações assíncronas](~/docs/framework/data/adonet/sql/asynchronous-operations.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCallback">
      <MemberSignature Language="C#" Value="public bool IsCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCallback" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a solicitação de página é resultado de um retorno de chamada.</summary>
        <value>
          <see langword="true" /> se a solicitação de página for resultado de um retorno de chamada; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações, consulte [implementando retornos de chamada de cliente sem Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientScriptBlockRegistered">
      <MemberSignature Language="C#" Value="public bool IsClientScriptBlockRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsClientScriptBlockRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsClientScriptBlockRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsClientScriptBlockRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">A chave de cadeia de caracteres do script de cliente a ser pesquisada.</param>
        <summary>Determina se o bloco de script de cliente com a chave especificada está registrado com a página.</summary>
        <returns>
          <see langword="true" /> se o bloco de script estiver registrado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método antes de chamar <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A?displayProperty=nameWithType> para evitar desnecessariamente montando o script do lado do cliente. Isso é particularmente importante se o script requer uma grande quantidade de recursos de servidor para criar.  
  
 O método <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.IsClientScriptBlockRegistered%2A> método o <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> método junto com o <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> método. Se o ECMAScript gravado no bloco de declaração de código não já foi registrado, conforme determinado pela <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, em seguida, um <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> chamada é feita.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCrossPagePostBack">
      <MemberSignature Language="C#" Value="public bool IsCrossPagePostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCrossPagePostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsCrossPagePostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a página está envolvida em um postback entre páginas.</summary>
        <value>
          <see langword="true" /> se a página estiver participando de uma solicitação entre páginas; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ASP.NET fornece dois mecanismos para transferir o controle de uma página para outra. Você pode usar o <xref:System.Web.HttpServerUtility.Transfer%2A> método para transferir o processamento entre páginas, ou você pode fazer uma solicitação de página atribuindo uma URL de página para o <xref:System.Web.UI.WebControls.IButtonControl.PostBackUrl%2A> propriedade de um controle de botão que implementa o <xref:System.Web.UI.WebControls.IButtonControl> interface.  
  
 Em ambos os casos, o <xref:System.Web.UI.Page.PreviousPage%2A> propriedade página conterá um objeto que representa a página anterior ou originador. Se, por exemplo, Page A envia para a página, Page A de B <xref:System.Web.UI.Page.IsCrossPagePostBack%2A> propriedade (acessível por meio de <xref:System.Web.UI.Page.PreviousPage%2A> propriedade) será `true` e página B <xref:System.Web.UI.Page.PreviousPage%2A> propriedade terá o nome do Page A.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostBack">
      <MemberSignature Language="C#" Value="public bool IsPostBack { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a página está sendo renderizada pela primeira vez ou está sendo carregada em resposta a um postback.</summary>
        <value>
          <see langword="true" /> se a página estiver sendo carregada em resposta a um postback do cliente; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma explicação da diferença entre postbacks e retornos de chamada, consulte [implementando retornos de chamada de cliente sem Postbacks](http://msdn.microsoft.com/library/dfaaa7d4-e1f2-4322-b2f5-796e0419f185).  
  
   
  
## Examples  
 O exemplo a seguir mostra como testar o valor de <xref:System.Web.UI.Page.IsPostBack%2A> propriedade quando a página for carregada para determinar se a página está sendo processada pela primeira vez ou se está respondendo a um postback. Se a página está sendo processada pela primeira vez, o código chama o <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> método.  
  
 A marcação de página (não mostrada) contém <xref:System.Web.UI.WebControls.RequiredFieldValidator> controles que exibem os asteriscos se nenhuma entrada for feita para um campo de entrada necessário. Chamando <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> faz com que os asteriscos seja exibido imediatamente quando a página é processada, em vez de aguardar até que o usuário clica no botão Enviar. Após um postback, você não precisa chamar <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType>, pois esse método é chamado como parte do <xref:System.Web.UI.Page> ciclo de vida.  
  
 [!code-csharp[System.Web.UI.Page.Validate#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#1)]
 [!code-vb[System.Web.UI.Page.Validate#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPostBackEventControlRegistered">
      <MemberSignature Language="C#" Value="public bool IsPostBackEventControlRegistered { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPostBackEventControlRegistered" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsPostBackEventControlRegistered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o controle na página que executa postbacks foi registrado.</summary>
        <value>
          <see langword="true" /> se o controle tiver sido registrado; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReusable">
      <MemberSignature Language="C#" Value="public bool IsReusable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReusable" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsReusable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Web.UI.Page" /> objeto pode ser reutilizado.</summary>
        <value>
          <see langword="false" /> em todos os casos.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStartupScriptRegistered">
      <MemberSignature Language="C#" Value="public bool IsStartupScriptRegistered (string key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsStartupScriptRegistered(string key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.IsStartupScriptRegistered(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.IsStartupScriptRegistered(string key). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">A chave de cadeia de caracteres do script de inicialização a ser pesquisada.</param>
        <summary>Determina se o script de inicialização do cliente está registrado com o objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>
          <see langword="true" /> se o script de inicialização está registrado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método antes de chamar <xref:System.Web.UI.Page.RegisterStartupScript%2A?displayProperty=nameWithType> para evitar desnecessariamente montando o script do lado do cliente. Isso é particularmente importante se o script requer uma grande quantidade de recursos de servidor para criar.  
  
 O método <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.IsStartupScriptRegistered%2A> método o <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.Page.RegisterStartupScript%2A> método junto com o <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> método. Se o ECMAScript gravado no bloco de declaração de código não já foi registrado, conforme determinado pela <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A>, em seguida, um <xref:System.Web.UI.Page.RegisterStartupScript%2A> chamada é feita.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValid">
      <MemberSignature Language="C#" Value="public bool IsValid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValid" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.IsValid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a validação da página foi bem-sucedida.</summary>
        <value>
          <see langword="true" /> se a validação da página for bem-sucedida; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para essa propriedade retornar `true`, todos os controles de servidor de validação no grupo de validação atual devem validar com êxito. Você deve verificar essa propriedade somente depois de ter chamado o <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> método ou conjunto o `CausesValidation` propriedade `true` no `OnServerClick` manipulador de eventos para um controle de servidor ASP.NET que inicia o processamento do formulário. Esses controles de servidor incluem o <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.HtmlControls.HtmlButton>, <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, <xref:System.Web.UI.WebControls.ImageButton>, e <xref:System.Web.UI.WebControls.LinkButton> classes.  
  
 Se você forçar a validação de um grupo de validação usando o <xref:System.Web.UI.Page.Validate%2A> método e, em seguida, todos os controles de validação no grupo de validação especificada devem validar com sucesso também.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.Page.IsValid%2A> propriedade para configurar uma instrução condicional. Se a propriedade retornar `true`, o `Text` propriedade o `lblOutput` controle é definido como "A página é válida!" Caso contrário, ele é definido como "Alguns dos campos obrigatórios estão vazios."  
  
 [!code-csharp[System.Web.UI.Page.Validate#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate/CS/validate.cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Validate#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate/VB/validate.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">A propriedade <see cref="P:System.Web.UI.Page.IsValid" /> é chamada antes da validação ocorrer.</exception>
      </Docs>
    </Member>
    <Member MemberName="Items">
      <MemberSignature Language="C#" Value="public System.Collections.IDictionary Items { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IDictionary Items" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Items" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma lista de objetos armazenados no contexto da página.</summary>
        <value>Uma referência a um <see cref="T:System.Collections.IDictionary" /> que contém os objetos armazenados no contexto da página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.Items%2A> propriedade para armazenar objetos com a mesma duração que a solicitação de página. Essa propriedade é somente leitura; No entanto, você pode adicionar objetos para o <xref:System.Collections.IDictionary> retorna do objeto.  
  
 Objetos adicionados ao <xref:System.Web.UI.Page.Items%2A> propriedade estão disponíveis em todo o tempo de vida da página, assim você pode adicionar objetos para o <xref:System.Web.UI.Page.Items%2A> propriedade nos eventos de vida da página no início do ciclo e acessar os objetos nos eventos posteriores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LCID">
      <MemberSignature Language="C#" Value="public int LCID { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LCID" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.LCID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define o identificador de localidade para o <see cref="T:System.Threading.Thread" /> objeto associado à página.</summary>
        <value>O identificador de localidade para passar para o <see cref="T:System.Threading.Thread" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. O `LCID` atributo pode ser definido na diretiva de arquivo. aspx, no entanto, o método preferencial de definir o identificador de localidade é através do uso do <xref:System.Web.UI.Page.Culture%2A> e <xref:System.Web.UI.Page.UICulture%2A> propriedades.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadComplete">
      <MemberSignature Language="C#" Value="public event EventHandler LoadComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LoadComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.LoadComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre no final do estágio de carregamento do ciclo de vida da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.LoadComplete> evento ocorre depois de postback todos os dados e dados de estado de exibição são carregados para a página e depois o <xref:System.Web.UI.Control.OnLoad%2A> método foi chamado para todos os controles na página.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadPageStateFromPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual object LoadPageStateFromPersistenceMedium ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object LoadPageStateFromPersistenceMedium() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.LoadPageStateFromPersistenceMedium" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Carrega todas as informações de estado de exibição salvas no objeto <see cref="T:System.Web.UI.Page" />.</summary>
        <returns>O estado de exibição salvo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> método usa o <xref:System.Web.UI.PageStatePersister.Load%2A> método o <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> objeto referenciado pelo <xref:System.Web.UI.Page.PageStatePersister%2A> propriedade ao carregar qualquer salva informações de estado de exibição para o <xref:System.Web.UI.Page> objeto.  
  
 O ASP.NET inclui dois descendentes do <xref:System.Web.UI.PageStatePersister> classe, o <xref:System.Web.UI.HiddenFieldPageStatePersister> classe que salva informações de estado de um campo oculto incluído na página do ASP.NET, e o <xref:System.Web.UI.SessionPageStatePersister> classe que salva o estado no <xref:System.Web.UI.Page.Session%2A> objeto associado à solicitação.  
  
 Para salvar o estado no local de sua escolha, você deve criar um novo descendente do <xref:System.Web.UI.PageStatePersister> classe salva e carrega o estado para a mídia de persistência de sua escolha. Para obter um exemplo de criação de um novo <xref:System.Web.UI.PageStatePersister> de objeto, consulte o <xref:System.Web.UI.PageStatePersister> classe.  
  
 Se você estiver usando o .NET Framework versão 1.0 ou 1.1, substitua este método se você deseja carregar o <xref:System.Web.UI.Page> estado de qualquer coisa diferente de um campo oculto. Se você optar por fazer isso, você também deve substituir o <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaintainScrollPositionOnPostBack">
      <MemberSignature Language="C#" Value="public bool MaintainScrollPositionOnPostBack { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaintainScrollPositionOnPostBack" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaintainScrollPositionOnPostBack" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o usuário retornará para a mesma posição no navegador do cliente após o postback. Essa propriedade substitui a propriedade obsoleta <see cref="P:System.Web.UI.Page.SmartNavigation" />.</summary>
        <value>
          <see langword="true" /> para manter a posição do cliente; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando páginas da Web são postadas no servidor, o usuário é retornado para a parte superior da página. Em páginas da Web longo, isso significa que o usuário tem que rolar a página de volta para a última posição na página.  
  
 Quando o <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> está definida como `true`, o usuário é voltará para a última posição na página.  
  
 Definir o <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> propriedade o [@ Page](http://msdn.microsoft.com/en-us/f06cf9e5-22bb-461d-8b8f-549e53ff40a4) diretiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MapPath">
      <MemberSignature Language="C#" Value="public string MapPath (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MapPath(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.MapPath(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Um <see cref="T:System.String" /> que representa um caminho virtual.</param>
        <summary>Recupera o caminho físico que mapeia um caminho virtual, relativo ou absoluto ou um caminho relativo do aplicativo.</summary>
        <returns>O caminho físico associado ao caminho virtual ou um caminho relativo do aplicativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  O <xref:System.Web.UI.Page.MapPath%2A> propriedade pode conter informações confidenciais sobre o ambiente de hospedagem. O valor de retorno não deve ser exibido aos usuários.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Page.MapPath%2A> método para obter o caminho físico de uma subpasta. Ele, em seguida, anexa o nome de arquivo que é lidos a partir de <xref:System.Web.UI.WebControls.TextBox.Text%2A> propriedade de um <xref:System.Web.UI.WebControls.TextBox> controle. O resultado é o caminho físico absoluto para o arquivo.  
  
 [!code-csharp[Page_MapPath_ResponseEncoding#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/CS/page_mappath_responseencoding.cs.aspx#1)]
 [!code-vb[Page_MapPath_ResponseEncoding#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_MapPath_ResponseEncoding/VB/page_mappath_responseencoding.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Master">
      <MemberSignature Language="C#" Value="public System.Web.UI.MasterPage Master { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.MasterPage Master" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Master" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.MasterPage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a página mestra que determina a aparência geral da página.</summary>
        <value>O <see cref="T:System.Web.UI.MasterPage" /> associado a esta página, se existir; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.Master%2A> propriedade retorna o <xref:System.Web.UI.MasterPage> objeto associado a esta página. Essa propriedade é somente leitura; No entanto, você pode definir propriedades no <xref:System.Web.UI.MasterPage> retorna do objeto.  
  
 O <xref:System.Web.UI.Page.Master%2A> propriedade só é válida em páginas que fazem referência a uma página mestra a <xref:System.Web.UI.Page.MasterPageFile%2A> propriedade. Se você acessar o <xref:System.Web.UI.Page.Master%2A> propriedade em uma página que não faz referência a uma página mestra, `null` será retornado. O conteúdo de uma página mestra não está disponível até que o <xref:System.Web.UI.Page.PreInit> evento foi gerado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MasterPageFile">
      <MemberSignature Language="C#" Value="public virtual string MasterPageFile { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MasterPageFile" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MasterPageFile" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o caminho virtual da página mestra.</summary>
        <value>O caminho virtual da página mestra.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.MasterPageFile%2A> propriedade é um caminho virtual (a partir da raiz do aplicativo) do arquivo de página mestra associado a esta página. O <xref:System.Web.UI.Page.MasterPageFile%2A> propriedade pode ser definida apenas no <xref:System.Web.UI.Page.PreInit> evento; a tentativa de definir o <xref:System.Web.UI.Page.MasterPageFile%2A> propriedade após o <xref:System.Web.UI.Page.PreInit> evento lançará um <xref:System.InvalidOperationException> exceção. Se o <xref:System.Web.UI.Page.MasterPageFile%2A> propriedade não é válida, uma exceção do tipo <xref:System.Web.HttpException> é lançada posteriormente no ciclo de vida da página, mas nenhuma exceção é lançada quando a propriedade é definida <xref:System.Web.UI.Page.PreInit> evento.  
  
 Páginas que têm o <xref:System.Web.UI.Page.MasterPageFile%2A> conjunto de propriedades são páginas de conteúdo e, portanto, pode conter controles somente de nível superior que são <xref:System.Web.UI.WebControls.Content> controles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.Page.MasterPageFile" /> é definida após o evento <see cref="E:System.Web.UI.Page.PreInit" /> ser concluído.</exception>
        <exception cref="T:System.Web.HttpException">O arquivo especificado na propriedade <see cref="P:System.Web.UI.Page.MasterPageFile" /> não existe.  
  
 \- ou -  
  
 A página não tem um controle <see cref="T:System.Web.UI.WebControls.Content" /> como o controle de nível superior.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxPageStateFieldLength">
      <MemberSignature Language="C#" Value="public int MaxPageStateFieldLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxPageStateFieldLength" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MaxPageStateFieldLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o comprimento máximo do campo de estado da página.</summary>
        <value>O comprimento máximo, em bytes, do campo de estado da página. O padrão é -1.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propriedade é definida como um número positivo, o estado de exibição enviado para o navegador do cliente é dividido em vários campos ocultos e cada valor de campo é menor que o tamanho especificado no <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propriedade.  
  
 Definindo o <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propriedade com um número negativo (o padrão) indica que o campo de estado de exibição não deverá ser separado em partes. Definir o <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> como um número pequeno pode resultar em baixo desempenho.  
  
 Defina o valor da <xref:System.Web.UI.Page.MaxPageStateFieldLength%2A> propriedade no do arquivo Web. config.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A propriedade <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> não é igual a -1 ou a um número positivo.</exception>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.Page.MaxPageStateFieldLength" /> foi definida após a página ter sido inicializada.</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaDescription">
      <MemberSignature Language="C#" Value="public string MetaDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaDescription" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o conteúdo do elemento <see langword="meta" /> da “descrição”.</summary>
        <value>O conteúdo do elemento <see langword="meta" /> da “descrição”.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementos podem ser usados para melhorar o mecanismo de pesquisa. "Descrição" `meta` elemento é usado por alguns mecanismos de pesquisa para melhorar as visualizações de lista.  
  
 Se não houver nenhuma "Descrição" `meta` elemento o `head` elemento de marcação da página, o `meta` elemento é adicionado à página quando a página é renderizada. Se a marcação de página já tem uma "Descrição" `meta` elemento, essa propriedade obtém ou define o `content` atributo o `meta` elemento.  
  
 Você também pode definir essa propriedade na diretiva.  
  
   
  
## Examples  
 Se você definir o <xref:System.Web.UI.Page.MetaDescription%2A> propriedade de uma página "Visão geral do ASP.NET", o seguinte elemento será exibido no HTML renderizado:  
  
 `<meta name="description" content="ASP.NET Overview" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A página não tem um controle de cabeçalho (um elemento <see langword="head" /> com o atributo <see langword="runat" /> definido como “servidor”).</exception>
      </Docs>
    </Member>
    <Member MemberName="MetaKeywords">
      <MemberSignature Language="C#" Value="public string MetaKeywords { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MetaKeywords" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.MetaKeywords" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o conteúdo do elemento <see langword="meta" /> de “palavras-chave”.</summary>
        <value>O conteúdo do elemento <see langword="meta" /> de “palavras-chave”.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML `meta` elementos podem ser usados para melhorar o mecanismo de pesquisa. "keywords" `meta` elemento não for usado em todos os ou recebe um peso muito pouco por principais mecanismos de pesquisa.  
  
 Se não houver nenhuma "palavra-chave" `meta` elemento o `head` elemento de marcação da página, o `meta` elemento é adicionado à página quando a página é renderizada. Se a marcação de página já tem um "palavras-chave" `meta` elemento, essa propriedade obtém ou define o `content` atributo o `meta` elemento.  
  
 Você também pode definir essa propriedade na diretiva.  
  
   
  
## Examples  
 Se você definir o <xref:System.Web.UI.Page.MetaKeywords%2A> propriedade de uma página para "HTML, CSS, XML, JavaScript", o seguinte elemento será exibido no HTML renderizado:  
  
 `<meta name="keywords" content=" HTML,CSS,XML,JavaScript" />`  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A página não tem um controle de cabeçalho (um elemento <see langword="head" /> com o atributo <see langword="runat" /> definido como “servidor”).</exception>
      </Docs>
    </Member>
    <Member MemberName="ModelBindingExecutionContext">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelBindingExecutionContext ModelBindingExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelBindingExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelBindingExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o contexto de execução de associação de modelo.</summary>
        <value>O contexto de execução de associação de modelo. Se o contexto de execução de associação de modelo é <see langword="null" />, uma nova é criada e retornada.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModelState">
      <MemberSignature Language="C#" Value="public System.Web.ModelBinding.ModelStateDictionary ModelState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.ModelBinding.ModelStateDictionary ModelState" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ModelState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ModelBinding.ModelStateDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto de dicionário de estado de modelo que contém o estado do modelo e da validação de associação de modelo.</summary>
        <value>O objeto de dicionário de estado de modelo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para uma série de tutoriais sobre como usar a associação de modelo com formulários da Web, consulte [modelo de associação e formulários da Web](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected override void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Web.UI.Control.Init" /> para inicializar a página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.OnInit%2A> método executa as etapas de inicialização e configuração necessárias para criar um <xref:System.Web.UI.Page> instância. Neste estágio do ciclo de vida da página, os controles de servidor declarado na página são inicializados ao seu estado padrão. No entanto, o estado de exibição de cada controle não é populado ainda. Um controle na página não é possível acessar outros controles de servidor na página durante a `Page_Init` fase, independentemente se os outros controles são controles filho ou pai. Não há garantia de que outros controles de servidor ser criado e está pronto para acesso.  
  
 O <xref:System.Web.UI.Page.OnInit%2A> método é chamado após o <xref:System.Web.UI.Page.OnPreInit%2A> método e antes do <xref:System.Web.UI.Page.OnInitComplete%2A> método.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [Eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Web.UI.Page.OnInit%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Web.UI.Page.OnInit(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnInitComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnInitComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.Page.InitComplete" /> após a inicialização da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.OnInitComplete%2A> método é chamado após a conclusão da inicialização da página. Neste estágio do ciclo de vida da página, todos declarados controles na página são inicializados, mas o estado de exibição da página ainda não está preenchido. Você pode acessar os controles de servidor, mas eles ainda não conterá informações retornadas do usuário.  
  
 O <xref:System.Web.UI.Page.OnInitComplete%2A> método ocorre no final de <xref:System.Web.UI.Page> estágio de inicialização e antes do estágio de carga.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [Eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Web.UI.Page.OnInitComplete%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Web.UI.Page.OnInitComplete(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLoadComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnLoadComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoadComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.Page.LoadComplete" /> no final do estágio de carregamento da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.OnLoadComplete%2A> método é chamado no final do estágio de carregamento de página. Neste ponto do ciclo de vida da página, todos os dados de postagem e dados de estado de exibição é carregado em controles na página.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [NIB: gerar um evento](http://msdn.microsoft.com/en-us/f2adaf01-1ed1-42e1-8c31-8d467e7e0ee2).  
  
 O <xref:System.Web.UI.Page.OnLoadComplete%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Web.UI.Page.OnLoadComplete(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreInit">
      <MemberSignature Language="C#" Value="protected virtual void OnPreInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.Page.PreInit" /> no início da inicialização da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.OnPreInit%2A> método é chamado no início do estágio de inicialização de página.  
  
 Após o <xref:System.Web.UI.Page.OnPreInit%2A> método é chamado, informações de personalização são carregadas e o tema da página, se houver, é inicializado. Isso também é o estágio preferencial para definir dinamicamente um <xref:System.Web.UI.PageTheme> ou <xref:System.Web.UI.MasterPage> para a página.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [Eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Web.UI.Page.OnPreInit%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Web.UI.Page.OnPreInit(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnPreLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.Page.PreLoad" /> após os dados de postback serem carregados nos controles de servidor de página, mas antes do evento <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.OnPreLoad%2A> método é chamado postback depois que todos os dados retornados do usuário são carregados. Neste estágio do ciclo de vida da página, as informações de estado de exibição e dados de postagem para declarado controles e criado durante o estágio de inicialização são carregados nos controles da página.  
  
 Os controles criados no <xref:System.Web.UI.Page.OnPreLoad%2A> método também será carregado com dados de postagem e estado de exibição.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [Eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Web.UI.Page.OnPreLoad%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Web.UI.Page.OnPreLoad(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnPreRenderComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnPreRenderComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPreRenderComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Gera o evento <see cref="E:System.Web.UI.Page.PreRenderComplete" /> após o evento <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> e antes que a página seja processada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.OnPreRenderComplete%2A> método é chamado quando o estágio de pré-processamento do ciclo de vida da página é concluído. Neste estágio do ciclo de vida da página, todos os controles são criados e a página está pronta para processar a saída.  
  
 Este é o último evento chamado antes que o estado de exibição da página é salvo.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [Eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Web.UI.Page.OnPreRenderComplete%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Web.UI.Page.OnPreRenderComplete(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSaveStateComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnSaveStateComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSaveStateComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um objeto <see cref="T:System.EventArgs" /> que contém os dados de eventos.</param>
        <summary>Gera o <see cref="E:System.Web.UI.Page.SaveStateComplete" /> evento após o estado da página foi salvo na mídia de persistência.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.OnSaveStateComplete%2A> método é chamado quando as informações de estado para o controle foram gravadas para a mídia de persistência para a página. As informações de estado são gravadas na mídia de persistência chamando o <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> método.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [Eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Web.UI.Page.OnSaveStateComplete%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Web.UI.Page.OnSaveStateComplete(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="public System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o adaptador que renderiza a página para o navegador solicitante específico.</summary>
        <value>O <see cref="T:System.Web.UI.Adapters.PageAdapter" /> que renderiza a página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.PageAdapter%2A> propriedade retorna específico <xref:System.Web.UI.Adapters.PageAdapter> que modifica o comportamento do objeto de <xref:System.Web.UI.Page> objeto para o navegador solicitante.  
  
 Específico <xref:System.Web.UI.Adapters.PageAdapter> objeto é determinado pelo exame características de entrada <xref:System.Web.UI.Page.Request%2A> objeto. Quando um adaptador é escolhido para a solicitação, quaisquer eventos de ciclo de vida no <xref:System.Web.UI.Adapters.PageAdapter> objeto substituir os eventos correspondentes no <xref:System.Web.UI.Page> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PageStatePersister">
      <MemberSignature Language="C#" Value="protected virtual System.Web.UI.PageStatePersister PageStatePersister { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.PageStatePersister PageStatePersister" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PageStatePersister" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.UI.PageStatePersister</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.UI.PageStatePersister" /> associado à página.</summary>
        <value>Um <see cref="T:System.Web.UI.PageStatePersister" /> associado à página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Solicitações e respostas HTTP são inerentemente sem monitoração de estado. Para manter o estado entre as solicitações HTTP, páginas de servidor ASP.NET podem armazenar <xref:System.Web.UI.Page> estado. Nesse estado, chamado de estado de exibição, consiste em página e as configurações de controle e os dados que tornam os controles que aparecem como se eles são os mesmos que o usuário ver e interagir com em seu último ida e volta para a página e a página. Existem vários mecanismos para armazenar o estado de exibição entre as solicitações sucessivas para a mesma página. O resumo <xref:System.Web.UI.PageStatePersister> classe representa a classe base para esses mecanismos de armazenamento de estado.  
  
 Os desenvolvedores de página geralmente não serão necessário usar o <xref:System.Web.UI.Page.PageStatePersister%2A> propriedade. O <xref:System.Web.UI.Page.PageStatePersister%2A> propriedade é usada principalmente por desenvolvedores de controle estender a funcionalidade do <xref:System.Web.UI.Page> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="postEventArgumentID">
      <MemberSignature Language="C#" Value="public const string postEventArgumentID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventArgumentID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventArgumentID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uma cadeia de caracteres que define o campo oculto EVENTARGUMENT na página renderizada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="postEventSourceID">
      <MemberSignature Language="C#" Value="public const string postEventSourceID;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal string postEventSourceID" />
      <MemberSignature Language="DocId" Value="F:System.Web.UI.Page.postEventSourceID" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Uma cadeia de caracteres que define o campo oculto EVENTTARGET na página renderizada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreInit">
      <MemberSignature Language="C#" Value="public event EventHandler PreInit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreInit" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreInit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes da inicialização da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento permite que você verifique condições da solicitação de página, como se a página está sendo carregada em resposta a um postback. Você também pode verificar os valores das propriedades de perfil.  
  
 O evento permite que você defina os valores que são usados mais tarde no ciclo de vida da página. Dinamicamente, você pode definir uma página mestra ou um tema para a página solicitada e criar controles dinâmicos.  
  
 Para obter mais informações sobre como o <xref:System.Web.UI.Page.PreInit> evento adapta o ciclo de vida do ASP.NET, consulte [visão geral do ciclo de vida de página ASP.NET](http://msdn.microsoft.com/library/7949d756-1a79-464e-891f-904b1cfc7991).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreLoad">
      <MemberSignature Language="C#" Value="public event EventHandler PreLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreLoad" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreLoad" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes do evento <see cref="E:System.Web.UI.Control.Load" /> da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.PreLoad> evento é gerado depois que todos os dados de processamento de postback e antes do <xref:System.Web.UI.Control.Load> evento. Há uma segunda tentativa para carregar dados de postagem antes do <xref:System.Web.UI.Page.OnLoadComplete%2A> evento. Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreRenderComplete">
      <MemberSignature Language="C#" Value="public event EventHandler PreRenderComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PreRenderComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.PreRenderComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes do conteúdo da página ser renderizado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.PreRenderComplete> é gerado quando o estágio de pré-processamento do ciclo de vida da página está concluído. Neste estágio do ciclo de vida da página, todos os controles são criados, qualquer paginação necessária é concluída e a página está pronta para processar para a saída.  
  
 Este é o último evento gerado antes do estado de exibição da página é salvo.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [NIB: consumindo eventos](http://msdn.microsoft.com/en-us/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviousPage">
      <MemberSignature Language="C#" Value="public System.Web.UI.Page PreviousPage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page PreviousPage" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.PreviousPage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a página que transferiu o controle para a página atual.</summary>
        <value>O <see cref="T:System.Web.UI.Page" /> que representa a página que transferiu o controle para a página atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando você usa o <xref:System.Web.HttpServerUtility.Transfer%2A> método ou use entre páginas de lançamento para transferir o processamento de uma página ASP.NET para outra, a página de origem contém informações de solicitação que podem ser necessárias para a página de destino. Você pode usar o <xref:System.Web.UI.Page.PreviousPage%2A> propriedade para acessar essas informações.  
  
 Se a página atual está sendo processada como resultado de uma solicitação direta (não uma transferência ou post cruzada de outra página), o <xref:System.Web.UI.Page.PreviousPage%2A> propriedade contém `null`.  
  
   
  
## Examples  
 O exemplo a seguir está em duas partes. A primeira é uma página ASP.NET que usa o <xref:System.Web.HttpServerUtility.Transfer%2A> método, exposto no modelo de página como `Server.Transfer("path")`. A segunda parte é a página de destino, que usa o <xref:System.Web.UI.Page.PreviousPage%2A> para alterar o título da primeira página.  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Main.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Main.aspx#1)]  
  
 [!code-aspx-csharp[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/CS/Notify.aspx#2)]
 [!code-aspx-vb[System.Web.UI.Page.PreviousPage#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.PreviousPage/VB/Notify.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O usuário atual não tem permissão para acessar a página anterior.  
  
 -ou-  
  
 O roteamento do ASP.NET está em uso e a URL da página anterior é uma URL roteada. Quando o ASP.NET verifica as permissões de acesso, ele assume que a URL é um caminho real para um arquivo. Como esse não é o caso com uma URL roteada, a verificação falha.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessRequest">
      <MemberSignature Language="C#" Value="public virtual void ProcessRequest (System.Web.HttpContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ProcessRequest(class System.Web.HttpContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.ProcessRequest(System.Web.HttpContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="context" Type="System.Web.HttpContext" />
      </Parameters>
      <Docs>
        <param name="context">Um objeto <see cref="T:System.Web.HttpContext" /> que fornece referências aos objetos intrínsecos do servidor (por exemplo, <see cref="P:System.Web.HttpContext.Request" />, <see cref="P:System.Web.HttpContext.Response" /> e <see cref="P:System.Web.HttpContext.Session" />) usados para atender a solicitações HTTP.</param>
        <summary>Define os objetos do servidor intrínseco do objeto <see cref="T:System.Web.UI.Page" />, como as propriedades <see cref="P:System.Web.UI.Page.Context" />, <see cref="P:System.Web.UI.Page.Request" />, <see cref="P:System.Web.UI.Page.Response" /> e <see cref="P:System.Web.UI.Page.Application" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você não deve chamar esse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaisePostBackEvent">
      <MemberSignature Language="C#" Value="protected virtual void RaisePostBackEvent (System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RaisePostBackEvent(class System.Web.UI.IPostBackEventHandler sourceControl, string eventArgument) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RaisePostBackEvent(System.Web.UI.IPostBackEventHandler,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceControl" Type="System.Web.UI.IPostBackEventHandler" />
        <Parameter Name="eventArgument" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="sourceControl">O controle de servidor ASP.NET que causou o postback. Esse controle deve implementar a interface <see cref="T:System.Web.UI.IPostBackEventHandler" />.</param>
        <param name="eventArgument">O argumento de postback.</param>
        <summary>Notifica o controle de servidor que causou o postback de que ele deve tratar um evento de postback de entrada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page> objeto chama o <xref:System.Web.UI.Page.RaisePostBackEvent%2A> método quando ocorre um postback. Essa chamada ocorre no ciclo de vida da página após a conclusão de carregamento e alterações de notificação, mas antes da ocorrência de pré-processamento.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Web.UI.Page.RaisePostBackEvent%2A> método para notificar o ASP.NET que um evento de pós-back é gerado quando um personalizado `userButton` controle de servidor é clicado.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterArrayDeclaration">
      <MemberSignature Language="C#" Value="public void RegisterArrayDeclaration (string arrayName, string arrayValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterArrayDeclaration(string arrayName, string arrayValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterArrayDeclaration(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterArrayDeclaration(string arrayName, string arrayValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrayName" Type="System.String" />
        <Parameter Name="arrayValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="arrayName">O nome da matriz na qual o valor deverá ser declarado.</param>
        <param name="arrayValue">O valor a ser colocado na matriz.</param>
        <summary>Declara um valor como uma declaração de matriz ECMAScript quando a página é renderizada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado por controles de script para declarar-se em uma matriz para que uma biblioteca de script de cliente possa trabalhar com todos os controles do mesmo tipo.  
  
 O método <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.RegisterArrayDeclaration%2A> método o <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.RegisterArrayDeclaration%2A> método para declarar uma matriz, `myArray`, que contém três objetos nomeados `x`, `y`, e `z`. O exemplo define e registra um script de inicialização usando o <xref:System.Web.UI.Page.RegisterStartupScript%2A> método. Quando o ECMAScript `doClick` função é chamada de página que contém esse código, a matriz e seus objetos são inicializados.  
  
 [!code-csharp[Page_RegisterArrayDeclaration#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/CS/page_registerarraydeclaration.cs.aspx#1)]
 [!code-vb[Page_RegisterArrayDeclaration#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterArrayDeclaration/VB/page_registerarraydeclaration.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAsyncTask">
      <MemberSignature Language="C#" Value="public void RegisterAsyncTask (System.Web.UI.PageAsyncTask task);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterAsyncTask(class System.Web.UI.PageAsyncTask task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterAsyncTask(System.Web.UI.PageAsyncTask)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Web.UI.PageAsyncTask" />
      </Parameters>
      <Docs>
        <param name="task">Um <see cref="T:System.Web.UI.PageAsyncTask" /> que define a tarefa assíncrona.</param>
        <summary>Registra uma nova tarefa assíncrona na página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir uma tarefa assíncrona usando o <xref:System.Web.UI.PageAsyncTask> classe. Quando a tarefa é definida, use o <xref:System.Web.UI.Page.RegisterAsyncTask%2A> método para registrar a tarefa com a página. Depois de registrar a tarefa, invoque o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> método para iniciar a tarefa assíncrona.  
  
 O <xref:System.Web.UI.Page.RegisterAsyncTask%2A> método pode ser usado com páginas síncronas e assíncronas.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade com o <xref:System.Web.UI.Page.ExecuteRegisteredAsyncTasks%2A> e <xref:System.Web.UI.Page.RegisterAsyncTask%2A> métodos. Observe o uso de manipuladores de tempo limite de início e final. No exemplo, um atraso artificial é introduzido para demonstrar a situação de uma tarefa assíncrona excedeu o tempo alocado para a tarefa conforme especificado no <xref:System.Web.UI.Page.AsyncTimeout%2A> propriedade. Em um cenário do mundo real, uma tarefa assíncrona pode ser usada para realizar chamadas de banco de dados ou a geração de imagem, por exemplo, e o manipulador de tempo limite fornece degradação de forma suave se a tarefa não é executada em um período de tempo especificado.  
  
 [!code-aspx-csharp[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.AsyncTimeout#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.aspx#1)]  
  
 [!code-csharp[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/CS/page_asynctask.cs#2)]
 [!code-vb[System.Web.UI.Page.AsyncTimeout#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.AsyncTimeout/vb/page_asynctask.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">A tarefa assíncrona é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterClientScriptBlock">
      <MemberSignature Language="C#" Value="public virtual void RegisterClientScriptBlock (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterClientScriptBlock(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterClientScriptBlock(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterClientScriptBlock(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chave exclusiva que identifica um bloco de script.</param>
        <param name="script">Conteúdo do script que é enviado ao cliente.</param>
        <summary>Emite blocos de script do lado do cliente para a resposta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O script do lado do cliente é emitido somente após a marca de abertura do <xref:System.Web.UI.Page> do objeto `<form runat= server>` elemento. Certifique-se de incluir a abertura e fechamento `<script>` elementos ao redor do script bloqueiam a cadeia de caracteres especificada no `script` parâmetro.  
  
 Como esse método usa uma chave para identificar o bloco de script, o bloco de script não precisa ser emitido para o fluxo de saída de cada vez que forem solicitados por uma instância do controle de servidor diferente. Usando uma chave também diminui a probabilidade de blocos de script de controles diferentes interfiram umas com as outras.  
  
 Os scripts de blocos com o mesmo `key` valores de parâmetro são considerados duplicatas.  
  
> [!NOTE]
>  Lembre-se de incluir marcas de comentário HTML ao redor de seu script para que ele não será renderizado se o navegador solicitante não oferece suporte a scripts.  
  
 O método <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.RegisterClientScriptBlock%2A> método o <xref:System.Web.UI.ClientScriptManager> classe em vez disso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> método junto com o <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A> método. Se o ECMAScript no bloco de declaração de código não já foi registrado, conforme determinado pela <xref:System.Web.UI.Page.IsClientScriptBlockRegistered%2A>, o <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> chamada é feita.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterHiddenField">
      <MemberSignature Language="C#" Value="public virtual void RegisterHiddenField (string hiddenFieldName, string hiddenFieldInitialValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterHiddenField(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterHiddenField(string hiddenFieldName, string hiddenFieldInitialValue). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hiddenFieldName" Type="System.String" />
        <Parameter Name="hiddenFieldInitialValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="hiddenFieldName">O nome exclusivo do campo oculto a ser renderizado.</param>
        <param name="hiddenFieldInitialValue">O valor a ser emitido no formulário oculto.</param>
        <summary>Permite que os controles do servidor registrem automaticamente um campo oculto no formulário. O campo será enviado para o objeto <see cref="T:System.Web.UI.Page" /> quando o controle de servidor <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> for renderizado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Web.UI.Page.RegisterHiddenField%2A> foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.RegisterHiddenField%2A> método o <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.RegisterHiddenField%2A> método para ajudar a criar código ECMAScript que é passado para o navegador solicitante. O nome do campo oculto é definido como `myHiddenField` e seu valor é definido como "Bem-vindo ao Microsoft!" O <xref:System.Web.UI.Page.RegisterStartupScript%2A> chamadas de método de `myHiddenField` valor quando o usuário clica em um botão na página.  
  
> [!IMPORTANT]
>  Este exemplo tem um campo oculto, que é uma possível ameaça à segurança. Por padrão, você deve validar o valor de um campo oculto como você faria com o valor de uma caixa de texto. Páginas da Web ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#1)]
 [!code-vb[Page_RegisterHiddenField#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterOnSubmitStatement">
      <MemberSignature Language="C#" Value="public void RegisterOnSubmitStatement (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterOnSubmitStatement(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterOnSubmitStatement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterOnSubmitStatement(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chave exclusiva que identifica um bloco de script.</param>
        <param name="script">O script do lado do cliente a ser enviado ao cliente.</param>
        <summary>Permite uma página a acessar o evento <see langword="OnSubmit" /> de cliente. O script deve ser uma chamada de função para o código de cliente registrado em outro lugar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.RegisterOnSubmitStatement%2A> método o <xref:System.Web.UI.ClientScriptManager> classe.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Web.UI.Page.RegisterOnSubmitStatement%2A> para acessar um script que responde quando um botão de envio do lado do cliente é clicado. Quando esse evento ocorrer, o código ECMAScript registrado é executado no cliente.  
  
> [!IMPORTANT]
>  Este exemplo tem um campo oculto, que é uma possível ameaça à segurança. Por padrão, você deve validar o valor de um campo oculto como você faria com o valor de uma caixa de texto. Páginas da Web ASP.NET validam que a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterHiddenField#2](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterHiddenField/CS/page_registerhiddenfield.cs.aspx#2)]
 [!code-vb[Page_RegisterHiddenField#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterHiddenField/VB/page_registerhiddenfield.vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void RegisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle a ser registrado.</param>
        <summary>Registra um controle como um controle cujo estado deve ser persistido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles personalizados de servidor que usam o estado de controle devem chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método em cada solicitação porque o registro para o estado de controle não é transportado da solicitação à solicitação durante um evento de postback. É recomendável que o registro ocorra no <xref:System.Web.UI.Control.Init> evento.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra uma chamada de controle de servidor personalizado a <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método.  
  
 [!code-csharp[ControlState#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlState/CS/controlstatecs.aspx#1)]
 [!code-vb[ControlState#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlState/VB/controlstatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O controle a ser registrado é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O método <see cref="M:System.Web.UI.Page.RegisterRequiresControlState(System.Web.UI.Control)" /> pode ser chamado somente antes ou durante o evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresPostBack">
      <MemberSignature Language="C#" Value="public void RegisterRequiresPostBack (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresPostBack(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresPostBack(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle a ser registrado.</param>
        <summary>Registra um controle como um controle que requer manipulação de postback quando é feito o postback da página para o servidor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O controle a ser registrado deve implementar o <xref:System.Web.UI.IPostBackDataHandler> interface ou um <xref:System.Web.HttpException> é gerado. Quando implementado por um controle, o <xref:System.Web.UI.IPostBackDataHandler> habilita a interface de tratamento de dados de postagem e aumento de qualquer publicação fazer eventos de dados alterados. Para obter mais informações sobre o modelo de evento de controle de servidor, consulte [modelo de evento de controle do ASP.NET Web Forms Server](http://msdn.microsoft.com/library/6304bff7-1b0e-4641-8acb-6d3b0badc4a3).  
  
 Registrar controles na página até o `Page_PreRender` eventos de ciclo de vida da página.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.RegisterRequiresPostBack%2A> método para exigir um controle de caixa de texto, `myTextBox`, para ser postada antes de executar qualquer código associado à caixa de texto. <xref:System.Web.UI.WebControls.TextBox>implementam controles de <xref:System.Web.UI.IPostBackDataHandler> interface.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-csharp[Page_RegisterRequiresPostBack#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/CS/page_registerrequirespostback.cs.aspx#1)]
 [!code-vb[Page_RegisterRequiresPostBack#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterRequiresPostBack/VB/page_registerrequirespostback.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O controle a ser registrado não implementa a interface <see cref="T:System.Web.UI.IPostBackDataHandler" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresRaiseEvent">
      <MemberSignature Language="C#" Value="public virtual void RegisterRequiresRaiseEvent (System.Web.UI.IPostBackEventHandler control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterRequiresRaiseEvent(class System.Web.UI.IPostBackEventHandler control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresRaiseEvent(System.Web.UI.IPostBackEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.IPostBackEventHandler" />
      </Parameters>
      <Docs>
        <param name="control">O controle a ser registrado.</param>
        <summary>Registra um controle de servidor ASP.NET como uma necessidade de um evento ser gerado quando o controle é processado no <see cref="T:System.Web.UI.Page" /> objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controle de apenas um servidor pode ser registrado por solicitação de página. O <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> deve ser usado quando o controle não tem seu controle de dados de postagem de ID no formulário. Além disso, o controle que está registrado deve implementar o <xref:System.Web.UI.IPostBackEventHandler> interface.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.RegisterRequiresRaiseEvent%2A> método para registrar um <xref:System.Web.UI.WebControls.Button> Web de controle de servidor, como exigir um evento ser gerado. Depois que você registrou o primeiro <xref:System.Web.UI.WebControls.Button> controle, você poderá causar a segunda <xref:System.Web.UI.WebControls.Button> controle declarado no código para enviar os resultados do primeiro botão clique em eventos para a página.  
  
 [!code-csharp[Page_RaisePostBackEvent#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RaisePostBackEvent/CS/page_raisepostbackevent.cs.aspx#1)]
 [!code-vb[Page_RaisePostBackEvent#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RaisePostBackEvent/VB/page_raisepostbackevent.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterRequiresViewStateEncryption">
      <MemberSignature Language="C#" Value="public void RegisterRequiresViewStateEncryption ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterRequiresViewStateEncryption() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Registra um controle com a página como um que exige criptografia de estado de exibição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver desenvolvendo um controle personalizado que lida com informações potencialmente confidenciais, chame o <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A> método para registrar o controle com a página e verifique se o estado de exibição para o controle é criptografado.  
  
 O estado da página inteira será criptografado se o <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> é definido como <xref:System.Web.UI.ViewStateEncryptionMode.Auto> ou <xref:System.Web.UI.ViewStateEncryptionMode.Always>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a definição do modo de exibição de estado de criptografia para um <xref:System.Web.UI.Page> objeto e solicita criptografia do estado de exibição por meio de <xref:System.Web.UI.Page.RegisterRequiresViewStateEncryption%2A>. Neste exemplo, o estado de exibição será criptografado quando as informações do cliente são recuperadas de um banco de dados.  
  
 [!code-aspx-csharp[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/CS/encryptViewState.cs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.ViewStateEncryptionMode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.ViewStateEncryptionMode/VB/encryptViewState.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="M:System.Web.UI.Page.RegisterRequiresViewStateEncryption" /> método deve ser chamado antes ou durante a página <see langword="PreRender" /> fase no ciclo de vida da página.</exception>
      </Docs>
    </Member>
    <Member MemberName="RegisterStartupScript">
      <MemberSignature Language="C#" Value="public virtual void RegisterStartupScript (string key, string script);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RegisterStartupScript(string key, string script) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterStartupScript(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is ClientScript.RegisterStartupScript(Type type, string key, string script). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="script" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Chave exclusiva que identifica um bloco de script.</param>
        <param name="script">Conteúdo do script que será enviado ao cliente.</param>
        <summary>Emite um bloco de script do lado do cliente na resposta da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Semelhante do <xref:System.Web.UI.Page.RegisterClientScriptBlock%2A> método, o <xref:System.Web.UI.Page.RegisterStartupScript%2A> método emite o script antes da marca de fechamento do <xref:System.Web.UI.Page> do objeto `<form runat= server>` elemento. Certifique-se de incluir a abertura e fechamento `<script>` elementos ao redor do script bloqueiam a cadeia de caracteres especificada no `script` parâmetro.  
  
 Como esse método usa uma chave para identificar o bloco de script, o bloco de script não precisa ser emitido para o fluxo de saída de cada vez que forem solicitados por uma instância do controle de servidor diferente  
  
 Os scripts de blocos com o mesmo `key` valores de parâmetro são considerados duplicatas.  
  
> [!NOTE]
>  Lembre-se de incluir marcas de comentário HTML ao redor de seu script para que ele não será renderizado se o navegador solicitante não oferece suporte a scripts.  
  
 O método <xref:System.Web.UI.Page.RegisterStartupScript%2A> foi substituído. Use o <xref:System.Web.UI.ClientScriptManager.RegisterStartupScript%2A> método o <xref:System.Web.UI.ClientScriptManager> classe em vez disso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Web.UI.Page.RegisterStartupScript%2A> método junto com o <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> método. Se o ECMAScript gravado no bloco de declaração de código não já foi registrado, conforme determinado pelo <xref:System.Web.UI.Page.IsStartupScriptRegistered%2A> método, uma <xref:System.Web.UI.Page.RegisterStartupScript%2A> chamada é feita.  
  
 [!code-aspx-csharp[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/CS/defaultcs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.RegisterClientScriptBlock#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.RegisterClientScriptBlock/VB/defaultvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterViewStateHandler">
      <MemberSignature Language="C#" Value="public void RegisterViewStateHandler ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterViewStateHandler() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RegisterViewStateHandler" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Faz com que o estado de exibição de página sejam mantidas, se for chamado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.RegisterViewStateHandler%2A> método é chamado automaticamente por meio de <xref:System.Web.UI.HtmlControls.HtmlForm> controle de servidor. Se esse método não for chamado, o estado de exibição de página não será mantido.  
  
> [!NOTE]
>  Normalmente, somente o <xref:System.Web.UI.HtmlControls.HtmlForm> controle de servidor para a página chama esse método.  
  
   
  
## Examples  
 [!code-csharp[Page_RegisterViewStateHandler#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_RegisterViewStateHandler/CS/page_registerviewstatehandler.cs#1)]
 [!code-vb[Page_RegisterViewStateHandler#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_RegisterViewStateHandler/VB/page_registerviewstatehandler.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected override void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see cref="T:System.Web.UI.HtmlTextWriter" /> que recebe o conteúdo da página.</param>
        <summary>Inicializa o objeto <see cref="T:System.Web.UI.HtmlTextWriter" /> chama os controles filho do <see cref="T:System.Web.UI.Page" /> a serem renderizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.Render%2A> método é responsável por criar o texto e marcação que é enviada para o navegador do cliente. O padrão <xref:System.Web.UI.Page.Render%2A> chamadas de método <xref:System.Web.UI.Control.RenderChildren%2A> para escrever o texto e marcação para os controles contidos na página.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Request">
      <MemberSignature Language="C#" Value="public System.Web.HttpRequest Request { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpRequest Request" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Request" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpRequest</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpRequest" /> para a página solicitada.</summary>
        <value>O <see cref="T:System.Web.HttpRequest" /> atual associado à página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O objeto <xref:System.Web.HttpRequest> contém informações sobre a solicitação HTTP atual.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como obter o <xref:System.Web.HttpRequest.Headers%2A> coleção do <xref:System.Web.HttpRequest> do objeto e gravá-la a uma página ASP.NET.  
  
 [!code-csharp[Classic HttpRequest.Headers Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/CS/source.cs#1)]
 [!code-vb[Classic HttpRequest.Headers Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpRequest.Headers Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Ocorre quando o objeto <see cref="T:System.Web.HttpRequest" /> não está disponível.</exception>
      </Docs>
    </Member>
    <Member MemberName="RequiresControlState">
      <MemberSignature Language="C#" Value="public bool RequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool RequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.RequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O <see cref="T:System.Web.UI.Control" /> para verificar se há um requisito de estado do controle.</param>
        <summary>Determina se o especificado <see cref="T:System.Web.UI.Control" /> objeto está registrado para participar do gerenciamento de estado do controle.</summary>
        <returns>
          <see langword="true" />Se especificado <see cref="T:System.Web.UI.Control" /> requer controle estado; caso contrário,<see langword="false" /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado do controle é um objeto composto de dados de estado de exibição essenciais que precisam de controles de servidor Web para funcionar; ele está contido em um objeto separado do estado de exibição normal.  
  
 Controles personalizados usando o estado do controle devem chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> método antes de salvar o estado do controle. Use o <xref:System.Web.UI.Page.RequiresControlState%2A> método para verificar se há controles que estão registrados com a página exigir o estado do controle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Response">
      <MemberSignature Language="C#" Value="public System.Web.HttpResponse Response { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpResponse Response" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Response" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpResponse</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.HttpResponse" /> associado ao objeto <see cref="T:System.Web.UI.Page" />. Esse objeto permite que você envie dados de resposta HTTP para um cliente e contém informações sobre essa resposta.</summary>
        <value>O <see cref="T:System.Web.HttpResponse" /> atual associado à página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra a criação de um cookie e adicioná-lo à saída HTTP da página, usando o <xref:System.Web.HttpResponse> objeto.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O objeto <see cref="T:System.Web.HttpResponse" /> não está disponível.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResponseEncoding">
      <MemberSignature Language="C#" Value="public string ResponseEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ResponseEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ResponseEncoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define o idioma de codificação para o objeto <see cref="T:System.Web.HttpResponse" /> atual.</summary>
        <value>Uma cadeia de caracteres que contém o idioma de codificação do <see cref="T:System.Web.HttpResponse" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `ResponseEncoding` de atributo para o valor desejado usando a diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RouteData">
      <MemberSignature Language="C#" Value="public System.Web.Routing.RouteData RouteData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.Routing.RouteData RouteData" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.RouteData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.Routing.RouteData</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor <see cref="P:System.Web.Routing.RequestContext.RouteData" /> da instância <see cref="T:System.Web.Routing.RequestContext" /> atual.</summary>
        <value>O valor <see cref="P:System.Web.Routing.RequestContext.RouteData" /> da instância <see cref="T:System.Web.Routing.RequestContext" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se uma página está sendo executada em resposta a uma solicitação feita por meio de roteamento do ASP.NET, esta propriedade fornece acesso para os valores de parâmetro de URL que foram passados como dados de rota. Se a página é executada em resposta a uma URL física, em vez de uma URL da rota, essa propriedade é `null`. O exemplo a seguir mostra como extrair o valor de um parâmetro de URL chamado `year`.  
  
```vb  
Dim year As Integer = Convert.ToInt32(Page.RouteData.Values("year"))  
```  
  
```csharp  
int year = Convert.ToInt32(Page.RouteData.Values["year"])  
```  
  
 Se a rota é definida usando o padrão de URL `{locale}/{year}` para o domínio `contoso.com`, e se a URL solicitada é `contoso.com/US/2010`, `year` conterá o valor "2010" quando esse código é executado.  
  
 Para obter mais informações sobre roteamento ASP.NET, consulte [roteamento ASP.NET](http://msdn.microsoft.com/library/892441af-8f1d-483e-ab5f-b82c23576f5a).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SavePageStateToPersistenceMedium">
      <MemberSignature Language="C#" Value="protected virtual void SavePageStateToPersistenceMedium (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SavePageStateToPersistenceMedium(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SavePageStateToPersistenceMedium(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Um <see cref="T:System.Object" /> no qual as informações de estado de exibição serão armazenadas.</param>
        <summary>Salva as informações de estado de exibição e de estado de controle da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.SavePageStateToPersistenceMedium%2A> método usa o <xref:System.Web.UI.PageStatePersister.Save%2A> método o <xref:System.Web.UI.PageStatePersister?displayProperty=nameWithType> objeto referenciado pelo <xref:System.Web.UI.Page.PageStatePersister%2A> propriedade para armazenar informações de estado de controle e estado de exibição para a página.  
  
 O ASP.NET inclui dois descendentes do <xref:System.Web.UI.PageStatePersister> classe, o <xref:System.Web.UI.HiddenFieldPageStatePersister> classe que salva informações de estado de um campo oculto incluído na página do ASP.NET, e o <xref:System.Web.UI.SessionPageStatePersister> classe que salva o estado no <xref:System.Web.UI.Page.Session%2A> objeto associado à solicitação. Observe que ao usar o <xref:System.Web.UI.SessionPageStatePersister> o campo oculto VIEWSTATE ainda é processado como isso é usado para determinar a postagem de classe.  
  
 Para salvar o estado no local de sua escolha, você deve criar um novo descendente do <xref:System.Web.UI.PageStatePersister> classe salva e carrega o estado para a mídia de persistência de sua escolha. Para obter um exemplo de criação de um novo <xref:System.Web.UI.PageStatePersister> de objeto, consulte o <xref:System.Web.UI.PageStatePersister> classe.  
  
 Se você estiver usando o .NET Framework versão 1.0 ou 1.1, substitua este método se você deseja salvar o <xref:System.Web.UI.Page> estado em algo diferente de um campo oculto. Se você optar por fazer isso, você também deve substituir o <xref:System.Web.UI.Page.LoadPageStateFromPersistenceMedium%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveStateComplete">
      <MemberSignature Language="C#" Value="public event EventHandler SaveStateComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SaveStateComplete" />
      <MemberSignature Language="DocId" Value="E:System.Web.UI.Page.SaveStateComplete" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após a página terminar de salvar todas as informações de estado de controle e estado de exibição da página e dos controles da página.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Informações de estado para controles na página da Web é salvo após a <xref:System.Web.UI.Page.PreRenderComplete> eventos. O <xref:System.Web.UI.Page.SaveStateComplete> é gerado depois que o estado de exibição e o estado de controle da página e controles da página são salvos na mídia de persistência.  
  
 Este é o último evento gerado antes da página é renderizada no navegador do solicitante.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Web.HttpServerUtility Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpServerUtility Server" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.HttpServerUtility</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see langword="Server" />, que é uma instância da classe <see cref="T:System.Web.HttpServerUtility" />.</summary>
        <value>O objeto <see langword="Server" /> atual associado à página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade fornece acesso aos usados com frequência <xref:System.Web.HttpServerUtility.HtmlEncode%2A> e <xref:System.Web.HttpServerUtility.MapPath%2A> métodos, entre outros.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como acessar informações de erro do servidor usando o `Server` objeto. Em particular, o exemplo obtém a URL solicitada do `Request` objeto, o erro mais recente do `Server` objeto (usando o <xref:System.Web.HttpServerUtility.GetLastError%2A> método) e converte-os em cadeias de caracteres que podem ser exibidas pelo cliente. Uma vez o `message` variável é gravado no cliente, o erro for excluído usando o <xref:System.Web.HttpServerUtility.ClearError%2A> método.  
  
 [!code-csharp[System.Web.UI.Page_Error method#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_Error method/CS/sourcecs.aspx#1)]
 [!code-vb[System.Web.UI.Page_Error method#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_Error method/VB/sourcevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Session">
      <MemberSignature Language="C#" Value="public virtual System.Web.SessionState.HttpSessionState Session { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.SessionState.HttpSessionState Session" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Session" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.SessionState.HttpSessionState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see langword="Session" /> atual fornecido pelo ASP.NET.</summary>
        <value>Os dados do estado da sessão atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade fornece informações sobre sessão a solicitação atual. Um `Session` objeto é mantido para cada usuário que solicita uma página ou um documento de um aplicativo ASP.NET. Variáveis armazenadas no `Session` objeto não serão descartadas quando o usuário move de uma página no aplicativo; em vez disso, essas variáveis persistem desde que o usuário está acessando páginas em seu aplicativo. Para obter mais informações sobre o estado de sessão, consulte [visão geral sobre o estado de sessão ASP.NET](http://msdn.microsoft.com/library/6d60d381-6521-4e1d-9089-da6464f2a9bc).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um `GetStyle` função que recupera uma chave armazenada no estado da sessão da página Web Forms e converte o valor em uma cadeia de caracteres.  
  
 [!code-csharp[Page.Session_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page.Session_Samples1/CS/sessioncs.aspx#1)]
 [!code-vb[Page.Session_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page.Session_Samples1/VB/sessionvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Ocorre quando as informações da sessão são definidas como <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (string clientID);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(string clientID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clientID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clientID">A ID do controle para a qual o foco será definido.</param>
        <summary>Define o foco do navegador para o controle com o identificador especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.SetFocus%2A> o controle ativo na página da Web exibida pelo navegador de cadeia de caracteres de método para tornar o controle com a ID especificada. O <xref:System.Web.UI.Page.SetFocus%2A> método deve ser chamado antes que a página está preparada para renderização para o cliente a <xref:System.Web.UI.Control.PreRender> eventos.  
  
> [!NOTE]
>  O <xref:System.Web.UI.Page.SetFocus%2A> método só funcionará em navegadores com suporte ECMAScript versão 1.3 ou posterior.  
  
   
  
## Examples  
 O exemplo de código a seguir define o foco para a segunda caixa de texto em uma página da Web.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbyidcs.aspx#1)]
 [!code-aspx-vb[PageSetFocus#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbyidvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="clientID" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> é chamado quando o controle não é parte de uma página Web Forms.  
  
 \- ou -  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.String)" /> é chamado após o evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetFocus">
      <MemberSignature Language="C#" Value="public void SetFocus (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetFocus(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle a receber o foco.</param>
        <summary>Define o foco do navegador para o controle especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.SetFocus%2A> método para fazer o controle especificado o controle ativo na página da Web exibida pelo navegador. O <xref:System.Web.UI.Page.SetFocus%2A> método deve ser chamado antes que a página está preparada para renderização para o cliente a <xref:System.Web.UI.Control.PreRender> eventos.  
  
> [!NOTE]
>  O <xref:System.Web.UI.Page.SetFocus%2A> método só funcionará em navegadores com suporte ECMAScript versão 1.3 ou posterior.  
  
   
  
## Examples  
 O exemplo de código a seguir define o foco para a segunda caixa de texto em uma página da Web.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[PageSetFocus#2](~/samples/snippets/csharp/VS_Snippets_WebNet/PageSetFocus/CS/setfocusbycontrolcs.aspx#2)]
 [!code-aspx-vb[PageSetFocus#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageSetFocus/VB/setfocusbycontrolvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="control" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> é chamado quando o controle não é parte de uma página Web Forms.  
  
 \- ou -  
  
 <see cref="M:System.Web.UI.Page.SetFocus(System.Web.UI.Control)" /> é chamado após o evento <see cref="E:System.Web.UI.Control.PreRender" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipFormActionValidation">
      <MemberSignature Language="C#" Value="public bool SkipFormActionValidation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SkipFormActionValidation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SkipFormActionValidation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o valor de cadeia de caracteres de consulta é validado.</summary>
        <value>
          <see langword="true" />Se a validação da cadeia de caracteres de consulta deve ser ignorada (a cadeia de caracteres de consulta não deve ser validada); Caso contrário, <see langword="false" /> se a validação da cadeia de caracteres de consulta deve levar colocar como normal. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SmartNavigation">
      <MemberSignature Language="C#" Value="public bool SmartNavigation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SmartNavigation" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.SmartNavigation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("The recommended alternative is Page.SetFocus and Page.MaintainScrollPositionOnPostBack. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a navegação inteligente está habilitada. Essa propriedade é substituída.</summary>
        <value>
          <see langword="true" /> se a navegação inteligente estiver habilitada; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `SmartNavigation` atributo `true` na diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define essa propriedade.  
  
> [!NOTE]
>  No ASP.NET 2.0, o <xref:System.Web.UI.Page.SmartNavigation%2A> propriedade foi preterida. Use o <xref:System.Web.UI.Page.SetFocus%2A> método e o <xref:System.Web.UI.Page.MaintainScrollPositionOnPostBack%2A> propriedade em vez disso.  
  
 Quando uma página é solicitada pelo navegador Microsoft Internet Explorer 5.5 ou posterior, navegação inteligente aprimora a experiência do usuário da página executando as seguintes ações:  
  
-   Eliminando o flash causado pela navegação.  
  
-   Manter a posição de rolagem ao mover de uma página.  
  
-   Manter o foco elemento entre navegações.  
  
-   Preservando apenas o último estado de página no histórico do navegador.  
  
 Navegação inteligente é melhor usada com páginas ASP.NET que exigem postagens frequentes, mas com conteúdo visual que não se altera drasticamente no retorno. Considerar isso com cuidado ao decidir se deve definir essa propriedade como `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleSheetTheme">
      <MemberSignature Language="C#" Value="public virtual string StyleSheetTheme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StyleSheetTheme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.StyleSheetTheme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Web.UI.Filterable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do tema aplicado à página no início do ciclo de vida da página.</summary>
        <value>O nome do tema aplicado à página no início do ciclo de vida da página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não faz referência diretamente a uma folha de estilo em cascata (CSS). A propriedade contém o nome de um tema ASP.NET, que pode incluir arquivos CSS dentro dele.  
  
 O <xref:System.Web.UI.Page.StyleSheetTheme%2A> propriedade especifica o nome de um tema aplicado a uma página no início do ciclo de vida da página, enquanto o <xref:System.Web.UI.Page.Theme%2A> propriedade especifica o nome de um tema aplicado a uma página mais tarde no ciclo de vida da página. Isso significa que as configurações na página têm precedência sobre configurações no tema de folha de estilos. Para obter mais informações, consulte [capas e temas do ASP.NET](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 Normalmente, um valor para essa propriedade é definida na diretiva de página ou substituindo a propriedade. Para obter informações, consulte os tópicos a seguir:  
  
-   [Como: aplicar temas do ASP.NET](http://msdn.microsoft.com/library/f9d72364-4d77-4b73-84be-7630dc63e0fe)  
  
-   [Como: aplicar temas ASP.NET programaticamente](http://msdn.microsoft.com/library/02eed7c3-01e8-4e20-8358-df47dbd4f148))  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de definir a propriedade <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> após o método <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> ter sido chamado.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.StyleSheetTheme" /> é definido com um nome de tema inválido. Essa exceção é lançada quando o método <see cref="M:System.Web.UI.Page.FrameworkInitialize" /> é chamado e não pelo setter de propriedade.</exception>
      </Docs>
    </Member>
    <Member MemberName="Theme">
      <MemberSignature Language="C#" Value="public virtual string Theme { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Theme" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Theme" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do tema de página.</summary>
        <value>O nome do tema de página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.Theme%2A> propriedade define o nome do tema usado para a página. Se você quiser que as configurações na página têm precedência sobre as configurações no tema, use o <xref:System.Web.UI.Page.StyleSheetTheme%2A> propriedade. Para obter mais informações, consulte [capas e temas do ASP.NET](http://msdn.microsoft.com/library/5df3ebbd-d46c-4502-9406-02f9df4ef2c3).  
  
 O <xref:System.Web.UI.Page.Theme%2A> propriedade deve ser definida antes do <xref:System.Web.UI.Page.PreInit> evento; a configuração a <xref:System.Web.UI.Page.Theme%2A> propriedade após o <xref:System.Web.UI.Page.PreInit> evento fará com que um <xref:System.InvalidOperationException> exceção.  
  
 O tema especificado deve existir como um aplicativo ou um tema global. Se o tema não existir, um <xref:System.Web.HttpException> exceção será lançada.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Web.UI.Page.Theme%2A> propriedade para um nome passado na cadeia de caracteres de consulta.  
  
 [!code-csharp[PageTheme#1](~/samples/snippets/csharp/VS_Snippets_WebNet/PageTheme/CS/pagethemecs.aspx#1)]
 [!code-vb[PageTheme#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/PageTheme/VB/pagethemevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de definir <see cref="P:System.Web.UI.Page.Theme" /> após o evento <see cref="E:System.Web.UI.Page.PreInit" />.</exception>
        <exception cref="T:System.ArgumentException">
          <see cref="P:System.Web.UI.Page.Theme" /> é definido com um nome de tema inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Title" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o título para a página.</summary>
        <value>O título da página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Web.UI.Page.Title%2A> propriedade para definir o título da página no cabeçalho HTML enviado ao navegador do solicitante.  
  
> [!NOTE]
>  A página deve conter um `head` elemento que tem o atributo `runat="server"`, caso contrário, o título não será processada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Web.UI.Page.Title" /> exige um controle de cabeçalho na página.</exception>
      </Docs>
    </Member>
    <Member MemberName="Trace">
      <MemberSignature Language="C#" Value="public System.Web.TraceContext Trace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.TraceContext Trace" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Trace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Web.TraceContext" /> para a solicitação Web atual.</summary>
        <value>Dados do <see cref="T:System.Web.TraceContext" /> objeto para a solicitação da Web atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O rastreamento controla e apresenta os detalhes de execução sobre uma solicitação da Web. Para dados de rastreamento ser visível em uma página renderizada, você deve ativar o rastreamento no nível do aplicativo ou página.  
  
 O rastreamento em uma página está desabilitado por padrão. Para habilitar o rastreamento para uma página, use a diretiva `<% @ Page trace="true" %>`. Para habilitar o rastreamento para um aplicativo inteiro, você deve habilitá-la no arquivo de configuração do aplicativo, Web. config, que reside no diretório raiz do aplicativo. Para obter mais informações, consulte [visão geral do rastreamento ASP.NET](http://msdn.microsoft.com/library/1552561d-887c-4002-8770-f92662cdf416).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o acesso a <xref:System.Web.TraceContext.IsEnabled%2A?displayProperty=nameWithType> propriedade e o <xref:System.Web.TraceContext.Write%2A?displayProperty=nameWithType> método por meio de <xref:System.Web.UI.Page.Trace%2A> propriedade. Esse código chama o <xref:System.Diagnostics.Trace.Write%2A> método somente durante o rastreamento está habilitado para o <xref:System.Web.UI.Page> objeto. Se não estiver habilitado, esse código não será executado, que pode ajudar a reduzir a sobrecarga para o seu aplicativo.  
  
 [!code-csharp[System.Web.UI.Page.Trace#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Trace/CS/trace1cs.aspx#2)]
 [!code-vb[System.Web.UI.Page.Trace#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Trace/VB/trace1vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceEnabled">
      <MemberSignature Language="C#" Value="public bool TraceEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TraceEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define um valor que indica se o rastreamento está habilitado para o <see cref="T:System.Web.UI.Page" /> objeto.</summary>
        <value>
          <see langword="true" />Se o rastreamento está habilitado para a página. Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `Trace` atributo `true` na diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TraceModeValue">
      <MemberSignature Language="C#" Value="public System.Web.TraceMode TraceModeValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.TraceMode TraceModeValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TraceModeValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.TraceMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define o modo no qual o rastreamento, as instruções são exibidas na página.</summary>
        <value>Um dos membros da enumeração <see cref="T:System.Web.TraceMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `TraceMode` atributo na diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TransactionMode">
      <MemberSignature Language="C#" Value="protected int TransactionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TransactionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.TransactionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define o nível de transação suporte para a página.</summary>
        <value>Um inteiro que representa uma da <see cref="T:System.EnterpriseServices.TransactionOption" /> membros de enumeração.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na maioria das circunstâncias, não defina essa propriedade no código. Definir o `Transaction` atributo na diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define a propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryUpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Atualiza a instância de modelo especificada usando valores do provedor de valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para uma série de tutoriais sobre como usar a associação de modelo com formulários da Web, consulte [modelo de associação e formulários da Web](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">O tipo do modelo.</typeparam>
        <param name="model">O modelo.</param>
        <summary>Atualiza a instância de modelo especificada usando valores do controle associado a dados.</summary>
        <returns>
          <see langword="true" />Se a associação de modelo for bem-sucedida; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método só deve ser chamado a partir de um método que é especificado por um controle de associação de dados `UpdateMethod` ou `InsertMethod` propriedade.  
  
 Para uma série de tutoriais sobre como usar a associação de modelo com formulários da Web, consulte [modelo de associação e formulários da Web](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryUpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual bool TryUpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryUpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.TryUpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">O tipo do modelo.</typeparam>
        <param name="model">O modelo.</param>
        <param name="valueProvider">O provedor de valor.</param>
        <summary>Atualiza a instância de modelo usando valores do provedor de valor especificado.</summary>
        <returns>
          <see langword="true" />Se a associação de modelo for bem-sucedida; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para uma série de tutoriais sobre como usar a associação de modelo com formulários da Web, consulte [modelo de associação e formulários da Web](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UICulture">
      <MemberSignature Language="C#" Value="public string UICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UICulture" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define a ID de interface do usuário para o objeto <see cref="T:System.Threading.Thread" /> associado à página.</summary>
        <value>A ID da interface do usuário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é um atalho para o <xref:System.Threading.Thread.CurrentThread%2A> propriedade. A cultura é uma propriedade de thread em execução  
  
 Definir o `UICulture` atributo na diretiva no arquivo. aspx. Quando a página é solicitada, a classe gerada dinamicamente define o valor dessa propriedade. Além disso, você pode definir explicitamente o valor da <xref:System.Web.UI.Page.UICulture%2A> propriedade no do arquivo Web. config.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UniqueFilePathSuffix">
      <MemberSignature Language="C#" Value="protected virtual string UniqueFilePathSuffix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueFilePathSuffix" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UniqueFilePathSuffix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um sufixo exclusivo para acrescentar ao caminho do arquivo de cache de navegadores.</summary>
        <value>Um sufixo exclusivo acrescentado ao caminho do arquivo. O padrão é "__ufps =" mais um número exclusivo de 6 dígitos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.UniqueFilePathSuffix%2A> propriedade retorna uma cadeia de caracteres que é acrescentada ao final de um caminho de arquivo quando necessário para o cache de navegadores. A cadeia de caracteres é usada para identificar o caminho de arquivo associado a uma solicitação específica.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnobtrusiveValidationMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.UnobtrusiveValidationMode UnobtrusiveValidationMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.UnobtrusiveValidationMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.UnobtrusiveValidationMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se um JavaScript não invasivo é usado para a validação do lado do cliente.</summary>
        <value>
          <see langword="true" /> se um JavaScript não invasivo for usado; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterRequiresControlState">
      <MemberSignature Language="C#" Value="public void UnregisterRequiresControlState (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterRequiresControlState(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UnregisterRequiresControlState(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O <see cref="T:System.Web.UI.Control" /> para qual parar a persistência de estado do controle.</param>
        <summary>Interrompe a persistência de estado de controle para o controle especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Controles personalizados de servidor que usam o estado de controle devem chamar o <xref:System.Web.UI.Page.RegisterRequiresControlState%2A> em cada solicitação durante antes que o estado é mantido. Registro de estado de controle não sejam transportado da solicitação à solicitação durante um postback. Use o <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> método para garantir que o estado de controle não é persistente para controles que não precisam ser mantidos para postback.  
  
 Internamente, o <xref:System.Web.UI.Page.UnregisterRequiresControlState%2A> método é invocado ao usar o <xref:System.Web.UI.Control.RemovedControl%2A> método para remover um controle de uma coleção de controles.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Web.UI.Control" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpdateModel&lt;TModel&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Atualiza a instância de modelo especificada usando valores do provedor de valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para uma série de tutoriais sobre como usar a associação de modelo com formulários da Web, consulte [modelo de associação e formulários da Web](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">O tipo do modelo.</typeparam>
        <param name="model">O modelo.</param>
        <summary>Atualiza a instância de modelo especificada usando valores do controle associado a dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método só deve ser chamado a partir de um método que é especificado por um controle de associação de dados `UpdateMethod` ou `InsertMethod` propriedade.  
  
 Para uma série de tutoriais sobre como usar a associação de modelo com formulários da Web, consulte [modelo de associação e formulários da Web](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateModel&lt;TModel&gt;">
      <MemberSignature Language="C#" Value="public virtual void UpdateModel&lt;TModel&gt; (TModel model, System.Web.ModelBinding.IValueProvider valueProvider) where TModel : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UpdateModel&lt;class TModel&gt;(!!TModel model, class System.Web.ModelBinding.IValueProvider valueProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.UpdateModel``1(``0,System.Web.ModelBinding.IValueProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TModel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="model" Type="TModel" />
        <Parameter Name="valueProvider" Type="System.Web.ModelBinding.IValueProvider" />
      </Parameters>
      <Docs>
        <typeparam name="TModel">O tipo do modelo.</typeparam>
        <param name="model">O modelo.</param>
        <param name="valueProvider">O provedor de valor.</param>
        <summary>Atualiza a instância de modelo especificada usando valores do provedor de valor especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para uma série de tutoriais sobre como usar a associação de modelo com formulários da Web, consulte [modelo de associação e formulários da Web](http://go.microsoft.com/fwlink/?LinkId=286117).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="User">
      <MemberSignature Language="C#" Value="public System.Security.Principal.IPrincipal User { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Principal.IPrincipal User" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.User" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém informações sobre o usuário que fez a solicitação de página.</summary>
        <value>Um <see cref="T:System.Security.Principal.IPrincipal" /> que representa o usuário que fez a solicitação de página.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Security.Principal.IPrincipal> objeto representa o contexto de segurança do usuário em cujo nome o código está sendo executado, incluindo a identidade do usuário e todas as funções às quais eles pertencem.  
  
 Esta propriedade usa o <xref:System.Web.HttpContext> do objeto <xref:System.Web.HttpContext.User%2A> propriedade para determinar onde se origina a solicitação.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.UI.Page.User%2A> propriedade para acessar informações de autenticação e identidade do usuário atual. Se o usuário não é autenticado, ele redireciona para uma página de logon.  
  
 [!code-csharp[Page_User#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_User/CS/page_user.cs.aspx#1)]
 [!code-vb[Page_User#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_User/VB/page_user.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instrui os controles de validação incluídos na página a validar suas informações atribuídas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um usuário clica em qualquer controle de servidor ASP.NET que tenha o `CausesValidation` propriedade definida como `true`, que é o padrão. Isso inclui o <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, e <xref:System.Web.UI.WebControls.LinkButton> controles de servidor Web, o <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, e <xref:System.Web.UI.HtmlControls.HtmlButton> controles de servidor HTML e controles que podem lançar automaticamente para o servidor, como o <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, e <xref:System.Web.UI.WebControls.BulletedList> controles.  
  
 Para desabilitar a validação para qualquer controle de botão na página, defina o controle de botão `CausesValidation` propriedade `false`.  
  
 Quando esse método é chamado, ele itera os controles de validação contidos no <xref:System.Web.UI.ValidatorCollection> objeto associado a <xref:System.Web.UI.Page.Validators%2A?displayProperty=nameWithType> propriedade e invoca a lógica de validação para cada controle de validação no grupo de validação atual. O grupo de validação é determinado pelo controle que lançadas a página para o servidor. Se nenhum grupo de validação for especificado, nenhum grupo de validação é usado.  
  
> [!NOTE]
>  O comportamento de validação de página foi alterado. Em [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], não mais controla chamada a <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> método; eles usar o <xref:System.Web.UI.Page.Validate%28System.String%29?displayProperty=nameWithType> método em vez disso. Se você usar o <xref:System.Web.UI.Page.Validate?displayProperty=nameWithType> método em um [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)] página, grupos de validação são ignorados e todos os controles são validados.  
  
   
  
## Examples  
 O código a seguir exemplo chama o <xref:System.Web.UI.Page.Validate%2A> método em uma página em um cenário com vários grupos diferentes de validação definido.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>O <see cref="M:System.Web.UI.Page.Validate" /> método não é usado pelo [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)]. Quando você estiver usando [!INCLUDE[vstecasplong](~/includes/vstecasplong-md.md)], substituir o <see cref="M:System.Web.UI.Page.Validate(System.String)" /> método para alterar o comportamento de validação de página.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public virtual void Validate (string validationGroup);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Validate(string validationGroup) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.Validate(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationGroup" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="validationGroup">O nome do grupo de validação dos controles para validar.</param>
        <summary>Instrui os controles de validação no grupo de validação especificado para validar suas informações atribuídas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado quando um usuário clica em qualquer controle de servidor ASP.NET que tenha o `CausesValidation` propriedade definida como `true`, que é o padrão. Isso inclui o <xref:System.Web.UI.WebControls.Button>, <xref:System.Web.UI.WebControls.ImageButton>, e <xref:System.Web.UI.WebControls.LinkButton> controles de servidor Web, o <xref:System.Web.UI.HtmlControls.HtmlInputButton>, <xref:System.Web.UI.HtmlControls.HtmlInputImage>, e <xref:System.Web.UI.HtmlControls.HtmlButton> controles de servidor HTML e controles que podem lançar automaticamente para o servidor, como o <xref:System.Web.UI.WebControls.TextBox>, <xref:System.Web.UI.WebControls.CheckBox>, <xref:System.Web.UI.WebControls.ListControl>, e <xref:System.Web.UI.WebControls.BulletedList> controles.  
  
 Para desabilitar a validação para qualquer controle de botão na página, defina o controle de botão `CausesValidation` propriedade `false`.  
  
 O <xref:System.Web.UI.Page.Validate%2A> método valida o grupo de validação especificada. Depois de chamar o <xref:System.Web.UI.Page.Validate%2A> método em um grupo de validação, o <xref:System.Web.UI.Page.IsValid%2A> método retornará `true` somente se o grupo de validação especificado e o grupo de validação do controle que causou a página ser postada para o servidor são válidos.  
  
   
  
## Examples  
 O código a seguir exemplo chama o <xref:System.Web.UI.Page.Validate%2A> método em uma página em um cenário com vários grupos diferentes de validação definido.  
  
> [!IMPORTANT]
>  Este exemplo tem uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.UI.Page.Validate2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/cs/pagevalidatecs.aspx#1)]
 [!code-aspx-vb[System.Web.UI.Page.Validate2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page.Validate2/vb/pagevalidatevb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateRequestMode">
      <MemberSignature Language="C#" Value="public override System.Web.UI.ValidateRequestMode ValidateRequestMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ValidateRequestMode ValidateRequestMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ValidateRequestMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidateRequestMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a página verifica valores potencialmente perigosos na entrada do cliente por meio do navegador.</summary>
        <value>Um valor que indica se a página verifica a entrada do cliente. O padrão é <see cref="F:System.Web.UI.ValidateRequestMode.Enabled" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor <xref:System.Web.UI.ValidateRequestMode.Inherit> não é usado no <xref:System.Web.UI.Page> classe porque não há nada para herdar de.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validators">
      <MemberSignature Language="C#" Value="public System.Web.UI.ValidatorCollection Validators { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.ValidatorCollection Validators" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Validators" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ValidatorCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de todos os controles de validação contidos na página solicitada.</summary>
        <value>A coleção de controles de validação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode usar essa propriedade para manipular os métodos e propriedades do <xref:System.Web.UI.ValidatorCollection> objeto associado atual <xref:System.Web.UI.Page> instância. Esta coleção contém todos os controles de servidor de validação que estão contidos em uma página.  
  
 Chamar o <xref:System.Web.UI.Page.Validate%2A?displayProperty=nameWithType> método faz com que a lógica de validação a ser executado para cada controle de servidor de validação no grupo de validação atual. Se qualquer um desses controles não passar o <xref:System.Web.UI.Page.IsValid%2A?displayProperty=nameWithType> propriedade retorna `false`.  
  
 Para obter mais informações sobre controles de validação, consulte [controles de validação ASP.NET](http://msdn.microsoft.com/library/fa2aa14d-a461-492e-9a79-c990904613ef).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyRenderingInServerForm">
      <MemberSignature Language="C#" Value="public virtual void VerifyRenderingInServerForm (System.Web.UI.Control control);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void VerifyRenderingInServerForm(class System.Web.UI.Control control) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Page.VerifyRenderingInServerForm(System.Web.UI.Control)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="control" Type="System.Web.UI.Control" />
      </Parameters>
      <Docs>
        <param name="control">O controle de servidor ASP.NET que é necessário no controle <see cref="T:System.Web.UI.HtmlControls.HtmlForm" />.</param>
        <summary>Confirma que um controle <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> é processado para o controle de servidor ASP.NET especificado no tempo de execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os controles devem estar dentro de `<form runat=server>` marcas podem chamar esse método antes que eles sejam renderizados para que uma mensagem de erro é mostrada se eles são colocados fora das marcas. Controles que carregada novamente ou dependem de blocos de script registrado devem chamar esse método em uma substituição do <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método. Páginas que têm uma maneira diferente de renderizar o elemento de formulário do servidor podem substituir este método para gerar uma exceção em condições diferentes.  
  
 Controles de servidor que carregada novamente ou usam o script do lado do cliente não funcionará se eles não estão entre os <xref:System.Web.UI.HtmlControls.HtmlForm> controle de servidor (<`form runat="server">`) marcas. Esses controles podem chamar este método quando eles processem para fornecer uma mensagem de erro criptografado quando eles não estão entre os <xref:System.Web.UI.HtmlControls.HtmlForm> controle.  
  
 Quando você desenvolve um controle de servidor personalizado, é comum para chamar esse método quando você substituir o `Render` método para qualquer tipo de marca de entrada. Isso é particularmente importante se o controle de entrada chama <xref:System.Web.UI.Page.GetPostBackEventReference%2A>, ou se ele emite o script de cliente. Um controle composto de servidor não precisa fazer essa chamada.  
  
   
  
## Examples  
 O código a seguir exemplo substitui o <xref:System.Web.UI.Page.Render%2A?displayProperty=nameWithType> método de um controle de servidor personalizado. Quando esse controle grava seu conteúdo para uma página, ele usa o <xref:System.Web.UI.Page.VerifyRenderingInServerForm%2A> método para certificar-se de que o controle é exibido entre as marcas de abertura e fechamento de um <xref:System.Web.UI.HtmlControls.HtmlForm> controle.  
  
 [!code-csharp[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/CS/testlinkbutton.cs#3)]
 [!code-vb[System.Web.UI.Page_VerifyRenderingInServerForm#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.UI.Page_VerifyRenderingInServerForm/vb/testlinkbutton.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">O controle de servidor especificado não está contido entre as marcas de abertura e fechamento do controle de servidor <see cref="T:System.Web.UI.HtmlControls.HtmlForm" /> no tempo de execução.</exception>
        <exception cref="T:System.ArgumentNullException">O controle a ser verificado é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateEncryptionMode">
      <MemberSignature Language="C#" Value="public System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Web.UI.ViewStateEncryptionMode ViewStateEncryptionMode" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateEncryptionMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.ViewStateEncryptionMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modo de criptografia do estado de exibição.</summary>
        <value>Um dos valores de <see cref="T:System.Web.UI.ViewStateEncryptionMode" />. O valor padrão é <see cref="F:System.Web.UI.ViewStateEncryptionMode.Auto" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.UI.Page.ViewStateEncryptionMode%2A> propriedade não pode ser definida no código. Só pode ser definida na diretiva de ou além do < elemento do arquivo de configuração. Valores definidos na diretiva substituem todos os valores definidos no arquivo de configuração.  
  
 A sintaxe para definir essa propriedade na diretiva é da seguinte maneira:  
  
```vb  
<%@ Page Language="VB" ViewStateEncryptionMode="Always" %>  
```  
  
```csharp  
<%@ Page Language="C#" ViewStateEncryptionMode="Always" %>  
```  
  
 A sintaxe para definir essa propriedade no arquivo de configuração é da seguinte maneira:  
  
```vb  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
```csharp  
<system.web>  
  <pages viewStateEncryptionMode="Always" />  
</system.web>  
```  
  
 Os desenvolvedores de controle personalizado poderá verificar o valor dessa propriedade no código antes de salvar dados potencialmente confidenciais e estado de exibição em seu controle.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor definido não é membro da enumeração <see cref="T:System.Web.UI.ViewStateEncryptionMode" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="P:System.Web.UI.Page.ViewStateEncryptionMode" /> propriedade pode ser definida somente em ou antes da página <see langword="PreRender" /> fase no ciclo de vida da página.</exception>
      </Docs>
    </Member>
    <Member MemberName="ViewStateUserKey">
      <MemberSignature Language="C#" Value="public string ViewStateUserKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ViewStateUserKey" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.ViewStateUserKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Atribui um identificador para um usuário individual na variável de estado de exibição associado à página atual.</summary>
        <value>O identificador de usuário individual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definindo o <xref:System.Web.UI.Page.ViewStateUserKey%2A> propriedade pode ajudar a impedir ataques em seu aplicativo contra usuários mal-intencionados. Ele faz isso, permitindo que você atribua um identificador para a variável de estado de exibição para usuários individuais para que eles não podem usar a variável para gerar um ataque. Para obter mais informações sobre ataques de Web e que você pode fazer para ajudar a evitá-los, consulte [tirar vantagem do ASP.NET recursos internos para procurá-los fora da Web ataques](http://go.microsoft.com/fwlink/?LinkId=163557).  
  
 Você pode definir essa propriedade como qualquer valor de cadeia de caracteres, como o usuário do nome autenticado ou <xref:System.Web.SessionState.HttpSessionState.SessionID%2A> valor.  
  
> [!NOTE]
>  Você deve definir essa propriedade durante o `Page_Init` fase do processamento da página. A definição dessa propriedade durante o `Page_Load` fase lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">A propriedade <see cref="P:System.Web.UI.Page.ViewStateUserKey" /> foi acessada muito tarde durante o processamento da página.</exception>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public override bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Page.Visible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Web.UI.Page" /> objeto é processado.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Web.UI.Page" /> deve ser renderizado; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir define o <xref:System.Web.UI.Page.Visible%2A> propriedade `false` para ocultar o conteúdo renderizado de uma página. Quando esta página é solicitada pela primeira vez, uma fonte de dados é preenchida e exibida na página. Quando um usuário clica no botão, o `HideButton_Click` manipulador de eventos oculta todo o conteúdo da página renderizado.  
  
 [!code-csharp[Page_Visible#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Page_Visible/CS/page_visible.cs.aspx#1)]
 [!code-vb[Page_Visible#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Page_Visible/VB/page_visible.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
