<Type Name="TreeView" FullName="System.Windows.Forms.TreeView">
  <TypeSignature Language="C#" Value="public class TreeView : System.Windows.Forms.Control" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TreeView extends System.Windows.Forms.Control" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.TreeView" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Control</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("AfterSelect")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Nodes")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.TreeViewDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDispatch)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Exibe uma coleção hierárquica de itens rotulados, cada um representado por um <see cref="T:System.Windows.Forms.TreeNode" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.Nodes%2A> coleção contém todos os o <xref:System.Windows.Forms.TreeNode> objetos que recebem o <xref:System.Windows.Forms.TreeView> controle. Os nós de árvore na coleção são chamados de nós da árvore de raiz. Qualquer nó de árvore que é subsequentemente adicionado a um nó raiz da árvore é conhecido como um nó filho. Como cada <xref:System.Windows.Forms.TreeNode> pode conter uma coleção de outros <xref:System.Windows.Forms.TreeNode> objetos, talvez seja difícil determinar seu local na estrutura de árvore quando se itera através da coleção. Você pode analisar o <xref:System.Windows.Forms.TreeNode.FullPath%2A?displayProperty=nameWithType> cadeia de caracteres usando o <xref:System.Windows.Forms.TreeView.PathSeparator%2A> string valor para determinar onde um <xref:System.Windows.Forms.TreeNode> rótulo começa e termina.  
  
 Você pode exibir imagens ao lado de nós de árvore, atribuindo um <xref:System.Windows.Forms.ImageList> para o <xref:System.Windows.Forms.TreeView.ImageList%2A> propriedade e referenciando o valor de índice de um <xref:System.Drawing.Image> no <xref:System.Windows.Forms.ImageList> atribuir que <xref:System.Drawing.Image>. Use as propriedades a seguir para atribuir imagens:  
  
-   Definir o <xref:System.Windows.Forms.TreeView.ImageIndex%2A> propriedade para o valor de índice a <xref:System.Drawing.Image> que você deseja exibir quando um nó de árvore não está selecionado.  
  
-   Definir o <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> propriedade para o valor de índice a <xref:System.Drawing.Image> que você deseja exibir quando um nó de árvore é selecionado.  
  
 As imagens referenciadas pelo <xref:System.Windows.Forms.TreeView.ImageIndex%2A> e <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> valores de propriedade são imagens padrão exibidas por todos os nós de árvore que são atribuídos para a <xref:System.Windows.Forms.TreeView.Nodes%2A> coleção. Nós de árvore individual podem substituir as imagens padrão definindo o <xref:System.Windows.Forms.TreeNode.ImageIndex%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.TreeNode.SelectedImageIndex%2A?displayProperty=nameWithType> propriedades.  
  
 As imagens de estado exibidas no <xref:System.Windows.Forms.TreeView> 16x16 pixels por padrão. Definindo o <xref:System.Windows.Forms.ImageList.ImageSize%2A> propriedade o <xref:System.Windows.Forms.TreeView.StateImageList%2A> não tem efeito sobre como as imagens são exibidas. No entanto, as imagens de estado são redimensionadas de acordo com a configuração de DPI do sistema quando o arquivo App. config contém a seguinte entrada:  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
  
```  
  
 Nós de árvore podem ser expandidos para exibir o próximo nível filho de nós de árvore. O usuário pode expandir o <xref:System.Windows.Forms.TreeNode> clicando no botão de sinal de adição (+), caso seja exibida ao lado de <xref:System.Windows.Forms.TreeNode>, ou você pode expandir o <xref:System.Windows.Forms.TreeNode> chamando o <xref:System.Windows.Forms.TreeNode.Expand%2A?displayProperty=nameWithType> método. Para expandir todos os filhos árvore nó níveis no <xref:System.Windows.Forms.TreeNode.Nodes%2A> coleção, chame o <xref:System.Windows.Forms.TreeNode.ExpandAll%2A> método. Você pode recolher o filho <xref:System.Windows.Forms.TreeNode> nível chamando o <xref:System.Windows.Forms.TreeNode.Collapse%2A?displayProperty=nameWithType> método ou o usuário pode pressionar o botão de sinal de subtração (-), caso seja exibida ao lado de <xref:System.Windows.Forms.TreeNode>. Você também pode chamar o <xref:System.Windows.Forms.TreeNode.Toggle%2A?displayProperty=nameWithType> método para alternar entre os estados expandidos e recolhidos.  
  
 Nós de árvore, opcionalmente, podem exibir caixas de seleção. Para exibir as caixas de seleção, defina o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> propriedade o <xref:System.Windows.Forms.TreeView> para `true`. O <xref:System.Windows.Forms.TreeNode.Checked%2A> está definida como `true` para nós de árvore que estão em um estado selecionado.  
  
> [!NOTE]
>  Definindo o <xref:System.Windows.Forms.TreeNode.Checked%2A?displayProperty=nameWithType> propriedade de dentro do <xref:System.Windows.Forms.TreeView.BeforeCheck> ou <xref:System.Windows.Forms.TreeView.AfterCheck> evento faz com que o evento a ser gerado várias vezes e pode resultar em comportamento inesperado. Por exemplo, você pode definir o <xref:System.Windows.Forms.TreeNode.Checked%2A> propriedade no manipulador de eventos quando você estiver recursivamente atualizar os nós filho para que o usuário não precise expandir e verifique se cada um deles individualmente. Para impedir que o evento que está sendo gerado várias vezes, adicionar lógica para o manipulador de eventos que executa o código recursivo somente se o <xref:System.Windows.Forms.TreeViewEventArgs.Action%2A> propriedade o <xref:System.Windows.Forms.TreeViewEventArgs> não está definido como <xref:System.Windows.Forms.TreeViewAction?displayProperty=nameWithType>. Para obter um exemplo de como fazer isso, consulte a seção exemplo de <xref:System.Windows.Forms.TreeView.AfterCheck> ou <xref:System.Windows.Forms.TreeView.BeforeCheck> eventos.  
  
 Você pode alterar a aparência do <xref:System.Windows.Forms.TreeView> controle definindo algumas de suas propriedades de exibição e estilo. Configuração <xref:System.Windows.Forms.TreeView.ShowPlusMinus%2A> para `true` exibe um botão de sinal de adição ou sinal de subtração ao lado de cada <xref:System.Windows.Forms.TreeNode> que podem ser expandidas ou recolhidas, respectivamente. Definindo o <xref:System.Windows.Forms.TreeView.ShowRootLines%2A> propriedade `true` faz com que o <xref:System.Windows.Forms.TreeView> para exibir linhas que reúnam todos os nós de árvore de raiz. Você pode exibir linhas que conectam os nós de árvore filho para o nó raiz, definindo o <xref:System.Windows.Forms.TreeView.ShowLines%2A> propriedade `true`. Definindo o <xref:System.Windows.Forms.TreeView.HotTracking%2A> propriedade `true` alterações a aparência dos rótulos de nó de árvore quando o ponteiro do mouse passa sobre eles. Quando hot-rastreadas, os rótulos de nó de árvore assumem a aparência de um hiperlink. Também completamente, você pode personalizar a aparência do <xref:System.Windows.Forms.TreeView> controle. Para fazer isso, defina o <xref:System.Windows.Forms.TreeView.DrawMode%2A> propriedade com um valor diferente de <xref:System.Windows.Forms.TreeViewDrawMode?displayProperty=nameWithType> e tratar o <xref:System.Windows.Forms.TreeView.DrawNode> evento.  
  
> [!NOTE]
>  Ao definir o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A>, <xref:System.Windows.Forms.TreeView.Scrollable%2A>, <xref:System.Windows.Forms.TreeView.ImageIndex%2A>, e <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> propriedades em tempo de execução, o <xref:System.Windows.Forms.TreeView> identificador é recriado (consulte <xref:System.Windows.Forms.Control.RecreateHandle%2A?displayProperty=nameWithType>) para atualizar a aparência do controle. Isso faz com que todos os nós de árvore a ser recolhido, exceto a selecionada <xref:System.Windows.Forms.TreeNode>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Windows.Forms.TreeView> controle.  
  
 [!code-csharp[TreeViewMisc#10](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewMisc/cs/form1.cs#10)]
 [!code-vb[TreeViewMisc#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewMisc/vb/form1.vb#10)]  
  
 O exemplo de código a seguir e mais complexo exibe informações do cliente em um <xref:System.Windows.Forms.TreeView> controle. Os nós de árvore raiz exibem nomes de clientes, e os nós de árvore filho exibem os números de ordem atribuídos a cada cliente. Neste exemplo, 1.000 clientes são exibidos com 15 pedidos. De refazer o <xref:System.Windows.Forms.TreeView> é suprimida usando o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> e <xref:System.Windows.Forms.TreeView.EndUpdate%2A> métodos e uma espera <xref:System.Windows.Forms.Cursor> é exibida enquanto o <xref:System.Windows.Forms.TreeView> cria e pinta o <xref:System.Windows.Forms.TreeNode> objetos. Este exemplo requer que você tenha um `Customer` objeto que pode conter uma coleção de `Order` objetos. Ele também requer que você tenha um arquivo de cursor que é chamado `MyWait.cur` no diretório do aplicativo e que você criou uma instância de um <xref:System.Windows.Forms.TreeView> control em um <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TreeView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Forms.TreeView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como alterar o estado recolhido de uma <xref:System.Windows.Forms.TreeView> para que todos os nós marcados estão visíveis. Primeiro, todos os nós são expandidos e um manipulador é adicionado para o <xref:System.Windows.Forms.TreeView.BeforeCollapse> evento. Em seguida, todos os nós estão recolhidos. O <xref:System.Windows.Forms.TreeView.BeforeCollapse> manipulador de eventos determina se um determinado nó tem nós filhos que são verificadas. Se um nó verificou filhos, o recolhimento é cancelado para esse nó. Para permitir que o recolhimento de nó padrão quando o sinal de subtração ao lado de um nó é clicado, o <xref:System.Windows.Forms.TreeView.BeforeCollapse> manipulador de eventos é então removido.  
  
 Esse comportamento também pode ser implementado pelo tratamento de <xref:System.Windows.Forms.TreeView.BeforeExpand> evento, conforme ilustrado no exemplo para esse tópico.  
  
 [!code-cpp[TreeViewShowCheckedNodes2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewShowCheckedNodes2/CPP/treeviewshowcheckednodes2.cpp#1)]
 [!code-csharp[TreeViewShowCheckedNodes2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewShowCheckedNodes2/CS/treeviewshowcheckednodes2.cs#1)]
 [!code-vb[TreeViewShowCheckedNodes2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewShowCheckedNodes2/VB/treeviewshowcheckednodes2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AfterCheck">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewEventHandler AfterCheck;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewEventHandler AfterCheck" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.AfterCheck" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que a caixa de seleção do nó de árvore é marcada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definindo o <xref:System.Windows.Forms.TreeNode.Checked%2A?displayProperty=nameWithType> propriedade de dentro um <xref:System.Windows.Forms.TreeView.BeforeCheck> ou <xref:System.Windows.Forms.TreeView.AfterCheck> manipulador de eventos faz com que o evento a ser gerado várias vezes e pode resultar em comportamento inesperado. Para impedir que o evento que está sendo gerado várias vezes, adicionar lógica para o manipulador de eventos que executa o código recursivo somente se o <xref:System.Windows.Forms.TreeViewEventArgs.Action%2A> propriedade o <xref:System.Windows.Forms.TreeViewEventArgs> não está definido como <xref:System.Windows.Forms.TreeViewAction?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir atualiza todos os nós de árvore filho de um <xref:System.Windows.Forms.TreeNode> quando o usuário altera seu estado de ativação. Esse código requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.TreeView> com <xref:System.Windows.Forms.TreeNode> objetos no seu <xref:System.Windows.Forms.TreeNodeCollection>. O <xref:System.Windows.Forms.TreeNodeCollection> devem ter nós de árvore conosco filho.  
  
 [!code-cpp[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/CPP/tn_checked.cpp#1)]
 [!code-csharp[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/CS/tn_checked.cs#1)]
 [!code-vb[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/VB/tn_checked.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AfterCollapse">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewEventHandler AfterCollapse;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewEventHandler AfterCollapse" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.AfterCollapse" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que o nó de árvore é recolhido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir atualiza todos os nós de árvore filho de um <xref:System.Windows.Forms.TreeNode> quando o usuário altera seu estado de ativação. Esse código requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.TreeView> com <xref:System.Windows.Forms.TreeNode> objetos no seu <xref:System.Windows.Forms.TreeNodeCollection>. O <xref:System.Windows.Forms.TreeNodeCollection> devem ter nós de árvore conosco filho.  
  
 [!code-cpp[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/CPP/tn_checked.cpp#1)]
 [!code-csharp[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/CS/tn_checked.cs#1)]
 [!code-vb[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/VB/tn_checked.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AfterExpand">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewEventHandler AfterExpand;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewEventHandler AfterExpand" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.AfterExpand" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre depois que o nó de árvore é expandido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.TreeView.AfterExpand> eventos. Esse relatório ajuda a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.TreeView> chamado `TreeView1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.TreeView.AfterExpand> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#631](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#631)]
 [!code-vb[System.Windows.Forms.EventExamples#631](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#631)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AfterLabelEdit">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.NodeLabelEditEventHandler AfterLabelEdit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.NodeLabelEditEventHandler AfterLabelEdit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.AfterLabelEdit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.NodeLabelEditEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após a edição do texto de rótulo do nó de árvore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir permite que o usuário edite nós de árvore de não-raiz usando um <xref:System.Windows.Forms.ContextMenu>. Quando o usuário clica o mouse, o <xref:System.Windows.Forms.TreeNode> em que a posição é determinada e armazenada em uma variável chamada `mySelectedNode`. Se um nó de árvore de não-raiz foi selecionado, ela será colocada no estado editável, que permite que o usuário edite o rótulo do nó. Depois que o usuário para editar o rótulo do nó de árvore, o novo texto de rótulo é avaliado e salvo. Neste exemplo, vários caracteres são considerados não válidos no texto do rótulo. Se um dos caracteres inválidos está na cadeia de caracteres de rótulo, ou a cadeia de caracteres está vazia, o usuário é notificado sobre o erro e o rótulo é retornado ao seu texto anterior.  
  
 [!code-cpp[classic treenode.beginedit example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/CPP/source.cpp#1)]
 [!code-csharp[classic treenode.beginedit example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/CS/source.cs#1)]
 [!code-vb[classic treenode.beginedit example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AfterSelect">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewEventHandler AfterSelect;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewEventHandler AfterSelect" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.AfterSelect" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre após o nó da árvore ser selecionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento ocorre quando o nó estiver desmarcado. Para detectar se a seleção foi desmarcada, você pode testar o <xref:System.Windows.Forms.TreeNode.IsSelected%2A?displayProperty=nameWithType> propriedade.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.TreeViewAction> enumeração. Para executar este exemplo, cole o seguinte código em um formulário que contém um <xref:System.Windows.Forms.TreeView> controle chamado `TreeView1`. Este exemplo requer que `TreeView1` é preenchida com itens e o <xref:System.Windows.Forms.TreeView.AfterSelect> evento está conectado ao manipulador de eventos definido no exemplo.  
  
 [!code-cpp[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.BackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor da tela de fundo do controle.</summary>
        <value>Um <see cref="T:System.Drawing.Color" /> que representa a cor da tela de fundo do controle. O padrão é o valor da propriedade <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a imagem de tela de fundo do controle <see cref="T:System.Windows.Forms.TreeView" />.</summary>
        <value>O <see cref="T:System.Drawing.Image" /> que é a imagem de tela de fundo do controle <see cref="T:System.Windows.Forms.TreeView" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.BackgroundImageChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a propriedade <see cref="P:System.Windows.Forms.TreeView.BackgroundImage" /> muda.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o layout da imagem do plano de fundo para o <see cref="T:System.Windows.Forms.TreeView" /> controle.</summary>
        <value>Um dos valores de <see cref="T:System.Windows.Forms.ImageLayout" />. O padrão é <see cref="F:System.Windows.Forms.ImageLayout.Tile" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade/método/evento não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.BackgroundImageLayoutChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a propriedade <see cref="P:System.Windows.Forms.TreeView.BackgroundImageLayout" /> muda.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BeforeCheck">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewCancelEventHandler BeforeCheck;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewCancelEventHandler BeforeCheck" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.BeforeCheck" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes que a caixa de seleção do nó de árvore é marcada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Definindo o <xref:System.Windows.Forms.TreeNode.Checked%2A?displayProperty=nameWithType> propriedade de dentro do <xref:System.Windows.Forms.TreeView.BeforeCheck> ou <xref:System.Windows.Forms.TreeView.AfterCheck> evento faz com que o evento a ser gerado várias vezes e pode resultar em comportamento inesperado. Por exemplo, você pode definir o <xref:System.Windows.Forms.TreeNode.Checked%2A> propriedade no manipulador de eventos quando você estiver recursivamente atualizar os nós filho, para que o usuário não precise expandir e verifique se cada um deles individualmente. Para impedir que o evento que está sendo gerado várias vezes, adicionar lógica para o manipulador de eventos que executa o código recursivo somente se o <xref:System.Windows.Forms.TreeViewEventArgs.Action%2A> propriedade o <xref:System.Windows.Forms.TreeViewEventArgs> não está definido como <xref:System.Windows.Forms.TreeViewAction?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir atualiza todos os nós de árvore filho de um <xref:System.Windows.Forms.TreeNode> quando o usuário altera seu estado de ativação. Esse código requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.TreeView> com <xref:System.Windows.Forms.TreeNode> objetos no seu <xref:System.Windows.Forms.TreeNodeCollection>. O <xref:System.Windows.Forms.TreeNodeCollection> devem ter nós de árvore conosco filho.  
  
 [!code-cpp[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/CPP/tn_checked.cpp#1)]
 [!code-csharp[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/CS/tn_checked.cs#1)]
 [!code-vb[TreeView.AfterCheck_BeforeCheck#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView.AfterCheck_BeforeCheck/VB/tn_checked.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeforeCollapse">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewCancelEventHandler BeforeCollapse;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewCancelEventHandler BeforeCollapse" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.BeforeCollapse" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes que o nó de árvore é recolhido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como alterar o estado recolhido de uma <xref:System.Windows.Forms.TreeView> para que todos os nós marcados estão visíveis. Primeiro, todos os nós são expandidos e um manipulador é adicionado para o <xref:System.Windows.Forms.TreeView.BeforeCollapse> evento. Em seguida, todos os nós estão recolhidos. O <xref:System.Windows.Forms.TreeView.BeforeCollapse> manipulador de eventos determina se um determinado nó tem nós filhos que são verificadas. Se um nó verificou filhos, o recolhimento é cancelado para esse nó. Para permitir que o recolhimento de nó padrão quando o sinal de subtração ao lado de um nó é clicado, o <xref:System.Windows.Forms.TreeView.BeforeCollapse> manipulador de eventos é então removido.  
  
 Esse comportamento também pode ser implementado pelo tratamento de <xref:System.Windows.Forms.TreeView.BeforeExpand> evento, conforme ilustrado no exemplo para esse tópico.  
  
 Para o exemplo completo, consulte o <xref:System.Windows.Forms.TreeView.%23ctor%2A> tópico de referência de construtor.  
  
 [!code-cpp[TreeViewShowCheckedNodes2#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewShowCheckedNodes2/CPP/treeviewshowcheckednodes2.cpp#2)]
 [!code-csharp[TreeViewShowCheckedNodes2#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewShowCheckedNodes2/CS/treeviewshowcheckednodes2.cs#2)]
 [!code-vb[TreeViewShowCheckedNodes2#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewShowCheckedNodes2/VB/treeviewshowcheckednodes2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeforeExpand">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewCancelEventHandler BeforeExpand;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewCancelEventHandler BeforeExpand" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.BeforeExpand" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes que o nó de árvore é expandido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como alterar o estado recolhido de uma <xref:System.Windows.Forms.TreeView> para que todos os nós marcados estão visíveis. Primeiro, todos os nós são recolhidos, e um manipulador é adicionado para o <xref:System.Windows.Forms.TreeView.BeforeExpand> evento. Em seguida, todos os nós são expandidos. O <xref:System.Windows.Forms.TreeView.BeforeExpand> manipulador de eventos determina se um determinado nó tem nós filhos que são verificadas. Se um nó não tem filhos marcados, a expansão é cancelada para esse nó. Para permitir a expansão de nó padrão quando o sinal de adição ao lado de um nó é clicado, o <xref:System.Windows.Forms.TreeView.BeforeExpand> manipulador de eventos é então removido.  
  
 Esse comportamento também pode ser implementado pelo tratamento de <xref:System.Windows.Forms.TreeView.BeforeCollapse> evento, conforme ilustrado no exemplo para esse tópico.  
  
 Para o exemplo completo, consulte o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> tópico de referência.  
  
 [!code-cpp[TreeViewShowCheckedNodes1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/CPP/treeviewshowcheckednodes1.cpp#2)]
 [!code-csharp[TreeViewShowCheckedNodes1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/CS/treeviewshowcheckednodes1.cs#2)]
 [!code-vb[TreeViewShowCheckedNodes1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/VB/treeviewshowcheckednodes1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeforeLabelEdit">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.NodeLabelEditEventHandler BeforeLabelEdit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.NodeLabelEditEventHandler BeforeLabelEdit" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.BeforeLabelEdit" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.NodeLabelEditEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes da edição do texto de rótulo do nó de árvore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.TreeView.BeforeLabelEdit> <xref:System.Windows.Forms.TreeView.AfterSelect> e <xref:System.Windows.Forms.TreeView.TopNode%2A> membros. Para executar este exemplo, cole o seguinte código em um formulário que contém um `TreeView` controle chamado `TreeView1`. Chamar o `InitializeTreeView` método no construtor do formulário ou `Load` método.  
  
 [!code-cpp[System.Windows.Forms.TreeViewAndPrintPreview#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TreeViewAndPrintPreview#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TreeViewAndPrintPreview#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/VB/form1.vb#1)]  
[!code-cpp[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CPP/form1.cpp#2)]
[!code-csharp[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CS/form1.cs#2)]
[!code-vb[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeforeSelect">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeViewCancelEventHandler BeforeSelect;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeViewCancelEventHandler BeforeSelect" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.BeforeSelect" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre antes da seleção do nó de árvore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.TreeView.BeforeSelect> eventos. Esse relatório ajuda a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.TreeView> chamado `TreeView1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.TreeView.BeforeSelect> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#635](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#635)]
 [!code-vb[System.Windows.Forms.EventExamples#635](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#635)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginUpdate">
      <MemberSignature Language="C#" Value="public void BeginUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.BeginUpdate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Desabilita todo o redesenho do modo de exibição de árvore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para manter o desempenho enquanto os itens são adicionados um por vez para o <xref:System.Windows.Forms.TreeView>, chame o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> método. O <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> método impede que o controle de pintura até que o <xref:System.Windows.Forms.TreeView.EndUpdate%2A> método é chamado.  
  
 A melhor maneira de adicionar itens a um controle de exibição de árvore é usar o <xref:System.Windows.Forms.TreeNodeCollection.AddRange%2A> para adicionar uma matriz de itens do nó de árvore para uma exibição de árvore. No entanto, se você deseja adicionar um item por vez, use o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> método para impedir que o <xref:System.Windows.Forms.TreeView> controle de pintura durante as operações de adicionar. Para permitir que o controle retomar a pintura, chame o <xref:System.Windows.Forms.TreeView.EndUpdate%2A> método quando todos os nós de árvore foram adicionados para o modo de exibição de árvore.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe informações do cliente em um <xref:System.Windows.Forms.TreeView> controle. Os nós de árvore raiz exibem nomes de clientes, e os nós de árvore filho exibem os números de ordem atribuídos a cada cliente. Neste exemplo, 1.000 clientes são exibidos com 15 pedidos. De refazer o <xref:System.Windows.Forms.TreeView> é suprimida usando o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> e <xref:System.Windows.Forms.TreeView.EndUpdate%2A> métodos e uma espera <xref:System.Windows.Forms.Cursor> é exibida enquanto o <xref:System.Windows.Forms.TreeView> cria e pinta o <xref:System.Windows.Forms.TreeNode> objetos. Este exemplo requer que você tenha um `Customer` objeto que pode conter uma coleção de `Order` objetos. Ele também requer que você tenha um arquivo de cursor que é chamado `MyWait.cur` no diretório do aplicativo e que você criou uma instância de um <xref:System.Windows.Forms.TreeView> control em um <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.BorderStyle BorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.BorderStyle BorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.BorderStyle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.BorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o estilo de borda do controle de exibição de árvore.</summary>
        <value>Um dos valores de <see cref="T:System.Windows.Forms.BorderStyle" />. O padrão é <see cref="F:System.Windows.Forms.BorderStyle.Fixed3D" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Windows.Forms.TreeView.BorderStyle%2A> está definida como <xref:System.Windows.Forms.BorderStyle.Fixed3D>, o <xref:System.Windows.Forms.TreeView> tem uma aparência em baixo-relevo, tridimensional. Para exibir uma borda fina simples em torno de <xref:System.Windows.Forms.TreeView> controlar, defina o <xref:System.Windows.Forms.BorderStyle> propriedade <xref:System.Windows.Forms.BorderStyle.FixedSingle>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.BorderStyle> enumeração e <xref:System.Windows.Forms.TreeView.BorderStyle%2A>, <xref:System.Windows.Forms.TreeView.ShowLines%2A>, <xref:System.Windows.Forms.TreeView.Scrollable%2A>, <xref:System.Windows.Forms.TreeView.HideSelection%2A> e <xref:System.Windows.Forms.TreeView.ShowRootLines%2A> propriedades. Para executar este exemplo, cole o seguinte código em um formulário e a chamada a `InitializeTreeView` método no construtor do formulário ou `Load` método.  
  
 [!code-cpp[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O valor atribuído não é um dos valores <see cref="T:System.Windows.Forms.BorderStyle" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckBoxes">
      <MemberSignature Language="C#" Value="public bool CheckBoxes { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CheckBoxes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.CheckBoxes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as caixas de seleção são exibidas ao lado dos nós de árvore no controle de exibição de árvore.</summary>
        <value>
          <see langword="true" /> se uma caixa de seleção for exibida ao lado de cada nó de árvore no controle de exibição de árvore; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 É exibida uma caixa de seleção à esquerda do rótulo do nó de árvore e no nó de árvore <xref:System.Drawing.Image>, se houver. Caixas de seleção Permitir que o usuário selecionar mais de um nó de árvore de cada vez.  
  
 Quando o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> propriedade de um <xref:System.Windows.Forms.TreeView> é definido como `true`e o <xref:System.Windows.Forms.TreeView.StateImageList%2A> propriedade for definida, cada <xref:System.Windows.Forms.TreeNode> que está contida no <xref:System.Windows.Forms.TreeView> exibe as imagens de primeira e segunda do <xref:System.Windows.Forms.TreeView.StateImageList%2A> para indicar um estado marcado ou desmarcado, respectivamente. No entanto, as imagens exibidas podem ser diferentes se ocorre a seguinte situação: se o <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> do nó é definido como um valor diferente de 0 ou 1 e o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> propriedade do pai <xref:System.Windows.Forms.TreeView> é definido como `false`, o <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> não será automaticamente redefinido como -1 para indicar que não está definido. Nesse caso, é mostrada a imagem do estado na posição de índice indicado. Se <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> é definido como `true` novamente, as imagens de primeira e segunda do <xref:System.Windows.Forms.TreeView.StateImageList%2A> são mostradas para indicar um estado marcado ou desmarcado, respectivamente.  
  
> [!NOTE]
>  Ao definir o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> propriedade em tempo de execução, o <xref:System.Windows.Forms.TreeView> identificador é recriado (consulte <xref:System.Windows.Forms.Control.RecreateHandle%2A?displayProperty=nameWithType>) para atualizar a aparência do controle. Isso faz com que todos os nós de árvore a ser recolhido com a exceção selecionado <xref:System.Windows.Forms.TreeNode>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como alterar o estado recolhido de uma <xref:System.Windows.Forms.TreeView> para que todos os nós marcados estão visíveis. Primeiro, todos os nós são recolhidos, e um manipulador é adicionado para o <xref:System.Windows.Forms.TreeView.BeforeExpand> evento. Em seguida, todos os nós são expandidos. O <xref:System.Windows.Forms.TreeView.BeforeExpand> manipulador de eventos determina se um determinado nó tem nós filhos que são verificadas. Se um nó não tem filhos marcados, a expansão é cancelada para esse nó. Para permitir a expansão de nó padrão quando o sinal de adição ao lado de um nó é clicado, o <xref:System.Windows.Forms.TreeView.BeforeExpand> manipulador de eventos é então removido.  
  
 Esse comportamento também pode ser implementado pelo tratamento de <xref:System.Windows.Forms.TreeView.BeforeCollapse> evento, conforme ilustrado no exemplo para esse tópico.  
  
 [!code-cpp[TreeViewShowCheckedNodes1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/CPP/treeviewshowcheckednodes1.cpp#1)]
 [!code-csharp[TreeViewShowCheckedNodes1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/CS/treeviewshowcheckednodes1.cs#1)]
 [!code-vb[TreeViewShowCheckedNodes1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/VB/treeviewshowcheckednodes1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollapseAll">
      <MemberSignature Language="C#" Value="public void CollapseAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CollapseAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.CollapseAll" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recolhe todos os nós da árvore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.CollapseAll%2A> método recolhe todos os <xref:System.Windows.Forms.TreeNode> objetos, que inclui todos os nós de árvore filho, o que estão no <xref:System.Windows.Forms.TreeView> controle.  
  
> [!NOTE]
>  O estado de um <xref:System.Windows.Forms.TreeNode> persistir. Por exemplo, suponha que você chamar o <xref:System.Windows.Forms.TreeNode.Expand%2A> método para um nó raiz da árvore. Se os nós de árvore filho não foram recolhidos anteriormente, elas aparecerão em seu estado previamente expandidos. Chamar o <xref:System.Windows.Forms.TreeView.CollapseAll%2A> método garante que todos os nós de árvore aparecerão no estado recolhido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como alterar o estado recolhido de uma <xref:System.Windows.Forms.TreeView> para que todos os nós marcados estão visíveis. Primeiro, todos os nós são recolhidos, e um manipulador é adicionado para o <xref:System.Windows.Forms.TreeView.BeforeExpand> evento. Em seguida, todos os nós são expandidos. O <xref:System.Windows.Forms.TreeView.BeforeExpand> manipulador de eventos determina se um determinado nó tem nós filhos que são verificadas. Se um nó não tem filhos marcados, a expansão é cancelada para esse nó. Para permitir a expansão de nó padrão quando o sinal de adição ao lado de um nó é clicado, o <xref:System.Windows.Forms.TreeView.BeforeExpand> manipulador de eventos é então removido.  
  
 Esse comportamento também pode ser implementado pelo tratamento de <xref:System.Windows.Forms.TreeView.BeforeCollapse> evento, conforme ilustrado no exemplo para esse tópico.  
  
 Para o exemplo completo, consulte o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> tópico de referência.  
  
 [!code-cpp[TreeViewShowCheckedNodes1#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/CPP/treeviewshowcheckednodes1.cpp#2)]
 [!code-csharp[TreeViewShowCheckedNodes1#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/CS/treeviewshowcheckednodes1.cs#2)]
 [!code-vb[TreeViewShowCheckedNodes1#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewShowCheckedNodes1/VB/treeviewshowcheckednodes1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.CreateHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um identificador para o controle.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os parâmetros de criação necessários quando a alça de controle é criada.</summary>
        <value>Os parâmetros de criação.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">para acessar código não gerenciado ao obter o valor da propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho padrão do controle.</summary>
        <value>O <see cref="T:System.Drawing.Size" /> padrão do controle.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Windows.Forms.TreeView" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público `Dispose` e pelo método <xref:System.Object.Finalize%2A>. `Dispose` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro for true, este método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Windows.Forms.TreeView> referências. Este método invoca o método `Dispose` de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see langword="Dispose(Boolean)" /> cuidado para não fazer referência a objetos que têm foi descartados anteriormente em uma chamada anterior para <see langword="Dispose" />. Para obter mais informações sobre como implementar <see langword="Dispose(Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [substituindo o método Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DoubleBuffered">
      <MemberSignature Language="C#" Value="protected override bool DoubleBuffered { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DoubleBuffered" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.DoubleBuffered" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se este o controle deve redesenhar sua superfície usando um buffer secundário. A propriedade <see cref="P:System.Windows.Forms.TreeView.DoubleBuffered" /> não afeta o controle <see cref="T:System.Windows.Forms.TreeView" />.</summary>
        <value>
          <see langword="true" /> se o controle usar um buffer secundário; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definindo o <xref:System.Windows.Forms.TreeView.DoubleBuffered%2A> propriedade não afeta a <xref:System.Windows.Forms.TreeView> controle. Se você deseja reduzir a cintilação quando o <xref:System.Windows.Forms.TreeView> é desenhada, use o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> e <xref:System.Windows.Forms.TreeView.EndUpdate%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeViewDrawMode DrawMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.TreeViewDrawMode DrawMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.DrawMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewDrawMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o modo no qual o controle é desenhado.</summary>
        <value>Um dos valores de <see cref="T:System.Windows.Forms.TreeViewDrawMode" />. O padrão é <see cref="F:System.Windows.Forms.TreeViewDrawMode.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nós de um <xref:System.Windows.Forms.TreeView> normalmente são desenhadas pelo sistema operacional. O <xref:System.Windows.Forms.TreeView.DrawMode%2A> propriedade permite que você personalize a aparência de nós. Para fazer isso, defina <xref:System.Windows.Forms.TreeView.DrawMode%2A> para <xref:System.Windows.Forms.TreeViewDrawMode?displayProperty=nameWithType> ou <xref:System.Windows.Forms.TreeViewDrawMode?displayProperty=nameWithType> e fornecer um manipulador para o <xref:System.Windows.Forms.TreeView.DrawNode> evento. Isso é chamado de desenho do proprietário.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como personalizar um <xref:System.Windows.Forms.TreeView> controle usando o desenho do proprietário. O <xref:System.Windows.Forms.TreeView> controle no exemplo exibe marcas de nó opcional junto com os rótulos de nó padrão. Marcas de nó são especificadas usando o <xref:System.Windows.Forms.TreeNode.Tag%2A?displayProperty=nameWithType> propriedade. O <xref:System.Windows.Forms.TreeView> controle também usa cores personalizadas, que incluem uma cor de realce personalizadas.  
  
 Você pode personalizar a maioria do <xref:System.Windows.Forms.TreeView> cores definindo propriedades de cores, mas a cor de realce de seleção não está disponível como uma propriedade. Além disso, o retângulo de realce de seleção padrão estende-se apenas ao redor de um rótulo de nó. Desenho proprietário deve ser usado para desenhar as marcas de nó e desenhar um retângulo de realce personalizada grande o suficiente para incluir uma marca de nó.  
  
 Para o exemplo completo, consulte o <xref:System.Windows.Forms.TreeView.DrawNode> tópico de referência.  
  
 [!code-cpp[TreeViewOwnerDraw#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewOwnerDraw/CPP/treeviewownerdraw.cpp#2)]
 [!code-csharp[TreeViewOwnerDraw#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewOwnerDraw/CS/treeviewownerdraw.cs#2)]
 [!code-vb[TreeViewOwnerDraw#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewOwnerDraw/VB/treeviewownerdraw.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">O valor da propriedade não é um valor <see cref="T:System.Windows.Forms.TreeViewDrawMode" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="DrawNode">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawTreeNodeEventHandler DrawNode;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawTreeNodeEventHandler DrawNode" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.DrawNode" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawTreeNodeEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um <see cref="T:System.Windows.Forms.TreeView" /> é desenhado e a propriedade <see cref="P:System.Windows.Forms.TreeView.DrawMode" /> é definida como um valor de <see cref="T:System.Windows.Forms.TreeViewDrawMode" /> diferente de <see cref="F:System.Windows.Forms.TreeViewDrawMode.Normal" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este evento para personalizar a aparência de nós em um <xref:System.Windows.Forms.TreeView> controle usando o desenho do proprietário.  
  
 Esse evento é gerado apenas quando o <xref:System.Windows.Forms.TreeView.DrawMode%2A> está definida como <xref:System.Windows.Forms.TreeViewDrawMode> valores de <xref:System.Windows.Forms.TreeViewDrawMode.OwnerDrawAll> ou <xref:System.Windows.Forms.TreeViewDrawMode.OwnerDrawText>. A tabela a seguir indica como o <xref:System.Windows.Forms.TreeNode> pode ser personalizada quando o <xref:System.Windows.Forms.TreeView.DrawMode%2A> estiver definida como esses valores.  
  
|Valor da propriedade DrawMode|Personalização de TreeNode|  
|-----------------------------|----------------------------|  
|<xref:System.Windows.Forms.TreeViewDrawMode.OwnerDrawText>|O <xref:System.Windows.Forms.TreeNode> área rótulo pode ser personalizada. Todos os outros <xref:System.Windows.Forms.TreeNode> elementos serão desenhados automaticamente.|  
|<xref:System.Windows.Forms.TreeViewDrawMode.OwnerDrawAll>|A aparência de todo o <xref:System.Windows.Forms.TreeNode> pode ser personalizado. Ícones, caixas de verificação, adição e subtração sinais e linhas que conectam os nós devem ser definidas manualmente, se eles forem desejados.|  
  
 A região que o <xref:System.Windows.Forms.TreeNode.Text%2A?displayProperty=nameWithType> valor seria ocupam se ela foi desenhada usando a fonte especificada pelo <xref:System.Windows.Forms.TreeView> do controle <xref:System.Windows.Forms.Control.Font%2A> propriedade é a região em que um nó pode ser clicado para selecioná-lo. Isso é chamado de região de teste de clique. Se você desenhar esta região, você deve fornecer seu próprio código que seleciona um nó quando a área visível é clicada.  
  
 A região de teste de hit corresponde do <xref:System.Windows.Forms.DrawTreeNodeEventArgs.Bounds%2A?displayProperty=nameWithType> propriedade ao usar <xref:System.Windows.Forms.TreeViewDrawMode.OwnerDrawText>. Ao usar <xref:System.Windows.Forms.TreeViewDrawMode.OwnerDrawAll>, no entanto, o <xref:System.Windows.Forms.DrawTreeNodeEventArgs.Bounds%2A?displayProperty=nameWithType> propriedade abrange toda a largura do <xref:System.Windows.Forms.TreeView>. Nesse caso, você pode acessar a região de teste de clique Obtendo a <xref:System.Windows.Forms.DrawTreeNodeEventArgs.Node%2A?displayProperty=nameWithType> valor e acessar seu <xref:System.Windows.Forms.TreeNode.Bounds%2A?displayProperty=nameWithType> propriedade. É possível desenhar a região de teste de clique do nó dentro desses limites, ou você pode fornecer seu próprio código de teste de clique. Observe que a configuração de <xref:System.Windows.Forms.TreeNode.NodeFont%2A?displayProperty=nameWithType> propriedade não altera o tamanho da região de teste de clique, que é calculado usando a fonte especificada para toda a <xref:System.Windows.Forms.TreeView>.  
  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como personalizar um <xref:System.Windows.Forms.TreeView> controle usando o desenho do proprietário. O <xref:System.Windows.Forms.TreeView> controle no exemplo exibe marcas de nó opcional junto com os rótulos de nó padrão. Marcas de nó são especificadas usando o <xref:System.Windows.Forms.TreeNode.Tag%2A?displayProperty=nameWithType> propriedade. O <xref:System.Windows.Forms.TreeView> controle também usa cores personalizadas, que incluem uma cor de realce personalizadas.  
  
 Você pode personalizar a maioria do <xref:System.Windows.Forms.TreeView> cores definindo propriedades de cores, mas a cor de realce de seleção não está disponível como uma propriedade. Além disso, o retângulo de realce de seleção padrão estende-se apenas ao redor de um rótulo de nó. Desenho proprietário deve ser usado para desenhar as marcas de nó e desenhar um retângulo de realce personalizada grande o suficiente para incluir uma marca de nó.  
  
 No exemplo, um manipulador para o <xref:System.Windows.Forms.TreeView.DrawNode> desenhos de evento, as marcas de nó e a seleção personalizada realçar manualmente. Nós não selecionados não é necessário para personalização. Para isso, o <xref:System.Windows.Forms.DrawTreeNodeEventArgs.DrawDefault%2A?displayProperty=nameWithType> está definida como `true` para que eles serão desenhados pelo sistema operacional.  
  
 Além disso, um manipulador para o <xref:System.Windows.Forms.Control.MouseDown> evento fornece o teste de clique. Por padrão, um nó pode ser selecionado apenas clicando-se a região em torno de seu rótulo. O <xref:System.Windows.Forms.Control.MouseDown> manipulador seleciona um nó é clicado em qualquer lugar nesta região ou dentro da região em torno de uma marca de nó, se presente.  
  
 [!code-cpp[TreeViewOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewOwnerDraw/CPP/treeviewownerdraw.cpp#1)]
 [!code-csharp[TreeViewOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewOwnerDraw/CS/treeviewownerdraw.cs#1)]
 [!code-vb[TreeViewOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewOwnerDraw/VB/treeviewownerdraw.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndUpdate">
      <MemberSignature Language="C#" Value="public void EndUpdate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndUpdate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.EndUpdate" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Habilita o redesenho do modo de exibição de árvore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para manter o desempenho enquanto os itens são adicionados um por vez para o <xref:System.Windows.Forms.TreeView>, chame o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> método. O <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> método impede que o controle de pintura até que o <xref:System.Windows.Forms.TreeView.EndUpdate%2A> método é chamado.  
  
 A melhor maneira de adicionar itens a um controle de exibição de árvore é usar o <xref:System.Windows.Forms.TreeNodeCollection.AddRange%2A> para adicionar uma matriz de itens do nó de árvore para uma exibição de árvore. No entanto, se você deseja adicionar um item por vez, use o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> método para impedir que o <xref:System.Windows.Forms.TreeView> controle de pintura durante as operações de adicionar. Para permitir o controle retomar a pintura de controle, chame o <xref:System.Windows.Forms.TreeView.EndUpdate%2A> método quando todos os nós de árvore foram adicionados para o modo de exibição de árvore.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe informações do cliente em um <xref:System.Windows.Forms.TreeView> controle. Os nós de árvore raiz exibem nomes de clientes, e os nós de árvore filho exibem os números de ordem atribuídos a cada cliente. Neste exemplo, 1.000 clientes são exibidos com 15 pedidos. De refazer o <xref:System.Windows.Forms.TreeView> é suprimida usando o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> e <xref:System.Windows.Forms.TreeView.EndUpdate%2A> métodos e uma espera <xref:System.Windows.Forms.Cursor> é exibida enquanto o <xref:System.Windows.Forms.TreeView> cria e pinta o <xref:System.Windows.Forms.TreeNode> objetos. Este exemplo requer que você tenha um `Customer` objeto que pode conter uma coleção de `Order` objetos. Ele também requer que você tenha um arquivo de cursor que é chamado `MyWait.cur` no diretório do aplicativo e que você criou uma instância de um <xref:System.Windows.Forms.TreeView> control em um <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandAll">
      <MemberSignature Language="C#" Value="public void ExpandAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.ExpandAll" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Expande todos os nós de árvore.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.ExpandAll%2A> método expande todas as <xref:System.Windows.Forms.TreeNode> objetos, que inclui todos os nós de árvore filho, o que estão no <xref:System.Windows.Forms.TreeView> controle.  
  
> [!NOTE]
>  O estado de um <xref:System.Windows.Forms.TreeNode> persistir. Por exemplo, suponha que você chamar o <xref:System.Windows.Forms.TreeNode.ExpandAll%2A> método e, em seguida, os nós de árvore de raiz individuais são recolhidas. Os nós de árvore filho não foram recolhidos e aparecerão em seu estado expandido anteriormente quando os nós de árvore de raiz são expandidos novamente. Chamar o <xref:System.Windows.Forms.TreeView.CollapseAll%2A> método garante que todos os nós de árvore aparecerão no estado recolhido.  
  
   
  
## Examples  
 O exemplo de código a seguir expande todos os nós de árvore de um <xref:System.Windows.Forms.TreeView> controlar quando um <xref:System.Windows.Forms.CheckBox> está marcada e recolhe o <xref:System.Windows.Forms.TreeNode.FirstNode%2A> quando o <xref:System.Windows.Forms.CheckBox> está desmarcada. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.CheckBox>e um <xref:System.Windows.Forms.TreeView> controlar com um <xref:System.Windows.Forms.TreeNodeCollection> que tem várias <xref:System.Windows.Forms.TreeNode> objetos (preferencialmente com três ou mais níveis).  
  
 [!code-cpp[TreeNode_ForeColor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_ForeColor/CPP/treenode_forecolor.cpp#1)]
 [!code-csharp[TreeNode_ForeColor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_ForeColor/CS/treenode_forecolor.cs#1)]
 [!code-vb[TreeNode_ForeColor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_ForeColor/VB/treenode_forecolor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor de primeiro plano do controle.</summary>
        <value>O primeiro plano <see cref="T:System.Drawing.Color" /> do controle. O padrão é o valor da propriedade <see cref="P:System.Windows.Forms.Control.DefaultForeColor" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullRowSelect">
      <MemberSignature Language="C#" Value="public bool FullRowSelect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool FullRowSelect" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.FullRowSelect" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o realce de seleção abrange a largura do controle de exibição de árvore.</summary>
        <value>
          <see langword="true" /> se o realce de seleção abranger a largura do controle de exibição de árvore; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Windows.Forms.TreeView.FullRowSelect%2A> é `true`, realce uma seleção abrange toda a largura da exibição de árvore, exibir, em vez da largura do somente o rótulo do nó de árvore. O <xref:System.Windows.Forms.TreeView.FullRowSelect%2A> propriedade será ignorada se <xref:System.Windows.Forms.TreeView.ShowLines%2A> é definido como `true`.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra um personalizado <xref:System.Windows.Forms.TreeView>. Herdando de <xref:System.Windows.Forms.TreeView> classe, esta versão personalizada tem toda a funcionalidade de um típico <xref:System.Windows.Forms.TreeView>. Alterar vários valores de propriedade no construtor fornece uma aparência exclusiva. Porque o <xref:System.Windows.Forms.TreeView.ShowPlusMinus%2A> está definida como `false`, o controle personalizado também substitui o <xref:System.Windows.Forms.TreeView.OnAfterSelect%2A> método para nós podem ser expandidos e recolhidos quando eles são clicados.  
  
 Um controle que é personalizado dessa maneira pode ser usado em toda a organização, tornando mais fácil fornecer uma interface consistente sem exigir que as propriedades de controle a ser especificado em cada projeto.  
  
 [!code-cpp[TreeViewCustomization#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewCustomization/CPP/treeviewcustomization.cpp#2)]
 [!code-csharp[TreeViewCustomization#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewCustomization/CS/treeviewcustomization.cs#2)]
 [!code-vb[TreeViewCustomization#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewCustomization/VB/treeviewcustomization.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemRenderStyles">
      <MemberSignature Language="C#" Value="protected System.Windows.Forms.OwnerDrawPropertyBag GetItemRenderStyles (System.Windows.Forms.TreeNode node, int state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Forms.OwnerDrawPropertyBag GetItemRenderStyles(class System.Windows.Forms.TreeNode node, int32 state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.GetItemRenderStyles(System.Windows.Forms.TreeNode,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.OwnerDrawPropertyBag</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Windows.Forms.TreeNode" />
        <Parameter Name="state" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="node">O <see cref="T:System.Windows.Forms.TreeNode" /> para o qual retornar um <see cref="T:System.Windows.Forms.OwnerDrawPropertyBag" />.</param>
        <param name="state">O estado visível do <see cref="T:System.Windows.Forms.TreeNode" />.</param>
        <summary>Retorna um <see cref="T:System.Windows.Forms.OwnerDrawPropertyBag" /> especificado <see cref="T:System.Windows.Forms.TreeNode" />.</summary>
        <returns>Um <see cref="T:System.Windows.Forms.OwnerDrawPropertyBag" /> especificado <see cref="T:System.Windows.Forms.TreeNode" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNodeAt">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeNode GetNodeAt (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.TreeNode GetNodeAt(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.GetNodeAt(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">O <see cref="T:System.Drawing.Point" /> para avaliar e do qual recuperar o nó.</param>
        <summary>Recupera o nó de árvore que está no ponto especificado.</summary>
        <returns>O <see cref="T:System.Windows.Forms.TreeNode" /> no ponto especificado, em coordenadas do modo de exibição de árvore (de cliente) ou então <see langword="null" /> se não houver nenhum nó nesse local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode passar o <xref:System.Windows.Forms.MouseEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.MouseEventArgs.Y%2A?displayProperty=nameWithType> coordenadas do <xref:System.Windows.Forms.Control.MouseDown> evento como o <xref:System.Drawing.Point.X%2A> e <xref:System.Drawing.Point.Y%2A> valores de um novo <xref:System.Drawing.Point>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNodeAt">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeNode GetNodeAt (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.TreeNode GetNodeAt(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.GetNodeAt(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A posição <see cref="P:System.Drawing.Point.X" /> para avaliar e da qual recuperar o nó.</param>
        <param name="y">A posição <see cref="P:System.Drawing.Point.Y" /> para avaliar e da qual recuperar o nó.</param>
        <summary>Recupera o nó de árvore no ponto com as coordenadas especificadas.</summary>
        <returns>O <see cref="T:System.Windows.Forms.TreeNode" /> no local especificado, em coordenadas do modo de exibição de árvore (de cliente) ou então <see langword="null" /> se não houver nenhum nó nesse local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode passar o <xref:System.Windows.Forms.MouseEventArgs.X%2A?displayProperty=nameWithType> e <xref:System.Windows.Forms.MouseEventArgs.Y%2A?displayProperty=nameWithType> coordenadas do <xref:System.Windows.Forms.Control.MouseDown> evento como o `x` e `y` parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir permite que o usuário edite nós de árvore de não-raiz usando um <xref:System.Windows.Forms.ContextMenu>. Quando o usuário clica o mouse, o <xref:System.Windows.Forms.TreeNode> em que a posição é determinada e armazenada em uma variável chamada `mySelectedNode`. Se um nó de árvore de não-raiz foi selecionado, ela será colocada no estado editável, que permite que o usuário edite o rótulo do nó. Depois que o usuário para editar o rótulo do nó de árvore, o novo texto de rótulo é avaliado e salvo. Neste exemplo, vários caracteres são considerados não válidos no texto do rótulo. Se um dos caracteres inválidos está na cadeia de caracteres de rótulo, ou a cadeia de caracteres está vazia, o usuário é notificado sobre o erro e o rótulo é retornado ao seu texto anterior.  
  
 [!code-cpp[classic treenode.beginedit example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/CPP/source.cpp#1)]
 [!code-csharp[classic treenode.beginedit example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/CS/source.cs#1)]
 [!code-vb[classic treenode.beginedit example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNodeCount">
      <MemberSignature Language="C#" Value="public int GetNodeCount (bool includeSubTrees);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetNodeCount(bool includeSubTrees) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.GetNodeCount(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includeSubTrees" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includeSubTrees">
          <see langword="true" /> para contar os itens de <see cref="T:System.Windows.Forms.TreeNode" /> que as subárvores contêm; caso contrário, <see langword="false" />.</param>
        <summary>Recupera o número de nós de árvore, opcionalmente, incluindo aqueles em todas as subárvores, atribuídos ao controle de exibição de árvore.</summary>
        <returns>O número de nós de árvore, opcionalmente, incluindo aqueles em todas as subárvores, atribuídos ao controle de exibição de árvore.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `includeSubTrees` é `true`, o resultado é o número de todos os nós de árvore na estrutura de árvore inteira.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Windows.Forms.TreeView.PathSeparator%2A> propriedade de um <xref:System.Windows.Forms.TreeView> e exibe o número de nós de árvore filho que estão contidos no <xref:System.Windows.Forms.TreeNodeCollection> do <xref:System.Windows.Forms.TreeView.SelectedNode%2A>. A porcentagem filho do nó da árvore de nós de árvore total no controle de exibição de árvore também é exibida. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.Button>e um <xref:System.Windows.Forms.TreeView> controlar com um <xref:System.Windows.Forms.TreeNodeCollection> que tem várias <xref:System.Windows.Forms.TreeNode> objetos (preferencialmente com três ou mais níveis).  
  
 [!code-cpp[TreeNode_ForeColor#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_ForeColor/CPP/treenode_forecolor.cpp#2)]
 [!code-csharp[TreeNode_ForeColor#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_ForeColor/CS/treenode_forecolor.cs#2)]
 [!code-vb[TreeNode_ForeColor#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_ForeColor/VB/treenode_forecolor.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HideSelection">
      <MemberSignature Language="C#" Value="public bool HideSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HideSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.HideSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o nó de árvore selecionado permanece realçado mesmo quando o modo de exibição de árvore perde o foco.</summary>
        <value>
          <see langword="true" /> se o nó de árvore selecionado não ficar realçado quando o modo de exibição de árvore perder o foco; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando essa propriedade é definida como `false`, nós em selecionados a <xref:System.Windows.Forms.TreeView> controle permanece realçado em uma cor diferente da seleção atual cor quando o <xref:System.Windows.Forms.TreeView> controle perde o foco. Você pode usar essa propriedade para manter os itens que são selecionados pelo usuário visível quando o usuário clica em um controle diferente no formulário ou move para uma janela diferente.  
  
> [!NOTE]
>  Se você estiver preocupado com a acessibilidade de seus aplicativos, é recomendável que você defina o <xref:System.Windows.Forms.TreeView.HideSelection%2A> propriedade `false`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.TreeView.HideSelection%2A> propriedade. Para executar este exemplo, cole o seguinte código em um formulário e a chamada a `InitializeSelectedTreeView` método no construtor do formulário ou <xref:System.Windows.Forms.Form.Load> manipulador de eventos.  
  
 [!code-cpp[System.Windows.Forms.TreeViewExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.TreeViewExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.TreeViewExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeViewHitTestInfo HitTest (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.TreeViewHitTestInfo HitTest(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.HitTest(System.Drawing.Point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewHitTestInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">O <see cref="T:System.Drawing.Point" /> no qual as informações do nó serão recuperadas.</param>
        <summary>Fornece informações do nó, considerando um ponto.</summary>
        <returns>As informações do nó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para determinar se um ponto está localizado em um <xref:System.Windows.Forms.TreeNode> e a localização dentro do nó do ponto, como na área de rótulo ou a imagem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HitTest">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeViewHitTestInfo HitTest (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.TreeViewHitTestInfo HitTest(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.HitTest(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeViewHitTestInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">A coordenada X na qual recuperar as informações do nó</param>
        <param name="y">A coordenada y no qual recuperar informações do nó.</param>
        <summary>Fornece informações sobre o nó dadas as coordenadas x e y.</summary>
        <returns>As informações do nó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para determinar se um conjunto de coordenadas x e y-está localizado em um <xref:System.Windows.Forms.TreeNode> e a localização dentro do nó do ponto, como na área de rótulo ou a imagem.  
  
   
  
## Examples  
 O seguinte código de exemplo de código demonstra como usar o <xref:System.Windows.Forms.TreeNode.Level%2A>, <xref:System.Windows.Forms.TreeViewHitTestInfo.Node%2A>, e <xref:System.Windows.Forms.TreeView.HitTest%2A> membros. Para executar este exemplo, crie um formulário do Windows que contém um <xref:System.Windows.Forms.TreeView> chamado `treeView1` e preenchê-lo com vários níveis de nós. Cole o seguinte código para o formulário e associar o <xref:System.Windows.Forms.Control.MouseDown> evento `treeView1` com o `treeView1_MouseDown` método neste exemplo.  
  
 [!code-cpp[System.Windows.Forms.TreeViewWhidbeyMembers#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/cpp/Form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.TreeViewWhidbeyMembers#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.TreeViewWhidbeyMembers#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HotTracking">
      <MemberSignature Language="C#" Value="public bool HotTracking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HotTracking" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.HotTracking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica que se um rótulo do nó de árvore assume a aparência de um hiperlink quando o ponteiro do mouse passa sobre ele.</summary>
        <value>
          <see langword="true" /> se um rótulo do nó de árvore assume a aparência de um hiperlink quando o ponteiro do mouse passa sobre ele; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> está definida como `true`, o <xref:System.Windows.Forms.TreeView.HotTracking%2A> propriedade não tem nenhum efeito.  
  
> [!NOTE]
>  Quando o <xref:System.Windows.Forms.TreeView.HotTracking%2A> está definida como `true`, cada árvore nó rótulo assume a aparência de um hiperlink que o ponteiro do mouse passa sobre ele. O <xref:System.Drawing.FontStyle.Underline> estilo de fonte é aplicado para o <xref:System.Drawing.Font> e o <xref:System.Windows.Forms.Control.ForeColor%2A> é definido como azul para fazer com que o rótulo exibido como um link. A aparência não é controlada pelas configurações de Internet do sistema operacional do usuário.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra um personalizado <xref:System.Windows.Forms.TreeView>. Herdando de <xref:System.Windows.Forms.TreeView> classe, esta versão personalizada tem toda a funcionalidade de um típico <xref:System.Windows.Forms.TreeView>. Alterar vários valores de propriedade no construtor fornece uma aparência exclusiva. Porque o <xref:System.Windows.Forms.TreeView.ShowPlusMinus%2A> está definida como `false`, o controle personalizado também substitui o <xref:System.Windows.Forms.TreeView.OnAfterSelect%2A> método para que nós podem ser expandidos e recolhidos quando eles são clicados.  
  
 Um controle que é personalizado dessa maneira pode ser usado em toda a organização, tornando mais fácil fornecer uma interface consistente sem exigir que as propriedades de controle a ser especificado em cada projeto.  
  
 [!code-cpp[TreeViewCustomization#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewCustomization/CPP/treeviewcustomization.cpp#2)]
 [!code-csharp[TreeViewCustomization#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewCustomization/CS/treeviewcustomization.cs#2)]
 [!code-vb[TreeViewCustomization#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewCustomization/VB/treeviewcustomization.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageIndex">
      <MemberSignature Language="C#" Value="public int ImageIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ImageIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ImageIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.NoneExcludedImageIndexConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Forms.RelatedImageList("ImageList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de índice da lista de imagens da imagem padrão exibida pelos nós da árvore.</summary>
        <value>Um valor de índice de base zero que representa a posição de um <see cref="T:System.Drawing.Image" /> em um <see cref="T:System.Windows.Forms.ImageList" />. O padrão é zero.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.ImageIndex%2A> valor é o índice de um <xref:System.Drawing.Image> armazenados no <xref:System.Windows.Forms.ImageList> atribuído para o <xref:System.Windows.Forms.TreeView.ImageList%2A> propriedade.  
  
 O <xref:System.Windows.Forms.TreeView.ImageKey%2A> e <xref:System.Windows.Forms.TreeView.ImageIndex%2A> propriedades são mutuamente exclusivas; se um for definido, a outra será ignorada. Se você definir <xref:System.Windows.Forms.TreeView.ImageKey%2A>, <xref:System.Windows.Forms.TreeView.ImageIndex%2A> é automaticamente definido como -1. Como alternativa, se você definir <xref:System.Windows.Forms.TreeView.ImageIndex%2A>, <xref:System.Windows.Forms.TreeView.ImageKey%2A> é definida automaticamente como uma cadeia de caracteres vazia ("").  
  
> [!NOTE]
>  Ao definir o <xref:System.Windows.Forms.TreeView.ImageIndex%2A> propriedade em tempo de execução, o <xref:System.Windows.Forms.TreeView> identificador é recriado (consulte <xref:System.Windows.Forms.Control.RecreateHandle%2A?displayProperty=nameWithType>) para atualizar a aparência do controle. Isso faz com que todos os nós de árvore a ser recolhido com a exceção selecionado <xref:System.Windows.Forms.TreeNode>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria e atribui uma <xref:System.Windows.Forms.ImageList> para um <xref:System.Windows.Forms.TreeView> controle e preenche o <xref:System.Windows.Forms.TreeView> controlar com <xref:System.Windows.Forms.TreeNode> objetos. Os nós de árvore atribuídos imagens a partir de <xref:System.Windows.Forms.ImageList> que são exibidos quando em um estado selecionado ou desmarcado. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.TreeView>e um <xref:System.Collections.ArrayList> que contém `Customer` objetos que contêm `Order` objetos. Presume-se também que o `Customer` e `Order` objetos são definidos.  
  
 [!code-cpp[TreeNode_TreeNode#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_TreeNode/CPP/treenode_treenode.cpp#1)]
 [!code-csharp[TreeNode_TreeNode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_TreeNode/CS/treenode_treenode.cs#1)]
 [!code-vb[TreeNode_TreeNode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_TreeNode/VB/treenode_treenode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice especificado é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ImageKey">
      <MemberSignature Language="C#" Value="public string ImageKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ImageKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.ImageKeyConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Forms.RelatedImageList("ImageList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a chave da imagem padrão para cada nó no controle <see cref="T:System.Windows.Forms.TreeView" /> quando ele está em um estado não selecionado.</summary>
        <value>A chave da imagem padrão mostrada para cada controle <see cref="T:System.Windows.Forms.TreeView" /> do nó quando o nó está em um estado desmarcado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.ImageKey%2A> propriedade diferencia maiusculas de minúsculas.  
  
 Se um <xref:System.Windows.Forms.TreeNode> não tem uma imagem definida, a imagem especificada pelo <xref:System.Windows.Forms.TreeView.ImageKey%2A> propriedade será mostrada quando o nó não está selecionado. Quando o nó é selecionado, o primeiro item a <xref:System.Windows.Forms.ImageList> será mostrado.  
  
 O <xref:System.Windows.Forms.TreeView.ImageKey%2A> e <xref:System.Windows.Forms.TreeView.ImageIndex%2A> propriedades são mutuamente exclusivas, que significa que se um for definido, a outra será ignorada. Se você definir o <xref:System.Windows.Forms.TreeView.ImageKey%2A> propriedade, o <xref:System.Windows.Forms.TreeView.ImageIndex%2A> propriedade é definida automaticamente como -1. Como alternativa, se você definir o <xref:System.Windows.Forms.TreeView.ImageIndex%2A> propriedade, o <xref:System.Windows.Forms.TreeView.ImageKey%2A> é definida automaticamente como uma cadeia de caracteres vazia ("").  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageList">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImageList ImageList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ImageList ImageList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ImageList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o <see cref="T:System.Windows.Forms.ImageList" /> que contém os objetos <see cref="T:System.Drawing.Image" /> usados pelos nós de árvore.</summary>
        <value>O <see cref="T:System.Windows.Forms.ImageList" /> que contém os objetos <see cref="T:System.Drawing.Image" /> usados pelos nós de árvore. O valor padrão é <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Forms.ImageList> o valor da propriedade for algo diferente de `null`, todos os nós de árvore exibem a primeira <xref:System.Drawing.Image> armazenados no <xref:System.Windows.Forms.ImageList>. Você pode especificar quais imagens da lista são exibidas para os nós selecionados e desmarcados, definindo o <xref:System.Windows.Forms.TreeView.ImageIndex%2A> e <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> propriedades. Individuais <xref:System.Windows.Forms.TreeNode> objetos podem especificar qual imagem é exibida, definindo suas <xref:System.Windows.Forms.TreeNode.ImageIndex%2A> e <xref:System.Windows.Forms.TreeNode.SelectedImageIndex%2A> propriedades. Essas configurações individuais substituirão as configurações correspondentes <xref:System.Windows.Forms.TreeView> propriedades.  
  
> [!NOTE]
>  No .NET Framework versão 1.1, há um problema que impede que as imagens que aparecem em <xref:System.Windows.Forms.TreeView> nós quando o aplicativo chama <xref:System.Windows.Forms.Application.EnableVisualStyles%2A?displayProperty=nameWithType>. Para contornar esse problema, chame <xref:System.Windows.Forms.Application.DoEvents%2A?displayProperty=nameWithType> no seu `Main` método imediatamente depois de chamar <xref:System.Windows.Forms.Application.EnableVisualStyles%2A>. Esse problema é corrigido no [!INCLUDE[dnprdnlong](~/includes/dnprdnlong-md.md)].  
  
   
  
## Examples  
 O exemplo de código a seguir cria e atribui uma <xref:System.Windows.Forms.ImageList> para um <xref:System.Windows.Forms.TreeView> controle e preenche o <xref:System.Windows.Forms.TreeView> controlar com <xref:System.Windows.Forms.TreeNode> objetos. Os nós de árvore atribuídos imagens a partir de <xref:System.Windows.Forms.ImageList> que são exibidos quando em um estado selecionado ou desmarcado. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.TreeView>e um <xref:System.Collections.ArrayList> que contém `Customer` objetos que contêm `Order` objetos.  
  
 [!code-cpp[TreeNode_TreeNode#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_TreeNode/CPP/treenode_treenode.cpp#1)]
 [!code-csharp[TreeNode_TreeNode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_TreeNode/CS/treenode_treenode.cs#1)]
 [!code-vb[TreeNode_TreeNode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_TreeNode/VB/treenode_treenode.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Indent">
      <MemberSignature Language="C#" Value="public int Indent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Indent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.Indent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a distância do recuo de cada nível do nó de árvore filho.</summary>
        <value>A distância, em pixels, do recuo de cada nível de nó de árvore filho. O valor padrão é 19.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir essa propriedade como um valor de -1 não lançará uma exceção se o valor ainda não tiver sido alterado do padrão. Isso ocorre porque o controle usa um valor de -1 como um padrão interno antes que a alça de controle foi criada. O valor padrão interno faz com que o controle encapsulado retornar o seu próprio valor padrão de 19.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra um personalizado <xref:System.Windows.Forms.TreeView>. Herdando de <xref:System.Windows.Forms.TreeView> classe, esta versão personalizada tem toda a funcionalidade de um típico <xref:System.Windows.Forms.TreeView>. Alterar vários valores de propriedade no construtor fornece uma aparência exclusiva. Porque o <xref:System.Windows.Forms.TreeView.ShowPlusMinus%2A> propriedade é definida como false, o controle personalizado também substitui o <xref:System.Windows.Forms.TreeView.OnAfterSelect%2A> método para que nós podem ser expandidos e recolhidos quando eles são clicados.  
  
 Um controle que é personalizado dessa maneira pode ser usado em toda a organização, tornando mais fácil fornecer uma interface consistente sem exigir que as propriedades de controle a ser especificado em cada projeto.  
  
 [!code-cpp[TreeViewCustomization#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewCustomization/CPP/treeviewcustomization.cpp#2)]
 [!code-csharp[TreeViewCustomization#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewCustomization/CS/treeviewcustomization.cs#2)]
 [!code-vb[TreeViewCustomization#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewCustomization/VB/treeviewcustomization.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor atribuído é menor que 0.  
  
 -ou-  
  
 O valor atribuído é maior que 32.000.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsInputKey">
      <MemberSignature Language="C#" Value="protected override bool IsInputKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsInputKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.IsInputKey(System.Windows.Forms.Keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Um dos valores de chaves.</param>
        <summary>Determina se a chave especificada é uma chave de entrada regular ou uma chave especial que exige o pré-processamento.</summary>
        <returns>
          <see langword="true" /> se a chave especificada for uma chave de entrada regular; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o usuário estiver editando um nó de árvore, o <xref:System.Windows.Forms.TreeView> controle trata as chaves como ENTER, ESC, HOME e END como chaves de entrada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ItemDragEventHandler ItemDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ItemDragEventHandler ItemDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.ItemDrag" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ItemDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário começa a arrastar um nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre a manipulação de eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como habilitar operações arrastar e soltar em um <xref:System.Windows.Forms.TreeView> controle. Neste exemplo, qualquer nó pode ser arrastado para outro nó que não é um descendente do nó arrastado. O nó arrastado, que inclui todos os seus nós descendentes, se torna um filho do nó de destino. Quando o botão esquerdo do mouse é usado, o nó arrastado é movido para o nó de destino. Quando o botão direito do mouse é usado, o nó arrastado é copiado para o nó de destino.  
  
 [!code-cpp[TreeViewDragDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewDragDrop/CPP/treeviewdragdrop.cpp#1)]
 [!code-csharp[TreeViewDragDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewDragDrop/CS/treeviewdragdrop.cs#1)]
 [!code-vb[TreeViewDragDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewDragDrop/VB/treeviewdragdrop.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ItemHeight">
      <MemberSignature Language="C#" Value="public int ItemHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ItemHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ItemHeight" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a altura de cada nó de árvore no controle de exibição de árvore.</summary>
        <value>A altura, em pixels, de cada nó de árvore no modo de exibição de árvore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a altura do item é definida como um valor maior que a altura do controle de exibição de árvore, chamar o <xref:System.Windows.Forms.TreeNode.EnsureVisible%2A?displayProperty=nameWithType> método terão resultados inesperados.  
  
   
  
## Examples  
 O exemplo de código a seguir altera o tamanho <xref:System.Windows.Forms.TreeNode.NodeFont%2A> o tamanho especificado e ajusta a <xref:System.Windows.Forms.TreeView.ItemHeight%2A> do pai do nó de árvore <xref:System.Windows.Forms.TreeView> controle. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.TreeView> controle com uma coleção de <xref:System.Windows.Forms.TreeNode> objetos e um <xref:System.Windows.Forms.ComboBox> que contém os tamanhos de fonte.  
  
 [!code-cpp[TreeNode_Bounds#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_Bounds/CPP/treenode_bounds.cpp#2)]
 [!code-csharp[TreeNode_Bounds#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_Bounds/CS/treenode_bounds.cs#2)]
 [!code-vb[TreeNode_Bounds#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_Bounds/VB/treenode_bounds.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor atribuído será menor que 1.  
  
 -ou-  
  
 O valor atribuído é maior que o valor de <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LabelEdit">
      <MemberSignature Language="C#" Value="public bool LabelEdit { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool LabelEdit" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.LabelEdit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o texto de rótulo dos nós da árvore pode ser editado.</summary>
        <value>
          <see langword="true" /> se for possível editar o texto de rótulo dos nós de árvore; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeNode.BeginEdit%2A> método só funcionará se o <xref:System.Windows.Forms.TreeView.LabelEdit%2A> é de propriedade `true`. Se <xref:System.Windows.Forms.TreeView.LabelEdit%2A> é `false` quando você tentar editar o rótulo, uma exceção será lançada e o nó de árvore não será colocado em um estado editável.  
  
   
  
## Examples  
 O exemplo de código a seguir permite que o usuário edite nós de árvore de não-raiz usando um <xref:System.Windows.Forms.ContextMenu>. Quando o usuário clica o mouse, o <xref:System.Windows.Forms.TreeNode> em que a posição é determinada e armazenada em uma variável chamada `mySelectedNode`. Se um nó de árvore de não-raiz foi selecionado, ela será colocada no estado editável, que permite que o usuário edite o rótulo do nó. Depois que o usuário para editar o rótulo do nó de árvore, o novo texto de rótulo é avaliado e salvo. Neste exemplo, vários caracteres são considerados não válidos no texto do rótulo. Se um dos caracteres inválidos está na cadeia de caracteres de rótulo, ou a cadeia de caracteres está vazia, o usuário é notificado sobre o erro e o rótulo é retornado ao seu texto anterior.  
  
 [!code-cpp[classic treenode.beginedit example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/CPP/source.cpp#1)]
 [!code-csharp[classic treenode.beginedit example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/CS/source.cs#1)]
 [!code-vb[classic treenode.beginedit example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic TreeNode.BeginEdit Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LineColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LineColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LineColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.LineColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Color), "Black")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a cor das linhas que conectam os nós do controle <see cref="T:System.Windows.Forms.TreeView" />.</summary>
        <value>O <see cref="T:System.Drawing.Color" /> das linhas que conectam os nós de árvore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir mostra a configuração de <xref:System.Windows.Forms.TreeNode> cor da linha. Para executar este exemplo, cole o código em um formulário do Windows. Chamar `InitializeLineTreeView` do construtor do formulário ou <xref:System.Windows.Forms.Form.Load> manipulador de eventos.  
  
 [!code-cpp[System.Windows.Forms.TreeViewWhidbeyMembers#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/cpp/Form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.TreeViewWhidbeyMembers#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.TreeViewWhidbeyMembers#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeMouseClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeNodeMouseClickEventHandler NodeMouseClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeNodeMouseClickEventHandler NodeMouseClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.NodeMouseClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNodeMouseClickEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário clica em um <see cref="T:System.Windows.Forms.TreeNode" /> com o mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento ocorre quando o usuário clica em qualquer parte de um nó de árvore com o mouse, incluindo o sinal de adição (**+**) ou sinal de subtração (**-**) que indica se o nó é recolhido ou expandido.  
  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como tratar o <xref:System.Windows.Forms.TreeView.NodeMouseClick> evento.  
  
 [!code-cpp[System.Windows.Forms.TreeViewWhidbeyMembers#4](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/cpp/Form1.cpp#4)]
 [!code-csharp[System.Windows.Forms.TreeViewWhidbeyMembers#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.TreeViewWhidbeyMembers#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeMouseDoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeNodeMouseClickEventHandler NodeMouseDoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeNodeMouseClickEventHandler NodeMouseDoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.NodeMouseDoubleClick" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNodeMouseClickEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o usuário clica duas vezes em um <see cref="T:System.Windows.Forms.TreeNode" /> com o mouse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento ocorre quando o usuário clica duas vezes em qualquer parte de um nó de árvore com o mouse, incluindo o sinal de adição (+) ou sinal de menos (-) que indica se o nó é recolhido ou expandido.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como tratar o <xref:System.Windows.Forms.TreeView.NodeMouseDoubleClick> eventos e como usar o <xref:System.Windows.Forms.TreeNodeMouseClickEventArgs>. Para executar este exemplo, cole o código em um Windows Form que contém um <xref:System.Windows.Forms.TreeView> chamado `treeView1`. Popular `treeView1` com os nomes de arquivos localizados no `c:\` diretório do exemplo está em execução no sistema e associar o <xref:System.Windows.Forms.TreeView.NodeMouseDoubleClick> eventos de `treeView1` com o `treeView1_NodeMouseDoubleClick` método neste exemplo.  Este exemplo requer que o usuário tem privilégios de administrador no computador executando o exemplo.  
  
 [!code-cpp[System.Windows.Forms.TreeViewWhidbeyMembers#5](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/cpp/Form1.cpp#5)]
 [!code-csharp[System.Windows.Forms.TreeViewWhidbeyMembers#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.TreeViewWhidbeyMembers#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeMouseHover">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.TreeNodeMouseHoverEventHandler NodeMouseHover;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.TreeNodeMouseHoverEventHandler NodeMouseHover" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.NodeMouseHover" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNodeMouseHoverEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o mouse focaliza um <see cref="T:System.Windows.Forms.TreeNode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o mouse estiver localizado em um <xref:System.Windows.Forms.TreeNode>, o <xref:System.Windows.Forms.TreeView.NodeMouseHover> evento ocorrerá antes do <xref:System.Windows.Forms.Control.MouseHover> evento.  
  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.TreeView.NodeMouseHover> eventos. Esse relatório ajuda a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.TreeView> chamado `TreeView1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.TreeView.NodeMouseHover> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#634](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#634)]
 [!code-vb[System.Windows.Forms.EventExamples#634](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#634)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nodes">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeNodeCollection Nodes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.TreeNodeCollection Nodes" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.Nodes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNodeCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a coleção de nós de árvore atribuídos ao controle de exibição de árvore.</summary>
        <value>Um <see cref="T:System.Windows.Forms.TreeNodeCollection" /> que representa os nós de árvore atribuídos ao controle de exibição de árvore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.Nodes%2A> propriedade contém uma coleção de <xref:System.Windows.Forms.TreeNode> objetos, cada um deles tem um <xref:System.Windows.Forms.TreeNode.Nodes%2A> propriedade que pode conter seu próprio <xref:System.Windows.Forms.TreeNodeCollection>. Este aninhamento de nós de árvore pode dificultar navegar de uma estrutura de árvore, mas o <xref:System.Windows.Forms.TreeNode.FullPath%2A> propriedade torna mais fácil determinar seu local dentro da estrutura de árvore.  
  
   
  
## Examples  
 O exemplo de código a seguir exibe informações do cliente em um <xref:System.Windows.Forms.TreeView> controle. Os nós de árvore raiz exibem nomes de clientes, e os nós de árvore filho exibem os números de ordem atribuídos a cada cliente. Neste exemplo, 1.000 clientes são exibidos com 15 pedidos. De refazer o <xref:System.Windows.Forms.TreeView> é suprimida usando o <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> e <xref:System.Windows.Forms.TreeView.EndUpdate%2A> métodos e uma espera <xref:System.Windows.Forms.Cursor> é exibida enquanto o <xref:System.Windows.Forms.TreeView> cria e pinta o <xref:System.Windows.Forms.TreeNode> objetos. Este exemplo requer que você tenha um `Customer` objeto que pode conter uma coleção de `Order` objetos. Ele também requer que você tenha criado uma instância de um <xref:System.Windows.Forms.TreeView> control em um <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[TreeView#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeView/CPP/treeview.cpp#1)]
 [!code-csharp[TreeView#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeView/CS/treeview.cs#1)]
 [!code-vb[TreeView#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeView/VB/treeview.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAfterCheck">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterCheck (System.Windows.Forms.TreeViewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterCheck(class System.Windows.Forms.TreeViewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnAfterCheck(System.Windows.Forms.TreeViewEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.AfterCheck" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnAfterCheck%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnAfterCheck(System.Windows.Forms.TreeViewEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnAfterCheck(System.Windows.Forms.TreeViewEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnAfterCollapse">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterCollapse (System.Windows.Forms.TreeViewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnAfterCollapse(class System.Windows.Forms.TreeViewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnAfterCollapse(System.Windows.Forms.TreeViewEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.AfterCollapse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnAfterCollapse%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnAfterCollapse(System.Windows.Forms.TreeViewEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnAfterCollapse(System.Windows.Forms.TreeViewEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnAfterExpand">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterExpand (System.Windows.Forms.TreeViewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterExpand(class System.Windows.Forms.TreeViewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnAfterExpand(System.Windows.Forms.TreeViewEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.AfterExpand" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnAfterExpand%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnAfterExpand(System.Windows.Forms.TreeViewEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnAfterExpand(System.Windows.Forms.TreeViewEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnAfterLabelEdit">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterLabelEdit (System.Windows.Forms.NodeLabelEditEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterLabelEdit(class System.Windows.Forms.NodeLabelEditEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnAfterLabelEdit(System.Windows.Forms.NodeLabelEditEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.NodeLabelEditEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.NodeLabelEditEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.AfterLabelEdit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnAfterLabelEdit%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnAfterLabelEdit(System.Windows.Forms.NodeLabelEditEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnAfterLabelEdit(System.Windows.Forms.NodeLabelEditEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnAfterSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnAfterSelect (System.Windows.Forms.TreeViewEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAfterSelect(class System.Windows.Forms.TreeViewEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnAfterSelect(System.Windows.Forms.TreeViewEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.AfterSelect" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnAfterSelect%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnAfterSelect(System.Windows.Forms.TreeViewEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnAfterSelect(System.Windows.Forms.TreeViewEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeCheck">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeCheck (System.Windows.Forms.TreeViewCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeCheck(class System.Windows.Forms.TreeViewCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnBeforeCheck(System.Windows.Forms.TreeViewCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.BeforeCheck" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnBeforeCheck%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnBeforeCheck(System.Windows.Forms.TreeViewCancelEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnBeforeCheck(System.Windows.Forms.TreeViewCancelEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeCollapse">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeCollapse (System.Windows.Forms.TreeViewCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnBeforeCollapse(class System.Windows.Forms.TreeViewCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnBeforeCollapse(System.Windows.Forms.TreeViewCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.BeforeCollapse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnBeforeCollapse%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnBeforeCollapse(System.Windows.Forms.TreeViewCancelEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnBeforeCollapse(System.Windows.Forms.TreeViewCancelEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeExpand">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeExpand (System.Windows.Forms.TreeViewCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeExpand(class System.Windows.Forms.TreeViewCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnBeforeExpand(System.Windows.Forms.TreeViewCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.BeforeExpand" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnBeforeExpand%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnBeforeExpand(System.Windows.Forms.TreeViewCancelEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnBeforeExpand(System.Windows.Forms.TreeViewCancelEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeLabelEdit">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeLabelEdit (System.Windows.Forms.NodeLabelEditEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeLabelEdit(class System.Windows.Forms.NodeLabelEditEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnBeforeLabelEdit(System.Windows.Forms.NodeLabelEditEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.NodeLabelEditEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.NodeLabelEditEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.BeforeLabelEdit" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnBeforeLabelEdit%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnBeforeLabelEdit(System.Windows.Forms.NodeLabelEditEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnBeforeLabelEdit(System.Windows.Forms.NodeLabelEditEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBeforeSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnBeforeSelect (System.Windows.Forms.TreeViewCancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeforeSelect(class System.Windows.Forms.TreeViewCancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnBeforeSelect(System.Windows.Forms.TreeViewCancelEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeViewCancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeViewCancelEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.BeforeSelect" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnBeforeSelect%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnBeforeSelect(System.Windows.Forms.TreeViewCancelEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnBeforeSelect(System.Windows.Forms.TreeViewCancelEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawNode">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawNode (System.Windows.Forms.DrawTreeNodeEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawNode(class System.Windows.Forms.DrawTreeNodeEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnDrawNode(System.Windows.Forms.DrawTreeNodeEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawTreeNodeEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.DrawTreeNodeEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.DrawNode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnDrawNode%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnDrawNode(System.Windows.Forms.DrawTreeNodeEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnDrawNode(System.Windows.Forms.DrawTreeNodeEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnHandleCreated(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Substitui <see cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnHandleCreated%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnHandleCreated(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnHandleCreated(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnHandleDestroyed(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Substitui <see cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnHandleDestroyed%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnHandleDestroyed(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnHandleDestroyed(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnItemDrag">
      <MemberSignature Language="C#" Value="protected virtual void OnItemDrag (System.Windows.Forms.ItemDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnItemDrag(class System.Windows.Forms.ItemDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnItemDrag(System.Windows.Forms.ItemDragEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ItemDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.ItemDragEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.ItemDrag" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnItemDrag%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnItemDrag(System.Windows.Forms.ItemDragEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnItemDrag(System.Windows.Forms.ItemDragEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected override void OnKeyDown (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyDown(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnKeyDown(System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.KeyEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.KeyDown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> está definida como `true` e o <xref:System.Windows.Forms.KeyEventArgs.Handled%2A> está definida como `false`, o <xref:System.Windows.Forms.TreeView.OnKeyDown%2A> método alterna marcando e desmarcando a caixa de seleção quando o usuário pressiona a barra de espaços.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnKeyDown%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnKeyDown(System.Windows.Forms.KeyEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyPress">
      <MemberSignature Language="C#" Value="protected override void OnKeyPress (System.Windows.Forms.KeyPressEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyPress(class System.Windows.Forms.KeyPressEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyPressEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.KeyPressEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.KeyPress" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A> está definida como `false`, o <xref:System.Windows.Forms.TreeView> seleciona o primeiro item que começa com o valor do controle a <xref:System.Windows.Forms.KeyPressEventArgs.KeyChar%2A> propriedade de `e`.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnKeyPress%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnKeyPress(System.Windows.Forms.KeyPressEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected override void OnKeyUp (System.Windows.Forms.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnKeyUp(class System.Windows.Forms.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.KeyEventArgs" /> que contém os dados do evento.</param>
        <summary>Substitui <see cref="M:System.Windows.Forms.Control.OnKeyUp(System.Windows.Forms.KeyEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnKeyUp%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnKeyUp(System.Windows.Forms.KeyEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseHover">
      <MemberSignature Language="C#" Value="protected override void OnMouseHover (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseHover(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnMouseHover(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.MouseHover" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.OnMouseHover%2A> método executa um teste de clique para ver se o mouse está localizado em um <xref:System.Windows.Forms.TreeNode>e se for, gera o <xref:System.Windows.Forms.TreeView.NodeMouseHover> evento.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnMouseHover%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnMouseHover(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnMouseHover(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected override void OnMouseLeave (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnMouseLeave(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnMouseLeave(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.Control.MouseLeave" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnMouseLeave%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnMouseLeave(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnMouseLeave(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnNodeMouseClick">
      <MemberSignature Language="C#" Value="protected virtual void OnNodeMouseClick (System.Windows.Forms.TreeNodeMouseClickEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNodeMouseClick(class System.Windows.Forms.TreeNodeMouseClickEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnNodeMouseClick(System.Windows.Forms.TreeNodeMouseClickEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeNodeMouseClickEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeNodeMouseClickEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.NodeMouseClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnNodeMouseClick%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnNodeMouseClick(System.Windows.Forms.TreeNodeMouseClickEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnNodeMouseClick(System.Windows.Forms.TreeNodeMouseClickEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnNodeMouseDoubleClick">
      <MemberSignature Language="C#" Value="protected virtual void OnNodeMouseDoubleClick (System.Windows.Forms.TreeNodeMouseClickEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNodeMouseDoubleClick(class System.Windows.Forms.TreeNodeMouseClickEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnNodeMouseDoubleClick(System.Windows.Forms.TreeNodeMouseClickEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeNodeMouseClickEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.Windows.Forms.TreeNodeMouseClickEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.NodeMouseDoubleClick" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnNodeMouseDoubleClick%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnNodeMouseDoubleClick(System.Windows.Forms.TreeNodeMouseClickEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnNodeMouseDoubleClick(System.Windows.Forms.TreeNodeMouseClickEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnNodeMouseHover">
      <MemberSignature Language="C#" Value="protected virtual void OnNodeMouseHover (System.Windows.Forms.TreeNodeMouseHoverEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnNodeMouseHover(class System.Windows.Forms.TreeNodeMouseHoverEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnNodeMouseHover(System.Windows.Forms.TreeNodeMouseHoverEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.TreeNodeMouseHoverEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O <see cref="T:System.Windows.Forms.TreeNodeMouseHoverEventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.NodeMouseHover" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnNodeMouseHover%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnNodeMouseHover(System.Windows.Forms.TreeNodeMouseHoverEventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnNodeMouseHover(System.Windows.Forms.TreeNodeMouseHoverEventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Um <see cref="T:System.EventArgs" /> que contém os dados do evento.</param>
        <summary>Aciona o evento <see cref="E:System.Windows.Forms.TreeView.RightToLeftLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter mais informações, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 O <xref:System.Windows.Forms.TreeView.OnRightToLeftLayoutChanged%2A> método também permite que classes derivadas manipular o evento sem anexar um representante. Isso é a técnica preferida para manipular o evento em uma classe derivada.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Ao substituir <see cref="M:System.Windows.Forms.TreeView.OnRightToLeftLayoutChanged(System.EventArgs)" /> em uma classe derivada, certifique-se de chamar a classe base <see cref="M:System.Windows.Forms.TreeView.OnRightToLeftLayoutChanged(System.EventArgs)" /> método para que registrado delegados receber o evento.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Padding">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Padding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Padding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.Padding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o espaçamento entre o conteúdo do controle <see cref="T:System.Windows.Forms.TreeView" /> e suas bordas.</summary>
        <value>Um <see cref="T:System.Windows.Forms.Padding" /> indicando o espaço entre as bordas do controle e seu conteúdo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PaddingChanged">
      <MemberSignature Language="C#" Value="public event EventHandler PaddingChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler PaddingChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.PaddingChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o valor da propriedade <see cref="P:System.Windows.Forms.TreeView.Padding" /> muda.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Paint">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.PaintEventHandler Paint;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.PaintEventHandler Paint" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.Paint" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.PaintEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o <see cref="T:System.Windows.Forms.TreeView" /> é desenhado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PathSeparator">
      <MemberSignature Language="C#" Value="public string PathSeparator { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathSeparator" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.PathSeparator" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("\")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a de cadeia de caracteres delimitadora que o caminho do nó de árvore usa.</summary>
        <value>A cadeia de caracteres delimitadora que a propriedade <see cref="P:System.Windows.Forms.TreeNode.FullPath" /> do nó de árvore usa. O padrão é o caractere de barra invertida (\\).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caminho de nó de árvore consiste em um conjunto de rótulos de nó de árvore, separados pelo <xref:System.Windows.Forms.TreeView.PathSeparator%2A> cadeias de caracteres de delimitador. O intervalo de rótulos do nó de árvore de raiz para o nó de árvore que você deseja.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Windows.Forms.TreeView.PathSeparator%2A> propriedade de um <xref:System.Windows.Forms.TreeView> e exibe o número de nós de árvore filho que está contida no <xref:System.Windows.Forms.TreeNodeCollection> do <xref:System.Windows.Forms.TreeView.SelectedNode%2A>. A porcentagem filho do nó da árvore de nós de árvore total no controle de exibição de árvore também é exibida. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.Button>e um <xref:System.Windows.Forms.TreeView> controlar com um <xref:System.Windows.Forms.TreeNodeCollection> que tem várias <xref:System.Windows.Forms.TreeNode> objetos (preferencialmente com três ou mais níveis).  
  
 [!code-cpp[TreeNode_ForeColor#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_ForeColor/CPP/treenode_forecolor.cpp#2)]
 [!code-csharp[TreeNode_ForeColor#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_ForeColor/CS/treenode_forecolor.cs#2)]
 [!code-vb[TreeNode_ForeColor#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_ForeColor/VB/treenode_forecolor.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.RightToLeftLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Windows.Forms.TreeView" /> devem ser apresentados da direita para a esquerda.</summary>
        <value>
          <see langword="true" />Se o controle deve ser apresentado da direita para a esquerda; Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.RightToLeftLayout%2A> é de propriedade para uso com aplicativos internacionais onde o idioma é lido da direita para esquerda. Se você definir <xref:System.Windows.Forms.TreeView.RightToLeftLayout%2A> e <xref:System.Windows.Forms.Control.RightToLeft%2A> para `true` conteúdo e o texto do controle serão dispostos da direita para a esquerda.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.RightToLeftLayoutChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o valor da propriedade <see cref="P:System.Windows.Forms.TreeView.RightToLeftLayout" /> muda.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como manipular eventos, consulte [tratamento e gerando eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso desse membro. No exemplo, um manipulador de eventos relatórios sobre a ocorrência da <xref:System.Windows.Forms.TreeView.RightToLeftLayoutChanged> eventos. Esse relatório ajuda a saber quando o evento ocorre e pode ajudá-lo na depuração. Para gerar relatórios sobre vários eventos ou eventos que ocorrem com frequência, considere substituir <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> com <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou anexar a mensagem como um multiline <xref:System.Windows.Forms.TextBox>.  
  
 Para executar o código de exemplo, cole-o em um projeto que contém uma instância do tipo <xref:System.Windows.Forms.TreeView> chamado `TreeView1`. Certifique-se de que o manipulador de eventos está associado com o <xref:System.Windows.Forms.TreeView.RightToLeftLayoutChanged> evento.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#639](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#639)]
 [!code-vb[System.Windows.Forms.EventExamples#639](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#639)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Scrollable">
      <MemberSignature Language="C#" Value="public bool Scrollable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Scrollable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.Scrollable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o controle de exibição de árvore exibirá as barras de rolagem quando elas forem necessárias.</summary>
        <value>
          <see langword="true" /> se o controle de exibição de árvore exibirá barras de rolagem quando elas forem necessárias; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se essa propriedade é definida como `true`, barras de rolagem são exibidas no <xref:System.Windows.Forms.TreeView> quando qualquer <xref:System.Windows.Forms.TreeNode> está localizado fora da região do cliente do controle.  
  
> [!NOTE]
>  Ao definir o <xref:System.Windows.Forms.TreeView.Scrollable%2A> propriedade em tempo de execução, o <xref:System.Windows.Forms.TreeView> identificador é recriado (consulte <xref:System.Windows.Forms.Control.RecreateHandle%2A?displayProperty=nameWithType>) para atualizar a aparência do controle. Isso faz com que todos os nós de árvore a ser recolhido com a exceção selecionado <xref:System.Windows.Forms.TreeNode>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.BorderStyle> enumeração e <xref:System.Windows.Forms.TreeView.BorderStyle%2A>, <xref:System.Windows.Forms.TreeView.ShowLines%2A>, <xref:System.Windows.Forms.TreeView.Scrollable%2A>, <xref:System.Windows.Forms.TreeView.HideSelection%2A> e <xref:System.Windows.Forms.TreeView.ShowRootLines%2A> propriedades. Para executar este exemplo, cole o seguinte código em um formulário e a chamada a `InitializeTreeView` método no construtor do formulário ou `Load` método.  
  
 [!code-cpp[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedImageIndex">
      <MemberSignature Language="C#" Value="public int SelectedImageIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectedImageIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.SelectedImageIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(-1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.NoneExcludedImageIndexConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Forms.RelatedImageList("ImageList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define valor do índice da lista de imagens da imagem exibida quando um nó da árvore é selecionado.</summary>
        <value>Um valor de índice baseado em zero que representa a posição de um <see cref="T:System.Drawing.Image" /> em um <see cref="T:System.Windows.Forms.ImageList" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> valor é o índice de um <xref:System.Drawing.Image> armazenados no <xref:System.Windows.Forms.ImageList> atribuído para o <xref:System.Windows.Forms.TreeView.ImageList%2A> propriedade.  
  
> [!NOTE]
>  Ao definir o <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> propriedade em tempo de execução, o <xref:System.Windows.Forms.TreeView> identificador é recriado (consulte <xref:System.Windows.Forms.Control.RecreateHandle%2A?displayProperty=nameWithType>) para atualizar a aparência do controle. Isso faz com que todos os nós de árvore a ser recolhido, exceto a selecionada <xref:System.Windows.Forms.TreeNode>.  
  
   
  
## Examples  
 O exemplo de código a seguir cria e atribui uma <xref:System.Windows.Forms.ImageList> para um <xref:System.Windows.Forms.TreeView> controle e preenche o <xref:System.Windows.Forms.TreeView> controlar com <xref:System.Windows.Forms.TreeNode> objetos. Os nós de árvore atribuídos imagens a partir de <xref:System.Windows.Forms.ImageList> que são exibidos quando em um estado selecionado ou desmarcado. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> que contém um <xref:System.Windows.Forms.TreeView>e um <xref:System.Collections.ArrayList> que contém `Customer` objetos que contêm `Order` objetos. Presume-se também que o `Customer` e `Order` objetos são definidos.  
  
 [!code-cpp[TreeNode_TreeNode#1](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_TreeNode/CPP/treenode_treenode.cpp#1)]
 [!code-csharp[TreeNode_TreeNode#1](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_TreeNode/CS/treenode_treenode.cs#1)]
 [!code-vb[TreeNode_TreeNode#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_TreeNode/VB/treenode_treenode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O valor atribuído ao índice é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectedImageKey">
      <MemberSignature Language="C#" Value="public string SelectedImageKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedImageKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.SelectedImageKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Editor("System.Windows.Forms.Design.ImageIndexEditor, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.Drawing.Design.UITypeEditor))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties(System.ComponentModel.RefreshProperties.Repaint)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.ImageKeyConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Forms.RelatedImageList("ImageList")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a chave da imagem padrão mostrada quando um <see cref="T:System.Windows.Forms.TreeNode" /> está em um estado selecionado.</summary>
        <value>A chave da imagem padrão mostrada quando um <see cref="T:System.Windows.Forms.TreeNode" /> está em um estado selecionado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um <xref:System.Windows.Forms.TreeNode> não tem uma imagem selecionada definida, a imagem especificada pelo <xref:System.Windows.Forms.TreeView.SelectedImageKey%2A> propriedade será mostrada quando o nó não está selecionado.  
  
 O <xref:System.Windows.Forms.TreeView.SelectedImageKey%2A> e <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> propriedades são mutuamente exclusivas; se um for definido, a outra será ignorada. Se você definir o <xref:System.Windows.Forms.TreeView.SelectedImageKey%2A> propriedade, o <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> propriedade é definida automaticamente como -1. Como alternativa, se você definir o <xref:System.Windows.Forms.TreeView.SelectedImageIndex%2A> propriedade, o <xref:System.Windows.Forms.TreeView.SelectedImageKey%2A> é definida automaticamente como uma cadeia de caracteres vazia ("").  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectedNode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeNode SelectedNode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.TreeNode SelectedNode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.SelectedNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nó de árvore selecionado no momento no controle de exibição de árvore.</summary>
        <value>O <see cref="T:System.Windows.Forms.TreeNode" /> selecionado no momento no controle de exibição de árvore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhum <xref:System.Windows.Forms.TreeNode> está selecionado no momento, o <xref:System.Windows.Forms.TreeView.SelectedNode%2A> é de propriedade `null`.  
  
 Quando você define essa propriedade, o nó especificado é rolado para a exibição e qualquer pai nós são expandidos para que o nó especificado fique visível.  
  
 Quando o nó pai ou qualquer nó ancestral do nó selecionado é recolhido seja programaticamente ou por meio de ação do usuário, o nó recolhido torna-se o nó selecionado.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Windows.Forms.TreeView.PathSeparator%2A> propriedade de um <xref:System.Windows.Forms.TreeView> e exibe o número de nós de árvore filho que está contida no <xref:System.Windows.Forms.TreeNodeCollection> do <xref:System.Windows.Forms.TreeView.SelectedNode%2A>. A porcentagem filho do nó da árvore de nós de árvore total no controle de exibição de árvore também é exibida. Este exemplo requer que você tenha um <xref:System.Windows.Forms.Form> com um <xref:System.Windows.Forms.Button>e um <xref:System.Windows.Forms.TreeView> controlar com um <xref:System.Windows.Forms.TreeNodeCollection> que tem várias <xref:System.Windows.Forms.TreeNode> objetos (preferencialmente com três ou mais níveis).  
  
 [!code-cpp[TreeNode_ForeColor#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeNode_ForeColor/CPP/treenode_forecolor.cpp#2)]
 [!code-csharp[TreeNode_ForeColor#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeNode_ForeColor/CS/treenode_forecolor.cs#2)]
 [!code-vb[TreeNode_ForeColor#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeNode_ForeColor/VB/treenode_forecolor.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowLines">
      <MemberSignature Language="C#" Value="public bool ShowLines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ShowLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as linhas são desenhadas entre os nós de árvore no controle de exibição de árvore.</summary>
        <value>
          <see langword="true" /> se as linhas forem desenhadas entre os nós de árvore no controle de exibição de árvore; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Windows.Forms.TreeView.ShowLines%2A> é definido como `true`, o <xref:System.Windows.Forms.TreeView.FullRowSelect%2A> propriedade será ignorada.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra um personalizado <xref:System.Windows.Forms.TreeView>. Herdando de <xref:System.Windows.Forms.TreeView> classe, esta versão personalizada tem toda a funcionalidade de um típico <xref:System.Windows.Forms.TreeView>. Alterar vários valores de propriedade no construtor fornece uma aparência exclusiva. Porque o <xref:System.Windows.Forms.TreeView.ShowPlusMinus%2A> propriedade é definida como false, o controle personalizado também substitui o <xref:System.Windows.Forms.TreeView.OnAfterSelect%2A> método para que nós podem ser expandidos e recolhidos quando eles são clicados.  
  
 Um controle que é personalizado dessa maneira pode ser usado em toda a organização, tornando mais fácil fornecer uma interface consistente sem exigir que as propriedades de controle a ser especificado em cada projeto.  
  
 [!code-cpp[TreeViewCustomization#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewCustomization/CPP/treeviewcustomization.cpp#2)]
 [!code-csharp[TreeViewCustomization#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewCustomization/CS/treeviewcustomization.cs#2)]
 [!code-vb[TreeViewCustomization#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewCustomization/VB/treeviewcustomization.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowNodeToolTips">
      <MemberSignature Language="C#" Value="public bool ShowNodeToolTips { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowNodeToolTips" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ShowNodeToolTips" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica que dicas de ferramentas são exibidas quando o ponteiro do mouse passa sobre um <see cref="T:System.Windows.Forms.TreeNode" />.</summary>
        <value>
          <see langword="true" /> se dicas de ferramentas forem exibidas quando o ponteiro do mouse passar sobre um <see cref="T:System.Windows.Forms.TreeNode" />; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para dicas de ferramenta fique visível, você deve definir o <xref:System.Windows.Forms.TreeNode.ToolTipText%2A> para um <xref:System.Windows.Forms.TreeNode>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.TreeNode.ToolTipText%2A> e <xref:System.Windows.Forms.TreeView.ShowNodeToolTips%2A> propriedades. Para executar este exemplo, cole o seguinte código em um formulário do Windows e a chamada `InitializeTreeViewWithToolTips` do construtor do formulário ou <xref:System.Windows.Forms.Form.Load> manipulador de eventos.  
  
 [!code-csharp[System.Windows.Forms.TreeViewWhidbeyMembers#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.TreeViewWhidbeyMembers#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowPlusMinus">
      <MemberSignature Language="C#" Value="public bool ShowPlusMinus { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowPlusMinus" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ShowPlusMinus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os botões do sinal de adição (+) e do sinal de subtração (-) são exibidos ao lado de nós de árvore que contêm nós de árvores filhos.</summary>
        <value>
          <see langword="true" /> se os botões do sinal de adição e do sinal de subtração são exibidos ao lado de nós de árvore que contêm nós de árvores filhos; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os botões de sinal de adição e o sinal de menos são exibidos ao lado de raiz árvore nós somente se o <xref:System.Windows.Forms.TreeView.ShowRootLines%2A> é o valor da propriedade `true`. Se o sinal de adição e o sinal de menos botões não estiverem exibidos, existe nenhuma dica visual para indicar que o nó de árvore contém nós de árvore filho e é expansível. O usuário, em seguida, deve clique duas vezes em um nó de árvore para determinar se ele contém nós de árvore filho, para expandi-lo ou para recolhê-lo.  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra um personalizado <xref:System.Windows.Forms.TreeView>. Herdando de <xref:System.Windows.Forms.TreeView> classe, esta versão personalizada tem toda a funcionalidade de um típico <xref:System.Windows.Forms.TreeView>. Alterar vários valores de propriedade no construtor fornece uma aparência exclusiva. Porque o <xref:System.Windows.Forms.TreeView.ShowPlusMinus%2A> propriedade é definida como false, o controle personalizado também substitui o <xref:System.Windows.Forms.TreeView.OnAfterSelect%2A> método para que nós podem ser expandidos e recolhidos quando eles são clicados.  
  
 Um controle que é personalizado dessa maneira pode ser usado em toda a organização, tornando mais fácil fornecer uma interface consistente sem exigir que as propriedades de controle a ser especificado em cada projeto.  
  
 [!code-cpp[TreeViewCustomization#2](~/samples/snippets/cpp/VS_Snippets_Winforms/TreeViewCustomization/CPP/treeviewcustomization.cpp#2)]
 [!code-csharp[TreeViewCustomization#2](~/samples/snippets/csharp/VS_Snippets_Winforms/TreeViewCustomization/CS/treeviewcustomization.cs#2)]
 [!code-vb[TreeViewCustomization#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/TreeViewCustomization/VB/treeviewcustomization.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowRootLines">
      <MemberSignature Language="C#" Value="public bool ShowRootLines { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowRootLines" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.ShowRootLines" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se as linhas são ou não desenhadas entre os nós de árvore que estão na raiz do modo de exibição de árvore.</summary>
        <value>
          <see langword="true" /> se as linhas são desenhadas entre os nós de árvore que estão na raiz do modo de exibição de árvore; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o <xref:System.Windows.Forms.TreeView.ShowRootLines%2A> é de propriedade `false`, os botões de sinal de adição e o sinal de subtração não aparecerão ao lado de nós de árvore de raiz e o <xref:System.Windows.Forms.TreeView.ShowPlusMinus%2A> propriedade não terá efeito.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.BorderStyle> enumeração e <xref:System.Windows.Forms.TreeView.BorderStyle%2A>, <xref:System.Windows.Forms.TreeView.ShowLines%2A>, <xref:System.Windows.Forms.TreeView.Scrollable%2A>, <xref:System.Windows.Forms.TreeView.HideSelection%2A> e <xref:System.Windows.Forms.TreeView.ShowRootLines%2A> propriedades. Para executar este exemplo, cole o seguinte código em um formulário e a chamada a `InitializeTreeView` método no construtor do formulário ou `Load` método.  
  
 [!code-cpp[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TreeViewExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public void Sort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Sort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.Sort" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Classifica os itens no controle <see cref="T:System.Windows.Forms.TreeView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método reaplicará a classificação padrão, que é alfabética por texto de nó, ou uma classificação personalizada especificada pelo <xref:System.Windows.Forms.TreeView.TreeViewNodeSorter%2A> propriedade. Você pode usar esse método se o texto de nós existentes é alterado ou nós são movidos pelo usuário, e você deseja classificar os itens novamente.  
  
> [!NOTE]
>  A classificação padrão usa a <xref:System.Globalization.CompareInfo.Compare%2A> método com base no <xref:System.Windows.Forms.Application.CurrentCulture%2A> especificada pelo aplicativo. Isso significa que <xref:System.Windows.Forms.TreeNode> objetos com o mesmo valor são mantidos na ordem na qual eles foram adicionados para o <xref:System.Windows.Forms.TreeView> controle. Esse comportamento pode ser diferente se uma classificação personalizada é aplicada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sorted">
      <MemberSignature Language="C#" Value="public bool Sorted { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Sorted" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.Sorted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os nós de árvore no modo de exibição de árvore são classificados.</summary>
        <value>
          <see langword="true" /> se os nós de árvore no modo de exibição de árvore estiverem classificados; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Windows.Forms.TreeView.Sorted%2A> é definido como `true`, o <xref:System.Windows.Forms.TreeNode> objetos são classificados em ordem alfabética por seus <xref:System.Windows.Forms.TreeNode.Text%2A> valores de propriedade. Você sempre deve usar <xref:System.Windows.Forms.TreeView.BeginUpdate%2A> e <xref:System.Windows.Forms.TreeView.EndUpdate%2A> para manter o desempenho quando você adiciona uma grande quantidade de itens a um classificada <xref:System.Windows.Forms.TreeView>. Quando o texto de um nó existente é alterado, você deve chamar <xref:System.Windows.Forms.TreeView.Sort%2A> os itens de recurso.  
  
> [!NOTE]
>  A classificação padrão usa a <xref:System.Globalization.CompareInfo.Compare%2A> método com base no <xref:System.Windows.Forms.Application.CurrentCulture%2A> especificada pelo aplicativo. Isso significa que <xref:System.Windows.Forms.TreeNode> objetos com o mesmo valor são mantidos na ordem na qual eles foram adicionados para o <xref:System.Windows.Forms.TreeView> controle.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StateImageList">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.ImageList StateImageList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.ImageList StateImageList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.StateImageList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageList</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a lista de imagens que é usada para indicar o estado da <see cref="T:System.Windows.Forms.TreeView" /> e seus nós.</summary>
        <value>A <see cref="T:System.Windows.Forms.ImageList" /> usada para indicar o estado da <see cref="T:System.Windows.Forms.TreeView" /> e seus nós.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para indicar o estado de um <xref:System.Windows.Forms.TreeNode>, defina o <xref:System.Windows.Forms.TreeView.StateImageList%2A> propriedade e também definir o <xref:System.Windows.Forms.TreeNode.StateImageKey%2A> ou <xref:System.Windows.Forms.TreeNode.StateImageIndex%2A> propriedade para cada <xref:System.Windows.Forms.TreeNode>.  
  
 As imagens de estado exibidas no <xref:System.Windows.Forms.TreeView> 16x16 pixels por padrão. Definindo o <xref:System.Windows.Forms.ImageList.ImageSize%2A> propriedade o <xref:System.Windows.Forms.TreeView.StateImageList%2A> não tem efeito sobre como as imagens são exibidas. No entanto, as imagens de estado são redimensionadas de acordo com a configuração de DPI do sistema quando o arquivo App. config contém a seguinte entrada:  
  
```  
<appSettings>  
  <add key="EnableWindowsFormsHighDpiAutoResizing" value="true" />  
</appSettings>  
  
```  
  
 Quando o <xref:System.Windows.Forms.TreeView.CheckBoxes%2A> propriedade de um <xref:System.Windows.Forms.TreeView> é definido como `true` e <xref:System.Windows.Forms.TreeView.StateImageList%2A> propriedade for definida, cada <xref:System.Windows.Forms.TreeNode> que está contida no <xref:System.Windows.Forms.TreeView> exibe as imagens de primeira e segunda do <xref:System.Windows.Forms.TreeView.StateImageList%2A> para indicar um estado marcado ou desmarcado, respectivamente. Você deve definir o <xref:System.Windows.Forms.TreeView.StateImageList%2A> propriedade antes de adicionar nós a <xref:System.Windows.Forms.TreeView> impedir que as imagens de estado que está sendo mostradas em tempo de design para nós que não tem uma imagem de estado definido.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Windows.Forms.TreeView.StateImageList%2A> propriedade. Para executar este exemplo, cole o código em um formulário do Windows e a chamada `InitializeCheckTreeView` do construtor do formulário ou <xref:System.Windows.Forms.Form.Load> manipulador de eventos.  
  
 [!code-cpp[System.Windows.Forms.TreeViewWhidbeyMembers#8](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/cpp/Form1.cpp#8)]
 [!code-csharp[System.Windows.Forms.TreeViewWhidbeyMembers#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.TreeViewWhidbeyMembers#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o texto do <see cref="T:System.Windows.Forms.TreeView" />.</summary>
        <value>
          <see langword="Null" /> em todos os casos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade não é relevante para essa classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.TreeView.TextChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando a propriedade <see cref="P:System.Windows.Forms.TreeView.Text" /> muda.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopNode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.TreeNode TopNode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.TreeNode TopNode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.TopNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.TreeNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o primeiro nó de árvore totalmente visível no controle de exibição de árvore.</summary>
        <value>Um <see cref="T:System.Windows.Forms.TreeNode" /> que representa o primeiro nó de árvore totalmente visível no controle de exibição de árvore.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Inicialmente, o <xref:System.Windows.Forms.TreeView.TopNode%2A> retorna o primeiro nó de árvore de raiz, que está localizado na parte superior do <xref:System.Windows.Forms.TreeView>. No entanto, se o usuário tem percorreu o conteúdo, o outro nó de árvore pode ser na parte superior.  
  
> [!NOTE]
>  A definição dessa propriedade não tem nenhum efeito quando o <xref:System.Windows.Forms.TreeView.Scrollable%2A> é o valor da propriedade `false`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.TreeView.BeforeLabelEdit> <xref:System.Windows.Forms.TreeView.AfterSelect> e <xref:System.Windows.Forms.TreeView.TopNode%2A> membros. Para executar este exemplo, cole o seguinte código em um formulário que contém um `TreeView` controle chamado `TreeView1`. Chamar o `InitializeTreeView` método no construtor do formulário ou `Load` método.  
  
 [!code-cpp[System.Windows.Forms.TreeViewAndPrintPreview#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TreeViewAndPrintPreview#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.TreeViewAndPrintPreview#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/VB/form1.vb#1)]  
[!code-cpp[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CPP/form1.cpp#2)]
[!code-csharp[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/CS/form1.cs#2)]
[!code-vb[System.Windows.Forms.TreeViewAndPrintPreview#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewAndPrintPreview/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.String" /> que contém o nome do <see cref="T:System.ComponentModel.Component" />, se houver. Esse método não deve ser substituído.</summary>
        <returns>Um <see cref="T:System.String" /> contendo o nome do <see cref="T:System.ComponentModel.Component" />, se houver, ou <see langword="null" /> se o <see cref="T:System.ComponentModel.Component" /> estiver sem nome.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TreeViewNodeSorter">
      <MemberSignature Language="C#" Value="public System.Collections.IComparer TreeViewNodeSorter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer TreeViewNodeSorter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.TreeViewNodeSorter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a implementação de <see cref="T:System.Collections.IComparer" /> para executar uma classificação personalizada dos nós <see cref="T:System.Windows.Forms.TreeView" />.</summary>
        <value>O <see cref="T:System.Collections.IComparer" /> para executar a classificação personalizada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A classificação personalizada é aplicada quando o <xref:System.Windows.Forms.TreeView.TreeViewNodeSorter%2A> está definido.  
  
 Se um <xref:System.Windows.Forms.TreeNode> rótulo for alterado, você pode chamar o <xref:System.Windows.Forms.TreeView.Sort%2A> método para classificar os itens novamente com a classificação personalizada especificada pelo <xref:System.Windows.Forms.TreeView.TreeViewNodeSorter%2A> propriedade.  
  
> [!NOTE]
>  A classificação padrão usa a <xref:System.Globalization.CompareInfo.Compare%2A> método com base no <xref:System.Windows.Forms.Application.CurrentCulture%2A> especificada pelo aplicativo. Isso significa que <xref:System.Windows.Forms.TreeNode> objetos com o mesmo valor são mantidos na ordem na qual eles foram adicionados para o <xref:System.Windows.Forms.TreeView> controle. Esse comportamento pode ser diferente se uma classificação personalizada é aplicada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Windows.Forms.TreeView.TreeViewNodeSorter%2A> propriedade para classificar nós do menor ao maior. Para executar este exemplo, cole o seguinte código em um formulário do Windows e a chamada `InitializeTreeView1` do construtor do formulário ou <xref:System.Windows.Forms.Form.Load> manipulador de eventos.  
  
 [!code-cpp[System.Windows.Forms.TreeViewWhidbeyMembers#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/cpp/Form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.TreeViewWhidbeyMembers#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.TreeViewWhidbeyMembers#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.TreeViewWhidbeyMembers/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisibleCount">
      <MemberSignature Language="C#" Value="public int VisibleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisibleCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.TreeView.VisibleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de nós de árvore que pode ser totalmente visíveis no controle de exibição de árvore.</summary>
        <value>O número de <see cref="T:System.Windows.Forms.TreeNode" /> itens que podem ser totalmente visíveis no <see cref="T:System.Windows.Forms.TreeView" /> controle.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Windows.Forms.TreeView.VisibleCount%2A> valor pode ser maior que o número de nós de árvore na exibição de árvore. O valor é calculado dividindo-se a altura da janela do cliente, a altura de um item do nó de árvore. O resultado é o número total de <xref:System.Windows.Forms.TreeNode> objetos que o <xref:System.Windows.Forms.TreeView> pode exibir em suas dimensões atuais.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.TreeView.WndProc(System.Windows.Forms.Message@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">O <see cref="T:System.Windows.Forms.Message" /> do Windows a ser processado.</param>
        <summary>Substitui <see cref="M:System.Windows.Forms.Control.WndProc(System.Windows.Forms.Message@)" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermissionFlag">para acessar código não gerenciado ao obter o valor da propriedade. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>
