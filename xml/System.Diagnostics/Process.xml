<Type Name="Process" FullName="System.Diagnostics.Process">
  <TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece acesso a processos locais e remotos e permite que você inicie e pare os processos do sistema local.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#System/services/monitoring/system/diagnosticts/Process.cs#f8b2e604d6f1fe04). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Um <xref:System.Diagnostics.Process> componente fornece acesso a um processo que está executando em um computador. Um processo, em termos mais simples, é um aplicativo em execução. Um thread é a unidade básica para o qual o sistema operacional aloca tempo do processador. Um thread pode executar qualquer parte do código do processo, incluindo partes que está sendo executadas no momento por outro thread.  
  
 O <xref:System.Diagnostics.Process> componente é uma ferramenta útil para iniciar, parar, controlar e monitorar aplicativos. Você pode usar o <xref:System.Diagnostics.Process> componente, para obter uma lista dos processos em execução, ou você pode iniciar um novo processo. Um <xref:System.Diagnostics.Process> componente é usado para acessar os processos do sistema. Após um <xref:System.Diagnostics.Process> componente foi inicializado, ele pode ser usado para obter informações sobre o processo em execução. Essas informações incluem o conjunto de threads, os módulos carregados (arquivos. dll e .exe), e informações de desempenho, como a quantidade de memória que o processo está usando.  
  
 Este tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, descarte-direta ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `catch` bloco. Para descartar indiretamente dele, use uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico de interface.  
  
> [!NOTE]
>  processos de 32 bits não podem acessar os módulos de um processo de 64 bits. Se você tentar obter informações sobre um processo de 64 bits de um processo de 32 bits, você receberá um <xref:System.ComponentModel.Win32Exception> exceção. Por outro lado, um processo de 64 bits, pode acessar os módulos de um processo de 32 bits.  
  
 O componente do processo obtém informações sobre um grupo de propriedades de uma só vez. Após o <xref:System.Diagnostics.Process> componente obteve informações sobre um membro de nenhum grupo, ele armazenar em cache os valores para as outras propriedades no grupo e não obter novas informações sobre os outros membros do grupo até que você chamar o <xref:System.Diagnostics.Process.Refresh%2A> método. Portanto, um valor de propriedade não é garantido para ser qualquer mais recente do que a última chamada para o <xref:System.Diagnostics.Process.Refresh%2A> método. As divisões de grupo são dependentes do sistema operacional.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
 Um processo do sistema é identificado exclusivamente no sistema por seu identificador de processo. Como muitos recursos do Windows, um processo também é identificado por seu identificador, que pode não ser exclusivo no computador. Um identificador é o termo genérico para um identificador de um recurso. O sistema operacional persistir o identificador de processo, que é acessado através de <xref:System.Diagnostics.Process.Handle%2A> propriedade o <xref:System.Diagnostics.Process> componente, mesmo quando o processo foi encerrado. Assim, você pode obter informações administrativas do processo, como o <xref:System.Diagnostics.Process.ExitCode%2A> (geralmente um zero em êxito ou um código de erro diferente de zero) e o <xref:System.Diagnostics.Process.ExitTime%2A>. Identificadores são um recurso extremamente valioso, portanto vazando identificadores é mais virulentos de vazamento de memória.  
  
> [!NOTE]
>  Esta classe contém uma demanda de link e uma demanda de herança no nível de classe que se aplica a todos os membros. Um <xref:System.Security.SecurityException> é lançado quando o chamador imediato ou a classe derivada não tem permissão de confiança total. Para obter detalhes sobre as exigências de segurança, consulte [demandas de Link](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)]Anotações  
 No .NET Framework, o <xref:System.Diagnostics.Process> classe por padrão, usa <xref:System.Console> codificações, que geralmente são codificações de página, para os fluxos de entrada, saída e de erro de código. Por exemplo de código, em sistemas cuja é cultura é inglês (Estados Unidos), página de código 437 é a codificação padrão para o <xref:System.Console> classe. No entanto, [!INCLUDE[net_core](~/includes/net-core-md.md)] podem criar somente um subconjunto limitado dessas codificações disponível. Se esse for o caso, ele usa <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> como a codificação padrão.  
  
 Se um <xref:System.Diagnostics.Process> objeto depende de codificações de página de código específico, você poderá ainda disponibilizá-los usando o seguinte procedimento *antes de* você chamar qualquer <xref:System.Diagnostics.Process> métodos:  
  
1.  Adicione uma referência ao assembly System.Text.Encoding.CodePages.dll ao seu projeto.  
  
2.  Recuperar o <xref:System.Text.EncodingProvider> de objeto do <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propriedade.  
  
3.  Passar o <xref:System.Text.EncodingProvider> o objeto para o <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> método para fazer as codificações adicionais com suporte pelo provedor de codificação disponível.  
  
 O <xref:System.Diagnostics.Process> classe automaticamente usará a codificação padrão do sistema em vez de UTF8, desde que você registrou o provedor de codificação antes de chamar qualquer <xref:System.Diagnostics.Process> métodos.  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância do <xref:System.Diagnostics.Process> classe para iniciar um processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 O exemplo a seguir usa o <xref:System.Diagnostics.Process> de classe em si e estático <xref:System.Diagnostics.Process.Start%2A> método para iniciar um processo.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 O seguinte exemplo F # define uma `runProc` função que inicia um processo de captura todas as informações de saída e o erro e registra o número de milissegundos que o processo foi executado.  O `runProc` função tem três parâmetros: o nome do aplicativo para iniciar, os argumentos para fornecer ao aplicativo e o diretório inicial.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 O código para o `runProc` função foi escrita por [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) e está disponível sob o [licença pública da Microsoft](http://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Esta classe não pode ser usada pelo código parcialmente confiável.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Esta classe não pode ser herdada pelo código parcialmente confiável.</permission>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não especificar o <xref:System.Diagnostics.Process.MachineName%2A> propriedade, o padrão é o computador local, (".").  
  
 Você tem duas opções para associar um novo <xref:System.Diagnostics.Process> componente com um processo no computador. A primeira opção é usar o construtor para criar o <xref:System.Diagnostics.Process> componente, definir os membros apropriados a <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chame <xref:System.Diagnostics.Process.Start%2A> para associar o <xref:System.Diagnostics.Process> com um novo processo de sistema. A segunda opção é associar o <xref:System.Diagnostics.Process> com um processo de sistema em execução usando <xref:System.Diagnostics.Process.GetProcessById%2A> ou uma da <xref:System.Diagnostics.Process.GetProcesses%2A> valores de retorno.  
  
 Se você usar um `static` de sobrecarga do <xref:System.Diagnostics.Process.Start%2A> método para iniciar um novo processo do sistema, o método cria um novo <xref:System.Diagnostics.Process> componente e a associa o processo.  
  
 Quando o <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> propriedade é definida como seu valor padrão, `true`, você pode iniciar aplicativos e documentos de maneira semelhante ao uso de `Run` caixa de diálogo do Windows `Start` menu. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> é `false`, você pode iniciar somente os executáveis.  
  
 Qualquer arquivo executável que você pode chamar a partir da linha de comando pode ser iniciado em uma das duas maneiras: definindo os membros apropriados do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar o <xref:System.Diagnostics.Process.Start%2A> método sem parâmetros ou passando o parâmetro apropriado para o `static` <xref:System.Diagnostics.Process.Start%2A> membro.  
  
 Você pode criar um <xref:System.Diagnostics.Process> componente usando o construtor, um estático <xref:System.Diagnostics.Process.Start%2A> sobrecargas ou qualquer o <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> métodos. Depois de você ter feito isso, você tem uma exibição para o processo associado. Isso não é uma exibição dinâmica que se atualiza automaticamente quando as propriedades de processo foram alteradas na memória. Em vez disso, você deve chamar <xref:System.Diagnostics.Process.Refresh%2A> para o componente atualizar o <xref:System.Diagnostics.Process> informações de propriedade em seu aplicativo.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a prioridade base do processo associado.</summary>
        <value>A prioridade base, que é calculada de <see cref="P:System.Diagnostics.Process.PriorityClass" /> do processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.BasePriority%2A> do processo é a prioridade inicial de threads criados dentro do processo associado. Você pode exibir informações sobre a prioridade base por meio de contador Base de prioridade do Monitor do sistema.  
  
 Com base no tempo decorrida ou outras aumenta, o sistema operacional pode alterar a prioridade base quando um processo deve ser colocado antes dos outros.  
  
 O <xref:System.Diagnostics.Process.BasePriority%2A> propriedade permite que você exiba inicial prioridade atribuída a um processo. No entanto, porque ele é somente leitura, você não pode usar o <xref:System.Diagnostics.Process.BasePriority%2A> para definir a prioridade do processo. Para alterar a prioridade, use o <xref:System.Diagnostics.Process.PriorityClass%2A> propriedade. O <xref:System.Diagnostics.Process.BasePriority%2A> pode ser exibido usando o Monitor do sistema, enquanto o <xref:System.Diagnostics.Process.PriorityClass%2A> não é. Tanto o <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> podem ser exibidas programaticamente. A tabela a seguir mostra a relação entre <xref:System.Diagnostics.Process.BasePriority%2A> valores e <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|Classe de prioridade|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">O processo foi encerrado.  
  
 -ou-  
  
 O processo não foi iniciado, portanto, não há ID de processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia as operações de leitura assíncronas no fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> redirecionado do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.StandardError%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída de erro do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardError%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardError%2A> fluxo. Esse método permite que o manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A> para um <xref:System.Diagnostics.Process> :  
  
1.  Defina <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> como `false`.  
  
2.  Defina <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> como `true`.  
  
3.  Adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.ErrorDataReceived> evento. O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> assinatura do delegado.  
  
4.  Iniciar o <xref:System.Diagnostics.Process>.  
  
5.  Chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para o <xref:System.Diagnostics.Process>. Essa chamada inicia as operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Quando iniciar operações de leitura assíncrona, o manipulador de eventos é chamado sempre que o associado <xref:System.Diagnostics.Process> escreve uma linha de texto a seu <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>. A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Depois de cancelar, você pode chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> novamente para retomar as operações de leitura assíncronas.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardError%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir usa o `net view` comando para listar os recursos de rede disponíveis em um computador remoto. O usuário fornece o nome do computador de destino como um argumento de linha de comando. O usuário também pode fornecer um nome de arquivo de saída de erro. O exemplo coleta a saída do comando net, aguarda a conclusão do processo e, em seguida, grava a saída de resultados para o console. Se o usuário fornece o arquivo de erro opcional, o exemplo grava erros no arquivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> é <see langword="false" />.  
  
 \- ou -  
  
 Uma operação de leitura assíncrona já está em andamento no fluxo <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
 \- ou -  
  
 O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> foi usado por uma operação de leitura síncrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia as operações de leitura assíncronas no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirecionado do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A> para um <xref:System.Diagnostics.Process> :  
  
1.  Defina <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> como `false`.  
  
2.  Defina <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> como `true`.  
  
3.  Adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.OutputDataReceived> evento. O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> assinatura do delegado.  
  
4.  Iniciar o <xref:System.Diagnostics.Process>.  
  
5.  Chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para o <xref:System.Diagnostics.Process>. Essa chamada inicia as operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Quando iniciar operações de leitura assíncrona, o manipulador de eventos é chamado sempre que o associado <xref:System.Diagnostics.Process> escreve uma linha de texto a seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
 Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>. A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Depois de cancelar, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> novamente para retomar as operações de leitura assíncronas.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como executar operações de leitura assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo do `sort` comando. O `sort` comando é um aplicativo de console que lê e classifica a entrada de texto.  
  
 O exemplo cria um delegado de evento para o `SortOutputHandler` manipulador de eventos e o associa a <xref:System.Diagnostics.Process.OutputDataReceived> eventos. O manipulador de eventos recebe linhas de texto do redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, formata o texto e escreve o texto na tela.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> é <see langword="false" />.  
  
 \- ou -  
  
 Uma operação de leitura assíncrona já está em andamento no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
 \- ou -  
  
 O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> foi usado por uma operação de leitura síncrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela a operação de leitura assíncrona no fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> redirecionado de um aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>inicia uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardError%2A> fluxo. <xref:System.Diagnostics.Process.CancelErrorRead%2A>termina a assíncrona operação de leitura.  
  
 Depois de cancelar, você pode retomar a operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> novamente.  
  
 Quando você chama <xref:System.Diagnostics.Process.CancelErrorRead%2A>, todas as operações para de leitura em andamento <xref:System.Diagnostics.Process.StandardError%2A> sejam concluídas e, em seguida, o manipulador de eventos está desabilitado. Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardError%2A> é salvo em um buffer. Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>, a saída a salva é enviada ao manipulador de eventos e retomar operações de leitura assíncronas. Se você quiser alterar o manipulador de eventos antes de continuar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar um novo manipulador de eventos:  
  
```  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardError%2A> fluxo. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Se você cancelar assíncrona operação de leitura em <xref:System.Diagnostics.Process.StandardError%2A> e, em seguida, é necessário ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para retomar as operações de leitura assíncronas. Não siga <xref:System.Diagnostics.Process.CancelErrorRead%2A> com uma chamada para o síncrona ler métodos de <xref:System.Diagnostics.Process.StandardError%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia o `nmake` comando com o usuário os argumentos fornecidos. Os fluxos de saída e de erro são de leitura assíncrona. as linhas de texto coletados são exibidas no console, bem como gravadas em um arquivo de log. Se a saída do comando excede um número especificado de linhas, as operações de leitura assíncronas serão canceladas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> não está habilitado para operações de leitura assíncronas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela a operação de leitura assíncrona no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirecionado de um aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>inicia uma assíncrona operação de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. <xref:System.Diagnostics.Process.CancelOutputRead%2A>termina a assíncrona operação de leitura.  
  
 Depois de cancelar, você pode retomar operações de leitura assíncronas chamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> novamente.  
  
 Quando você chama <xref:System.Diagnostics.Process.CancelOutputRead%2A>, todas as operações para de leitura em andamento <xref:System.Diagnostics.Process.StandardOutput%2A> sejam concluídas e, em seguida, o manipulador de eventos está desabilitado. Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardOutput%2A> é salvo em um buffer. Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, a saída a salva é enviada ao manipulador de eventos e retomar operações de leitura assíncronas. Se você quiser alterar o manipulador de eventos antes de continuar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar um novo manipulador de eventos:  
  
```  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Se você cancelar assíncrona operação de leitura em <xref:System.Diagnostics.Process.StandardOutput%2A> e, em seguida, é necessário ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para retomar as operações de leitura assíncronas. Não siga <xref:System.Diagnostics.Process.CancelOutputRead%2A> com uma chamada para o síncrona ler métodos de <xref:System.Diagnostics.Process.StandardOutput%2A> como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia o `nmake` comando com o usuário os argumentos fornecidos. Os fluxos de saída e de erro são de leitura assíncrona. as linhas de texto coletados são exibidas no console, bem como gravadas em um arquivo de log. Se a saída do comando excede um número especificado de linhas, as operações de leitura assíncronas serão canceladas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> não está habilitado para operações de leitura assíncronas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos associados a esse componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.Close%2A> método faz com que o processo de interromper a espera para sair se estava aguardando, fecha o identificador de processo e limpa propriedades específicas do processo. <xref:System.Diagnostics.Process.Close%2A>Não feche o gravadores e leitores de saída, de entrada e de erro padrão caso eles estão sendo referenciados externamente.  
  
> [!NOTE]
>  O método <xref:System.Diagnostics.Process.Dispose%2A> chama <xref:System.Diagnostics.Process.Close%2A>. Colocando o <xref:System.Diagnostics.Process> do objeto em um `using` bloco libera recursos sem a necessidade de chamar <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em intervalos de 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha um processo que tem uma interface do usuário enviando uma mensagem de fechamento à janela principal.</summary>
        <returns>
          <see langword="true" /> se a mensagem de fechamento tiver sido enviada com êxito; <see langword="false" /> se o processo associado não tiver uma janela principal ou se a janela principal estiver desabilitada (por exemplo, se uma caixa de diálogo modal estiver sendo mostrada).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um processo está em execução, seu loop de mensagem está em estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagens para o aplicativo. A solicitação para sair do processo chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> não força o aplicativo para sair. O aplicativo pode pedir para verificação do usuário antes de encerrar, ou ele pode recusar sair. Para forçar o aplicativo para sair, use o <xref:System.Diagnostics.Process.Kill%2A> método. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> é idêntico de um usuário fechando a janela principal do aplicativo, usando o menu do sistema. Portanto, a solicitação para sair do processo, fechando a janela principal não força o aplicativo para ser encerrado imediatamente.  
  
 Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A>faz com que um encerramento anormal de processo e deve ser usado somente quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A>Habilita um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> falhar, você pode usar <xref:System.Diagnostics.Process.Kill%2A> para encerrar o processo. <xref:System.Diagnostics.Process.Kill%2A>é a única maneira de encerrar os processos que não têm interfaces gráficas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> somente para processos em execução no computador local. Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">O processo já terminou.  
  
 -ou-  
  
 Nenhum processo está associado a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libere todos os recursos usados por esse processo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se o evento <see cref="E:System.Diagnostics.Process.Exited" /> deve ser gerado quando o processo é encerrado.</summary>
        <value>
          <see langword="true" /> se o evento <see cref="E:System.Diagnostics.Process.Exited" /> precisar ser gerado quando o processo associado for terminado (por meio de uma saída ou uma chamada a <see cref="M:System.Diagnostics.Process.Kill" />); caso contrário, <see langword="false" />. O padrão é <see langword="false" />. Observe que o <see cref="E:System.Diagnostics.Process.Exited" /> é gerado mesmo se o valor de <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> é <see langword="false" /> quando o processo foi encerrado durante ou antes que o usuário executa um <see cref="P:System.Diagnostics.Process.HasExited" /> verificar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
O <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade sugere se o componente deve ser notificado quando o sistema operacional foi fechado por um processo. O <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> no processamento assíncrono, a propriedade é usada para notificar o aplicativo que um processo foi encerrado. Para forçar o aplicativo de forma síncrona espera para um evento de saída (que interrompe o processamento do aplicativo até que o evento de saída ocorreu), use o <xref:System.Diagnostics.Process.WaitForExit%2A> método.

> [!NOTE]
> Se você estiver usando o Visual Studio e clique duas vezes em um <xref:System.Diagnostics.Process> componente no seu projeto, um <xref:System.Diagnostics.Process.Exited> delegado do evento e o manipulador de eventos são gerados automaticamente. Conjuntos de código adicional a <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade `false`. Você deve alterar essa propriedade como `true` para o manipulador de eventos executar quando o processo associado for encerrado.

Se o componente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valor é `true`, ou quando <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é `false` e um <xref:System.Diagnostics.Process.HasExited%2A> verificação é chamada pelo componente, o componente pode acessar as informações administrativas para o processo associado, que permanece armazenado pelo sistema operacional. Essas informações incluem o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.ExitCode%2A>.

Depois que o processo associado for encerrado, o <xref:System.Diagnostics.Process.Handle%2A> do componente não aponta para um recurso existente do processo. Em vez disso, ele só pode ser usado para acessar as informações do sistema operacional sobre o recurso de processo. O sistema operacional está ciente de que há identificadores encerrados processos que ainda não foram liberados por <xref:System.Diagnostics.Process> componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória.

Há um custo associado observando um processo sair. Se <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é `true`, o <xref:System.Diagnostics.Process.Exited> é gerado quando o processo associado é encerrado. Os procedimentos para o <xref:System.Diagnostics.Process.Exited> eventos que são executados nesse horário.

Às vezes, o aplicativo inicia um processo, mas não requer a notificação de seu fechamento. Por exemplo, seu aplicativo pode iniciar o bloco de notas para permitir que o usuário efetue a edição de texto, mas nenhuma outra fazer uso do aplicativo bloco de notas. Você pode escolher evitar a notificação quando o processo foi encerrado porque ele não é relevante para a operação contínua de seu aplicativo. Configuração <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> para `false` pode salvar os recursos do sistema.

## Examples  
O exemplo de código a seguir cria um processo que imprime um arquivo. Ele define o <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade para fazer com que o processo gerar o <xref:System.Diagnostics.Process.Exited> evento quando ele sai. O <xref:System.Diagnostics.Process.Exited> manipulador de eventos exibe informações de processo.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Coloca um componente <see cref="T:System.Diagnostics.Process" /> no estado para interagir com os processos do sistema operacional executados em um modo especial, habilitando a propriedade nativa <see langword="SeDebugPrivilege" /> no thread atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns processos do sistema operacional executado em um modo especial. Tentativa de ler propriedades de ou anexar a esses processos não for possível, a menos que você chamou <xref:System.Diagnostics.Process.EnterDebugMode%2A> no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando você não precisa mais acesso a esses processos que são executados em modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um aplicativo realiza gravação em seu fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> redirecionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.ErrorDataReceived> evento indica que o processo associado foi gravados seu redirecionado <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 O evento ocorre apenas durante operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>. Para iniciar as operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardError%2A> fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.ErrorDataReceived> eventos e chamadas <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Depois disso, o <xref:System.Diagnostics.Process.ErrorDataReceived> sinais de evento sempre que o processo grava uma linha para o redirecionamento <xref:System.Diagnostics.Process.StandardError%2A> transmitir, até que o processo será encerrado ou chame <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para garantir que o buffer de saída foi liberado.  
  
   
  
## Examples  
 O exemplo a seguir usa o `net view` comando para listar os recursos de rede disponíveis em um computador remoto. O usuário fornece o nome do computador de destino como um argumento de linha de comando. O usuário também pode fornecer um nome de arquivo de saída de erro. O exemplo coleta a saída do comando net, aguarda a conclusão do processo e, em seguida, grava a saída de resultados para o console. Se o usuário fornece o arquivo de erro opcional, o exemplo grava erros no arquivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor especificado pelo processo associado quando ele foi finalizado.</summary>
        <value>O código especificado pelo processo associado quando ele foi finalizado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.ExitCode%2A> para obter o status que o processo de sistema retornado quando ele foi encerrado. Você pode usar o código de saída muito, como um número inteiro retornar o valor de uma `main()` procedimento.  
  
 O <xref:System.Diagnostics.Process.ExitCode%2A> valor para um processo reflete a convenção específica implementada pelo desenvolvedor do aplicativo para que o processo. Se você usar o valor de código de saída para tomar decisões em seu código, certifique-se de que você sabe que a convenção de código de saída usada pelo processo de aplicativo.  
  
 Os desenvolvedores geralmente indicam uma saída com êxito por um <xref:System.Diagnostics.Process.ExitCode%2A> valor de zero e designar erros por valores diferentes de zero e o método de chamada pode usar para identificar a causa do encerramento de um processo anormal. Não é necessário seguir essas diretrizes, mas eles são a convenção.  
  
 Se você tentar obter o <xref:System.Diagnostics.Process.ExitCode%2A> antes que o processo foi encerrado, a tentativa de lança uma exceção. Examine o <xref:System.Diagnostics.Process.HasExited%2A> propriedade primeiro para verificar se o processo associado foi encerrado.  
  
> [!NOTE]
>  Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída terá não concluído quando <xref:System.Diagnostics.Process.HasExited%2A> retorna `true`. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro antes de verificar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Você pode usar o <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A> método para fazer com que um processo associado sair.  
  
 Há duas maneiras de ser notificado quando o processo associado for encerrado: modo síncrono e assíncrono. Notificação síncrona depende de chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para pausar o processamento de seu aplicativo até que o componente associado será encerrado. Notificação assíncrona depende de <xref:System.Diagnostics.Process.Exited> eventos. Ao usar a notificação assíncrona, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve ser definido como `true` para o <xref:System.Diagnostics.Process> componente para receber a notificação de que o processo foi encerrado.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não foi encerrado.  
  
 -ou-  
  
 O processo <see cref="P:System.Diagnostics.Process.Handle" /> não é válido.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.ExitCode" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um processo é fechado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.Exited> evento indica que o processo associado foi encerrado. Essa ocorrência significa que o processo encerrado (interrompida) ou fechada com êxito. Esse evento pode ocorrer somente se o valor de <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é de propriedade `true`.  
  
 Há duas maneiras de ser notificado quando o processo associado for encerrado: modo síncrono e assíncrono. Notificação síncrona significa chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para bloquear o thread atual até que o processo foi encerrado. Notificação assíncrona usa o <xref:System.Diagnostics.Process.Exited> evento, que permite que o thread de chamada continuar a execução nesse meio tempo. No último caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve ser definido como `true` para o aplicativo de chamada receber o evento Exited.  
  
 Quando o sistema operacional é desligado por um processo, ele notifica todos os outros processos que registraram manipuladores para o evento Exited. Neste momento, o identificador do processo que acabou de sair pode ser usado para acessar algumas propriedades como <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.HasExited%2A> que o sistema operacional mantém até que ele libera esse identificador completamente.  
  
> [!NOTE]
>  Mesmo se você tiver um identificador para um processo encerrado, não é possível chamar <xref:System.Diagnostics.Process.Start%2A> novamente para reconectar-se para o mesmo processo. Chamando <xref:System.Diagnostics.Process.Start%2A> automaticamente libera o processo associado e se conecta a um processo com o mesmo arquivo, mas um totalmente novo <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Para obter mais informações sobre o uso do <xref:System.Diagnostics.Process.Exited> eventos em aplicativos de formulários do Windows, consulte o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um processo que imprime um arquivo. Ele gera o <xref:System.Diagnostics.Process.Exited> evento quando o processo foi encerrado porque o <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade foi definida quando o processo foi criado. O <xref:System.Diagnostics.Process.Exited> manipulador de eventos exibe informações de processo.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a hora em que o processo associado foi encerrado.</summary>
        <value>Um <see cref="T:System.DateTime" /> que indica quando o processo associado foi encerrado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o processo não foi encerrado, a tentativa de recuperar o <xref:System.Diagnostics.Process.ExitTime%2A> propriedade gera uma exceção. Use <xref:System.Diagnostics.Process.HasExited%2A> antes de obter o <xref:System.Diagnostics.Process.ExitTime%2A> propriedade para determinar se o processo associado foi encerrado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um processo que imprime um arquivo. O processo gera o <xref:System.Diagnostics.Process.Exited> eventos quando ele sai e o manipulador de eventos exibe o <xref:System.Diagnostics.Process.ExitTime%2A> processam de propriedade e outras informações.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.ExitTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um novo componente <see cref="T:System.Diagnostics.Process" /> e o associa ao processo ativo no momento.</summary>
        <returns>Um novo componente <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo que está executando o aplicativo de chamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> instância e associá-lo com o recurso de processo no computador local.  
  
 Como o semelhante <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A> métodos, <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associa um recurso existente com um novo <xref:System.Diagnostics.Process> componente.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">O identificador exclusivo do sistema de um recurso de processo.</param>
        <summary>Retorna um novo componente <see cref="T:System.Diagnostics.Process" />, tendo em conta o identificador de um processo no computador local.</summary>
        <returns>Um componente <see cref="T:System.Diagnostics.Process" /> associado ao recurso de processo local identificado pelo parâmetro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> componente e associá-lo a um recurso de processo no computador local. O recurso de processo já deve existir no computador, pois <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> não cria um recurso do sistema, mas em vez disso, associa um recurso com um aplicativo gerado <xref:System.Diagnostics.Process> componente. Um processo <xref:System.Diagnostics.Process.Id%2A> pode ser recuperado somente para um processo que está sendo executado no computador. Depois que o processo termina, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> lança uma exceção se você passar um identificador expirado.  
  
 Em qualquer computador em particular, o identificador de um processo é exclusivo. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29>Retorna um processo no máximo. Se você deseja obter todos os processos em execução de um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se existirem vários processos no computador executando o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retorna uma matriz que contém todos os processos associados. Você pode consultar cada um desses processos para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O processo especificado pelo parâmetro <paramref name="processId" /> não está em execução. O identificador pode ter expirado.</exception>
        <exception cref="T:System.InvalidOperationException">O processo não foi iniciado por esse objeto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">O identificador exclusivo do sistema de um recurso de processo.</param>
        <param name="machineName">O nome de um computador na rede.</param>
        <summary>Retorna um novo componente <see cref="T:System.Diagnostics.Process" />, dado um identificador de processo e o nome de um computador na rede.</summary>
        <returns>Um componente <see cref="T:System.Diagnostics.Process" /> associado ao recurso de processo remoto identificado pelo parâmetro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> componente e associá-lo a um recurso de processo em um computador remoto na rede. O recurso de processo já deve existir no computador especificado, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> não cria um recurso do sistema, mas em vez disso, associa um recurso com um aplicativo gerado <xref:System.Diagnostics.Process> componente. Um processo <xref:System.Diagnostics.Process.Id%2A> pode ser recuperado somente para um processo que está sendo executado no computador. Depois que o processo termina, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> lança uma exceção se você passar um identificador expirado.  
  
 Em qualquer computador em particular, o identificador de um processo é exclusivo. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29>Retorna um processo no máximo. Se você deseja obter todos os processos em execução de um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se existirem vários processos no computador executando o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retorna uma matriz que contém todos os processos associados. Você pode consultar cada um desses processos para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo.  
  
 Se você não especificar um `machineName`, será usado o computador local. Como alternativa, você pode especificar o computador local, definindo `machineName` com o valor "." ou uma cadeia de caracteres vazia ("").  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O processo especificado pelo parâmetro <paramref name="processId" /> não está em execução. O identificador pode ter expirado.  
  
 -ou-  
  
 A sintaxe do parâmetro <paramref name="machineName" /> é inválida. O nome pode ter tamanho zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="machineName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O processo não foi iniciado por esse objeto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo componente <see cref="T:System.Diagnostics.Process" /> para cada recurso de processo no computador local.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa todos os recursos de processo sendo executados no computador local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos de processo no computador local. Os recursos de processo já devem existir no computador local, pois <xref:System.Diagnostics.Process.GetProcesses%2A> não cria recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Porque o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.  
  
 Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A>cria um <xref:System.Diagnostics.Process> componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método. <xref:System.Diagnostics.Process.GetProcessesByName%2A>cria uma matriz de <xref:System.Diagnostics.Process> componentes cujos recursos de processo associado compartilhem o arquivo executável que você passa para o método.  
  
> [!NOTE]
>  Vários serviços do Windows podem ser carregados na mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identificar esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O computador por meio do qual deve ser lida a lista de processos.</param>
        <summary>Cria um novo componente <see cref="T:System.Diagnostics.Process" /> para cada recurso de processo no computador especificado.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa todos os recursos de processo sendo executados no computador especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos de processo no computador (geralmente remoto) especificado. Os recursos de processo já devem existir no computador local, pois <xref:System.Diagnostics.Process.GetProcesses%2A> não cria recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Porque o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.  
  
 Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A>cria um <xref:System.Diagnostics.Process> componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método. <xref:System.Diagnostics.Process.GetProcessesByName%2A>cria uma matriz de <xref:System.Diagnostics.Process> componentes cujos recursos de processo associado compartilhem o arquivo executável que você passa para o método.  
  
 Esta sobrecarga do <xref:System.Diagnostics.Process.GetProcesses%2A> método geralmente é usado para recuperar a lista de recursos do processo em execução em um computador remoto na rede, mas você pode especificar o computador local, passando ".".  
  
> [!NOTE]
>  Vários serviços do Windows podem ser carregados na mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identificar esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="machineName" /> é inválida. Ele pode ter comprimento zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="machineName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma de sistema operacional não dá suporte a esta operação em computadores remotos.</exception>
        <exception cref="T:System.InvalidOperationException">Há problemas ao acessar as APIs de contador de desempenho usadas para obter informações do processo. Essa exceção é específica ao Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um problema ao acessar uma API do sistema subjacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">O nome amigável do processo.</param>
        <summary>Cria uma matriz de novos componentes <see cref="T:System.Diagnostics.Process" /> e os associa a todos os recursos do processo no computador local que compartilham o nome do processo especificado.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa os recursos do processo que executam o aplicativo ou arquivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos do processo que estiver executando o mesmo arquivo executável no computador local. Os recursos de processo já devem existir no computador, pois <xref:System.Diagnostics.Process.GetProcessesByName%2A> não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Um `processName` pode ser especificado para um arquivo executável não estiver em execução no computador local, portanto, a matriz, o método retorna pode ser vazia.  
  
 O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. <xref:System.Diagnostics.Process.GetProcessesByName%2A>é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável. Por exemplo, você pode passar um nome de arquivo executável, como o `processName` parâmetro para fechar todas as instâncias em execução do arquivo executável.  
  
 Embora um processo <xref:System.Diagnostics.Process.Id%2A> é exclusivo a um recurso de um único processo no sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro. Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A> retorna um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A> retorna uma matriz que contém todos os processos associados. Se você precisar manipular o processo usando chamadas de API padrão, você pode consultar cada um desses processos para seu identificador. Você não pode acessar recursos de processo por meio apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process> componentes que foram associados com os recursos de processo, você pode iniciar, encerrar e manipular os recursos do sistema.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Há problemas ao acessar as APIs de contador de desempenho usadas para obter informações do processo. Essa exceção é específica ao Windows NT, Windows 2000 e Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">O nome amigável do processo.</param>
        <param name="machineName">O nome de um computador na rede.</param>
        <summary>Cria uma matriz de novos componentes <see cref="T:System.Diagnostics.Process" /> e os associa a todos os recursos do processo em um computador remoto que compartilham o nome do processo especificado.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa os recursos do processo que executam o aplicativo ou arquivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos do processo que estiver executando o mesmo arquivo executável no computador especificado. Os recursos de processo já devem existir no computador, pois <xref:System.Diagnostics.Process.GetProcessesByName%2A> não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Um `processName` pode ser especificado para um arquivo executável não estiver em execução no computador local, portanto, a matriz, o método retorna pode ser vazia.  
  
 O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. <xref:System.Diagnostics.Process.GetProcessesByName%2A>é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável. Por exemplo, você pode passar um nome de arquivo executável, como o `processName` parâmetro para fechar todas as instâncias em execução do arquivo executável.  
  
 Embora um processo <xref:System.Diagnostics.Process.Id%2A> é exclusivo a um recurso de um único processo no sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro. Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A> retorna um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A> retorna uma matriz que contém todos os processos associados. Se você precisar manipular o processo usando chamadas de API padrão, você pode consultar cada um desses processos para seu identificador. Você não pode acessar recursos de processo por meio apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process> componentes que foram associados com os recursos de processo, você pode iniciar, encerrar e manipular os recursos do sistema.  
  
 Você pode usar essa sobrecarga para obter os processos no computador local, bem como em um computador remoto. Use "." para especificar o computador local. Outra sobrecarga existe que utiliza o computador local por padrão.  
  
 Você pode acessar processos em computadores remotos somente para exibir informações, como estatísticas sobre os processos. Você não pode fechar, encerrar (usando <xref:System.Diagnostics.Process.Kill%2A>), ou inicie os processos em computadores remotos.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Em seguida, ele recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="machineName" /> é inválida. Ele pode ter comprimento zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="machineName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma de sistema operacional não dá suporte a esta operação em computadores remotos.</exception>
        <exception cref="T:System.InvalidOperationException">Há problemas ao acessar as APIs de contador de desempenho usadas para obter informações do processo. Essa exceção é específica ao Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um problema ao acessar uma API do sistema subjacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador nativo do processo associado.</summary>
        <value>O identificador que o sistema operacional atribuiu ao processo associado quando o processo foi iniciado. O sistema usa esse identificador para manter o controle dos atributos do processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo pode obter um identificador para um processo que pode ser usado como um parâmetro para muitas funções de informações de processo e controle. Você pode usar esse identificador para inicializar um <xref:System.Threading.WaitHandle> ou chamar métodos nativos com a plataforma de invocação.  
  
 Esse identificador de processo é particular para um aplicativo - em outras palavras, processo identificadores não podem ser compartilhados. Um processo também tem um processo <xref:System.Diagnostics.Process.Id%2A> que, diferentemente do <xref:System.Diagnostics.Process.Handle%2A>, é exclusivo e, portanto, válido em todo o sistema.  
  
 Somente processos iniciados por meio de uma chamada para <xref:System.Diagnostics.Process.Start%2A> definir o <xref:System.Diagnostics.Process.Handle%2A> propriedade correspondente <xref:System.Diagnostics.Process> instâncias.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não foi iniciado ou foi fechado. A propriedade <see cref="P:System.Diagnostics.Process.Handle" /> não pode ser lida porque não há um processo associado a essa instância de <see cref="T:System.Diagnostics.Process" />.  
  
 -ou-  
  
 A instância de <see cref="T:System.Diagnostics.Process" /> foi anexada a um processo em execução, mas você não tem as permissões necessárias para obter um identificador com direitos de acesso completo.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Handle" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de identificadores abertos pelo processo.</summary>
        <value>O número de identificadores do sistema operacional abertos pelo processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificadores fornecem uma maneira para um processo para se referir a objetos. Um processo pode obter identificadores de arquivos, recursos, filas de mensagens e muitos outros objetos do sistema operacional. O sistema operacional recupera a memória associada ao processo somente quando a contagem de identificadores é zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o processo associado foi encerrado.</summary>
        <value>
          <see langword="true" /> se o processo do sistema operacional referenciado pelo componente <see cref="T:System.Diagnostics.Process" /> tiver sido terminado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de `true` para <xref:System.Diagnostics.Process.HasExited%2A> indica que o processo associado foi finalizado, normalmente ou anormal. Você pode solicitar ou forçar o processo associado ao sair chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Se um identificador é aberto para o processo, o sistema operacional libera a memória do processo quando o processo foi encerrado, mas retém informações administrativas sobre o processo, como o identificador, o código de saída e a hora de saída. Para obter essas informações, você pode usar o <xref:System.Diagnostics.Process.ExitCode%2A> e <xref:System.Diagnostics.Process.ExitTime%2A> propriedades. Essas propriedades são preenchidas automaticamente para os processos que foram iniciados por este componente. A informação administrativa é liberada quando todos os a <xref:System.Diagnostics.Process> componentes que estão associados com o processo de sistema são destruídos e manter não mais identificadores para o processo encerrado.  
  
 Um processo pode encerrar independentemente de seu código. Se você iniciou o processo usando esse componente, o sistema atualiza o valor de <xref:System.Diagnostics.Process.HasExited%2A> automaticamente, mesmo que o processo associado for encerrado independentemente.  
  
> [!NOTE]
>  Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída não tenha concluído quando essa propriedade retornará `true`. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro antes de verificar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há nenhum processo associado ao objeto.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O código de saída do processo não pôde ser recuperado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador exclusivo para o processo associado.</summary>
        <value>O identificador exclusivo gerado pelo sistema do processo que é referenciado por essa instância de <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processo de <xref:System.Diagnostics.Process.Id%2A> não é válido se o processo associado não está em execução. Portanto, você deve garantir que o processo está em execução antes de tentar recuperar o <xref:System.Diagnostics.Process.Id%2A> propriedade. Até que o processo termina, o identificador de processo identifica exclusivamente o processo em todo o sistema.  
  
 Você pode se conectar a um processo que está em execução em um computador local ou remoto para um novo <xref:System.Diagnostics.Process> instância passando o identificador de processo para o <xref:System.Diagnostics.Process.GetProcessById%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A>é um `static` método que cria um novo componente e define o <xref:System.Diagnostics.Process.Id%2A> propriedade para o novo <xref:System.Diagnostics.Process> instância automaticamente.  
  
 Identificadores de processo podem ser reutilizados pelo sistema. O <xref:System.Diagnostics.Process.Id%2A> o valor da propriedade é exclusivo somente enquanto o processo associado está em execução. Depois que o processo foi encerrado, o sistema pode reutilizar o <xref:System.Diagnostics.Process.Id%2A> valor da propriedade de um processo relacionado.  
  
 Como o identificador é exclusivo no sistema, você pode passar para outros threads como uma alternativa para passar um <xref:System.Diagnostics.Process> instância. Esta ação pode economizar recursos do sistema e garantir que o processo é identificado corretamente.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como obter o <xref:System.Diagnostics.Process.Id%2A> para todas as instâncias de um aplicativo em execução. O código cria uma nova instância do bloco de notas, lista todas as instâncias do bloco de notas e, em seguida, permite que o usuário insira o <xref:System.Diagnostics.Process.Id%2A> número para remover uma instância específica.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.Process.Id" /> do processo não foi definida.  
  
 -ou-  
  
 Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe imediatamente o processo associado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A>força um encerramento do processo, enquanto <xref:System.Diagnostics.Process.CloseMainWindow%2A> solicita somente um encerramento. Durante a execução de um processo com uma interface gráfica, seu loop de mensagem está em estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagens para o aplicativo. A solicitação para sair do processo chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> não força o aplicativo para sair. O aplicativo pode pedir para verificação do usuário antes de encerrar, ou ele pode recusar sair. Para forçar o aplicativo para sair, use o <xref:System.Diagnostics.Process.Kill%2A> método. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> é idêntico de um usuário fechando a janela principal do aplicativo, usando o menu do sistema. Portanto, a solicitação para sair do processo, fechando a janela principal não força o aplicativo para ser encerrado imediatamente.  
  
> [!NOTE]
>  O <xref:System.Diagnostics.Process.Kill%2A> método é executado de forma assíncrona. Depois de chamar o <xref:System.Diagnostics.Process.Kill%2A> método, chame o <xref:System.Diagnostics.Process.WaitForExit%2A> método para aguardar o processo sair ou verificar o <xref:System.Diagnostics.Process.HasExited%2A> propriedade para determinar se o processo foi encerrado.  
  
 Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A>faz com que um encerramento anormal de processo e deve ser usado somente quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A>Habilita um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> falhar, você pode usar <xref:System.Diagnostics.Process.Kill%2A> para encerrar o processo. <xref:System.Diagnostics.Process.Kill%2A>é a única maneira de encerrar os processos que não têm interfaces gráficas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> somente para processos em execução no computador local. Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos.  
  
> [!NOTE]
>  Se a chamada para o <xref:System.Diagnostics.Process.Kill%2A> método é feito durante o processo está sendo encerrado no momento, um <xref:System.ComponentModel.Win32Exception> é lançada para acesso negado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível terminar o processo associado.  
  
 -ou-  
  
 O processo está sendo encerrado.  
  
 -ou-  
  
 O processo associado é um executável do Win16.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando chamar <see cref="M:System.Diagnostics.Process.Kill" /> para um processo em execução em um computador remoto. Esse método está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo já terminou.  
  
 -ou-  
  
 Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Leva um <see cref="T:System.Diagnostics.Process" /> componente fora do estado que permite interagir com processos do sistema operacional que são executados em um modo especial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns processos do sistema operacional executado em um modo especial. Tentativa de ler propriedades de ou anexar a esses processos não for possível, a menos que você chamou <xref:System.Diagnostics.Process.EnterDebugMode%2A> no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando você não precisa mais acesso a esses processos que são executados em modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do computador no qual o processo associado está em execução.</summary>
        <value>O nome do computador no qual o processo associado está em execução.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode exibir dados de estatísticas e informações de processo para processos em execução em computadores remotos, mas não é possível chamar <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, ou <xref:System.Diagnostics.Process.Kill%2A> em computadores remotos.  
  
> [!NOTE]
>  Quando o processo associado está em execução no computador local, essa propriedade retorna um ponto (".") para o nome do computador. Você deve usar o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para obter o nome do computador correto.  
  
   
  
## Examples  
 Para usar o exemplo a seguir, você deve primeiro iniciar pelo menos uma instância do bloco de notas em um computador remoto. O exemplo solicita o nome do computador remoto no qual o bloco de notas está em execução e, em seguida, exibe os respectivos <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, e <xref:System.Diagnostics.Process.MachineName%2A> propriedades para cada instância.  
  
 [!code-cpp[process_GetProcessesByName2_2#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CPP/process_getprocessesbyname2_2.cpp#2)]
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o módulo principal do processo associado.</summary>
        <value>O <see cref="T:System.Diagnostics.ProcessModule" /> usado para iniciar o processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. O <xref:System.Diagnostics.Process.MainModule%2A> propriedade permite que você exiba informações sobre o executável usado para iniciar o processo, incluindo o nome do módulo, nome de arquivo e detalhes de memória do módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MainModule" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Um processo de 32 bits está tentando acessar os módulos de um processo de 64 bits.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.  
  
 -ou-  
  
 O processo foi encerrado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de janela da janela principal do processo associado.</summary>
        <value>O identificador de janela gerado pelo sistema da janela principal do processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A janela principal é a janela aberta pelo processo que atualmente tem o foco (o <xref:System.Windows.Forms.Form.TopLevel%2A> formulário). Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A> método para atualizar o <xref:System.Diagnostics.Process> objeto para obter o identificador de janela principal atual, se ele tiver sido alterada. Em geral, como o identificador de janela é armazenado em cache, use <xref:System.Diagnostics.Process.Refresh%2A> antecipadamente para garantir que você vai recuperar o identificador atual.  
  
 Você pode obter o <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriedade somente para processos em execução no computador local. O <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriedade é um valor que identifica exclusivamente a janela que está associada com o processo.  
  
 Um processo tem uma janela principal associada a ele apenas se o processo tem uma interface gráfica. Se o processo associado não tem uma janela principal, o <xref:System.Diagnostics.Process.MainWindowHandle%2A> valor é zero. O valor também é zero para processos que foram ocultos, ou seja, processos que não são visíveis na barra de tarefas. Isso pode ser o caso para processos que são exibidos como ícones na área de notificação, na extrema direita da barra de tarefas.  
  
 Se você acabou de iniciar um processo e deseja usar seu identificador de janela principal, considere o uso de <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado. Caso contrário, uma exceção será gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> não foi definido porque o processo foi encerrado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a legenda da janela principal do processo.</summary>
        <value>O título da janela principal do processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um processo tem uma janela principal associada a ele apenas se o processo tem uma interface gráfica. Se o processo associado não tem uma janela principal (para que <xref:System.Diagnostics.Process.MainWindowHandle%2A> é zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> é uma cadeia de caracteres vazia (""). Se você acabou de iniciar um processo e deseja usar o título da janela principal, considere o uso de <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado. Caso contrário, o sistema gerará uma exceção.  
  
> [!NOTE]
>  A janela principal é a janela que atualmente tem o foco. Observe que isso pode não ser a janela principal para o processo. Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A> método para atualizar o <xref:System.Diagnostics.Process> objeto para obter o identificador de janela principal atual, se ele tiver sido alterada.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas e recupera a legenda da janela principal do processo.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> não foi definida, porque o processo foi encerrado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho de conjunto de trabalho máximo permitido em bytes para o processo associado.</summary>
        <value>O tamanho máximo do conjunto de trabalho permitido na memória para o processo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e os arquivos de DLL. Como o conjunto de trabalho cresce, aumenta a demanda por memória.  
  
 Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema reserva uma quantidade de memória igual ao mínimo o tamanho do conjunto para o processo de trabalho. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo está ativo, mas nunca mantém mais do que o tamanho máximo.  
  
 O sistema define o conjunto de tamanhos de trabalho padrão. Você pode modificar esses tamanhos usando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membros. No entanto, definir esses valores não garante que a memória será reservado ou residente.  
  
> [!NOTE]
>  Quando você aumenta o tamanho do conjunto de trabalho de um processo, você colocar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínimo ou máximo é muito grande, porque assim pode prejudicar o desempenho do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho máximo do conjunto de trabalho é inválido. Ele deve ser maior ou igual ao tamanho mínimo de conjunto de trabalho.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">As informações de conjunto de trabalho não puderam ser recuperadas do recurso do processo associado.  
  
 -ou-  
  
 O identificador de processo é zero, porque o processo não foi iniciado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.  
  
 -ou-  
  
 O processo foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho de conjunto de trabalho mínimo permitido em bytes para o processo associado.</summary>
        <value>O tamanho mínimo do conjunto de trabalho necessário na memória para o processo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e os arquivos de DLL. Como o conjunto de trabalho cresce, aumenta a demanda por memória.  
  
 Um processo tem tamanhos de conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema reserva uma quantidade de memória igual ao mínimo o tamanho do conjunto para o processo de trabalho. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo está ativo, mas nunca mantém mais do que o tamanho máximo.  
  
 O sistema define o conjunto de tamanhos de trabalho padrão. Você pode modificar esses tamanhos usando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membros. No entanto, definir esses valores não garante que a memória será reservado ou residente.  
  
> [!NOTE]
>  Quando você aumenta o tamanho do conjunto de trabalho de um processo, você colocar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínimo ou máximo é muito grande, porque assim pode prejudicar o desempenho do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho mínimo do conjunto de trabalho é inválido. Ele deve ser menor ou igual ao tamanho máximo do conjunto de trabalho.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">As informações de conjunto de trabalho não puderam ser recuperadas do recurso do processo associado.  
  
 -ou-  
  
 O identificador de processo é zero, porque o processo não foi iniciado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.  
  
 -ou-  
  
 O processo foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os módulos que foram carregados pelo processo associado.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Diagnostics.ProcessModule" /> que representa os módulos que foram carregados pelo processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. Um <xref:System.Diagnostics.ProcessModule> instância permite que você exiba informações sobre um módulo, incluindo o nome do módulo, nome de arquivo e detalhes de memória do módulo.  
  
 Um processo pode carregar vários módulos na memória. Por exemplo, arquivos de .exe que carregar arquivos. dll adicionais têm vários módulos.  
  
 Depois de iniciar o processo, essa coleção está vazia até que o sistema tenha carregado o processo. Se o processo tem uma janela principal, você pode chamar <xref:System.Diagnostics.Process.WaitForInputIdle%2A> antes de recuperar esta propriedade para garantir que a coleção está vazia quando você obtém a lista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Modules" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Modules" /> para o processo do sistema ou o tempo ocioso. Esses processos não têm módulos.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória não paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, que o sistema alocou para o processo associado que não pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória não paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória do sistema, em bytes, alocada para o processo associado que não pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual de memória não paginável do sistema usada pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. Alocações de memória não paginada permanecem na memória do sistema e não são transferidas para o arquivo de paginação de memória virtual.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes de Pool não-paginável** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aciona o evento <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A>é o método de API que gera o <xref:System.Diagnostics.Process.Exited> evento. Chamando <xref:System.Diagnostics.Process.OnExited%2A> faz com que o <xref:System.Diagnostics.Process.Exited> evento ocorra e é a única maneira de gerar o evento usando o <xref:System.Diagnostics.Process> componente. <xref:System.Diagnostics.Process.OnExited%2A>é usado principalmente ao derivar de classes do componente.  
  
 Como uma alternativa para <xref:System.Diagnostics.Process.OnExited%2A>, você pode escrever seu próprio manipulador de eventos. Crie seu próprio delegado do manipulador de eventos e seu próprio método de manipulação de eventos.  
  
> [!NOTE]
>  Se você estiver usando o ambiente do Visual Studio, um representante do manipulador de eventos (AddOnExited) e um método de manipulação de eventos (Process1_Exited) são criados para você quando você arrasta um <xref:System.Diagnostics.Process> componente em um formulário e clique duas vezes no ícone. O código que você cria para executar quando o <xref:System.Diagnostics.Process.Exited> evento ocorre é inserido no procedimento Process1_Exited. Você não precisa criar o <xref:System.Diagnostics.Process.OnExited%2A> membro, porque ele é implementado para você.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Diagnostics.Process.OnExited%2A> método em uma classe derivada.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre sempre que um aplicativo grava uma linha no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirecionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.OutputDataReceived> evento indica que o associado <xref:System.Diagnostics.Process> escreveu uma linha, terminando com um caractere de nova linha, para o redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
 O evento é ativado durante operações de leitura assíncronas <xref:System.Diagnostics.Process.StandardOutput%2A>. Para iniciar as operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos para o <xref:System.Diagnostics.Process.OutputDataReceived> eventos e chamadas <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Depois disso, o <xref:System.Diagnostics.Process.OutputDataReceived> sinais de evento sempre que o processo grava uma linha para o redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir, até que o processo será encerrado ou chame <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para garantir que o buffer de saída foi liberado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como executar operações de leitura assíncronas no redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo do `ipconfig` comando.  
  
 O exemplo cria um delegado de evento para o `OutputHandler` manipulador de eventos e o associa a <xref:System.Diagnostics.Process.OutputDataReceived> eventos. O manipulador de eventos recebe linhas de texto do redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, formata o texto e salva-o em uma cadeia de caracteres de saída que é mostrada posteriormente na janela do console de exemplo.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, alocada pelo processo associado que pode ser gravado para o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual da memória no arquivo de paginação de memória virtual usada pelo processo, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco. Para obter o tamanho de memória usada pelo sistema operacional para o processo, use o <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> propriedade.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes do arquivo de página** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas e, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginável do sistema, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, o sistema tem alocada para o processo associado que pode ser gravado para o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginável do sistema, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória do sistema, em bytes, alocada para o processo associado que pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo valor dessa propriedade representa o tamanho atual de memória paginável do sistema usada pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco. Para obter o tamanho da memória do aplicativo usado pelo processo, use o <xref:System.Diagnostics.Process.PagedMemorySize64%2A> propriedade.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes de Pool paginável** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória, em bytes, no arquivo de paginação de memória virtual usado pelo processo associado.</summary>
        <value>A quantidade máxima de memória, em bytes, alocada pelo processo associado foi possível gravar o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória, em bytes, no arquivo de paginação de memória virtual usado pelo processo associado.</summary>
        <value>A quantidade máxima de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado desde que ele foi iniciado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo valor dessa propriedade representa o tamanho máximo de memória no arquivo de paginação de memória virtual usada pelo processo desde que ele iniciado, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual em disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de Bytes de arquivo de paginação** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória virtual, em bytes, usada pelo processo associado.</summary>
        <value>A quantidade máxima de memória virtual, em bytes, que solicitou o processo associado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória virtual, em bytes, usada pelo processo associado.</summary>
        <value>A quantidade máxima de memória virtual, em bytes, alocada ao processo associado desde sua inicialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho máximo de memória virtual usada pelo processo desde que ele iniciado, em bytes. O sistema operacional mapeia o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou a páginas armazenadas no arquivo de paginação de memória virtual em disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de Bytes virtuais** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho máximo de trabalho conjunto para o processo associado, em bytes.</summary>
        <value>A quantidade máxima de memória física que o processo associado foi necessária uma só vez, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo módulos de processo e as bibliotecas do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória física, em bytes, usada pelo processo associado.</summary>
        <value>A quantidade máxima de memória física, em bytes, alocada para o processo associado desde sua inicialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho máximo do trabalho conjunto de memória usada pelo processo desde que ele iniciado, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções de módulos de processo e as bibliotecas do sistema.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de conjunto de trabalho** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a prioridade do processo associada deve temporariamente ser aumentada pelo sistema operacional quando o foco estiver na janela principal.</summary>
        <value>
          <see langword="true" /> se o aumento dinâmico da prioridade de processo deve ocorrer para um processo quando ele sair do estado de espera; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread é executado em um processo para o qual a classe de prioridade tem um dos valores de enumeração prioridade dinâmica (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), o sistema aumenta a prioridade do segmento temporariamente quando ele é retirado de um estado de espera. Essa ação impede que outros processos a interromper o processamento do thread atual. O <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> configuração afeta todos os threads existentes e qualquer threads criados posteriormente pelo processo. Para restaurar o comportamento normal, defina o <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propriedade `false`.  
  
> [!NOTE]
>  Aumentando demais a prioridade pode esgotar os recursos essenciais do sistema operacional e funções de rede, causando problemas com outras tarefas do sistema operacional.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível recuperar as informações de aumento de prioridade do recurso de processo associado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.  
  
 - ou -  
  
 O identificador de processo é zero. (O processo não foi iniciado.)</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a categoria geral de prioridade para o processo associado.</summary>
        <value>A categoria de prioridade do processo associado, do qual o <see cref="P:System.Diagnostics.Process.BasePriority" /> do processo é calculado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma classe de prioridade do processo abrange uma gama de níveis de prioridade de thread. Os threads com diferentes prioridades, que estão em execução no processo de executar em relação a classe de prioridade do processo. Win32 usa quatro classes de prioridade com sete níveis de prioridade básica por classe. Essas classes de prioridade de processo são capturados no <xref:System.Diagnostics.ProcessPriorityClass> enumeração, que permite que você defina a prioridade do processo <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Com base no tempo decorrida ou outras aumenta, o nível de prioridade base pode ser alterada pelo sistema operacional quando um processo precisa ser colocado à frente de outros usuários para acesso ao processador. Além disso, você pode definir o <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> para aumentar temporariamente o nível de prioridade de segmentos que foram executadas fora do estado de espera. A prioridade será redefinida quando o processo de volta para o estado de espera.  
  
 O <xref:System.Diagnostics.Process.BasePriority%2A> propriedade permite que você exiba a prioridade inicial que é atribuída a um processo. No entanto, porque ele é somente leitura, você não pode usar o <xref:System.Diagnostics.Process.BasePriority%2A> propriedade para definir a prioridade de um processo. Para alterar a prioridade, use o <xref:System.Diagnostics.Process.PriorityClass%2A> propriedade, que obtém ou define a categoria geral de prioridade para o processo.  
  
 A classe de prioridade não pode ser exibida usando o Monitor do sistema. A tabela a seguir mostra a relação entre o <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|Classe de prioridade|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">As informações de prioridade do processo não puderam ser definidas nem recuperadas do recurso do processo associado.  
  
 -ou-  
  
 O identificador de processo é zero. (O processo não foi iniciado.)</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.PriorityClass" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Você definiu o <see cref="P:System.Diagnostics.Process.PriorityClass" /> como <see langword="AboveNormal" /> ou <see langword="BelowNormal" /> ao usar o Windows 98 ou Windows Millennium Edition (Windows Me). Essas plataformas não dão suporte a esses valores para a classe de prioridade.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">A classe de prioridade não pode ser definida porque ela não usa um valor válido, conforme definido na enumeração <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória privada, em bytes, alocada ao processo associado.</summary>
        <value>O número de bytes alocados pelo processo associado que não podem ser compartilhados com outros processos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória privada, em bytes, alocada ao processo associado.</summary>
        <value>A quantidade de memória, em bytes, alocada ao processo associado que não pode ser compartilhada com outros processos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual da memória usada pelo processo, em bytes, que não pode ser compartilhada com outros processos.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes particulares** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo de processador privilegiado para esse processo.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica a quantidade de tempo que o processo gastou executando o código no núcleo do sistema operacional.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do processo.</summary>
        <value>O nome que o sistema usa para identificar o processo para o usuário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.ProcessName%2A> propriedade contém um nome de arquivo executável, como o Outlook, que não inclui a extensão .exe ou o caminho. É útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável.  
  
> [!NOTE]
>  Em [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] sistemas operacionais, o <xref:System.Diagnostics.Process.ProcessName%2A> propriedade poderá ser truncada a 15 caracteres, se as informações do módulo de processo não podem ser obtidas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passando um nome de arquivo executável, para recuperar uma matriz que contém todas as instâncias em execução no computador especificado. Você pode usar essa matriz, por exemplo, para fechar todas as instâncias em execução do arquivo executável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não tem um identificador ou nenhum processo está associado ao <see cref="T:System.Diagnostics.Process" />.  
  
 -ou-  
  
 O processo associado foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou Windows Millennium Edition (Windows Me); defina <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">O processo não está neste computador.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define os processadores nos quais os threads desse processo podem ser agendados para execução.</summary>
        <value>Um bitmask que representa os processadores nos quais os threads do processo associado podem ser executados. O padrão depende do número de processadores no computador. O valor padrão é 2 <sup> n </sup> -1, onde n é o número de processadores.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No Windows 2000 e posterior, um thread em um processo pode migrar do processador, com cada migração recarregando o cache do processador. Sob cargas de sistema pesadas, especificar qual processador deve executar um thread específico pode melhorar o desempenho reduzindo o número de vezes que o cache de processador é recarregado. A associação entre um processador e um thread é chamada a afinidade do processador.  
  
 Cada processador é representado como um pouco. Bit 0 é o processador de um, o bit 1 é o processador de dois e assim por diante. Se você definir um bit para o valor 1, o processador correspondente é selecionado para atribuição de thread. Quando você define o <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor como zero, o sistema operacional do agendamento de conjunto de algoritmos a afinidade do thread. Quando o <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor é definido como qualquer valor diferente de zero, o valor será interpretado como um bitmask que especifica esses processadores qualificados para seleção.  
  
 A tabela a seguir mostra uma seleção de <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valores para um sistema com oito processadores.  
  
|Máscara de bits|Valor binário|Processadores qualificados|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 e 2|  
|0x0007|00000000 00000111|1, 2 e 3|  
|0x0009|00000000 00001001|1 e 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 e 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">
          As informações de <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> não puderam ser definidas nem recuperadas do recurso do processo associado.  
  
 -ou-  
  
 O identificador de processo é zero. (O processo não foi iniciado.)</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não estava disponível.  
  
 -ou-  
  
 O processo foi encerrado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarta informações sobre o processo associado que foi armazenado em cache dentro do componente do processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de <xref:System.Diagnostics.Process.Refresh%2A> é chamado, a primeira solicitação para obter informações sobre cada propriedade faz com que o componente do processo obter um novo valor do processo associado.  
  
 Quando um <xref:System.Diagnostics.Process> componente está associado um recurso de processo, os valores de propriedade de <xref:System.Diagnostics.Process> imediatamente são preenchidas de acordo com o status do processo associado. Se as informações sobre o processo associado for alterado posteriormente, essas alterações não são refletidas no <xref:System.Diagnostics.Process> do componente de valores em cache. O <xref:System.Diagnostics.Process> componente é um instantâneo do recurso de processo no momento em que eles estão associados. Para exibir os valores atuais para o processo associado, chame o <xref:System.Diagnostics.Process.Refresh%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Em seguida, recupera o uso de memória física do processo associado em 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo foi encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a interface do usuário do processo está respondendo.</summary>
        <value>
          <see langword="true" /> se a interface do usuário do processo associado estiver respondendo ao sistema; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um processo tem uma interface de usuário, o <xref:System.Diagnostics.Process.Responding%2A> propriedade entra em contato com a interface do usuário para determinar se o processo está respondendo à entrada do usuário. Se a interface não responder imediatamente, o <xref:System.Diagnostics.Process.Responding%2A> propriedade retorna `false`. Use essa propriedade para determinar se a interface do processo associado parou de responder.  
  
 Se o processo não tem um <xref:System.Diagnostics.Process.MainWindowHandle%2A>, essa propriedade retornará `true`.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Responding" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador nativo para esse processo.</summary>
        <value>O identificador nativo para esse processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador só estará disponível se o componente de discagem iniciou o processo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de sessão dos Serviços de Terminal para o processo associado.</summary>
        <value>O identificador de sessão dos Serviços de Terminal para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.SessionId%2A> propriedade identifica a sessão na qual o aplicativo está sendo executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Não há nenhuma sessão associada a este processo.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum processo associado a esse identificador de sessão.  
  
 -ou-  
  
 O processo associado não está neste computador.</exception>
        <exception cref="T:System.PlatformNotSupportedException">O <see cref="P:System.Diagnostics.Process.SessionId" /> propriedade não é suportada no Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um fluxo usado para ler a saída de erro do aplicativo.</summary>
        <value>Um <see cref="T:System.IO.StreamReader" /> que pode ser usado para ler o fluxo de erro padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Diagnostics.Process> escreve o texto para seu fluxo de erro padrão que o texto é exibido normalmente no console. Redirecionando o <xref:System.Diagnostics.Process.StandardError%2A> fluxo, você pode manipular ou suprimir a saída de erro de um processo. Por exemplo, o texto de filtro, formatá-los de maneira diferente ou escrever a saída para o console e um arquivo de log designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardError%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> para `true`. Caso contrário, ler o <xref:System.Diagnostics.Process.StandardError%2A> fluxo lança uma exceção.  
  
 O redirecionamento <xref:System.Diagnostics.Process.StandardError%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída de erro do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardError%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardError%2A> fluxo. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Síncrona ler operações apresentam uma dependência entre o chamador leem o <xref:System.Diagnostics.Process.StandardError%2A> fluxo e o filho processam gravação nesse fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê o fluxo redirecionado de um processo filho, é dependente de filho. O chamador espera a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente de pai. O processo filho esperas a próxima operação de gravação até que o pai lê o fluxo total ou fecha o fluxo. A condição de deadlock ocorre quando o chamador e o processo filho Aguarde uns dos outros para concluir uma operação, e não pode continuar. Você pode evitar deadlocks avaliando as dependências entre o chamador e o processo filho.  
  
 O seguinte código c#, por exemplo, mostra como ler de um fluxo redirecionado e aguarde até que a saída do processo filho.  
  
```  
// Start the child process.  
 Process p = new Process();  
 // Redirect the error stream of the child process.  
 p.StartInfo.UseShellExecute = false;  
 p.StartInfo.RedirectStandardError = true;  
 p.StartInfo.FileName = "Write500Lines.exe";  
 p.Start();  
 // Do not wait for the child process to exit before  
 // reading to the end of its redirected error stream.  
 // p.WaitForExit();  
 // Read the error stream first and then wait.  
 string error = p.StandardError.ReadToEnd();  
 p.WaitForExit();  
```  
  
 O exemplo de código evita uma condição de deadlock chamando `p.StandardError.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode surgir se o pai processar chamadas `p.WaitForExit` antes de `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve esperar indefinidamente para o saída do processo filho. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Há um problema semelhante ao ler todo o texto de fluxos de erro padrão e a saída padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.  
  
```  
// Do not perform a synchronous read to the end of both   
// redirected streams.  
// string output = p.StandardOutput.ReadToEnd();  
// string error = p.StandardError.ReadToEnd();  
// p.WaitForExit();  
// Use asynchronous read operations on at least one of the streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 O exemplo de código evita a condição de deadlock pela execução assíncrona de operações de leitura de <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve esperar indefinidamente para o processo filho fechar seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Você pode usar operações de leitura assíncronas para evitar essas dependências e seu possíveis de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardError%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir usa o `net use` comando junto com um usuário forneceu o argumento para mapear um recurso de rede. Em seguida, ele lê o fluxo de erro padrão do comando net e grava no console.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> não foi definido para o redirecionamento; verifique se <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> foi definido como <see langword="true" /> e se <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> foi definido como <see langword="false" />.  
  
 \- ou -  
  
 O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> foi aberto para operações de leitura assíncronas com <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um fluxo usado para gravar a entrada do aplicativo.</summary>
        <value>Um <see cref="T:System.IO.StreamWriter" /> que pode ser usado para gravar o fluxo de entrada padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Diagnostics.Process> pode ler o texto de entrada de seu fluxo de entrada padrão, normalmente o teclado. Redirecionando o <xref:System.Diagnostics.Process.StandardInput%2A> fluxo, programaticamente, você pode especificar a entrada. Por exemplo, em vez de usar a entrada do teclado, você pode fornecer o texto do conteúdo de um arquivo designado ou saída de outro aplicativo.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardInput%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> para `true`. Caso contrário, gravar o <xref:System.Diagnostics.Process.StandardInput%2A> fluxo lança uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como redirecionar o <xref:System.Diagnostics.Process.StandardInput%2A> fluxo de um processo. O exemplo inicia o `sort` com entrada redirecionada. Ele, em seguida, solicita ao usuário para texto e passa para o `sort` processo por meio do redirecionamento <xref:System.Diagnostics.Process.StandardInput%2A> fluxo. O `sort` resultados são exibidos para o usuário no console.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardInput" /> não foi definido porque <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> está definido como <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um fluxo usado para ler a saída textual do aplicativo.</summary>
        <value>Um <see cref="T:System.IO.StreamReader" /> que pode ser usado para ler o fluxo de saída padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Diagnostics.Process> escreve o texto para seu fluxo padrão, que o texto é exibido normalmente no console. Redirecionando o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, você pode manipular ou suprimir a saída de um processo. Por exemplo, o texto de filtro, formatá-los de maneira diferente ou escrever a saída para o console e um arquivo de log designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardOutput%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> para `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> para `true`. Caso contrário, ler o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo lança uma exceção.  
  
 O redirecionamento <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída do processo. Esses síncrona ler operações não concluída até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo ou fecha o fluxo.  
  
 Por outro lado, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> inicia assíncrona operações de leitura no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Síncrona ler operações apresentam uma dependência entre o chamador leem o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo e o filho processam gravação nesse fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê o fluxo redirecionado de um processo filho, é dependente de filho. O chamador espera a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente de pai. O processo filho esperas a próxima operação de gravação até que o pai lê o fluxo total ou fecha o fluxo. A condição de deadlock ocorre quando o chamador e o processo filho Aguarde uns dos outros para concluir uma operação, e não pode continuar. Você pode evitar deadlocks avaliando as dependências entre o chamador e o processo filho.  
  
 O seguinte código c#, por exemplo, mostra como ler de um fluxo redirecionado e aguarde até que a saída do processo filho.  
  
```  
Process p = new Process();  
p.StartInfo.UseShellExecute = false;  
p.StartInfo.RedirectStandardOutput = true;  
p.StartInfo.FileName = "Write500Lines.exe";  
p.Start();  
  
// To avoid deadlocks, always read the output stream first and then wait.  
string output = p.StandardOutput.ReadToEnd();  
p.WaitForExit();  
```  
  
 O exemplo de código evita uma condição de deadlock chamando `p.StandardOutput.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode surgir se o pai processar chamadas `p.WaitForExit` antes de `p.StandardOutput.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve esperar indefinidamente para o saída do processo filho. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo.  
  
 Há um problema semelhante ao ler todo o texto de fluxos de erro padrão e a saída padrão. O seguinte código c#, por exemplo, executa uma operação de leitura em ambos os fluxos.  
  
```  
// To avoid deadlocks, use asynchronous read operations on at least one of the streams.  
// Do not perform a synchronous read to the end of both redirected streams.  
p.BeginOutputReadLine();  
string error = p.StandardError.ReadToEnd();  
p.WaitForExit();  
```  
  
 O exemplo de código evita a condição de deadlock pela execução assíncrona de operações de leitura de <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve esperar indefinidamente para o processo filho fechar seu <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo. O processo filho seria espere indefinidamente pai leiam completa <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
 Você pode usar operações de leitura assíncronas para evitar essas dependências e seu possíveis de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.  
  
> [!NOTE]
>  Não é possível misturar operações de leitura síncronas e assíncronas em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as mais leitura operações no fluxo devem estar no mesmo modo. Por exemplo, não execute <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> no <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes de modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> fluxo.  
  
   
  
## Examples  
 O exemplo a seguir executa o comando ipconfig.exe e redireciona a saída padrão para a janela do console de exemplo.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> não foi definido para o redirecionamento; verifique se <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> foi definido como <see langword="true" /> e se <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> foi definido como <see langword="false" />.  
  
 \- ou -  
  
 O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> foi aberto para operações de leitura assíncronas com <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia (ou reutiliza) o recurso do processo que é especificado pela propriedade <see cref="P:System.Diagnostics.Process.StartInfo" /> desse componente <see cref="T:System.Diagnostics.Process" /> e o associa ao componente.</summary>
        <returns>
          <see langword="true" /> se um recurso de processo for iniciado, <see langword="false" /> se nenhum novo recurso de processo for iniciado (por exemplo, se um processo existente for reutilizado).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso de processo e associá-lo a atual <xref:System.Diagnostics.Process> componente. O valor de retorno `true` indica que um novo recurso do processo foi iniciado. Se o recurso de processo especificado pelo <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade já está em execução no computador, nenhum recurso de processo adicional será iniciado. Em vez disso, a execução processar recursos é reutilizado e `false` é retornado.  
  
 Você pode iniciar um aplicativo ClickOnce, especificando o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
> [!NOTE]
>  Se você estiver usando o Visual Studio, essa sobrecarga do <xref:System.Diagnostics.Process.Start%2A> método é aquele que você inserir no seu código depois que você arrasta um <xref:System.Diagnostics.Process> componente no designer. Use o `Properties` janela para expandir o `StartInfo` categoria e gravar o valor apropriado para o `FileName` propriedade. As alterações serão exibidas no formulário de `InitializeComponent` procedimento.  
  
 Esta sobrecarga do <xref:System.Diagnostics.Process.Start%2A> não é um `static` método. Você deve chamá-lo de uma instância do <xref:System.Diagnostics.Process> classe. Antes de chamar <xref:System.Diagnostics.Process.Start%2A>, você deve primeiro especificar <xref:System.Diagnostics.Process.StartInfo%2A> informações de propriedade para este <xref:System.Diagnostics.Process> instância, porque essa informação é usada para determinar o recurso de processo para iniciar.  
  
 As outras sobrecargas do <xref:System.Diagnostics.Process.Start%2A> método são `static` membros. Você não precisa criar uma instância do <xref:System.Diagnostics.Process> componente antes de chamar essas sobrecargas do método. Em vez disso, você pode chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> de classe em si e um novo <xref:System.Diagnostics.Process> componente é criado se o processo foi iniciado. Ou, `null` será retornado se um processo foi reutilizado. O recurso de processo é associado automaticamente com o novo <xref:System.Diagnostics.Process> componente que é retornado pelo <xref:System.Diagnostics.Process.Start%2A> método.  
  
 O <xref:System.Diagnostics.Process.StartInfo%2A> membros podem ser usados para duplicar a funcionalidade do `Run` caixa de diálogo do Windows `Start` menu. Qualquer coisa que podem ser digitados em uma linha de comando pode ser iniciada, definindo os valores apropriados no <xref:System.Diagnostics.Process.StartInfo%2A> propriedade. A única <xref:System.Diagnostics.Process.StartInfo%2A> é de propriedade deve ser definida a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. O <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não tem que ser um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada um aplicativo que é instalado no sistema. Por exemplo, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter uma extensão. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word.  
  
 Na linha de comando, você pode especificar ações a serem tomadas para determinados tipos de arquivos. Por exemplo, você pode imprimir documentos ou editar arquivos de texto. Especifique essas ações usando o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> membro o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade. Para outros tipos de arquivos, você pode especificar argumentos de linha de comando ao iniciar o arquivo a partir de `Run` caixa de diálogo. Por exemplo, você pode passar uma URL como um argumento, se você especificar o navegador como o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Esses argumentos podem ser especificados no <xref:System.Diagnostics.Process.StartInfo%2A> da propriedade <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membro.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância do <xref:System.Diagnostics.Process> classe para iniciar um processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não foi especificado nenhum nome de arquivo no <see cref="P:System.Diagnostics.Process.StartInfo" /> do componente <see cref="T:System.Diagnostics.Process" />.
 - ou - <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> membro o <see cref="P:System.Diagnostics.Process.StartInfo" /> é de propriedade <see langword="true" /> enquanto <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />, ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> é <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Erro ao abrir o arquivo associado.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método não tem suportado em sistemas operacionais sem suporte do shell, como o Nano Server (somente para o .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">O <see cref="T:System.Diagnostics.ProcessStartInfo" /> que contém as informações usadas para iniciar o processo, incluindo o nome do arquivo e quaisquer argumentos de linha de comando.</param>
        <summary>Inicia o recurso de processo especificado pelo parâmetro que contém informações de início do processo (por exemplo, o nome do arquivo do processo a ser iniciado) e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso do processo especificando um <xref:System.Diagnostics.ProcessStartInfo> instância. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. Usando essa sobrecarga com um <xref:System.Diagnostics.ProcessStartInfo> parâmetro é uma alternativa às etapas de criação de um novo explícitas <xref:System.Diagnostics.Process> instância, definindo seu <xref:System.Diagnostics.Process.StartInfo%2A> propriedades e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Usando um <xref:System.Diagnostics.ProcessStartInfo> instância como o parâmetro permite que você chame <xref:System.Diagnostics.Process.Start%2A> com mais controle sobre o que é passado para a chamada para iniciar o processo. Se você precisar passar um nome de arquivo ou um nome de arquivo e os argumentos, não é necessário criar um novo <xref:System.Diagnostics.ProcessStartInfo> instância, embora o que é uma opção. A única <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> é de propriedade deve ser definida a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. O <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisam para representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada um aplicativo que é instalado no sistema. Por exemplo, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter uma extensão. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word.  
  
 Você pode iniciar um aplicativo ClickOnce, especificando o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Se o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> instância são definidas, não gerenciado `CreateProcessWithLogonW` função é chamada, que inicia o processo de uma nova janela, mesmo se o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> é o valor da propriedade `true` ou o <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> é o valor da propriedade <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Se o <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> é de propriedade `null`, o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> propriedade deve estar no formato UPN, *usuário*@*DNS_domain_name*.   
  
 Ao contrário de outras sobrecargas, a sobrecarga do <xref:System.Diagnostics.Process.Start%2A> que não tenha parâmetros não é um `static` membro. Use essa sobrecarga quando você já tiver criado um <xref:System.Diagnostics.Process> instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-lo a existente <xref:System.Diagnostics.Process> instância. Use um do `static` sobrecargas quando você deseja criar um novo <xref:System.Diagnostics.Process> componente, em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique as informações de início para o recurso de processo usando um <xref:System.Diagnostics.ProcessStartInfo> instância.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` no `startInfo` parâmetro, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele algumas outras instâncias do Internet Explorer é iniciado e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada durante a navegação até um site específico.  
  
 Para obter exemplos adicionais de outros usos desse método, consulte as propriedades individuais do <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nenhum nome de arquivo foi especificado na propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> do parâmetro <paramref name="startInfo" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do parâmetro <paramref name="startInfo" /> é <see langword="true" /> e a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> também é <see langword="true" />.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do parâmetro <paramref name="startInfo" /> é <see langword="true" /> e a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> não é <see langword="null" /> ou está vazia ou a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="startInfo" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado na propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> do parâmetro <paramref name="startInfo" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.  
  
 -ou-  
  
 A soma do comprimento dos argumentos e do comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada a essa exceção pode ser uma das seguintes: “A área de dados transferida para uma chamada do sistema é muito pequena”. ou “O acesso foi negado”.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método não tem suportado em sistemas operacionais sem suporte do shell, como o Nano Server (somente para o .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo ou documento a ser executado no processo.</param>
        <summary>Inicia um recurso de processo especificando o nome de um arquivo de aplicativo ou documento e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso do processo especificando seu nome de arquivo. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Você pode iniciar um aplicativo ClickOnce, definindo o `fileName` parâmetro para o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Iniciar um processo especificando seu nome de arquivo é semelhante ao digitar as informações de `Run` caixa de diálogo do Windows `Start` menu. Portanto, o nome do arquivo não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada com um aplicativo instalado no sistema. Por exemplo o nome do arquivo pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, da mesma forma que o `Run` caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad".  
  
 Essa sobrecarga não permite que os argumentos de linha de comando para o processo. Se você precisar especificar um ou mais argumentos de linha de comando para o processo, use o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> ou <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecargas.  
  
 Ao contrário de outras sobrecargas, a sobrecarga do <xref:System.Diagnostics.Process.Start%2A> que não tenha parâmetros não é um `static` membro. Use essa sobrecarga quando você já tiver criado um <xref:System.Diagnostics.Process> instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-lo a existente <xref:System.Diagnostics.Process> instância. Use um do `static` sobrecargas quando você deseja criar um novo <xref:System.Diagnostics.Process> componente, em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique o nome do arquivo do recurso para iniciar o processo.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele algumas outras instâncias do Internet Explorer é iniciado e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada durante a navegação até um site específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">A variável de ambiente PATH tem uma cadeia de caracteres que contém aspas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo a ser executado no processo.</param>
        <param name="arguments">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <summary>Inicia um recurso de processo especificando o nome de um aplicativo e um conjunto de argumentos de linha de comando e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso do processo especificando seu nome de arquivo e argumentos de linha de comando. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membros do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Iniciar um processo, especificando seu nome de arquivo e argumentos é semelhante ao digitar o nome de arquivo e argumentos de linha de comando do `Run` caixa de diálogo do Windows `Start` menu. Portanto, o nome do arquivo não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada com um aplicativo instalado no sistema. Por exemplo o nome do arquivo pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, da mesma forma que o `Run` caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`. Se o `fileName` parâmetro representa um arquivo de comando (. cmd), o `arguments` parâmetro deve incluir um "`/c`"ou"`/k`" argumento para especificar se a janela de comando sai ou permanece após a conclusão.  
  
 Ao contrário de outras sobrecargas, a sobrecarga do <xref:System.Diagnostics.Process.Start%2A> que não tenha parâmetros não é um `static` membro. Use essa sobrecarga quando você já tiver criado um <xref:System.Diagnostics.Process> instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-lo a existente <xref:System.Diagnostics.Process> instância. Use um do `static` sobrecargas quando você deseja criar um novo <xref:System.Diagnostics.Process> componente, em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique o nome do arquivo do recurso de processo para iniciar e argumentos de linha de comando para passar.  
  
 Se você tiver uma variável de caminho declarada em seu sistema usando aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não estiver em seu caminho, e adicioná-lo usando aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente um processo `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de página e o servidor Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou um controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto do navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre os estados de apartment em threads gerenciados aqui é necessária. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` de estado ou coloque no `MTA` estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não seja `unknown`. Se o estado não for definido explicitamente, quando o aplicativo encontra tal método, o padrão é `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja lançada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele algumas outras instâncias do Internet Explorer é iniciado e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada durante a navegação até um site específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O parâmetro <paramref name="fileName" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.  
  
 -ou-  
  
 A soma do comprimento dos argumentos e do comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada a essa exceção pode ser uma das seguintes: “A área de dados transferida para uma chamada do sistema é muito pequena”. ou “O acesso foi negado”.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">A variável de ambiente PATH tem uma cadeia de caracteres que contém aspas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo a ser executado no processo.</param>
        <param name="userName">O nome de usuário a ser usado ao iniciar o processo.</param>
        <param name="password">Um <see cref="T:System.Security.SecureString" /> que contém a senha a ser usada ao iniciar o processo.</param>
        <param name="domain">O domínio a ser usado ao iniciar o processo.</param>
        <summary>Inicia um recurso de processo, especificando o nome de um aplicativo, um nome de usuário, uma senha e um domínio e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um novo processo e o thread principal especificando o nome de arquivo, nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).  
  
> [!NOTE]
>  Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um identificador de recurso uniforme (URI), não uma letra de unidade vinculado.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  O nome do arquivo deve representar um arquivo executável no <xref:System.Diagnostics.Process.Start%2A> sobrecargas que têm `userName`, `password`, e `domain` parâmetros.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso dessa sobrecarga para iniciar um arquivo executável e também demonstra o lançamento de um <xref:System.ComponentModel.Win32Exception> quando é feita uma tentativa para iniciar um aplicativo associado a um arquivo não executável.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nenhum nome de arquivo foi especificado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Erro ao abrir o arquivo associado.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método não tem suportado no Linux ou macOS (somente no .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
        <Parameter Name="userName" Type="System.String" />
        <Parameter Name="password" Type="System.Security.SecureString" />
        <Parameter Name="domain" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo a ser executado no processo.</param>
        <param name="arguments">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <param name="userName">O nome de usuário a ser usado ao iniciar o processo.</param>
        <param name="password">Um <see cref="T:System.Security.SecureString" /> que contém a senha a ser usada ao iniciar o processo.</param>
        <param name="domain">O domínio a ser usado ao iniciar o processo.</param>
        <summary>Inicia um recurso de processo, especificando o nome de um aplicativo, um conjunto de argumentos de linha de comando, um nome de usuário, uma senha e um domínio e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um novo processo e o thread principal especificando o nome do arquivo, argumentos de linha de comando, o nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).  
  
> [!NOTE]
>  Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um identificador de recurso uniforme (URI), não uma letra de unidade vinculado.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite iniciar um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para a <xref:System.Diagnostics.Process> instância.  
  
 Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  O nome do arquivo deve representar um arquivo executável no <xref:System.Diagnostics.Process.Start%2A> sobrecargas que têm `userName`, `password`, e `domain` parâmetros.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou você corre o risco de perda de recursos do sistema. Fechar processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nenhum nome de arquivo foi especificado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.  
  
 -ou-  
  
 A soma do tamanho dos argumentos e o tamanho do caminho completo para o arquivo associado excede 2.080. A mensagem de erro associada a essa exceção pode ser uma das seguintes: “A área de dados transferida para uma chamada do sistema é muito pequena”. ou “O acesso foi negado”.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Método não tem suportado no Linux ou macOS (somente no .NET Core).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as propriedades a serem passadas para o método <see cref="M:System.Diagnostics.Process.Start" /> do <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>O <see cref="T:System.Diagnostics.ProcessStartInfo" /> que representa os dados com os quais o processo será iniciado. Esses argumentos incluem o nome do documento ou arquivo executável usado para iniciar o processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A>representa o conjunto de parâmetros a serem usados para iniciar um processo. Quando <xref:System.Diagnostics.Process.Start%2A> é chamado, o <xref:System.Diagnostics.Process.StartInfo%2A> é usado para especificar o processo para iniciar. Somente necessário <xref:System.Diagnostics.Process.StartInfo%2A> é membro para definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. Iniciar um processo, especificando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade assemelha-se de digitar as informações de **executar** caixa de diálogo do Windows **iniciar** menu. Portanto, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisam para representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada com um aplicativo instalado no sistema. Por exemplo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> pode ter uma extensão. txt se associou arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, da mesma forma que o **executar** caixa de diálogo pode aceitar um nome de arquivo executável, com ou sem a extensão .exe, a extensão .exe é opcional no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade como "Notepad.exe" ou "Notepad".  
  
 Você pode iniciar um aplicativo ClickOnce, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade para o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Se o nome do arquivo envolve um arquivo não executável, como um arquivo. doc, você pode incluir um verbo especificando a ação que será executada no arquivo. Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> para "Print" de um arquivo na extensão. doc. O nome de arquivo especificado no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não é necessário ter uma extensão, se você inserir manualmente um valor para o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> propriedade. No entanto, se você usar o <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> para determinar quais verbos disponíveis, você deve incluir a extensão.  
  
 Você pode alterar os parâmetros especificados o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade até o momento em que você chamar o <xref:System.Diagnostics.Process.Start%2A> método sobre o processo. Depois de iniciar o processo, alterando o <xref:System.Diagnostics.Process.StartInfo%2A> valores não afetam ou reiniciar o processo associado. Se você chamar o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> método com o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propriedades definidas, não gerenciado `CreateProcessWithLogonW` função é chamada, que inicia o processo de uma nova janela, mesmo se o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> é o valor da propriedade `true` ou <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> é o valor da propriedade <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Se você não usou o <xref:System.Diagnostics.Process.Start%2A> método para iniciar um processo, o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade não reflete os parâmetros usados para iniciar o processo. Por exemplo, se você usar <xref:System.Diagnostics.Process.GetProcesses%2A> para obter uma matriz de processos em execução no computador, o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade de cada <xref:System.Diagnostics.Process> não contém o nome do arquivo original ou os argumentos usados para iniciar o processo.  
  
 Quando o processo é iniciado, o nome do arquivo é o arquivo que preenche (somente leitura) <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Se você quiser recuperar o arquivo executável que está associado com o processo depois que o processo foi iniciado, use o <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Se você deseja definir o arquivo executável de um <xref:System.Diagnostics.Process> instância para que um processo associado não foi iniciado, use o <xref:System.Diagnostics.Process.StartInfo%2A> da propriedade <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Porque os membros do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade são argumentos que são passados para o <xref:System.Diagnostics.Process.Start%2A> método de um processo, alterando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade depois de iniciado o processo associado não será redefinido o <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Essas propriedades são usadas apenas para inicializar o processo associado.  
  
   
  
## Examples  
 O exemplo a seguir preenche um <xref:System.Diagnostics.Process.StartInfo%2A> com o arquivo para executar, a ação executada nele e se ele deve exibe uma interface do usuário. Para obter exemplos adicionais, consulte as páginas de referência para propriedades da <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor que especifica o <see cref="P:System.Diagnostics.Process.StartInfo" /> é <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a hora em que o processo associado foi iniciado.</summary>
        <value>Um objeto que indica quando o processo é iniciado. Uma exceção é lançada se o processo não está em execução.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.StartTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo foi encerrado.  
  
 -ou-  
  
 O processo não foi iniciado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro na chamada para a função do Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de um evento de encerramento de um processo.</summary>
        <value>O <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de um evento <see cref="E:System.Diagnostics.Process.Exited" /> no processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> é `null`, métodos que manipulam o <xref:System.Diagnostics.Process.Exited> eventos são chamados em um thread do pool de threads do sistema. Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Quando o <xref:System.Diagnostics.Process.Exited> evento é manipulado por um componente de Windows Forms visual, como um <xref:System.Windows.Forms.Button>, acessar o componente através do pool de threads de sistema pode não funcionar, ou pode resultar em uma exceção. Evitar isso definindo <xref:System.Diagnostics.Process.SynchronizingObject%2A> para um componente de Windows Forms, que faz com que os métodos de manipulação de <xref:System.Diagnostics.Process.Exited> evento seja chamado no mesmo thread em que o componente foi criado.  
  
 Se o <xref:System.Diagnostics.Process> é usado dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] em um designer de formulários do Windows, <xref:System.Diagnostics.Process.SynchronizingObject%2A> é definida automaticamente como o controle que contém o <xref:System.Diagnostics.Process>. Por exemplo, se você colocar um <xref:System.Diagnostics.Process> em um designer para `Form1` (que herda de <xref:System.Windows.Forms.Form>) o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade <xref:System.Diagnostics.Process> é definido como a instância do `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Normalmente, essa propriedade é definida quando o componente é colocado dentro de um controle ou formulário, porque esses componentes estão associados a um segmento específico.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o conjunto de threads que estão em execução no processo associado.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Diagnostics.ProcessThread" /> que representa o sistema operacional de threads em execução no processo associado no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread pode executar código em um processo. Cada processo é iniciado com um único thread, o thread principal. Qualquer thread pode criar threads adicionais. Threads em um processo compartilham o espaço de endereço do processo.  
  
 Use <xref:System.Diagnostics.ProcessThread> para obter todos os threads associados ao processo atual. O thread principal não é necessariamente no índice zero na matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">O processo não tem um <see cref="P:System.Diagnostics.Process.Id" /> ou nenhum processo está associado à instância <see cref="T:System.Diagnostics.Process" />.  
  
 -ou-  
  
 O processo associado foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formata o nome do processo como uma cadeia de caracteres, combinada com o tipo de componente pai, se aplicável.</summary>
        <returns>O <see cref="P:System.Diagnostics.Process.ProcessName" />, combinado com o valor retornado <see cref="M:System.Object.ToString" /> do componente base.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="M:System.Diagnostics.Process.ToString" />Não há suporte no Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo de processador total para esse processo.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica o tempo que o processo associado passou utilizando a CPU. Esse valor é a soma de <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> e <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo de processador do usuário para esse processo.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica a quantidade de tempo que o processo associado gastou executando o código dentro da porção de aplicativo do processo (e não dentro do núcleo do sistema operacional).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho da memória virtual do processo, em bytes.</summary>
        <value>A quantidade de memória virtual, em bytes, que o processo associado solicitou.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória virtual, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória virtual, em bytes, alocada para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual de memória virtual usada pelo processo, em bytes. O sistema operacional mapeia o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou a páginas armazenadas no arquivo de paginação de memória virtual em disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes virtuais** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instrui o componente <see cref="T:System.Diagnostics.Process" /> a esperar indefinidamente que o processo associado seja encerrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit>faz com que o thread atual Aguarde até que encerra o processo associado.  Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o <xref:System.Diagnostics.Process.Exited> evento.  
  
 Esse método instrui o <xref:System.Diagnostics.Process> componente aguardar um período infinito para os processo e manipuladores de eventos sair. Isso pode causar um aplicativo pare de responder. Por exemplo, se você chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A> para um processo que tenha uma interface de usuário, a solicitação para o sistema operacional para encerrar o processo associado pode não ser manipulada se o processo é gravado nunca insira seu loop de mensagem.  
  
> [!NOTE]
>  No [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versões anteriores, o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga aguardou <xref:System.Int32.MaxValue> milissegundos (aproximadamente 24 dias), não indefinidamente. Além disso, as versões anteriores não aguardou os manipuladores de eventos sair se completa <xref:System.Int32.MaxValue> tempo foi atingido.  
  
 Essa sobrecarga garante que todo o processamento foi concluída, incluindo a manipulação de eventos assíncronos para a saída redirecionada do padrão. Você deve usar essa sobrecarga após uma chamada para o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono de sobrecargas.  
  
 Quando um processo associado existe (ou seja, quando está desligado, o sistema operacional por meio de um encerramento normal ou anormal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que chamaram <xref:System.Diagnostics.Process.WaitForExit>. O <xref:System.Diagnostics.Process> componente pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A> ao processo encerrado.  
  
 Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A> propriedade do componente não aponta para um recurso existente do processo. Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerradas processos que não foram liberados por <xref:System.Diagnostics.Process> componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória até que o <xref:System.Diagnostics.Process> componente especificamente libera os recursos. Por esse motivo, sempre que você chamar <xref:System.Diagnostics.Process.Start%2A> para um <xref:System.Diagnostics.Process> instância, chame <xref:System.Diagnostics.Process.Close%2A> quando o processo associado foi finalizado e você não precisar mais qualquer informação administrativa sobre ele. <xref:System.Diagnostics.Process.Close%2A>libera a memória alocada para o processo encerrado.  
  
   
  
## Examples  
 Consulte a seção comentários a <xref:System.Diagnostics.Process.StandardError%2A> página de propriedades de referência.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível acessar a configuração de espera.</exception>
        <exception cref="T:System.SystemException">Nenhum processo <see cref="P:System.Diagnostics.Process.Id" /> foi definido e não existe um <see cref="P:System.Diagnostics.Process.Handle" /> do qual a propriedade <see cref="P:System.Diagnostics.Process.Id" /> possa ser determinada.  
  
 -ou-  
  
 Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.  
  
 -ou-  
  
 Você está tentando chamar <see cref="M:System.Diagnostics.Process.WaitForExit" /> para um processo em execução em um computador remoto. Esse método está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">O tempo, em milissegundos, a aguardar até que o processo seja encerrado. O máximo é o maior valor possível de um inteiro de 32 bits, que representa o infinito para o sistema operacional.</param>
        <summary>Instrui o componente <see cref="T:System.Diagnostics.Process" /> a aguardar o número especificado de milissegundos para que o processo associado seja encerrado.</summary>
        <returns>
          <see langword="true" /> se o processo associado tiver sido encerrado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>faz com que o thread atual Aguarde até que encerra o processo associado. Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o <xref:System.Diagnostics.Process.Exited> evento.  
  
 Esse método instrui o <xref:System.Diagnostics.Process> componente aguardar uma quantidade finita de tempo para o processo sair. Se o processo associado não sair no final do intervalo de porque a solicitação para encerrar for negada, `false` é retornado ao procedimento de chamada. Você pode especificar um número negativo (<xref:System.Threading.Timeout.Infinite>) para `milliseconds`, e <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> irão se comportar o mesmo que o <xref:System.Diagnostics.Process.WaitForExit> de sobrecarga. Se você passar 0 (zero) para o método, ele retorna `true` somente se o processo já terminou; caso contrário, ele retorna imediatamente `false`.  
  
> [!NOTE]
>  No [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versões anteriores, se `milliseconds` foi -1, o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sobrecarga aguardou <xref:System.Int32.MaxValue> milissegundos (aproximadamente 24 dias), não indefinidamente.  
  
 Quando a saída padrão foi redirecionada para manipuladores de eventos assíncrono, é possível que o processamento de saída não tenha concluído quando este método retorna. Para garantir que a manipulação de eventos assíncrona foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro após o recebimento um `true` dessa sobrecarga. Para ajudar a garantir que o <xref:System.Diagnostics.Process.Exited> evento é manipulado corretamente em aplicativos de formulários do Windows, defina o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade.  
  
 Quando um processo associado for encerrado (desligar o sistema operacional por meio de um encerramento normal ou anormal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que chamaram <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. O <xref:System.Diagnostics.Process> componente pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A> ao processo encerrado.  
  
 Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A> propriedade do componente não aponta para um recurso existente do processo. Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerradas processos que não foram liberados por <xref:System.Diagnostics.Process> componentes, para que ele mantém o <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória até que o <xref:System.Diagnostics.Process> componente especificamente libera os recursos. Por esse motivo, sempre que você chamar <xref:System.Diagnostics.Process.Start%2A> para um <xref:System.Diagnostics.Process> instância, chame <xref:System.Diagnostics.Process.Close%2A> quando o processo associado foi finalizado e você não precisar mais qualquer informação administrativa sobre ele. <xref:System.Diagnostics.Process.Close%2A>libera a memória alocada para o processo encerrado.  
  
   
  
## Examples  
 Consulte o exemplo de código para o <xref:System.Diagnostics.Process.ExitCode%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível acessar a configuração de espera.</exception>
        <exception cref="T:System.SystemException">Nenhum processo <see cref="P:System.Diagnostics.Process.Id" /> foi definido e não existe um <see cref="P:System.Diagnostics.Process.Handle" /> do qual a propriedade <see cref="P:System.Diagnostics.Process.Id" /> possa ser determinada.  
  
 -ou-  
  
 Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.  
  
 -ou-  
  
 Você está tentando chamar <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> para um processo em execução em um computador remoto. Esse método está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Faz com que o componente <see cref="T:System.Diagnostics.Process" /> aguarde por tempo indefinido até que o processo associado entre em um estado ocioso. Essa sobrecarga se aplica apenas a processos com uma interface do usuário e, portanto, um loop de mensagem.</summary>
        <returns>
          <see langword="true" /> se o processo associado tiver atingido um estado ocioso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle> para forçar o processamento de seu aplicativo para aguardar até que o loop de mensagens retornou ao estado ocioso. Quando um processo com uma interface do usuário está em execução, seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Em seguida, retorna o processo para o loop de mensagens. Um processo deve estar em um estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar para iniciar o processo terminar de criar a janela principal antes que o aplicativo se comunica com a janela.  
  
 Se um processo não tem um loop de mensagem, <xref:System.Diagnostics.Process.WaitForInputIdle> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Diagnostics.Process.WaitForInputIdle> sobrecarga instrui o <xref:System.Diagnostics.Process> componente aguardar indefinidamente para o processo de ficar ocioso no loop de mensagem. Essa instrução pode fazer com que um aplicativo pare de responder. Por exemplo, se o processo for gravado sempre sair seu loop de mensagem imediatamente, como o fragmento de código `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não tem uma interface gráfica.  
  
 -ou-  
  
 Erro desconhecido. O processo não conseguiu entrar em um estado ocioso.  
  
 -ou-  
  
 O processo já terminou.  
  
 -ou-  
  
 Nenhum processo está associado a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Um valor de 1 para <see cref="F:System.Int32.MaxValue" />, que especifica o tempo, em milissegundos, a aguardar até que o processo associado entre em um estado ocioso. Um valor de 0 especifica um retorno imediato e um valor de -1 especifica uma espera infinita.</param>
        <summary>Faz com que o componente <see cref="T:System.Diagnostics.Process" /> a aguarde o número especificado de milissegundos para que o processo entre em um estado ocioso. Essa sobrecarga se aplica apenas a processos com uma interface do usuário e, portanto, um loop de mensagem.</summary>
        <returns>
          <see langword="true" /> se o processo associado tiver atingido um estado ocioso; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> para forçar o processamento de seu aplicativo para aguardar até que o loop de mensagens retornou ao estado ocioso. Quando um processo com uma interface do usuário está em execução, seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Em seguida, retorna o processo para o loop de mensagens. Um processo deve estar em um estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar para iniciar o processo terminar de criar a janela principal antes que o aplicativo se comunica com a janela.  
  
 Se um processo não tem um loop de mensagem, <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> sobrecarga instrui o <xref:System.Diagnostics.Process> componente aguardar uma quantidade finita de tempo para o processo de ficar ocioso no loop de mensagem. Se o processo associado não ficou ocioso até o final do intervalo de porque o loop ainda está processando mensagens, `false` é retornado ao procedimento de chamada.  
  
 Para obter mais informações sobre a manipulação de eventos, consulte [eventos](http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não tem uma interface gráfica.  
  
 -ou-  
  
 Erro desconhecido. O processo não conseguiu entrar em um estado ocioso.  
  
 -ou-  
  
 O processo já terminou.  
  
 -ou-  
  
 Nenhum processo está associado a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o uso de memória física do processo associado, em bytes.</summary>
        <value>A quantidade total de memória física usada pelo processo associado, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual do trabalho conjunto de memória usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo os módulos de processo e as bibliotecas do sistema.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória física, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória física, em bytes, alocada para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por esta propriedade representa o tamanho atual do trabalho conjunto de memória usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções em módulos de processo e as bibliotecas do sistema.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **conjunto de trabalho** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo foi encerrado e exibe suas estatísticas de memória de código e o horário de pico de saída.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é o Windows 98 ou o Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
