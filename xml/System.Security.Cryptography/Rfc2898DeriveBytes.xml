<Type Name="Rfc2898DeriveBytes" FullName="System.Security.Cryptography.Rfc2898DeriveBytes">
  <TypeSignature Language="C#" Value="public class Rfc2898DeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Rfc2898DeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.Rfc2898DeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.3.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Implementa funcionalidade de derivação de chave baseada em senha, PBKDF2, usando um gerador de número pseudoaleatório com base em <see cref="T:System.Security.Cryptography.HMACSHA1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Security.Cryptography.Rfc2898DeriveBytes>usa uma senha, um valor falso e um número de iteração e, em seguida, gera chaves por meio de chamadas para o <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método.  
  
 RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros. Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.  
  
 Para obter mais informações sobre PBKDF2, consulte RFC 2898 "PKCS #5: baseada em senha Cryptography Specification Version 2.0," disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, "PBKDF2" para obter detalhes completos.  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Security.Cryptography.Rfc2898DeriveBytes> chaves de classe para criar dois idênticos para o <xref:System.Security.Cryptography.TripleDES> classe.  Ele criptografa e descriptografa alguns dados usando as chaves.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">A senha usada para derivar a chave.</param>
        <param name="salt">O salt chave usado para derivar a chave.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando uma senha e sal para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho de salt deve ser 8 bytes ou maior.  
  
 RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros. Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.  
  
 Para obter mais informações sobre PBKDF2, consulte RFC 2898 "PKCS #5: baseada em senha Cryptography Specification Version 2.0," disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, "PBKDF2" para obter detalhes completos.  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Security.Cryptography.Rfc2898DeriveBytes> chaves de classe para criar dois idênticos para o <xref:System.Security.Cryptography.TripleDES> classe.  Ele criptografa e descriptografa alguns dados usando as chaves.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">A senha ou o sal é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">A senha usada para derivar a chave.</param>
        <param name="saltSize">O tamanho do salt aleatório que você deseja gerar a classe.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando a senha e o tamanho salt para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho de salt deve ser 8 bytes ou maior.  
  
 RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros. Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.  
  
 Para obter mais informações sobre PBKDF2, consulte RFC 2898 "PKCS #5: baseada em senha Cryptography Specification Version 2.0," disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, "PBKDF2" para obter detalhes completos.  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de salt especificado é menor do que 8 bytes.</exception>
        <exception cref="T:System.ArgumentNullException">A senha ou o sal é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">A senha usada para derivar a chave.</param>
        <param name="salt">O salt chave usado para derivar a chave.</param>
        <param name="iterations">O número de iterações para a operação.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando uma senha, um sal e o número de iterações para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho de salt deve ser 8 bytes ou maior e a contagem de iteração deve ser maior que zero. O número mínimo recomendado de iterações é 1000.  
  
 RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros. Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.  
  
 Para obter mais informações sobre PBKDF2, consulte RFC 2898 "PKCS #5: baseada em senha Cryptography Specification Version 2.0," disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, "PBKDF2" para obter detalhes completos.  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">A senha ou o sal é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">A senha usada para derivar a chave.</param>
        <param name="salt">O salt chave usado para derivar a chave.</param>
        <param name="iterations">O número de iterações para a operação.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando uma senha, um sal e o número de iterações para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho de salt deve ser 8 bytes ou maior e a contagem de iteração deve ser maior que zero. O número mínimo recomendado de iterações é 1000.  
  
 RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros. Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.  
  
 Para obter mais informações sobre PBKDF2, consulte RFC 2898 "PKCS #5: baseada em senha Cryptography Specification Version 2.0," disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, "PBKDF2" para obter detalhes completos.  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Security.Cryptography.Rfc2898DeriveBytes> chaves de classe para criar dois idênticos para o <xref:System.Security.Cryptography.TripleDES> classe.  Ele criptografa e descriptografa alguns dados usando as chaves.  
  
 [!code-cpp[rfc28981#1](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#1)]
 [!code-csharp[rfc28981#1](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#1)]
 [!code-vb[rfc28981#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">A senha ou o sal é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">A senha usada para derivar a chave.</param>
        <param name="saltSize">O tamanho do salt aleatório que você deseja gerar a classe.</param>
        <param name="iterations">O número de iterações para a operação.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> usando uma senha, um tamanho salt e o número de iterações para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O tamanho de salt deve ser 8 bytes ou maior e a contagem de iteração deve ser maior que zero. O número mínimo recomendado de iterações é 1000.  
  
 RFC 2898 inclui métodos para criar um vetor de chave e de inicialização (IV) de uma senha e um valor falso. Você pode usar PBKDF2, uma função de derivação de chaves com base em senha, para gerar chaves usando uma função pseudo-aleatório que permita que as chaves de comprimento praticamente ilimitada para ser gerado. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe pode ser usada para gerar uma chave derivada de uma chave de base e outros parâmetros. Em uma função de derivação de chaves com base em senha, a chave de base é uma senha e os outros parâmetros são um valor falso e um número de iteração.  
  
 Para obter mais informações sobre PBKDF2, consulte RFC 2898 "PKCS n º 5: Password-Based Cryptography Specification Version 2.0," disponível no [de comentários Web site](http://go.microsoft.com/fwlink/?LinkID=37119). Consulte a seção 5.2, "PBKDF2" para obter detalhes completos.  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), usando um editor hexadecimal ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de salt especificado é menor do que 8 bytes ou a contagem de iterações for menor que 1.</exception>
        <exception cref="T:System.ArgumentNullException">A senha ou o sal é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="iterations" /> está fora do intervalo. Esse parâmetro requer um número não negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (byte[] password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.Byte[],System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">To be added.</param>
        <param name="salt">To be added.</param>
        <param name="iterations">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, byte[] salt, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, unsigned int8[] salt, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Byte[],System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">To be added.</param>
        <param name="salt">To be added.</param>
        <param name="iterations">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Rfc2898DeriveBytes (string password, int saltSize, int iterations, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string password, int32 saltSize, int32 iterations, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.#ctor(System.String,System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.String" />
        <Parameter Name="saltSize" Type="System.Int32" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="password">To be added.</param>
        <param name="saltSize">To be added.</param>
        <param name="iterations">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">O nome do algoritmo para o qual a chave será derivada.</param>
        <param name="alghashname">O nome do algoritmo de hash a ser usado para derivar a chave.</param>
        <param name="keySize">O tamanho da chave em bits, derivar.</param>
        <param name="rgbIV">O vetor de inicialização (IV) a ser usado para derivar a chave.</param>
        <summary>Deriva uma chave de criptografia do objeto <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" />.</summary>
        <returns>A chave derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa função é um wrapper para a função de API de criptografia CryptDeriveKey() e pretende oferecer interoperabilidade com aplicativos usando a API de criptografia.  
  
 Se o `keySize` parâmetro for definido como 0 bits, o tamanho de chave padrão para o algoritmo especificado será usado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O parâmetro <paramref name="keySize" /> está incorreto.  
  
 -ou-  
  
 O CSP (provedor de serviços de criptografia) não pode ser adquirido.  
  
 -ou-  
  
 O parâmetro <paramref name="algname" /> não é um nome de algoritmo válido.  
  
 -ou-  
  
 O parâmetro <paramref name="alghashname" /> não é um nome de algoritmo de hash válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pela classe <see cref="T:System.Security.Cryptography.Rfc2898DeriveBytes" /> e, opcionalmente, libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público `Dispose()` e pelo método `Finalize`. `Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`. `Finalize` invoca `Dispose` com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Security.Cryptography.Rfc2898DeriveBytes> referências. Este método invoca o método `Dispose()` de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see langword="Dispose(Boolean)" />, tenha cuidado em não para referenciar objetos que foi descartados anteriormente em uma chamada anterior para <see langword="Dispose" />. Para obter mais informações sobre como implementar <see langword="Dispose(Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see langword="Dispose" /> e <see langword="Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">O número de bytes de chave pseudoaleatórios a serem gerados.</param>
        <summary>Retorna a chave pseudoaleatória para esse objeto.</summary>
        <returns>Uma matriz de bytes preenchida com bytes de chave pseudoaleatórios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe implementa funcionalidade PBKDF2 usando um gerador de números pseudoaleatórios com base em <xref:System.Security.Cryptography.HMACSHA1>. O <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe usa uma senha, um valor falso e um número de iteração e, em seguida, gera chaves por meio de chamadas para o <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método. Chamadas repetidas para este método não irá gerar a mesma chave; em vez disso, acrescentando duas chamadas do <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método com um `cb` valor de parâmetro de `20` é o equivalente a chamar o <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método uma vez com um `cb` valor de parâmetro de `40`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Security.Cryptography.Rfc2898DeriveBytes.GetBytes%2A> método para obter a chave para uma instância do <xref:System.Security.Cryptography.Rfc2898DeriveBytes>. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe.  
  
 [!code-cpp[rfc28981#2](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#2)]
 [!code-csharp[rfc28981#2](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#2)]
 [!code-vb[rfc28981#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="cb" /> está fora do intervalo. Esse parâmetro requer um número não negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="HashAlgorithm">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.HashAlgorithmName HashAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.Cryptography.HashAlgorithmName HashAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.HashAlgorithmName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número de iterações para a operação.</summary>
        <value>O número de iterações para a operação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Contagem de iteração é o número de vezes que uma operação é executada. Para esse método, a contagem deve ser maior que zero. O número mínimo recomendado de iterações é 1000.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Security.Cryptography.Rfc2898DeriveBytes.IterationCount%2A> propriedade para exibir o número de iterações usadas na geração da chave. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe.  
  
 [!code-cpp[rfc28981#3](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#3)]
 [!code-csharp[rfc28981#3](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#3)]
 [!code-vb[rfc28981#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de iterações é menor que 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.Rfc2898DeriveBytes.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine o estado da operação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é chamado automaticamente se a contagem de iteração salt é modificada.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o método <xref:System.Security.Cryptography.Rfc2898DeriveBytes.Reset%2A>. Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.Cryptography.Rfc2898DeriveBytes> classe.  
  
 [!code-cpp[rfc28981#5](~/samples/snippets/cpp/VS_Snippets_CLR/rfc28981/CPP/rfc28981.cpp#5)]
 [!code-csharp[rfc28981#5](~/samples/snippets/csharp/VS_Snippets_CLR/rfc28981/CS/rfc28981.cs#5)]
 [!code-vb[rfc28981#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/rfc28981/vb/rfc28981.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.Rfc2898DeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.3.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de sal da chave para a operação.</summary>
        <value>O valor de sal da chave para a operação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Salt, um conjunto aleatório de bytes, é usado para fazer a descriptografia não autorizado de uma mensagem mais difícil. Um ataque de dicionário é um ataque em que o invasor tenta descriptografar uma mensagem criptografada, comparando o valor criptografado com valores criptografados anteriormente computados para as chaves mais prováveis. Esse ataque torna muito mais difícil pela introdução de sal ou aleatórios bytes, no final da senha antes da derivação de chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de salt especificado é menor do que 8 bytes.</exception>
        <exception cref="T:System.ArgumentNullException">O salt é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
