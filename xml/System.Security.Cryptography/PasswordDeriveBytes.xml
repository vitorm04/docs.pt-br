<Type Name="PasswordDeriveBytes" FullName="System.Security.Cryptography.PasswordDeriveBytes">
  <TypeSignature Language="C#" Value="public class PasswordDeriveBytes : System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PasswordDeriveBytes extends System.Security.Cryptography.DeriveBytes" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.PasswordDeriveBytes" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.DeriveBytes</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Deriva uma chave de uma senha usando uma extensão do algoritmo PBKDF1.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa classe usa uma extensão do algoritmo PBKDF1 definido no padrão de v 2.0 PKCS n º 5 derivar bytes adequados para uso como o material de chave de uma senha. O padrão é documentado em IETF RRC 2898.  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Codificado senhas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ferramenta, um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como notepad.exe.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de uma senha usando o <xref:System.Security.Cryptography.PasswordDeriveBytes> classe.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="password">A senha para a qual a chave é derivada.</param>
        <param name="salt">O sal da chave a ser usado para derivar a chave.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> especificando a senha e o sal da chave a serem usados para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca, codifique uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de uma senha usando o <xref:System.Security.Cryptography.PasswordDeriveBytes> classe.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[])" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="strPassword">A senha para a qual derivar a chave.</param>
        <param name="rgbSalt">O sal da chave a ser usado para derivar a chave.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> com a senha e o sal da chave a serem usados para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Codificado senhas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ferramenta, um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como notepad.exe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="password">A senha para a qual a chave é derivada.</param>
        <param name="salt">O sal da chave a ser usado para derivar a chave.</param>
        <param name="cspParams">Os parâmetros CSP (provedor) de serviços de criptografia para a operação.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> especificando a senha, o salt da chave e o provedor de serviços de criptografia (CSP) a ser usado para derivar a chave de classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca, codifique uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) l, um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma chave de uma senha usando o <xref:System.Security.Cryptography.PasswordDeriveBytes> classe.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#1)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#1)]
 [!code-vb[Cryptography.PasswordDerivedbytes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="strPassword">A senha para a qual derivar a chave.</param>
        <param name="rgbSalt">O sal da chave a ser usado para derivar a chave.</param>
        <param name="cspParams">Os parâmetros CSP para a operação.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> classe com a senha, salt da chave e parâmetros CSP (provedor) de serviços de criptografia a ser usado para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Codificado senhas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ferramenta, um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como notepad.exe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, string hashName, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, string hashName, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="hashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="password">A senha para a qual a chave é derivada.</param>
        <param name="salt">O sal da chave a ser usado para derivar a chave.</param>
        <param name="hashName">O algoritmo de hash a ser usado para derivar a chave.</param>
        <param name="iterations">A contagem de iterações a ser usada para derivar a chave.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> especificando a senha, o sal da chave, o nome do hash e as iterações a serem usadas para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca, codifique uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
 Para obter uma lista de nomes de algoritmo de hash, consulte o <xref:System.Security.Cryptography.CryptoConfig> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, string strHashName, int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, string strHashName, int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="strHashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strPassword">A senha para a qual derivar a chave.</param>
        <param name="rgbSalt">O sal da chave a ser usado para derivar a chave.</param>
        <param name="strHashName">O nome do algoritmo de hash para a operação.</param>
        <param name="iterations">O número de iterações para a operação.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> classe com a senha, o salt da chave, o nome de hash e o número de iterações a ser usado para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Codificado senhas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ferramenta, um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como notepad.exe.  
  
 Para obter uma lista de nomes de algoritmo de hash, consulte o <xref:System.Security.Cryptography.CryptoConfig> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (byte[] password, byte[] salt, string hashName, int iterations, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] password, unsigned int8[] salt, string hashName, int32 iterations, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.Byte[],System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="password" Type="System.Byte[]" />
        <Parameter Name="salt" Type="System.Byte[]" />
        <Parameter Name="hashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="password">A senha para a qual a chave é derivada.</param>
        <param name="salt">O sal da chave a ser usado para derivar a chave.</param>
        <param name="hashName">O algoritmo de hash a ser usado para derivar a chave.</param>
        <param name="iterations">A contagem de iterações a ser usada para derivar a chave.</param>
        <param name="cspParams">Os parâmetros CSP (provedor) de serviços de criptografia para a operação.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> especificando a senha, salt da chave, nome de hash, iterações e o provedor de serviços de criptografia (CSP) a ser usado para derivar a chave de classe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca, codifique uma senha em seu código-fonte.  Senhas codificadas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md), um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como Notepad.exe.  
  
 Para obter uma lista de nomes de algoritmo de hash, consulte o <xref:System.Security.Cryptography.CryptoConfig> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PasswordDeriveBytes (string strPassword, byte[] rgbSalt, string strHashName, int iterations, System.Security.Cryptography.CspParameters cspParams);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string strPassword, unsigned int8[] rgbSalt, string strHashName, int32 iterations, class System.Security.Cryptography.CspParameters cspParams) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.#ctor(System.String,System.Byte[],System.String,System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="strPassword" Type="System.String" />
        <Parameter Name="rgbSalt" Type="System.Byte[]" />
        <Parameter Name="strHashName" Type="System.String" />
        <Parameter Name="iterations" Type="System.Int32" />
        <Parameter Name="cspParams" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="strPassword">A senha para a qual derivar a chave.</param>
        <param name="rgbSalt">O sal da chave a ser usado para derivar a chave.</param>
        <param name="strHashName">O nome do algoritmo de hash para a operação.</param>
        <param name="iterations">O número de iterações para a operação.</param>
        <param name="cspParams">Os parâmetros CSP para a operação.</param>
        <summary>Inicializa uma nova instância do <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> classe com a senha, o salt da chave, o nome de hash, o número de iterações e parâmetros CSP (provedor) de serviços de criptografia a ser usado para derivar a chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Nunca codificar uma senha em seu código-fonte.  Codificado senhas podem ser recuperadas de um assembly usando o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ferramenta, um editor hexadecimal, ou, simplesmente abrindo o assembly em um editor de texto como notepad.exe.  
  
 Para obter uma lista de nomes de algoritmo de hash, consulte o <xref:System.Security.Cryptography.CryptoConfig> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CryptDeriveKey">
      <MemberSignature Language="C#" Value="public byte[] CryptDeriveKey (string algname, string alghashname, int keySize, byte[] rgbIV);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] CryptDeriveKey(string algname, string alghashname, int32 keySize, unsigned int8[] rgbIV) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.CryptDeriveKey(System.String,System.String,System.Int32,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algname" Type="System.String" />
        <Parameter Name="alghashname" Type="System.String" />
        <Parameter Name="keySize" Type="System.Int32" />
        <Parameter Name="rgbIV" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="algname">O nome do algoritmo para o qual a chave será derivada.</param>
        <param name="alghashname">O nome do algoritmo de hash a ser usado para derivar a chave.</param>
        <param name="keySize">O tamanho da chave em bits, derivar.</param>
        <param name="rgbIV">O vetor de inicialização (IV) a ser usado para derivar a chave.</param>
        <summary>Deriva uma chave de criptografia do objeto <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" />.</summary>
        <returns>A chave derivada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa função é um wrapper para a função de API de criptografia CryptDeriveKey() e pretende oferecer interoperabilidade com aplicativos usando a API de criptografia.  
  
 Se o `keySize` parâmetro for definido como 0 bits, o tamanho de chave padrão para o algoritmo especificado será usado.  
  
   
  
## Examples  
 Este exemplo de código é parte de um exemplo maior fornecido para a <xref:System.Security.Cryptography.PasswordDeriveBytes> classe.  
  
 [!code-cpp[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/cpp/sample.cpp#2)]
 [!code-csharp[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/CS/sample.cs#2)]
 [!code-vb[Cryptography.PasswordDerivedbytes#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.PasswordDerivedbytes/VB/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O parâmetro <paramref name="keySize" /> está incorreto.  
  
 -ou-  
  
 O CSP (provedor de serviços de criptografia) não pode ser adquirido.  
  
 -ou-  
  
 O parâmetro <paramref name="algname" /> não é um nome de algoritmo válido.  
  
 -ou-  
  
 O parâmetro <paramref name="alghashname" /> não é um nome de algoritmo de hash válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pela classe <see cref="T:System.Security.Cryptography.PasswordDeriveBytes" /> e, opcionalmente, libera os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público `Dispose()` e pelo método `Finalize`. `Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`. `Finalize` invoca `Dispose` com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Security.Cryptography.PasswordDeriveBytes> referências. Este método invoca o método `Dispose()` de cada objeto referenciado.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see langword="Dispose(Boolean)" />, tenha cuidado em não para referenciar objetos que foi descartados anteriormente em uma chamada anterior para <see langword="Dispose" />. Para obter mais informações sobre como implementar <see langword="Dispose(Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see langword="Dispose" /> e <see langword="Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override byte[] GetBytes (int cb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetBytes(int32 cb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.GetBytes(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cb" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="cb">O número de bytes de chave pseudoaleatórios a serem gerados.</param>
        <summary>Retorna bytes de chave pseudoaleatórios.</summary>
        <returns>Uma matriz de bytes preenchida com bytes de chave pseudoaleatórios.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode criar qualquer número de bytes pseudo-aleatório. No entanto, a intensidade da sequência de bytes é limitada pelo número de bytes na saída de hash.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HashName">
      <MemberSignature Language="C#" Value="public string HashName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HashName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.HashName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do algoritmo de hash da operação.</summary>
        <value>O nome do algoritmo de hash para a operação.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O nome do valor de hash é fixo e é feita uma tentativa de alterar esse valor.</exception>
      </Docs>
    </Member>
    <Member MemberName="IterationCount">
      <MemberSignature Language="C#" Value="public int IterationCount { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 IterationCount" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.IterationCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número de iterações para a operação.</summary>
        <value>O número de iterações para a operação.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O número de iterações é fixo e é feita uma tentativa de alterar esse valor.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A propriedade não pode ser definida porque seu valor está fora do intervalo. Esta propriedade requer um número negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public override void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.PasswordDeriveBytes.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Redefine o estado da operação.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Salt">
      <MemberSignature Language="C#" Value="public byte[] Salt { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Salt" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.PasswordDeriveBytes.Salt" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o valor de sal da chave para a operação.</summary>
        <value>O valor de sal da chave para a operação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um ataque de dicionário é um ataque em que o invasor tenta descriptografar uma mensagem criptografada, comparando o valor criptografado com valores criptografados anteriormente computados para as chaves mais prováveis. Esse ataque torna muito mais difícil pela introdução de bytes aleatórios no final da senha antes da derivação de chaves. Esses bytes aleatórios são conhecidos como salt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O valor da chave de salt é fixo e é feita uma tentativa de alterar esse valor.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
