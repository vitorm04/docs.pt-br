<Type Name="RSACryptoServiceProvider" FullName="System.Security.Cryptography.RSACryptoServiceProvider">
  <TypeSignature Language="C#" Value="public sealed class RSACryptoServiceProvider : System.Security.Cryptography.RSA, System.Security.Cryptography.ICspAsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit RSACryptoServiceProvider extends System.Security.Cryptography.RSA implements class System.Security.Cryptography.ICspAsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.RSACryptoServiceProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.RSA</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.Cryptography.ICspAsymmetricAlgorithm</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Realiza a criptografia assimétrica e a descriptografia usando a implementação do <see cref="T:System.Security.Cryptography.RSA" /> algoritmo fornecido pelo provedor de serviços de criptografia (CSP). Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso é a implementação padrão de <xref:System.Security.Cryptography.RSA>.  
  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider> oferece suporte a tamanhos de chave de 384 bits para 16384 bits em incrementos de 8 bits, se você tiver o Microsoft Enhanced Cryptographic Provider instalado.  Ele dá suporte a tamanhos de chave de 384 bits de 512 bits em incrementos de 8 bits se você tiver o Microsoft Base Cryptographic Provider instalado.  
  
 Tamanhos de chave válidos são dependentes o provedor de serviços de criptografia (CSP) que é usado pelo <xref:System.Security.Cryptography.RSACryptoServiceProvider> instância. Ativação do Windows CSPs chaves tamanhos de 384 para 16384 bits para versões do Windows anteriores ao [!INCLUDE[win81](~/includes/win81-md.md)]e a chave de tamanhos de 512 para 16384 bits para [!INCLUDE[win81](~/includes/win81-md.md)]. Para obter mais informações, consulte [CryptGenKey](http://msdn.microsoft.com/library/aa379941\(v=vs.85\).aspx) função na documentação do Windows.  
  
## <a name="interoperation-with-the-microsoft-cryptographic-api-capi"></a>Interoperação com a Microsoft Cryptographic API (CAPI)  
 Diferentemente de implementação RSA em CAPI não gerenciado, o <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe inverte a ordem de uma matriz criptografada de bytes após a criptografia e antes de descriptografia.  Por padrão, os dados criptografados pelo <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe não pode ser descriptografada pela CAPI `CryptDecrypt` função e os dados criptografados pela CAPI `CryptEncrypt` método não pode ser descriptografado pelo <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe.  
  
 Se você não compensar a ordem inversa ao interoperar entre APIs, o <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe lança um <xref:System.Security.Cryptography.CryptographicException>.  
  
 Para interoperar com CAPI, você deve manualmente inverter a ordem de bytes criptografados antes dos dados criptografados interopera com outra API.  Você pode facilmente reverter a ordem de uma matriz de bytes gerenciado chamando o <xref:System.Array.Reverse%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O seguinte exemplo de código usa a <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe para criptografar uma cadeia de caracteres em uma matriz de bytes e, em seguida, descriptografar os bytes de volta para uma cadeia de caracteres.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/VB/sample.vb#1)]  
  
 O exemplo de código a seguir exporta as informações de chave criadas usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider> em uma <xref:System.Security.Cryptography.RSAParameters> objeto.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/VB/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> usando a chave padrão.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhuma chave padrão for encontrado, uma nova chave é criada.  
  
 Este construtor cria um <xref:System.Security.Cryptography.KeyNumber.Exchange> adequado para criptografar a sessão do par de chaves das chaves de forma que eles possam ser com segurança armazenados e trocados com outros usuários.  A chave gerada corresponde a uma chave gerada usando o `AT_KEYEXCHANGE` valor usado de não gerenciado Microsoft Cryptographic API (CAPI).  
  
   
  
## Examples  
 O seguinte exemplo de código usa a <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe para criptografar uma cadeia de caracteres em uma matriz de bytes e, em seguida, descriptografar os bytes de volta para uma cadeia de caracteres.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O CSP (provedor de serviços de criptografia) não pode ser adquirido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (int dwKeySize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 dwKeySize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dwKeySize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dwKeySize">O tamanho da chave a ser usada em bits.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> com o tamanho de chave especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se nenhuma chave padrão for encontrado, uma nova chave é criada.  
  
 Este construtor cria um <xref:System.Security.Cryptography.KeyNumber.Exchange> adequado para criptografar a sessão do par de chaves das chaves de forma que eles possam ser com segurança armazenados e trocados com outros usuários.  A chave gerada corresponde a uma chave gerada usando o `AT_KEYEXCHANGE` valor usado de não gerenciado Microsoft Cryptographic API (CAPI).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Security.Cryptography.RSACryptoServiceProvider>, gera uma nova chave e armazena em um contêiner de chave.  
  
 [!code-cpp[Cryptography.RSACSP.ctor-int32-2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-2/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.ctor-int32-2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-2/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.ctor-int32-2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O CSP (provedor de serviços de criptografia) não pode ser adquirido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (System.Security.Cryptography.CspParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Cryptography.CspParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Os parâmetros a serem passados para o CSP (Provedor de Serviços de Criptografia).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> com os parâmetros especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria ou reutiliza um contêiner de chave especificado usando o <xref:System.Security.Cryptography.CspParameters.KeyContainerName> campo o `parameters` parâmetro.  
  
 Por padrão, este construtor cria um <xref:System.Security.Cryptography.KeyNumber.Exchange> adequado para criptografar a sessão do par de chaves das chaves de forma que eles possam ser com segurança armazenados e trocados com outros usuários.  A chave gerada corresponde a uma chave gerada usando o `AT_KEYEXCHANGE` valor usado de não gerenciado Microsoft Cryptographic API (CAPI).  
  
 Você pode criar um <xref:System.Security.Cryptography.KeyNumber.Signature> chave par adequado para a autenticação de mensagens (assinadas digitalmente) ou arquivos, definindo o <xref:System.Security.Cryptography.CspParameters.KeyNumber> campo do `parameters` parâmetro para o <xref:System.Security.Cryptography.KeyNumber.Signature> valor. Esse tipo de chave corresponde do `AT_SIGNATURE` valor usado em CAPI.  
  
 Se você criar um <xref:System.Security.Cryptography.RSACryptoServiceProvider> do objeto com o <xref:System.Security.Cryptography.KeyNumber.Exchange> valor especificado e, em seguida, criar outro <xref:System.Security.Cryptography.RSACryptoServiceProvider> do objeto com o <xref:System.Security.Cryptography.KeyNumber.Signature> valor especificado, as chaves serão colocadas em um único contêiner se ambos os objetos especificam o mesmo nome de contêiner de chave.  
  
 Para criar uma chave que é compatível com o nome de stong assinatura usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe, você deve criar um <xref:System.Security.Cryptography.KeyNumber.Signature> par de chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Security.Cryptography.RSACryptoServiceProvider> objeto, gera uma nova chave e as armazena em um contêiner de chave.  
  
 [!code-cpp[Cryptography.RSACSP.ctor-csp#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-csp/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.ctor-csp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-csp/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.ctor-csp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.ctor-csp/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Não é possível adquirir o CSP.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RSACryptoServiceProvider (int dwKeySize, System.Security.Cryptography.CspParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 dwKeySize, class System.Security.Cryptography.CspParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.#ctor(System.Int32,System.Security.Cryptography.CspParameters)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="dwKeySize" Type="System.Int32" />
        <Parameter Name="parameters" Type="System.Security.Cryptography.CspParameters" />
      </Parameters>
      <Docs>
        <param name="dwKeySize">O tamanho da chave a ser usada em bits.</param>
        <param name="parameters">Os parâmetros a serem passados para o CSP (Provedor de Serviços de Criptografia).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> com o parâmetro e o tamanho de chave especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria ou reutiliza um contêiner de chave especificado usando o <xref:System.Security.Cryptography.CspParameters.KeyContainerName> campo o `parameters` parâmetro.  
  
 Por padrão, este construtor cria um <xref:System.Security.Cryptography.KeyNumber.Exchange> adequado para criptografar a sessão do par de chaves das chaves de forma que eles possam ser com segurança armazenados e trocados com outros usuários.  A chave gerada corresponde a uma chave gerada usando o `AT_KEYEXCHANGE` valor usado de não gerenciado Microsoft Cryptographic API (CAPI).  
  
 Você pode criar um <xref:System.Security.Cryptography.KeyNumber.Signature> chave par adequado para a autenticação de mensagens (assinadas digitalmente) ou arquivos, definindo o <xref:System.Security.Cryptography.CspParameters.KeyNumber> campo do `parameters` parâmetro para o <xref:System.Security.Cryptography.KeyNumber.Signature> valor. Esse tipo de chave corresponde do `AT_SIGNATURE` valor usado em CAPI.  
  
 Se você criar um <xref:System.Security.Cryptography.RSACryptoServiceProvider> do objeto com o <xref:System.Security.Cryptography.KeyNumber.Exchange> valor especificado e, em seguida, criar outro <xref:System.Security.Cryptography.RSACryptoServiceProvider> do objeto com o <xref:System.Security.Cryptography.KeyNumber.Signature> valor especificado, as chaves serão colocadas em um único contêiner se ambos os objetos especificam o mesmo nome de contêiner de chave.  
  
 Para criar uma chave que é compatível com o nome de stong assinatura usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe, você deve criar um <xref:System.Security.Cryptography.KeyNumber.Signature> par de chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Security.Cryptography.RSACryptoServiceProvider>, gera uma nova chave e armazena em um contêiner de chave.  
  
 [!code-cpp[Cryptography.RSACSP.ctor-int32-csp#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-csp/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.ctor-int32-csp#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-csp/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.ctor-int32-csp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.ctor-int32-csp/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Não é possível adquirir o CSP.  
  
 -ou-  
  
 A chave não pode ser criada.</exception>
      </Docs>
    </Member>
    <Member MemberName="CspKeyContainerInfo">
      <MemberSignature Language="C#" Value="public System.Security.Cryptography.CspKeyContainerInfo CspKeyContainerInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.CspKeyContainerInfo CspKeyContainerInfo" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.CspKeyContainerInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CspKeyContainerInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto <see cref="T:System.Security.Cryptography.CspKeyContainerInfo" /> que descreve informações adicionais sobre um par de chaves de criptografia.</summary>
        <value>Um objeto <see cref="T:System.Security.Cryptography.CspKeyContainerInfo" /> que descreve informações adicionais sobre um par de chaves de criptografia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Security.Cryptography.RSACryptoServiceProvider.CspKeyContainerInfo%2A> propriedade para obter mais informações sobre um par de chaves criptográficas.  Retornado <xref:System.Security.Cryptography.CspKeyContainerInfo> objeto descreve se a chave é exportável e especifica o nome do contêiner de chave, informações sobre o provedor e outras informações.  
  
 Em casos em que uma chave aleatória é gerada, um contêiner de chave não será criado até você chamar um método que usa a chave.  Algumas propriedades do <xref:System.Security.Cryptography.CspKeyContainerInfo> objeto retornado pelo <xref:System.Security.Cryptography.DSACryptoServiceProvider.CspKeyContainerInfo%2A> propriedade gerará uma <xref:System.Security.Cryptography.CryptographicException> se um contêiner de chave não foi criado.  Para certificar-se de que um contêiner de chave foi criado, chamar um método, como <xref:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt%2A>, <xref:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt%2A>, <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignData%2A>, <xref:System.Security.Cryptography.DSACryptoServiceProvider.SignHash%2A>, e assim por diante, antes de chamar o <xref:System.Security.Cryptography.DSACryptoServiceProvider.CspKeyContainerInfo%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como chamar o <xref:System.Security.Cryptography.CspKeyContainerInfo> propriedade.  
  
 [!code-cpp[Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo/CPP/sample.cpp#1)]
 [!code-csharp[Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo/CS/sample.cs#1)]
 [!code-vb[Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RsaCryptoServiceProvider.CspKeyContainerInfo/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public byte[] Decrypt (byte[] rgb, bool fOAEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Decrypt(unsigned int8[] rgb, bool fOAEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt(System.Byte[],System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
        <Parameter Name="fOAEP" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rgb">Os dados a serem descriptografados.</param>
        <param name="fOAEP">
          <see langword="true" />para executar direta <see cref="T:System.Security.Cryptography.RSA" /> descriptografia usando preenchimento OAEP (apenas disponível em um computador executando o Microsoft Windows XP ou posterior); caso contrário, <see langword="false" /> para usar o preenchimento do PKCS #1 v 1.5.</param>
        <summary>Descriptografa dados com o algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
        <returns>Os dados descriptografados, que é o texto sem formatação original antes da criptografia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt%2A> para criptografar os dados para descriptografia com esse método.  
  
   
  
## Examples  
 O exemplo de código a seguir criptografa e descriptografa os dados.  
  
 Este exemplo usa o <xref:System.Text.ASCIIEncoding> classe; no entanto, a <xref:System.Text.UnicodeEncoding> classe pode ser preferível em operações de dados grandes. O valor criptografado pode ser salvo como um `nvarchar` tipo de dados no Microsoft SQL Server 2005.  
  
 [!code-cpp[Cryptography.RSACSP.Decrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.Decrypt/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.Decrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.Decrypt/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.Decrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.Decrypt/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O CSP (provedor de serviços de criptografia) não pode ser adquirido.  
  
 -ou-  
  
 O parâmetro <paramref name="fOAEP" /> é <see langword="true" /> e o tamanho do parâmetro <paramref name="rgb" /> é maior que <see cref="P:System.Security.Cryptography.RSACryptoServiceProvider.KeySize" />.  
  
 -ou-  
  
 O parâmetro <paramref name="fOAEP" /> é <see langword="true" /> e o OAEP não tem suporte.  
  
 -ou-  
  
 A chave não coincide com os dados criptografados. No entanto, o texto da exceção pode não estar preciso. Por exemplo, ele pode dizer <c>não há armazenamento suficiente está disponível para processar este comando</c>.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rgb" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">permissão descriptografar. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Decrypt" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Decrypt">
      <MemberSignature Language="C#" Value="public override byte[] Decrypt (byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Decrypt(unsigned int8[] data, class System.Security.Cryptography.RSAEncryptionPadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSAEncryptionPadding" />
      </Parameters>
      <Docs>
        <param name="data">Os dados a serem descriptografados.</param>
        <param name="padding">O preenchimento.</param>
        <summary>Descriptografa dados que foram criptografados previamente com o algoritmo <see cref="T:System.Security.Cryptography.RSA" /> usando o preenchimento especificado.</summary>
        <returns>Os dados descriptografados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `padding`deve ser <xref:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1%2A?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="data" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="padding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Não há suporte para o modo de preenchimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecryptValue">
      <MemberSignature Language="C#" Value="public override byte[] DecryptValue (byte[] rgb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] DecryptValue(unsigned int8[] rgb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.DecryptValue(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgb">Os dados a serem descriptografados.</param>
        <summary>Esse método não tem suporte na versão atual.</summary>
        <returns>Os dados descriptografados, que é o texto sem formatação original antes da criptografia.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Esse método não tem suporte na versão atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public byte[] Encrypt (byte[] rgb, bool fOAEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Encrypt(unsigned int8[] rgb, bool fOAEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt(System.Byte[],System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
        <Parameter Name="fOAEP" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rgb">Os dados a serem criptografados.</param>
        <param name="fOAEP">
          <see langword="true" />para executar direta <see cref="T:System.Security.Cryptography.RSA" /> criptografia usando preenchimento OAEP (apenas disponível em um computador executando o Windows XP ou posterior); caso contrário, <see langword="false" /> para usar o preenchimento do PKCS #1 v 1.5.</param>
        <summary>Criptografa dados com o algoritmo <see cref="T:System.Security.Cryptography.RSA" />.</summary>
        <returns>Os dados criptografados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir descreve o preenchimento suportado pelas versões diferentes do Microsoft Windows e o comprimento máximo de `rgb` permitido por diferentes combinações de sistemas operacionais e preenchimento.  
  
|Enchimento|Sistema operacional com suporte|Comprimento máximo do parâmetro de rgb|  
|-------------|--------------------------------|-------------------------------------|  
|Preenchimento OAEP (PKCS #1 v2)|Windows XP ou posterior.|Módulo tamanho-de-2 2 * hLen, onde hLen é o tamanho de hash.|  
|Direcionar criptografia (PKCS #1 v 1.5)|Microsoft Windows 2000 ou posterior com o pacote de criptografia alta instalado.|Tamanho do módulo - 11. (11 bytes é o mínimo possível de preenchimento).|  
|Direcionar o preenchimento OAEP e criptografia não tem suportado|Microsoft Windows 98, Windows Millennium Edition ou Windows 2000 ou posterior sem o pacote de criptografia alta instalado.|O tamanho máximo permitido para uma chave simétrica.|  
  
 Use <xref:System.Security.Cryptography.RSACryptoServiceProvider.Decrypt%2A> para descriptografar os resultados desse método.  
  
   
  
## Examples  
 O código a seguir exemplo inicializa um <xref:System.Security.Cryptography.RSACryptoServiceProvider> objeto para o valor de uma chave pública (enviado por terceiros), gera uma chave de sessão usando o <xref:System.Security.Cryptography.RijndaelManaged> algoritmo e, em seguida, criptografa a chave de sessão usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider> objeto.  Usando esse esquema, a chave de sessão pode ser enviada de volta ao proprietário da chave privada do RSA e duas partes podem usar a chave de sessão para trocar dados criptografados.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.Encrypt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.Encrypt/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.Encrypt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.Encrypt/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.Encrypt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.Encrypt/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O CSP (provedor de serviços de criptografia) não pode ser adquirido.  
  
 -ou-  
  
 O tamanho do parâmetro <paramref name="rgb" /> é maior que o tamanho máximo permitido.  
  
 -ou-  
  
 O parâmetro <paramref name="fOAEP" /> é <see langword="true" /> e o preenchimento OAEP não tem suporte.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rgb" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Encrypt">
      <MemberSignature Language="C#" Value="public override byte[] Encrypt (byte[] data, System.Security.Cryptography.RSAEncryptionPadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] Encrypt(unsigned int8[] data, class System.Security.Cryptography.RSAEncryptionPadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Encrypt(System.Byte[],System.Security.Cryptography.RSAEncryptionPadding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSAEncryptionPadding" />
      </Parameters>
      <Docs>
        <param name="data">Os dados a serem criptografados.</param>
        <param name="padding">O preenchimento.</param>
        <summary>Criptografa dados com o algoritmo <see cref="T:System.Security.Cryptography.RSA" /> usando o preenchimento especificado.</summary>
        <returns>Os dados criptografados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `padding`deve ser <xref:System.Security.Cryptography.RSAEncryptionPadding.Pkcs1%2A?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.RSAEncryptionPadding.OaepSHA1%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="data" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="padding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">Não há suporte para o modo de preenchimento.</exception>
      </Docs>
    </Member>
    <Member MemberName="EncryptValue">
      <MemberSignature Language="C#" Value="public override byte[] EncryptValue (byte[] rgb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] EncryptValue(unsigned int8[] rgb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.EncryptValue(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgb" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgb">Os dados a serem criptografados.</param>
        <summary>Esse método não tem suporte na versão atual.</summary>
        <returns>Os dados criptografados.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Esse método não tem suporte na versão atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExportCspBlob">
      <MemberSignature Language="C#" Value="public byte[] ExportCspBlob (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] ExportCspBlob(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ExportCspBlob(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" /> para incluir a chave privada; caso contrário, <see langword="false" />.</param>
        <summary>Exporta um blob que contém as informações de chave associadas a um objeto <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" />.</summary>
        <returns>Uma matriz de bytes que contém as informações de chave associadas a um objeto <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider.ExportCspBlob%2A> método retorna um blob que contém informações de chave que é compatíveis com o não gerenciado Microsoft Cryptographic API (CAPI).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">permissão acessar um contêiner de chave ao exportar uma chave privada. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Export" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.RSAParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Security.Cryptography.RSAParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.RSAParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <see langword="true" /> para incluir parâmetros particulares; caso contrário, <see langword="false" />.</param>
        <summary>Exporta o <see cref="T:System.Security.Cryptography.RSAParameters" />.</summary>
        <returns>Os parâmetros para <see cref="T:System.Security.Cryptography.RSA" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir exporta as informações de chave criadas usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider> em uma <xref:System.Security.Cryptography.RSAParameters> objeto.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.ExportParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ExportParameters/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">A chave não pode ser exportada.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">permissão exportar uma chave. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Export" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~RSACryptoServiceProvider ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected override byte[] HashData (System.IO.Stream data, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance unsigned int8[] HashData(class System.IO.Stream data, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.HashData(System.IO.Stream,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HashData">
      <MemberSignature Language="C#" Value="protected override byte[] HashData (byte[] data, int offset, int count, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance unsigned int8[] HashData(unsigned int8[] data, int32 offset, int32 count, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.HashData(System.Byte[],System.Int32,System.Int32,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="data">To be added.</param>
        <param name="offset">To be added.</param>
        <param name="count">To be added.</param>
        <param name="hashAlgorithm">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportCspBlob">
      <MemberSignature Language="C#" Value="public void ImportCspBlob (byte[] keyBlob);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportCspBlob(unsigned int8[] keyBlob) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ImportCspBlob(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyBlob" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="keyBlob">Uma matriz de bytes que representa um blob de chave RSA.</param>
        <summary>Importa um blob que representa informações de chave RSA.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider.ImportCspBlob%2A> método inicializa os dados da chave de um <xref:System.Security.Cryptography.RSACryptoServiceProvider> usando um blob que é compatível com o não gerenciado Microsoft Cryptographic API (CAPI) do objeto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">permissão acessar um contêiner de chave ao importar uma chave. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Import" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public override void ImportParameters (System.Security.Cryptography.RSAParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ImportParameters(valuetype System.Security.Cryptography.RSAParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters(System.Security.Cryptography.RSAParameters)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.RSAParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">Os parâmetros para <see cref="T:System.Security.Cryptography.RSA" />.</param>
        <summary>Importa o <see cref="T:System.Security.Cryptography.RSAParameters" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir importa informações de chave criadas a partir de um <xref:System.Security.Cryptography.RSAParameters> do objeto em um <xref:System.Security.Cryptography.RSACryptoServiceProvider> objeto.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ImportParameters/CPP/sample.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ImportParameters/CS/sample.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider.ImportParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Cryptography.RSACryptoServiceProvider.ImportParameters/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O CSP (provedor de serviços de criptografia) não pode ser adquirido.  
  
 -ou-  
  
 O parâmetro <paramref name="parameters" /> tem campos ausentes.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">permissão importar uma chave. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Import" /></permission>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do algoritmo de troca de chave disponível com essa implementação de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
        <value>O nome do algoritmo de troca de chaves, se ele existir. Caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade indica o nome do algoritmo, não do tipo. Por exemplo, RSA-PKCS1-KeyEx é um nome de algoritmo de troca de chaves.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeySize">
      <MemberSignature Language="C#" Value="public override int KeySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 KeySize" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.KeySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho da chave atual.</summary>
        <value>O tamanho da chave em bits.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider> oferece suporte a tamanhos de chave de 384 bits para 16384 bits em incrementos de 8 bits, se você tiver o Microsoft Enhanced Cryptographic Provider instalado.  Ele dá suporte a tamanhos de chave de 384 bits de 512 bits em incrementos de 8 bits se você tiver o Microsoft Base Cryptographic Provider instalado.  
  
 Tamanhos de chave válidos são dependentes o provedor de serviços de criptografia (CSP) que é usado pelo <xref:System.Security.Cryptography.RSACryptoServiceProvider> instância. Tamanhos de chave enable Windows CSPs de 384 para 16384 bits para versões do Windows anteriores ao [!INCLUDE[win81](~/includes/win81-md.md)]e a chave de tamanhos de 512 para 16384 bits para [!INCLUDE[win81](~/includes/win81-md.md)]. Para obter mais informações, consulte [CryptGenKey](http://msdn.microsoft.com/library/aa379941\(v=vs.85\).aspx) função na documentação do Windows.  
  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe não permite alterar os tamanhos de chave usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider.KeySize%2A> propriedade.  Qualquer valor gravado para essa propriedade não atualizarão a propriedade sem erro.  Para alterar o tamanho da chave, use uma das sobrecargas de construtor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LegalKeySizes">
      <MemberSignature Language="C#" Value="public override System.Security.Cryptography.KeySizes[] LegalKeySizes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.KeySizes[] LegalKeySizes" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.LegalKeySizes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.KeySizes[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PersistKeyInCsp">
      <MemberSignature Language="C#" Value="public bool PersistKeyInCsp { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PersistKeyInCsp" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.PersistKeyInCsp" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a chave deve ser persistente no CSP (provedor de serviços de criptografia).</summary>
        <value>
          <see langword="true" /> se a chave precisar ser persistente no CSP; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa propriedade para manter uma chave em um contêiner de chave.  
  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider.PersistKeyInCsp%2A> propriedade é definida automaticamente como `true` quando você especificar um nome de contêiner de chave no <xref:System.Security.Cryptography.CspParameters.KeyContainerName> campo de um <xref:System.Security.Cryptography.CspParameters> de objeto e usá-lo para inicializar um <xref:System.Security.Cryptography.RSACryptoServiceProvider> objeto chamando um dos construtores com um `parameters` parâmetro.  
  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider.PersistKeyInCsp%2A> propriedade não terá efeito se a <xref:System.Security.Cryptography.RSACryptoServiceProvider> objeto é criado com um `null` nome do contêiner de chave.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Security.Cryptography.RSACryptoServiceProvider> de objeto e persistir a chave para um contêiner de chave.  
  
 [!code-cpp[Cryptography.RSACSP.PersistKey#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.PersistKey/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.PersistKey#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.PersistKey/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.PersistKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.PersistKey/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">permissão Excluir uma chave. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Delete" />  
  
 -ou-  
  
 permissão Criar uma chave. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Create" /></permission>
      </Docs>
    </Member>
    <Member MemberName="PublicOnly">
      <MemberSignature Language="C#" Value="public bool PublicOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PublicOnly" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.PublicOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> objeto contém somente uma chave pública.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Security.Cryptography.RSACryptoServiceProvider" /> objeto contém apenas um público chave; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Security.Cryptography.RSACryptoServiceProvider> classe pode ser inicializado ou com uma chave pública apenas ou com ambos os uma pública e privada chave.  Use o <xref:System.Security.Cryptography.RSACryptoServiceProvider.PublicOnly%2A> propriedade para determinar se a instância atual contém somente uma chave pública ou uma chave pública e privada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do algoritmo de assinatura disponível com esta implementação de <see cref="T:System.Security.Cryptography.RSA" />.</summary>
        <value>O nome do algoritmo de assinatura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade é usada em classes de assinatura digital XML para indicar o URI do algoritmo. Nessa implementação, essa propriedade sempre retorna http://www.w3.org/2000/09/xmldsig#rsa-sha1.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] buffer, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] buffer, object halg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.Byte[],System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Os dados de entrada para os quais o hash será calculado.</param>
        <param name="halg">O algoritmo de hash a ser usado para criar o valor de hash.</param>
        <summary>Calcula o valor de hash da matriz de byte especificada usando o algoritmo de hash especificado e assina o valor de hash resultante.</summary>
        <returns>A assinatura <see cref="T:System.Security.Cryptography.RSA" /> dos dados especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma assinatura digital é verificada usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData%2A> método.  
  
 O `halg` parâmetro pode aceitar um <xref:System.String>, um <xref:System.Security.Cryptography.HashAlgorithm>, ou um <xref:System.Type>.  
  
   
  
## Examples  
 O exemplo de código a seguir assina e verifica os dados.  
  
 [!code-cpp[Cryptography.RSACSP.SignData2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.SignData2/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.SignData2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.SignData2/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.SignData2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.SignData2/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="halg" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="halg" /> não é um tipo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (System.IO.Stream inputStream, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(class System.IO.Stream inputStream, object halg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.IO.Stream,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputStream" Type="System.IO.Stream" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="inputStream">Os dados de entrada para os quais o hash será calculado.</param>
        <param name="halg">O algoritmo de hash a ser usado para criar o valor de hash.</param>
        <summary>Calcula o valor de hash do fluxo de entrada especificado usando o algoritmo de hash especificado e assina o valor de hash resultante.</summary>
        <returns>A assinatura <see cref="T:System.Security.Cryptography.RSA" /> dos dados especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `halg` parâmetro pode aceitar um <xref:System.String>, um <xref:System.Security.Cryptography.HashAlgorithm>, ou um <xref:System.Type>.  
  
   
  
## Examples  
 O exemplo de código a seguir assina e verifica os dados.  
  
 [!code-cpp[Cryptography.RSACSP.SignData3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.SignData3/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.SignData3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.SignData3/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.SignData3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.SignData3/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="halg" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="halg" /> não é um tipo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignData">
      <MemberSignature Language="C#" Value="public byte[] SignData (byte[] buffer, int offset, int count, object halg);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignData(unsigned int8[] buffer, int32 offset, int32 count, object halg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignData(System.Byte[],System.Int32,System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="halg" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Os dados de entrada para os quais o hash será calculado.</param>
        <param name="offset">O deslocamento na matriz da qual começar a usar os dados.</param>
        <param name="count">O número de bytes na matriz para usar como dados.</param>
        <param name="halg">O algoritmo de hash a ser usado para criar o valor de hash.</param>
        <summary>Calcula o valor de hash de um subconjunto da matriz de byte especificada usando o algoritmo de hash especificado e assina o valor de hash resultante.</summary>
        <returns>A assinatura <see cref="T:System.Security.Cryptography.RSA" /> dos dados especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma assinatura digital é verificada usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData%2A> método.  
  
 O `halg` parâmetro pode aceitar um <xref:System.String>, um <xref:System.Security.Cryptography.HashAlgorithm>, ou um <xref:System.Type>. O valor de cadeia de caracteres pode ser um dos seguintes:  
  
-   Nome do objeto (OID) de identificador amigável do algoritmo de hash a ser usado, um nome registrado no arquivo de configuração de criptografia ou uma na tabela de OID de API de criptografia.  
  
-   O valor OID. Deve ser a identificação de objeto reconhecido pela API de criptografia.  
  
 Por exemplo, você pode usar SignData (byte novo [5], "1.3.14.3.2.26") ou SignData (novo byte [5], "sha1") ou SignData (byte novo [5], "SHA1").  
  
   
  
## Examples  
 O exemplo de código a seguir assina e verifica os dados.  
  
 [!code-cpp[Cryptography.RSACSP.SignData1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.SignData1/CPP/example.cpp#1)]
 [!code-csharp[Cryptography.RSACSP.SignData1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.SignData1/CS/example.cs#1)]
 [!code-vb[Cryptography.RSACSP.SignData1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.SignData1/VB/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="halg" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="halg" /> não é um tipo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="SignHash">
      <MemberSignature Language="C#" Value="public byte[] SignHash (byte[] rgbHash, string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] SignHash(unsigned int8[] rgbHash, string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignHash(System.Byte[],System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="rgbHash">O valor de hash dos dados a serem assinados.</param>
        <param name="str">O identificador de algoritmo hash (OID) usado para criar o valor de hash dos dados.</param>
        <summary>Computa a assinatura para o valor de hash especificado criptografando-a com a chave privada.</summary>
        <returns>A assinatura de <see cref="T:System.Security.Cryptography.RSA" /> para o valor de hash especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria uma assinatura digital é verificada usando o <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash%2A> método.  
  
 Os algoritmos de hash válido são <xref:System.Security.Cryptography.SHA1> e <xref:System.Security.Cryptography.MD5>. O identificador de algoritmo pode ser derivado do nome do hash usando o <xref:System.Security.Cryptography.CryptoConfig.MapNameToOID%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir criptografa alguns dados, cria um hash dos dados criptografados e, em seguida, assina o hash com uma assinatura digital.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CS/class1.cs#1)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="rgbHash" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O CSP (provedor de serviços de criptografia) não pode ser adquirido.  
  
 -ou-  
  
 Não há nenhuma chave privada.</exception>
        <permission cref="T:System.Security.Permissions.KeyContainerPermissionAccessEntryCollection">permissão assinar um arquivo usando a chave. Ação de segurança: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />. Enumeração associada: <see cref="F:System.Security.Permissions.KeyContainerPermissionFlags.Sign" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SignHash">
      <MemberSignature Language="C#" Value="public override byte[] SignHash (byte[] hash, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] SignHash(unsigned int8[] hash, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, class System.Security.Cryptography.RSASignaturePadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.SignHash(System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSASignaturePadding" />
      </Parameters>
      <Docs>
        <param name="hash">O valor de hash dos dados a serem assinados.</param>
        <param name="hashAlgorithm">O nome de algoritmo de hash usado para criar o valor de hash dos dados.</param>
        <param name="padding">O preenchimento.</param>
        <summary>Computa a assinatura para o valor de hash especificado criptografando-a com a chave privada usando o preenchimento especificado.</summary>
        <returns>A assinatura de <see cref="T:System.Security.Cryptography.RSA" /> para o valor de hash especificado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hashAlgorithm" /> é <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hash" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="padding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="padding" />não é igual a <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseMachineKeyStore">
      <MemberSignature Language="C#" Value="public static bool UseMachineKeyStore { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UseMachineKeyStore" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a chave deve ser persistente no repositório de chaves do computador em vez do repositório de perfil do usuário.</summary>
        <value>
          <see langword="true" /> se a chave precisar ser persistente no repositório de chaves do computador; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definir essa propriedade como `true` é equivalente ao passar o <xref:System.Security.Cryptography.CspProviderFlags.UseMachineKeyStore> sinalizador como um <xref:System.Security.Cryptography.CspParameters> objeto. O <xref:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore%2A> propriedade se aplica a todo o código no domínio do aplicativo atual, enquanto o <xref:System.Security.Cryptography.CspParameters> objeto só se aplica a classes de referenciá-lo explicitamente. Essas configurações são úteis quando representando ou executado sob uma conta cujo perfil de usuário não está carregado. Configuração <xref:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore%2A> afeta a somente se do repositório de chaves local <xref:System.Security.Cryptography.RSACryptoServiceProvider> é inicializado sem parâmetros.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um <xref:System.Security.Cryptography.RSACryptoServiceProvider> de objeto e define estático <xref:System.Security.Cryptography.RSACryptoServiceProvider.UseMachineKeyStore%2A> propriedade para usar o repositório de chaves do computador em vez de repositório de chave de perfil do usuário.  
  
 [!code-cpp[Cryptography.RSACSP.UseMachineKey#2](~/samples/snippets/cpp/VS_Snippets_CLR/Cryptography.RSACSP.UseMachineKey/CPP/example2.cpp#2)]
 [!code-csharp[Cryptography.RSACSP.UseMachineKey#2](~/samples/snippets/csharp/VS_Snippets_CLR/Cryptography.RSACSP.UseMachineKey/CS/example2.cs#2)]
 [!code-vb[Cryptography.RSACSP.UseMachineKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Cryptography.RSACSP.UseMachineKey/VB/example2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerifyData">
      <MemberSignature Language="C#" Value="public bool VerifyData (byte[] buffer, object halg, byte[] signature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyData(unsigned int8[] buffer, object halg, unsigned int8[] signature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData(System.Byte[],System.Object,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="halg" Type="System.Object" />
        <Parameter Name="signature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Os dados que receberam um sinal.</param>
        <param name="halg">O nome do algoritmo de hash usado para criar o valor de hash dos dados.</param>
        <param name="signature">Os dados de assinatura a ser verificado.</param>
        <summary>Verifica se uma assinatura digital é válida determinando o valor de hash na assinatura com a chave pública fornecida e comparando-a com o valor de hash dos dados fornecidos.</summary>
        <returns>
          <see langword="true" /> se a assinatura for válida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método verifica a <xref:System.Security.Cryptography.RSA> assinatura digital produzido pelo <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignData%2A> método. A assinatura é verificada obtendo o valor de hash da assinatura usando a chave pública que foi assinado com, e comparar o valor para o valor de hash dos dados fornecidos.  
  
 O `halg` parâmetro pode aceitar um <xref:System.String>, um <xref:System.Security.Cryptography.HashAlgorithm>, ou um <xref:System.Type>.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyData%2A> método para verificar uma assinatura. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignHash%2A> método.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CPP/class1.cpp#2)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CS/class1.cs#2)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="halg" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="halg" /> não é um tipo válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public bool VerifyHash (byte[] rgbHash, string str, byte[] rgbSignature);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool VerifyHash(unsigned int8[] rgbHash, string str, unsigned int8[] rgbSignature) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash(System.Byte[],System.String,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rgbHash" Type="System.Byte[]" />
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="rgbSignature" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rgbHash">O valor de hash dos dados assinados.</param>
        <param name="str">O identificador de algoritmo hash (OID) usado para criar o valor de hash dos dados.</param>
        <param name="rgbSignature">Os dados de assinatura a ser verificado.</param>
        <summary>Verifica se uma assinatura digital é válida determinando o valor de hash na assinatura com a chave pública fornecida e comparando-a com valor de hash fornecido.</summary>
        <returns>
          <see langword="true" /> se a assinatura for válida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método verifica a <xref:System.Security.Cryptography.RSA> assinatura digital produzido pelo <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignHash%2A> método. A assinatura é verificada obtendo o valor de hash da assinatura usando a chave pública que foi assinado com, e comparar o valor para o valor de hash dos dados fornecidos.  
  
 Os algoritmos de hash válido são <xref:System.Security.Cryptography.SHA1> e <xref:System.Security.Cryptography.MD5>. O identificador de algoritmo pode ser derivado do nome do hash usando o <xref:System.Security.Cryptography.CryptoConfig.MapNameToOID%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash%2A> método para verificar uma assinatura. Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Security.Cryptography.RSACryptoServiceProvider.SignHash%2A> método.  
  
 [!code-cpp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CPP/class1.cpp#2)]
 [!code-csharp[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/CS/class1.cs#2)]
 [!code-vb[System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Security.Cryptography.RSACryptoServiceProvider ManualHash Example/VB/class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="rgbHash" /> é <see langword="null" />.  
  
 -ou-  
  
 O parâmetro <paramref name="rgbSignature" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">O CSP (provedor de serviços de criptografia) não pode ser adquirido.  
  
 -ou-  
  
 A assinatura não pode ser verificada.</exception>
      </Docs>
    </Member>
    <Member MemberName="VerifyHash">
      <MemberSignature Language="C#" Value="public override bool VerifyHash (byte[] hash, byte[] signature, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, System.Security.Cryptography.RSASignaturePadding padding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool VerifyHash(unsigned int8[] hash, unsigned int8[] signature, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, class System.Security.Cryptography.RSASignaturePadding padding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.RSACryptoServiceProvider.VerifyHash(System.Byte[],System.Byte[],System.Security.Cryptography.HashAlgorithmName,System.Security.Cryptography.RSASignaturePadding)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Csp</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hash" Type="System.Byte[]" />
        <Parameter Name="signature" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="padding" Type="System.Security.Cryptography.RSASignaturePadding" />
      </Parameters>
      <Docs>
        <param name="hash">O valor de hash dos dados assinados.</param>
        <param name="signature">Os dados de assinatura a ser verificado.</param>
        <param name="hashAlgorithm">O nome de algoritmo de hash usado para criar o valor de hash.</param>
        <param name="padding">O preenchimento.</param>
        <summary>Verifica se uma assinatura digital é válida determinando o valor de hash na assinatura usando o preenchimento e algoritmo de hash especificados e comparando-o com o valor de hash fornecido.</summary>
        <returns>
          <see langword="true" /> se a assinatura for válida; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="hashAlgorithm" /> é <see langword="null" /> ou <see cref="F:System.String.Empty" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="hash" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="padding" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <paramref name="padding" />não é igual a <see cref="P:System.Security.Cryptography.RSASignaturePadding.Pkcs1" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
