<Type Name="CompositeDuplexBindingElement" FullName="System.ServiceModel.Channels.CompositeDuplexBindingElement">
  <TypeSignature Language="C#" Value="public sealed class CompositeDuplexBindingElement : System.ServiceModel.Channels.BindingElement, System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit CompositeDuplexBindingElement extends System.ServiceModel.Channels.BindingElement implements class System.ServiceModel.Description.IPolicyExportExtension" />
  <TypeSignature Language="DocId" Value="T:System.ServiceModel.Channels.CompositeDuplexBindingElement" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ServiceModel.Channels.BindingElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ServiceModel.Description.IPolicyExportExtension</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa o elemento de associação que é usado quando o cliente deve expor um ponto de extremidade para o serviço enviar mensagens de volta ao cliente.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso é normalmente usado com transportes, como HTTP, que não permitem a comunicação duplex nativamente. TCP, por outro lado, permitir a comunicação duplex nativamente e, portanto, não exigir o uso desse elemento de associação para o serviço para enviar mensagens de volta para um cliente.  
  
 O cliente deve expor um endereço no qual o serviço pode contatar para estabelecer uma conexão do serviço para o cliente. Este endereço de cliente é fornecido pelo <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress%2A> propriedade. Observe que [!INCLUDE[indigo1](~/includes/indigo1-md.md)] gera automaticamente um <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress%2A> se um não for explicitamente definido pelo usuário.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CompositeDuplexBindingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.ServiceModel.Channels.CompositeDuplexBindingElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt; BuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelFactory`1&lt;!!TChannel&gt; BuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.BuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelFactory&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">O <see cref="T:System.ServiceModel.Channels.IChannel" /> produzidos pela fábrica.</typeparam>
        <param name="context">O <see cref="T:System.ServiceModel.Channels.BindingContext" /> que fornece o contexto necessário para criar a fábrica de canais.</param>
        <summary>Retorna uma fábrica de canais que pode criar um canal duplex composto.</summary>
        <returns>Um <see cref="T:System.ServiceModel.Channels.IChannelFactory`1" /> que cria um canal duplex composto do tipo <paramref name="TChannel" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O contexto de compilação requer um <xref:System.ServiceModel.Channels.IOutputChannel> para o `TChannel`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="TChannel" /> não é do tipo <see cref="T:System.ServiceModel.Channels.IOutputChannel" /> e não é suportado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt; BuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.IChannelListener`1&lt;!!TChannel&gt; BuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.BuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.IChannelListener&lt;TChannel&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">O <see cref="T:System.ServiceModel.Channels.IChannel" /> que aceita o ouvinte.</typeparam>
        <param name="context">O <see cref="T:System.ServiceModel.Channels.BindingContext" /> que fornece o contexto necessário para criar o ouvinte de canal.</param>
        <summary>Retorna um ouvinte de canal que pode aceitar um canal duplex composto.</summary>
        <returns>Um <see cref="T:System.ServiceModel.Channels.IChannelListener`1" /> que aceita um canal duplex composto do tipo <paramref name="TChannel" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O contexto de compilação requer um <xref:System.ServiceModel.Channels.IInputChannel> para o `TChannel`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="TChannel" /> não é do tipo <see cref="T:System.ServiceModel.Channels.IInputChannel" /> e não é suportado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelFactory&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelFactory&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelFactory&lt;TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.CanBuildChannelFactory``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">O <see cref="T:System.ServiceModel.Channels.IChannel" /> que produz a fábrica de canais.</typeparam>
        <param name="context">O <see cref="T:System.ServiceModel.Channels.BindingContext" /> que fornece o contexto necessário para criar o ouvinte de canal.</param>
        <summary>Retorna um valor que indica se a associação pode criar a fábrica de canais que produz um tipo específico de canal que satisfaz os requisitos de contexto.</summary>
        <returns>
          <see langword="true" />Se a associação pode criar a fábrica de canais; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`Se `TChannel`  ==  <xref:System.ServiceModel.Channels.IOutputChannel> e também pode criar a ligação interna <xref:System.ServiceModel.Channels.IOutputChannel>; caso contrário, `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CanBuildChannelListener&lt;TChannel&gt;">
      <MemberSignature Language="C#" Value="public override bool CanBuildChannelListener&lt;TChannel&gt; (System.ServiceModel.Channels.BindingContext context) where TChannel : class, System.ServiceModel.Channels.IChannel;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool CanBuildChannelListener&lt;class (class System.ServiceModel.Channels.IChannel) TChannel&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.CanBuildChannelListener``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TChannel">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
            <InterfaceName>System.ServiceModel.Channels.IChannel</InterfaceName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="TChannel">O <see cref="T:System.ServiceModel.Channels.IChannel" /> que aceita o ouvinte.</typeparam>
        <param name="context">O <see cref="T:System.ServiceModel.Channels.BindingContext" /> que fornece o contexto necessário para criar o ouvinte de canal.</param>
        <summary>Retorna um valor que indica se a associação pode criar o ouvinte de canal que aceita um tipo específico de canal que satisfaz os requisitos de contexto.</summary>
        <returns>
          <see langword="true" />Se o ouvinte de canal pode ser criado para a compilação deve aceitar o tipo especificado de canal. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `true`Se `TChannel`  ==  <xref:System.ServiceModel.Channels.IInputChannel> e também pode criar a ligação interna <xref:System.ServiceModel.Channels.IInputChannel>; caso contrário, `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ClientBaseAddress">
      <MemberSignature Language="C#" Value="public Uri ClientBaseAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri ClientBaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o endereço base para o cliente.</summary>
        <value>Um <see cref="T:System.Uri" /> que contém o endereço base para o cliente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade fornece um endereço no qual o serviço pode entrar em contato com o cliente. Um `null` valor faz com que o sistema gerar automaticamente um endereço base do cliente.  
  
 Este é um endereço base, não um endereço absoluto. Um GUID é acrescentado ao endereço base ao gerar os pontos de extremidade de ligação.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public override System.ServiceModel.Channels.BindingElement Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.ServiceModel.Channels.BindingElement Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ServiceModel.Channels.BindingElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um clone profundo do elemento de associação atual.</summary>
        <returns>Um <see cref="T:System.ServiceModel.Channels.CompositeDuplexBindingElement" /> que é um clone profundo do elemento de associação atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Retornar um clone permite que o tempo de execução suportar o caso em que várias associações personalizadas compartilham um elemento de associação personalizada. Se um clone não for retornado, o comportamento de tempo de execução é indefinido.  
  
 Um clone profundo de um objeto cria uma cópia do objeto e uma cópia de tudo direta ou indiretamente referenciado por esse objeto. (Isso também é chamado copiar o gráfico de objeto inteiro.) Um clone superficial de um objeto, por outro lado, é uma cópia do objeto somente. Se o objeto contiver referências a outros objetos, a cópia superficial não cria cópias dos objetos chamados; em vez disso, ele copia somente as referências a objetos originais. Em particular, o copiará um profundo <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement> copia sobre a <xref:System.ServiceModel.Channels.CompositeDuplexBindingElement.ClientBaseAddress%2A> valor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetProperty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public override T GetProperty&lt;T&gt; (System.ServiceModel.Channels.BindingContext context) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance !!T GetProperty&lt;class T&gt;(class System.ServiceModel.Channels.BindingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.GetProperty``1(System.ServiceModel.Channels.BindingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="context" Type="System.ServiceModel.Channels.BindingContext" />
      </Parameters>
      <Docs>
        <typeparam name="T">O objeto com tipo com o suporte está sendo testado.</typeparam>
        <param name="context">O <see cref="T:System.ServiceModel.Channels.BindingContext" /> que fornece o contexto necessário para criar o canal.</param>
        <summary>Retorna um objeto de tipo solicitado da camada apropriada em uma das pilhas de canais.</summary>
        <returns>O objeto de tipo <paramref name="T" /> solicitado se ele tem suporte; ou <see langword="null" /> se não for.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use isto para solicitar um objeto com tipo, como uma interface para definir propriedades ou obter status da camada de apropriado na associação empilhada. Se uma camada de suporte para retornar o objeto solicitado, ele retorna. Caso contrário, ela delega a chamada para a próxima camada da pilha. Se ele obtém a parte inferior da pilha e dá suporte a nenhuma camada, obtendo o objeto solicitado, em seguida, o chamador é retornado um `null` valor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy">
      <MemberSignature Language="C#" Value="void IPolicyExportExtension.ExportPolicy (System.ServiceModel.Description.MetadataExporter exporter, System.ServiceModel.Description.PolicyConversionContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ServiceModel.Description.IPolicyExportExtension.ExportPolicy(class System.ServiceModel.Description.MetadataExporter exporter, class System.ServiceModel.Description.PolicyConversionContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceModel.Channels.CompositeDuplexBindingElement.System#ServiceModel#Description#IPolicyExportExtension#ExportPolicy(System.ServiceModel.Description.MetadataExporter,System.ServiceModel.Description.PolicyConversionContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exporter" Type="System.ServiceModel.Description.MetadataExporter" />
        <Parameter Name="context" Type="System.ServiceModel.Description.PolicyConversionContext" />
      </Parameters>
      <Docs>
        <param name="exporter">O <see cref="T:System.ServiceModel.Description.MetadataExporter" /> que você pode usar para modificar o processo de exportação.</param>
        <param name="context">O <see cref="T:System.ServiceModel.Description.PolicyConversionContext" /> que você pode usar para inserir a declaração de política personalizada.</param>
        <summary>Exporta as declarações de políticas personalizadas sobre associações que representam a presença de duplex composto na associação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [!INCLUDE[crdefault](~/includes/crdefault-md.md)] <xref:System.ServiceModel.Description.IPolicyExportExtension>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="context" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
