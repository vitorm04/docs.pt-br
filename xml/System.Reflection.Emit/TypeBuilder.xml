<Type Name="TypeBuilder" FullName="System.Reflection.Emit.TypeBuilder">
  <TypeSignature Language="C#" Value="public sealed class TypeBuilder : System.Reflection.TypeInfo, System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit TypeBuilder extends System.Reflection.TypeInfo implements class System.Runtime.InteropServices._TypeBuilder" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.TypeBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Emit</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.TypeInfo</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netcore-2.0">System.Type</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._TypeBuilder</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._TypeBuilder))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Define e cria novas instâncias de classes no tempo de execução.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Reflection.Emit.TypeBuilder>a classe raiz é usada para controlar a criação de classes dinâmicas em tempo de execução. Ele fornece um conjunto de rotinas que são usados para definir classes, adicionar os métodos e campos e criar a classe dentro de um módulo. Um novo <xref:System.Reflection.Emit.TypeBuilder> podem ser criados a partir de um módulo dinâmico chamando o <xref:System.Reflection.Emit.ModuleBuilder.DefineType%2A?displayProperty=nameWithType> método, que retorna um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Emissão de reflexão fornece as seguintes opções para definir tipos:  
  
-   Defina uma classe ou interface com o nome fornecido.  
  
-   Defina uma classe ou interface com o nome e atributos.  
  
-   Defina uma classe com o nome fornecido, atributos e classe base.  
  
-   Defina uma classe com o nome fornecido, atributos, a classe base e o conjunto de interfaces que a classe implementa.  
  
-   Defina uma classe com o nome fornecido, atributos, a classe base e tamanho de pacote.  
  
-   Defina uma classe com o nome fornecido, atributos, a classe base e o tamanho de classe como um todo.  
  
-   Defina uma classe com o nome fornecido, atributos, a classe base, tamanho de pacote e o tamanho de classe como um todo.  
  
 Para criar um tipo de matriz, um tipo de ponteiro ou um tipo byref para um tipo incompleto é representado por um <xref:System.Reflection.Emit.TypeBuilder> de objeto, use o <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método, ou <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método, respectivamente.  
  
 Antes de um tipo é usado, o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A?displayProperty=nameWithType> método deve ser chamado. **CreateType** concluir a criação do tipo. Após a chamada ao **CreateType**, o chamador pode instanciar o tipo usando o <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método e chamar membros do tipo usando o <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> método. É um erro para invocar métodos que alteram a implementação de um tipo após **CreateType** foi chamado. Por exemplo, o common language runtime gera uma exceção se o chamador tenta adicionar novos membros a um tipo.  
  
 Um inicializador de classe é criado usando o <xref:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer%2A?displayProperty=nameWithType> método. **DefineTypeInitializer** retorna um <xref:System.Reflection.Emit.ConstructorBuilder> objeto.  
  
 Tipos aninhados são definidos chamando um do <xref:System.Reflection.Emit.TypeBuilder.DefineNestedType%2A?displayProperty=nameWithType> métodos.  
  
## <a name="attributes"></a>Atributos  
 O <xref:System.Reflection.Emit.TypeBuilder> classe usa a <xref:System.Reflection.TypeAttributes> enumeração para especificar as características do tipo a ser criado:  
  
-   Interfaces são especificadas usando o <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> e <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> atributos.  
  
-   Classes concretas (classes que não podem ser estendidos) são especificados usando o <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> atributo.  
  
-   Vários atributos determinam a visibilidade do tipo. Consulte a descrição do <xref:System.Reflection.TypeAttributes> enumeração.  
  
-   Se <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> for especificado, o carregador de classe dispõe campos na ordem em que elas são de leitura de metadados. O carregador de classe considera o tamanho de pacote especificado, mas ignora qualquer deslocamentos de campo especificado. Os metadados preserva a ordem em que as definições de campo são emitidas. Mesmo em uma mesclagem, os metadados não reorganizará as definições de campo. O carregador respeitará de deslocamentos de campo especificado somente se <xref:System.Reflection.TypeAttributes?displayProperty=nameWithType> for especificado.  
  
## <a name="known-issues"></a>Problemas conhecidos  
  
-   Emissão de reflexão não verifica se uma classe não abstrata que implementa uma interface implementou todos os métodos declarados na interface. No entanto, se a classe não implementa todos os métodos declarados em uma interface, o tempo de execução não carregar a classe.  
  
-   Embora <xref:System.Reflection.Emit.TypeBuilder> é derivado do <xref:System.Type>, alguns dos métodos abstratos definidos no <xref:System.Type> classe não são totalmente implementado o <xref:System.Reflection.Emit.TypeBuilder> classe. Chamadas para esses <xref:System.Reflection.Emit.TypeBuilder> métodos lançam uma <xref:System.NotSupportedException> exceção. A funcionalidade desejada pode ser obtida por recuperar o tipo criado usando o <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e refletir o tipo recuperado.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo mostra como criar um tipo dinâmico com um campo, construtor, propriedade e método. O segundo exemplo cria um método dinamicamente da entrada do usuário.  
  
 **Exemplo de um**  
  
 O exemplo de código a seguir mostra como definir um assembly dinâmico com um módulo. O módulo no assembly de exemplo contém um tipo, `MyDynamicType`, que tem um campo particular, uma propriedade que obtém e define o campo privado, construtores que inicializar o campo privado e um método que multiplica um número fornecido pelo usuário pelo campo particular valor e retorna o resultado.  
  
 O <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> campo for especificado quando o assembly é criado. O código do assembly é usado imediatamente, e o assembly também é salvas em disco para que ele pode ser examinado com [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) ou usado em outro programa.  
  
 [!code-cpp[AssemblyBuilderClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyBuilderClass/cpp/24895.cpp#1)]
 [!code-csharp[AssemblyBuilderClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyBuilderClass/cs/24895.cs#1)]
 [!code-vb[AssemblyBuilderClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyBuilderClass/vb/24895.vb#1)]  
  
 **Exemplo de dois**  
  
 O exemplo de código a seguir demonstra como criar um tipo dinâmico usando `TypeBuilder`.  
  
 [!code-cpp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit ILGenerator Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit ILGenerator Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TypeBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddDeclarativeSecurity">
      <MemberSignature Language="C#" Value="public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddDeclarativeSecurity(valuetype System.Security.Permissions.SecurityAction action, class System.Security.PermissionSet pset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddDeclarativeSecurity(System.Security.Permissions.SecurityAction,System.Security.PermissionSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="action" Type="System.Security.Permissions.SecurityAction" />
        <Parameter Name="pset" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="action">A ação de segurança a ser executada como demanda, Assert e assim por diante.</param>
        <param name="pset">O conjunto de permissões que a ação se aplica.</param>
        <summary>Adiciona a segurança declarativa para este tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `AddDeclarativeSecurity`pode ser chamado várias vezes com cada chamada especificando uma ação de segurança (como a demanda, Assert ou negar) e um conjunto de permissões que se aplicam à ação.  
  
> [!NOTE]
>  Nas versões do .NET Framework 1.0, 1.1 e 2.0, os atributos de segurança declarativa aplicados a um tipo usando esse método são armazenados no formato de metadados XML antigo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do `AddDeclarativeSecurity` método para adicionar uma exigência de segurança para <xref:System.Security.Permissions.SecurityPermission> com o <xref:System.Security.Permissions.SecurityPermissionFlag?displayProperty=nameWithType> sinalizador para um tipo dinâmico chamado `MyDynamicClass`, em um assembly nomeado EmittedExample.dll. O exemplo não produz nenhuma saída do console; Depois que você executá-lo, você pode usar [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar EmittedExample.dll. Em `MyDynamicClass`, abra o `.class public auto ansi` instrução para verificar a permissão declarativa.  
  
 [!code-cpp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CPP/typebuilder_adddeclarativesecurity.cpp#1)]
 [!code-csharp[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/CS/typebuilder_adddeclarativesecurity.cs#1)]
 [!code-vb[TypeBuilder_AddDeclarativeSecurity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_AddDeclarativeSecurity/VB/typebuilder_adddeclarativesecurity.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O <paramref name="action" /> é inválido (<see langword="RequestMinimum" />, <see langword="RequestOptional" />, e <see langword="RequestRefuse" /> são inválidos).</exception>
        <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 O conjunto de permissões <paramref name="pset" /> contém uma ação que foi adicionada anteriormente pelo <see langword="AddDeclarativeSecurity" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="pset" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddInterfaceImplementation">
      <MemberSignature Language="C#" Value="public void AddInterfaceImplementation (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddInterfaceImplementation(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.AddInterfaceImplementation(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">A interface implementada por esse tipo.</param>
        <summary>Adiciona uma interface implementada por esse tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra a implementação de uma interface em um tipo criado dinamicamente usando `AddInterfaceImplementation`.  
  
 [!code-cpp[TypeBuilder_Sample_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#3)]
 [!code-csharp[TypeBuilder_Sample_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#3)]
 [!code-vb[TypeBuilder_Sample_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="interfaceType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public override System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Assembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o assembly dinâmico que contém esta definição de tipo.</summary>
        <value>Somente leitura. Recupera o assembly dinâmico que contém esta definição de tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public override string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o nome completo deste tipo qualificado pelo nome de exibição do assembly.</summary>
        <value>Somente leitura. O nome completo deste tipo qualificado pelo nome de exibição do assembly.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formato de cadeia de caracteres retornada é a concatenação do nome completo do tipo (<xref:System.Reflection.Emit.TypeBuilder.FullName%2A>) e o nome para exibição do assembly (<xref:System.Reflection.AssemblyName.FullName%2A?displayProperty=nameWithType>), separados por uma vírgula e um espaço.  
  
 Consulte <xref:System.Reflection.AssemblyName> para obter uma descrição do formato do nome para exibição de um assembly.  
  
## <a name="version-information"></a>Informações de versão  
 Nas versões do .NET Framework 1.0 e 1.1, o valor dessa propriedade não inclui a cultura ou chave pública.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Attributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public override Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.BaseType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o tipo base deste tipo.</summary>
        <value>Somente leitura. Recupera o tipo base deste tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateType">
      <MemberSignature Language="C#" Value="public Type CreateType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type CreateType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um objeto <see cref="T:System.Type" /> para a classe. Depois de definir campos e métodos na classe, <see langword="CreateType" /> é chamado para carregar seu objeto <see langword="Type" />.</summary>
        <returns>Retorna o novo objeto <see cref="T:System.Type" /> dessa classe.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse tipo é um tipo aninhado, a <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método deve ser chamado em um tipo delimitador antes do tipo aninhado for chamado.  
  
 Se o tipo atual deriva de um tipo incompleto ou implementa as interfaces incompletas, chame o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método no tipo de pai e os tipos de interface antes de ele chamar o tipo atual.  
  
 Se o tipo de delimitador contém um campo que é um tipo de valor definido como um tipo aninhado (por exemplo, um campo que é uma enumeração definida como um tipo aninhado), chamando o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método do tipo delimitador gerará um <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos. Isso ocorre porque o carregador não é possível determinar o tamanho do tipo delimitador até que o tipo aninhado foi concluído. O chamador deve definir um manipulador para o <xref:System.AppDomain.TypeResolve> evento para concluir a definição do tipo aninhado chamando <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> no <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo aninhado. O exemplo de código para este tópico mostra como definir essa um manipulador de eventos.  
  
 Um tipo é criado apenas uma vez, não importa como quantas vezes o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método é chamado. Todas as chamadas retornam o mesmo <xref:System.Type> objeto.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como definir um manipulador de eventos para o <xref:System.AppDomain.TypeResolve?displayProperty=nameWithType> eventos, para chamar o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método em um tipo aninhado durante um <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> ligar o tipo de delimitador.  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CPP/nestedenum.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/CS/nestedenum.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.CreateType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.TypeBuilder.CreateType Example/VB/nestedenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo delimitador não foi criado.  
  
 -ou-  
  
 Esse tipo é não abstrato e contém um método abstrato.  
  
 -ou-  
  
 Esse tipo não é uma classe abstrata nem uma interface e tem um método sem um corpo do método.</exception>
        <exception cref="T:System.NotSupportedException">O tipo contém código MSIL (Microsoft Intermediate Language) inválido.  
  
 -ou-  
  
 O destino da ramificação é especificado usando um deslocamento de 1 byte, mas está em uma distância maior que 127 bytes da ramificação.</exception>
        <exception cref="T:System.TypeLoadException">O tipo não pode ser carregado. Por exemplo, contém um método <see langword="static" /> com a convenção de chamada <see cref="F:System.Reflection.CallingConventions.HasThis" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateTypeInfo">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeInfo CreateTypeInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.TypeInfo CreateTypeInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.CreateTypeInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um <see cref="T:System.Reflection.TypeInfo" /> que representa este tipo de objeto.</summary>
        <returns>Um objeto que representa esse tipo.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o método que declarado atual do parâmetro de tipo genérico.</summary>
        <value>Um <see cref="T:System.Reflection.MethodBase" /> que representa o método que é declarado como tipo atual, se o tipo atual é um parâmetro de tipo genérico; caso contrário, <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.DeclaringType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o tipo declarado desse tipo.</summary>
        <value>Somente leitura. O tipo que este tipo declarado.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="attributes">Os atributos do construtor.</param>
        <param name="callingConvention">A convenção de chamada do construtor.</param>
        <param name="parameterTypes">Os tipos de parâmetro do construtor.</param>
        <summary>Adiciona um novo construtor ao tipo, com a assinatura e os atributos determinados.</summary>
        <returns>O construtor definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não definir um construtor para o tipo dinâmico, um construtor padrão é fornecido automaticamente, e ele chama o construtor padrão da classe base.  
  
 Se você definir um construtor para o tipo dinâmico, não é fornecido um construtor padrão. Você tem as seguintes opções para fornecer um construtor padrão, além de construtor definido:  
  
-   Se você quiser um construtor padrão que simplesmente chama o construtor padrão da classe base, você pode usar o <xref:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor%2A> método para criar um (e opcionalmente restringir o acesso a ele). Não fornece uma implementação para esse construtor padrão. Se você fizer isso, uma exceção é lançada quando você tentar usar o construtor. Nenhuma exceção é lançada quando o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método é chamado.  
  
-   Se você quiser um construtor padrão que não algo mais do que simplesmente chamar o construtor padrão da classe base, ou que chama outro construtor de classe base ou que faz outra coisa totalmente, você deve usar o <xref:System.Reflection.Emit.TypeBuilder.DefineConstructor%2A?displayProperty=nameWithType> método para criar um e fornecer sua própria implementação.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de `DefineConstructor` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar correspondente <xref:System.Reflection.Emit.ConstructorBuilder> para população MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineConstructor (System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type[] parameterTypes, Type[][] requiredCustomModifiers, Type[][] optionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineConstructor(valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type[] parameterTypes, class System.Type[][] requiredCustomModifiers, class System.Type[][] optionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineConstructor(System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="attributes">Os atributos do construtor.</param>
        <param name="callingConvention">A convenção de chamada do construtor.</param>
        <param name="parameterTypes">Os tipos de parâmetro do construtor.</param>
        <param name="requiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <param name="optionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <summary>Adiciona um novo construtor para o tipo, com determinados atributos, assinatura e modificadores personalizados.</summary>
        <returns>O construtor definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para os designers de compiladores gerenciados.  
  
> [!NOTE]
>  Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II. A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="requiredCustomModifiers" /> ou <paramref name="optionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDefaultConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor (System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineDefaultConstructor(valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineDefaultConstructor(System.Reflection.MethodAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="attributes">Um <see langword="MethodAttributes" /> que representa os atributos a serem aplicadas para o construtor do objeto.</param>
        <summary>Define o construtor padrão. O construtor definido aqui serão simplesmente chamar o construtor padrão do pai.</summary>
        <returns>Retorna o construtor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como o construtor padrão é definido automaticamente, é necessário chamar esse método somente nas seguintes situações:  
  
-   Você definiu outro construtor e você deseja que um construtor padrão que simplesmente chama o construtor de classe base.  
  
-   Para definir os atributos em que o construtor padrão para algo diferente de <xref:System.Reflection.MethodAttributes.PrivateScope>, <xref:System.Reflection.MethodAttributes.Public>, <xref:System.Reflection.MethodAttributes.HideBySig>, <xref:System.Reflection.MethodAttributes.SpecialName>, e <xref:System.Reflection.MethodAttributes.RTSpecialName>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de `DefineConstructor` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar correspondente <xref:System.Reflection.Emit.ConstructorBuilder> para população MSIL.  
  
 [!code-cpp[TypeBuilder_Sample_4#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Sample_4/CPP/typebuilder_sample_4.cpp#2)]
 [!code-csharp[TypeBuilder_Sample_4#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Sample_4/CS/typebuilder_sample_4.cs#2)]
 [!code-vb[TypeBuilder_Sample_4#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Sample_4/VB/typebuilder_sample_4.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O tipo de pai (tipo base) não tem um construtor padrão.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.EventBuilder DefineEvent (string name, System.Reflection.EventAttributes attributes, Type eventtype);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.EventBuilder DefineEvent(string name, valuetype System.Reflection.EventAttributes attributes, class System.Type eventtype) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineEvent(System.String,System.Reflection.EventAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.EventBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.EventAttributes" />
        <Parameter Name="eventtype" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">O nome do evento. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do evento.</param>
        <param name="eventtype">O tipo do evento.</param>
        <summary>Adiciona um novo evento no tipo, nome, tipo de evento e atributos.</summary>
        <returns>O evento definido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="eventtype" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">O nome do campo. <c>nome do campo</c> não pode conter nulos incorporados.</param>
        <param name="type">O tipo do campo</param>
        <param name="attributes">Os atributos do campo.</param>
        <summary>Adiciona um novo campo para o tipo, com o nome fornecido, atributos e tipo de campo.</summary>
        <returns>O campo definido.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="fieldName" /> é zero.  
  
 -ou-  
  
 <paramref name="type" />é System. void.  
  
 -ou-  
  
 Um tamanho total especificado para a classe pai do campo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineField">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineField (string fieldName, Type type, Type[] requiredCustomModifiers, Type[] optionalCustomModifiers, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineField(string fieldName, class System.Type type, class System.Type[] requiredCustomModifiers, class System.Type[] optionalCustomModifiers, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineField(System.String,System.Type,System.Type[],System.Type[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fieldName" Type="System.String" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="requiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="optionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="fieldName">O nome do campo. <c>nome do campo</c> não pode conter nulos incorporados.</param>
        <param name="type">O tipo do campo</param>
        <param name="requiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados necessários para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="optionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais para o campo, como <see cref="T:Microsoft.VisualC.IsConstModifier" />.</param>
        <param name="attributes">Os atributos do campo.</param>
        <summary>Adiciona um novo campo para o tipo, com o nome fornecido, atributos, tipo de campo e modificadores personalizados.</summary>
        <returns>O campo definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para os designers de compiladores gerenciados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="fieldName" /> é zero.  
  
 -ou-  
  
 <paramref name="type" />é System. void.  
  
 -ou-  
  
 Um tamanho total especificado para a classe pai do campo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="fieldName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineGenericParameters">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (params string[] names);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters(string[] names) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineGenericParameters(System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.GenericTypeParameterBuilder[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="names" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="names">Uma matriz de nomes para os parâmetros de tipo genérico.</param>
        <summary>Define os parâmetros de tipo genérico para o tipo atual, especificando o número e seus nomes e retorna uma matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que podem ser usados para definir suas restrições.</summary>
        <returns>Uma matriz de <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /> objetos que podem ser usados para definir as restrições dos parâmetros de tipo genérico para o tipo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar esse método torna o tipo atual em um tipo genérico. Se o método é chamado novamente do mesmo tipo, um <xref:System.InvalidOperationException> é gerada.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um tipo genérico com dois parâmetros de tipo e salva-os no assembly GenericEmitExample1.dll. Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para exibir os tipos gerados. Para obter uma explicação mais detalhada das etapas envolvidas na definição de um tipo genérico dinâmico, consulte [como: definir um tipo genérico com emissão de reflexão](~/docs/framework/reflection-and-codedom/how-to-define-a-generic-type-with-reflection-emit.md).  
  
 [!code-cpp[EmitGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR/EmitGenericType/CPP/source.cpp#1)]
 [!code-csharp[EmitGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR/EmitGenericType/CS/source.cs#1)]
 [!code-vb[EmitGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EmitGenericType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Parâmetros de tipo genérico já tem foi definidos para este tipo.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="names" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="names" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="names" />é uma matriz vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineInitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineInitializedData (string name, byte[] data, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineInitializedData(string name, unsigned int8[] data, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineInitializedData(System.String,System.Byte[],System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Byte[]" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome usado para fazer referência aos dados. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="data">O blob de dados.</param>
        <param name="attributes">Os atributos do campo.</param>
        <summary>Define o campo de dados inicializado na seção de .sdata do arquivo PE (executável portátil).</summary>
        <returns>Um campo de dados de referência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O campo que você criar com esse método será `static`, mesmo se você não incluir `FieldAttributes.Static` no `attributes` parâmetro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="name" /> é zero.  
  
 -ou-  
  
 O tamanho dos dados é menor ou igual a zero, ou maior que ou igual a 0x3f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="data" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />foi chamado anteriormente.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do método.</param>
        <summary>Adiciona um novo método para o tipo, com os atributos de nome e o método especificados.</summary>
        <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga de método quando você não souber a assinatura do método no momento em que você definir o método. Por exemplo, os tipos de parâmetro e tipo de retorno de um método genérico podem ser especificados pelos parâmetros de tipo genérico do método, que devem ser definidos depois que o método foi adicionado para o tipo. Os parâmetros e o tipo de retorno do método podem ser definidos mais tarde usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.  
  
 Essa sobrecarga de método define um método com <xref:System.Reflection.CallingConventions?displayProperty=nameWithType>. Se você precisa definir um método sem uma assinatura, com uma convenção de chamada diferente, use o <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecarga do método.  
  
   
  
## Examples  
 O exemplo de código a seguir define um método genérico chamado `DemoMethod` cujo tipo de parâmetro e tipo de retorno são especificados por seus parâmetros de tipo genérico. O método está definido sem uma assinatura, usando a convenção de chamada padrão. O <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método é usado para fazer `DemoMethod` um método genérico e os parâmetros de tipo definidos recentemente são usados para a assinatura e tipo de retorno.  
  
 Este exemplo de código é parte de um exemplo maior fornecido para o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A> método.  
  
 [!code-cpp[GenericMethodBuilder#4](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#4)]
 [!code-csharp[GenericMethodBuilder#4](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#4)]
 [!code-vb[GenericMethodBuilder#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#4)]  
[!code-cpp[GenericMethodBuilder#3](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#3)]
[!code-csharp[GenericMethodBuilder#3](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#3)]
[!code-vb[GenericMethodBuilder#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#3)]  
[!code-cpp[GenericMethodBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/GenericMethodBuilder/cpp/source.cpp#5)]
[!code-csharp[GenericMethodBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/GenericMethodBuilder/CS/source.cs#5)]
[!code-vb[GenericMethodBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/GenericMethodBuilder/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.  
  
 -ou-  
  
 O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <summary>Adiciona um novo método para o tipo, com o nome especificado, os atributos de método e convenção de chamada.</summary>
        <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga de método quando você não souber a assinatura do método no momento em que você definir o método. Por exemplo, os tipos de parâmetro e tipo de retorno de um método genérico podem ser especificados pelos parâmetros de tipo genérico do método, que devem ser definidos depois que o método foi adicionado para o tipo. Os parâmetros e o tipo de retorno do método podem ser definidos mais tarde usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.  
  
 -ou-  
  
 O tipo do pai deste método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
        <summary>Adiciona um novo método para o tipo, com o nome especificado, os atributos de método e a assinatura do método.</summary>
        <returns>O método definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra o uso de `DefineMethod` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar um correspondente <xref:System.Reflection.Emit.MethodBuilder> para população MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.  
  
 -ou-  
  
 O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
        <summary>Adiciona um novo método ao tipo, com o nome, atributos de método, convenção de chamada e assinatura de método especificados.</summary>
        <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método recém-definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra o uso de `DefineMethod` para definir um construtor determinada assinatura e atributos em um tipo dinâmico e retornar um correspondente <xref:System.Reflection.Emit.MethodBuilder> para população MSIL.  
  
 [!code-cpp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CPP/typebuilder_definenestedtype1.cpp#2)]
 [!code-csharp[TypeBuilder_DefineNestedType1#2](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/CS/typebuilder_definenestedtype1.cs#2)]
 [!code-vb[TypeBuilder_DefineNestedType1#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineNestedType1/VB/typebuilder_definenestedtype1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.  
  
 -ou-  
  
 O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefineMethod (string name, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefineMethod(string name, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethod(System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Os tipos dos parâmetros do método.</param>
        <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <summary>Adiciona um novo método para o tipo, com o nome especificado, os atributos de método, chamando convenção, assinatura de método e modificadores personalizados.</summary>
        <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> objeto que representa o método recém-adicionada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga se você precisar especificar modificadores personalizados. Se você precisa especificar modificadores personalizados depois que o método tiver sido criado, como, por exemplo, com um método genérico cujos tipos de parâmetro são especificados por seus parâmetros de tipo genérico, você pode usar o <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%29> ou <xref:System.Reflection.Emit.TypeBuilder.DefineMethod%28System.String%2CSystem.Reflection.MethodAttributes%2CSystem.Reflection.CallingConventions%29> sobrecargas do método para definir o método e, em seguida, use o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método para definir o parâmetro e retornar tipos com modificadores personalizados.  
  
> [!NOTE]
>  Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II. A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.  
  
 -ou-  
  
 O tipo de pai desse método é uma interface e esse método não é virtual (<see langword="Overridable" /> no Visual Basic).  
  
 -ou-  
  
 O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineMethodOverride">
      <MemberSignature Language="C#" Value="public void DefineMethodOverride (System.Reflection.MethodInfo methodInfoBody, System.Reflection.MethodInfo methodInfoDeclaration);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DefineMethodOverride(class System.Reflection.MethodInfo methodInfoBody, class System.Reflection.MethodInfo methodInfoDeclaration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineMethodOverride(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodInfoBody" Type="System.Reflection.MethodInfo" />
        <Parameter Name="methodInfoDeclaration" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="methodInfoBody">O corpo do método a ser usado. Isso deve ser um objeto <see langword="MethodBuilder" />.</param>
        <param name="methodInfoDeclaration">O método cuja declaração deve ser usada.</param>
        <summary>Especifica um corpo de um determinado método que implementa uma declaração do mesmo, possivelmente com um nome diferente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não use esse método para emitir substituições de método ou implementações de interface. Para substituir um método de uma classe base ou para implementar um método de uma interface, simplesmente emita um método com o mesmo nome e assinatura como o método a ser substituído ou implementada, conforme demonstrado no exemplo de código.  
  
 O <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método é usado quando um corpo de método e uma declaração de método têm nomes diferentes. Por exemplo, uma classe pode substituir um método de classe base e também fornecem uma implementação separada para um membro de interface com o mesmo nome, conforme demonstrado no exemplo de código.  
  
 `DefineMethodOverride`define um `methodimpl`, que consiste em um par de tokens de metadados. Um token aponta para uma implementação e os outros pontos de token para uma declaração que implementa o corpo. O corpo deve ser definido no tipo de implementação de método é definida em e o corpo deve ser virtual (`Overridable` no Visual Basic). A declaração pode ser feita para um método definido em uma interface implementada por um método definido no tipo, um método em uma classe derivada ou o tipo. Se a declaração estiver em apenas uma interface, o slot definido para a interface é alterado. Se a declaração é feita para um método em um tipo base, o slot para o método é substituído e todas as duplicatas para o método substituído também são substituídas. O método substituído não pode ser o método real que é declarado. Se o método é do mesmo tipo, o slot é substituído e todas as duplicatas para os métodos substituídos são substituídas.  
  
> [!NOTE]
>  Para obter mais informações sobre o método impls, consulte `MethodImpl` na documentação do ECMA partição II metadados. A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
> [!IMPORTANT]
>  Após o <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método é chamado, alguns recursos do `methodInfoBody` não pode ser alterado. Por exemplo, você não pode aplicar um atributo a um parâmetro de tipo genérico do `methodInfoBody` usando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder.SetGenericParameterAttributes%2A> método. Se você deve usar o <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método, fazer isso depois de todas as características de `methodInfoBody` foram definidas.  
  
   
  
## Examples  
 O exemplo de código a seguir contém uma interface `I` com um método `M()`, uma classe base `A` que implementa a interface e uma classe derivada `C` que substitui a implementação da classe base `M()` e também Fornece uma implementação explícita separada de `I.M()`.  
  
 O `main()` método do exemplo de código mostra como emissão de classe derivada `C`. A substituição de `A.M()` é obtida simplesmente pela emissão de um método `M()` com a mesma assinatura. No entanto, para fornecer uma implementação separada de `I.M()`, você deve definir um corpo de método e, em seguida, usar o <xref:System.Reflection.Emit.TypeBuilder.DefineMethodOverride%2A> método associar esse corpo de método com um <xref:System.Reflection.MethodInfo> representando `I.M()`. O nome do corpo do método não importa.  
  
 O exemplo de código cria uma instância da classe emitida. Obtém um <xref:System.Reflection.MethodInfo> de objeto para `I.M()`, e a implementação de interface usos para chamar a classe emitida 's explícita. Em seguida, obtém um <xref:System.Reflection.MethodInfo> de objeto para `A.M()`e o usa para invocar a substituição da classe emitido desse método.  
  
 [!code-cpp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cpp/source.cpp#1)]
 [!code-csharp[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/cs/source.cs#1)]
 [!code-vb[TypeBuilder.DefineMethodOverride#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.DefineMethodOverride/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="methodInfoBody" /> não pertence a esta classe.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="methodInfoBody" /> ou <paramref name="methodInfoDeclaration" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 O tipo de declaração de <paramref name="methodInfoBody" /> não é do tipo representado por este <see cref="T:System.Reflection.Emit.TypeBuilder" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome curto do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <summary>Define um tipo aninhado, dado seu nome.</summary>
        <returns>O tipo aninhado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.  
  
 O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.  
  
 Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado. Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Comprimento de <paramref name="name" /> é igual a zero ou maior que 1023.  
  
 -ou-  
  
 Esta operação criará um tipo com uma duplicata <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> no assembly atual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome curto do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo.</param>
        <summary>Define um tipo aninhado, dado seu nome e atributos.</summary>
        <returns>O tipo aninhado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.  
  
 O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.  
  
 Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado. Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.  
  
 -ou-  
  
 Esse tipo está lacrado.  
  
 -ou-  
  
 Esse tipo é uma matriz.  
  
 -ou-  
  
 Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  
  
 -ou-  
  
 O comprimento de <paramref name="name" /> é igual a zero ou maior que 1023.  
  
 -ou-  
  
 Esta operação criará um tipo com uma duplicata <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> no assembly atual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">O nome curto do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo.</param>
        <param name="parent">O tipo que estende o tipo aninhado.</param>
        <summary>Define um tipo aninhado, dado seu nome, atributos e o tipo que ele estende.</summary>
        <returns>O tipo aninhado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.  
  
 O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.  
  
 Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado. Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.  
  
 -ou-  
  
 Esse tipo está lacrado.  
  
 -ou-  
  
 Esse tipo é uma matriz.  
  
 -ou-  
  
 Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  
  
 -ou-  
  
 O comprimento de <paramref name="name" /> é igual a zero ou maior que 1023.  
  
 -ou-  
  
 Esta operação criará um tipo com uma duplicata <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> no assembly atual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">O nome curto do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo.</param>
        <param name="parent">O tipo que estende o tipo aninhado.</param>
        <param name="typeSize">O tamanho total do tipo.</param>
        <summary>Define um tipo aninhado, dado seu nome, atributos, o tamanho total do tipo e o tipo que ele estende.</summary>
        <returns>O tipo aninhado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.  
  
 O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.  
  
 Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado. Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.  
  
 -ou-  
  
 Esse tipo está lacrado.  
  
 -ou-  
  
 Esse tipo é uma matriz.  
  
 -ou-  
  
 Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  
  
 -ou-  
  
 O comprimento de <paramref name="name" /> é igual a zero ou maior que 1023.  
  
 -ou-  
  
 Esta operação criará um tipo com uma duplicata <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> no assembly atual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
      </Parameters>
      <Docs>
        <param name="name">O nome curto do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo.</param>
        <param name="parent">O tipo que estende o tipo aninhado.</param>
        <param name="packSize">O tamanho de remessa do tipo.</param>
        <summary>Define um tipo aninhado, dado seu nome, atributos, o tipo que ele estende e o tamanho de remessa.</summary>
        <returns>O tipo aninhado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.  
  
 O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.  
  
 Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado. Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.  
  
 -ou-  
  
 Esse tipo está lacrado.  
  
 -ou-  
  
 Esse tipo é uma matriz.  
  
 -ou-  
  
 Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  
  
 -ou-  
  
 O comprimento de <paramref name="name" /> é igual a zero ou maior que 1023.  
  
 -ou-  
  
 Esta operação criará um tipo com uma duplicata <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> no assembly atual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, Type[] interfaces);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, class System.Type[] interfaces) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="interfaces" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome curto do tipo. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attr">Os atributos do tipo.</param>
        <param name="parent">O tipo que estende o tipo aninhado.</param>
        <param name="interfaces">As interfaces que implementa o tipo aninhado.</param>
        <summary>Define um tipo aninhado, dado seu nome, atributos, o tipo que ele estende e as interfaces que ele implementa.</summary>
        <returns>O tipo aninhado definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para criar aninhada tipos após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado no tipo de delimitador.  
  
 O tipo aninhado deve ser concluída antes de você pode refletir nele usando <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetNestedType%2A>, ou <xref:System.Type.GetNestedTypes%2A>.  
  
 Consulte a descrição de <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> para a ordem em que devem ser concluídos tipos aninhados e tipos de aninhamento.  
  
 Um nome duplicado não é necessariamente criado se `name` é idêntico ao nome de um tipo definido anteriormente ou tipo aninhado. Para ser duplicados, os nomes completos devem ser o mesmo, incluindo o namespace e todos os tipos de aninhamento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O atributo aninhado não é especificado.  
  
 -ou-  
  
 Esse tipo está lacrado.  
  
 -ou-  
  
 Esse tipo é uma matriz.  
  
 -ou-  
  
 Esse tipo é uma interface, mas o tipo aninhado não é uma interface.  
  
 -ou-  
  
 O comprimento de <paramref name="name" /> é igual a zero ou maior que 1023.  
  
 -ou-  
  
 Esta operação criará um tipo com uma duplicata <see cref="P:System.Reflection.Emit.TypeBuilder.FullName" /> no assembly atual.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 Um elemento de <paramref name="interfaces" /> matriz é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineNestedType">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeBuilder DefineNestedType (string name, System.Reflection.TypeAttributes attr, Type parent, System.Reflection.Emit.PackingSize packSize, int typeSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.TypeBuilder DefineNestedType(string name, valuetype System.Reflection.TypeAttributes attr, class System.Type parent, valuetype System.Reflection.Emit.PackingSize packSize, int32 typeSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineNestedType(System.String,System.Reflection.TypeAttributes,System.Type,System.Reflection.Emit.PackingSize,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attr" Type="System.Reflection.TypeAttributes" />
        <Parameter Name="parent" Type="System.Type" />
        <Parameter Name="packSize" Type="System.Reflection.Emit.PackingSize" />
        <Parameter Name="typeSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="name">O nome curto do tipo. <c>nome</c> não pode conter valores nulos inseridos.</param>
        <param name="attr">Os atributos do tipo.</param>
        <param name="parent">O tipo que estende o tipo aninhado.</param>
        <param name="packSize">O tamanho de remessa do tipo.</param>
        <param name="typeSize">O tamanho total do tipo.</param>
        <summary>Define um tipo aninhado, dado seu nome, atributos, tamanho e o tipo que ele estende.</summary>
        <returns>O tipo aninhado definido.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método <see langword="PInvoke" />. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <param name="nativeCallConv">A convenção de chamada nativa.</param>
        <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
        <summary>Define uma <see langword="PInvoke" /> método recebe seu nome, o nome da DLL no qual o método é definido, os atributos de método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método e o <see langword="PInvoke" /> sinalizadores.</summary>
        <returns>O método <see langword="PInvoke" /> definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns DLL importar atributos (consulte a descrição da <xref:System.Runtime.InteropServices.DllImportAttribute>) não podem ser especificados como argumentos para esse método. Por exemplo, o atributo de importação de DLL <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> deve ser adicionado após o `PInvoke` método é criado, caso o método retorna um valor. O exemplo mostra como fazer isso.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para criar um `PInvoke` método e como adicionar o <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> sinalizador para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType>métodos.  
  
> [!IMPORTANT]
>  Para obter um valor de retorno diferente de zero, você deve adicionar o <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> sinalizador.  
  
 O exemplo cria um assembly dinâmico com um módulo dinâmico e um único tipo, `MyType`, que contém o `PInvoke` método. O `PInvoke` método representa o Win32 `GetTickCount` função.  
  
 Quando o exemplo for executado, ele executa o `PInvoke` método. Ele também salva o assembly dinâmico como PInvokeTest.dll. Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o `MyType` classe e o `static` (`Shared` no Visual Basic) `PInvoke` método nele. Você pode compilar um programa Visual Basic ou c# que usa estático `MyType.GetTickCount` método, incluindo uma referência para a DLL ao executar csc.exe ou vbc.exe; por exemplo, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático.  
  
 - ou -  
  
 O tipo pai é uma interface.  
  
 - ou -  
  
 O método é abstrato.  
  
 -ou-  
  
 O método foi definido anteriormente.  
  
 -ou-  
  
 O comprimento de <paramref name="name" /> ou <paramref name="dllName" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ou <paramref name="dllName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método <see langword="PInvoke" />. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
        <param name="entryName">O nome do ponto de entrada na DLL.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <param name="nativeCallConv">A convenção de chamada nativa.</param>
        <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
        <summary>Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" />.</summary>
        <returns>O método <see langword="PInvoke" /> definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns DLL importar atributos (consulte a descrição da <xref:System.Runtime.InteropServices.DllImportAttribute>) não podem ser especificados como argumentos para esse método. Por exemplo, o atributo de importação de DLL <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> deve ser adicionado após o `PInvoke` método é criado, caso o método retorna um valor. O exemplo mostra como fazer isso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A> método para criar um `PInvoke` método e como adicionar o <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> sinalizador para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.  
  
> [!IMPORTANT]
>  Para obter um valor de retorno diferente de zero, você deve adicionar o <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> sinalizador.  
  
 O exemplo cria um assembly dinâmico com um módulo dinâmico e um único tipo, `MyType`, que contém o `PInvoke` método. O `PInvoke` método representa o Win32 `GetTickCount` função.  
  
 Quando o exemplo for executado, ele executa o `PInvoke` método. Ele também salva o assembly dinâmico como PInvokeTest.dll. Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o `MyType` classe e o `static` (`Shared` no Visual Basic) `PInvoke` método nele. Você pode compilar um programa Visual Basic ou c# que usa estático `MyType.GetTickCount` método, incluindo uma referência para a DLL ao executar csc.exe ou vbc.exe; por exemplo, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático.  
  
 - ou -  
  
 O tipo pai é uma interface.  
  
 - ou -  
  
 O método é abstrato.  
  
 -ou-  
  
 O método foi definido anteriormente.  
  
 - ou -  
  
 O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefinePInvokeMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.MethodBuilder DefinePInvokeMethod (string name, string dllName, string entryName, System.Reflection.MethodAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers, System.Runtime.InteropServices.CallingConvention nativeCallConv, System.Runtime.InteropServices.CharSet nativeCharSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.MethodBuilder DefinePInvokeMethod(string name, string dllName, string entryName, valuetype System.Reflection.MethodAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers, valuetype System.Runtime.InteropServices.CallingConvention nativeCallConv, valuetype System.Runtime.InteropServices.CharSet nativeCharSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod(System.String,System.String,System.String,System.Reflection.MethodAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][],System.Runtime.InteropServices.CallingConvention,System.Runtime.InteropServices.CharSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.MethodBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="dllName" Type="System.String" />
        <Parameter Name="entryName" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.MethodAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="nativeCallConv" Type="System.Runtime.InteropServices.CallingConvention" />
        <Parameter Name="nativeCharSet" Type="System.Runtime.InteropServices.CharSet" />
      </Parameters>
      <Docs>
        <param name="name">O nome do método <see langword="PInvoke" />. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="dllName">O nome da DLL na qual o método <see langword="PInvoke" /> é definido.</param>
        <param name="entryName">O nome do ponto de entrada na DLL.</param>
        <param name="attributes">Os atributos do método.</param>
        <param name="callingConvention">A convenção de chamada do método.</param>
        <param name="returnType">O tipo de retorno do método.</param>
        <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados obrigatórios, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno do método. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Os tipos de parâmetros do método.</param>
        <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <param name="nativeCallConv">A convenção de chamada nativa.</param>
        <param name="nativeCharSet">O conjunto de caracteres nativos do método.</param>
        <summary>Define um método <see langword="PInvoke" /> após serem informados seu nome, o nome da DLL no qual o método é definido, o nome do ponto de entrada, os atributos do método, a convenção de chamada do método, o tipo de retorno do método, os tipos dos parâmetros do método, os sinalizadores <see langword="PInvoke" /> e os modificadores personalizados para os parâmetros e o tipo de retorno.</summary>
        <returns>Um <see cref="T:System.Reflection.Emit.MethodBuilder" /> representando o método <see langword="PInvoke" /> definido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns DLL importar atributos (consulte a descrição da <xref:System.Runtime.InteropServices.DllImportAttribute>) não podem ser especificados como argumentos para esse método. Por exemplo, o atributo de importação de DLL <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> deve ser adicionado após o `PInvoke` método é criado, caso o método retorna um valor. O exemplo mostra como fazer isso.  
  
> [!NOTE]
>  Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II. A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o [\], tipo\[\], tipo\[\], tipo\[\]\[\], tipo\[ \] \<xref:System.Reflection.Emit.TypeBuilder.DefinePInvokeMethod%2A > método para criar um `PInvoke` método e como adicionar o <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> sinalizador para os sinalizadores de implementação de método depois de criar o <xref:System.Reflection.Emit.MethodBuilder>, usando o <xref:System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags%2A?displayProperty=nameWithType> e <xref:System.Reflection.Emit.MethodBuilder.SetImplementationFlags%2A?displayProperty=nameWithType> métodos.  
  
 O exemplo cria um assembly dinâmico com um módulo dinâmico e um único tipo, `MyType`, que contém o `PInvoke` método. O `PInvoke` método representa o Win32 `GetTickCount` função.  
  
> [!IMPORTANT]
>  Para obter um valor de retorno diferente de zero, você deve adicionar o <xref:System.Reflection.MethodImplAttributes?displayProperty=nameWithType> sinalizador.  
  
> [!NOTE]
>  O exemplo usa uma sobrecarga que não especifica modificadores personalizados. Para especificar modificadores personalizados, altere o código de exemplo para usar essa sobrecarga de método em vez disso.  
  
 Quando o exemplo for executado, ele executa o `PInvoke` método. Ele também salva o assembly dinâmico como PInvokeTest.dll. Você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o `MyType` classe e o `static` (`Shared` no Visual Basic) `PInvoke` método nele. Você pode compilar um programa Visual Basic ou c# que usa estático `MyType.GetTickCount` método, incluindo uma referência para a DLL ao executar csc.exe ou vbc.exe; por exemplo, `/r:PInvokeTest.dll`.  
  
 [!code-cpp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/cpp/100656_fix.cpp#1)]
 [!code-csharp[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/CS/100656_fix.cs#1)]
 [!code-vb[TypeBuilder_DefinePInvokeMethod_Fix#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefinePInvokeMethod_Fix/VB/100656_fix.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O método não é estático.  
  
 - ou -  
  
 O tipo pai é uma interface.  
  
 - ou -  
  
 O método é abstrato.  
  
 -ou-  
  
 O método foi definido anteriormente.  
  
 - ou -  
  
 O comprimento de <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é zero.  
  
 -ou-  
  
 O tamanho de <paramref name="parameterTypeRequiredCustomModifiers" /> ou <paramref name="parameterTypeOptionalCustomModifiers" /> não é igual ao tamanho de <paramref name="parameterTypes" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" />, <paramref name="dllName" /> ou <paramref name="entryName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome da propriedade. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos da propriedade.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
        <summary>Adiciona uma nova propriedade ao tipo, com o nome e assinatura de propriedade fornecidos.</summary>
        <returns>A propriedade definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo de código a seguir demonstra como definir uma propriedade dinâmica e obter um <xref:System.Reflection.Emit.PropertyBuilder> para especificação. Observe que uma `PropertyBuilder` também deve ter um correspondente <xref:System.Reflection.Emit.MethodBuilder>, que armazenará a lógica de IL para a propriedade.  
  
 [!code-cpp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.PropertyBuilder Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.PropertyBuilder Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] parameterTypes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome da propriedade. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos da propriedade.</param>
        <param name="callingConvention">A convenção de chamada de acessadores de propriedade.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
        <summary>Adiciona uma nova propriedade para o tipo, com o nome fornecido, atributos, convenção de chamada e assinatura de propriedade.</summary>
        <returns>A propriedade definida.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">O nome da propriedade. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos da propriedade.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados necessários, tais como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
        <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <summary>Adiciona uma nova propriedade para o tipo, com o nome fornecido, assinatura de propriedade e modificadores personalizados.</summary>
        <returns>A propriedade definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para os designers de compiladores gerenciados.  
  
> [!NOTE]
>  Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II. A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />  
  
 -ou-  
  
 Qualquer um dos elementos da <paramref name="parameterTypes" /> matriz<see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PropertyBuilder DefineProperty (string name, System.Reflection.PropertyAttributes attributes, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.PropertyBuilder DefineProperty(string name, valuetype System.Reflection.PropertyAttributes attributes, valuetype System.Reflection.CallingConventions callingConvention, class System.Type returnType, class System.Type[] returnTypeRequiredCustomModifiers, class System.Type[] returnTypeOptionalCustomModifiers, class System.Type[] parameterTypes, class System.Type[][] parameterTypeRequiredCustomModifiers, class System.Type[][] parameterTypeOptionalCustomModifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineProperty(System.String,System.Reflection.PropertyAttributes,System.Reflection.CallingConventions,System.Type,System.Type[],System.Type[],System.Type[],System.Type[][],System.Type[][])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PropertyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="attributes" Type="System.Reflection.PropertyAttributes" />
        <Parameter Name="callingConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="returnTypeRequiredCustomModifiers" Type="System.Type[]" />
        <Parameter Name="returnTypeOptionalCustomModifiers" Type="System.Type[]" />
        <Parameter Name="parameterTypes" Type="System.Type[]" />
        <Parameter Name="parameterTypeRequiredCustomModifiers" Type="System.Type[][]" />
        <Parameter Name="parameterTypeOptionalCustomModifiers" Type="System.Type[][]" />
      </Parameters>
      <Docs>
        <param name="name">O nome da propriedade. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="attributes">Os atributos da propriedade.</param>
        <param name="callingConvention">A convenção de chamada de acessadores de propriedade.</param>
        <param name="returnType">O tipo de retorno da propriedade.</param>
        <param name="returnTypeRequiredCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados necessários, tais como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados obrigatórios, especifique <see langword="null" />.</param>
        <param name="returnTypeOptionalCustomModifiers">Uma matriz de tipos que representam os modificadores personalizados opcionais, como <see cref="T:System.Runtime.CompilerServices.IsConst" />, para o tipo de retorno da propriedade. Se o tipo de retorno não tiver modificadores personalizados opcionais, especifique <see langword="null" />.</param>
        <param name="parameterTypes">Os tipos dos parâmetros da propriedade.</param>
        <param name="parameterTypeRequiredCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados obrigatórios para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados obrigatórios, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <param name="parameterTypeOptionalCustomModifiers">Uma matriz de matrizes de tipos. Cada matriz de tipos representa os modificadores personalizados opcionais para o parâmetro correspondente, por exemplo <see cref="T:System.Runtime.CompilerServices.IsConst" />. Se um determinado parâmetro tiver não modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de tipos. Se nenhum dos parâmetros tiver modificadores personalizados opcionais, especifique <see langword="null" /> em vez de uma matriz de matrizes.</param>
        <summary>Adiciona uma nova propriedade para o tipo, com o nome fornecido, chamando convenção, assinatura de propriedade e modificadores personalizados.</summary>
        <returns>A propriedade definida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga é fornecida para os designers de compiladores gerenciados.  
  
> [!NOTE]
>  Para obter mais informações sobre modificadores personalizados, consulte a documentação de metadados da ECMA partição II. A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
 Essa sobrecarga de método foi introduzida no [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="name" /> é zero.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.  
  
 -ou-  
  
 Qualquer um dos elementos da matriz de <paramref name="parameterTypes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineTypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.ConstructorBuilder DefineTypeInitializer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineTypeInitializer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.ConstructorBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Define o inicializador para este tipo.</summary>
        <returns>Retorna um inicializador de tipo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O inicializador criado sempre é público.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como criar um construtor de inicialização usando `DefineTypeInitializer`.  
  
 [!code-cpp[TypeBuilder_Properties1#3](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_Properties1/CPP/typebuilder_properties.cpp#3)]
 [!code-csharp[TypeBuilder_Properties1#3](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_Properties1/CS/typebuilder_properties.cs#3)]
 [!code-vb[TypeBuilder_Properties1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_Properties1/VB/typebuilder_properties.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo recipiente foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineUninitializedData">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.FieldBuilder DefineUninitializedData (string name, int size, System.Reflection.FieldAttributes attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.FieldBuilder DefineUninitializedData(string name, int32 size, valuetype System.Reflection.FieldAttributes attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.DefineUninitializedData(System.String,System.Int32,System.Reflection.FieldAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.FieldBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="attributes" Type="System.Reflection.FieldAttributes" />
      </Parameters>
      <Docs>
        <param name="name">O nome usado para fazer referência aos dados. <c>nome</c> não pode conter nulos incorporados.</param>
        <param name="size">O tamanho do campo de dados.</param>
        <param name="attributes">Os atributos do campo.</param>
        <summary>Define um campo de dados não inicializados no <see langword=".sdata" /> seção do arquivo PE (executável portátil).</summary>
        <returns>Um campo de dados de referência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O campo que você criar com esse método será `static`, mesmo se você não incluir `FieldAttributes.Static` no `attributes` parâmetro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso de `DefineUninitializedData` para criar um campo de dados não inicializados em um tipo dinâmico:  
  
 [!code-cpp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/cpp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CPP/typebuilder_defineuninitializeddata.cpp#1)]
 [!code-csharp[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/CS/typebuilder_defineuninitializeddata.cs#1)]
 [!code-vb[TypeBuilder_DefineUninitializedData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder_DefineUninitializedData/VB/typebuilder_defineuninitializeddata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho de <paramref name="name" /> é zero.  
  
 -ou-  
  
 <paramref name="size" />é menor ou igual a zero, ou maior que ou igual a 0x003f0000.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public override string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.FullName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o caminho completo deste tipo.</summary>
        <value>Somente leitura. Recupera o caminho completo deste tipo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formato retornado é "enclosingTypeFullName + nestedTypeName" para "typeName" para tipos não aninhada e de tipos aninhados.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public override System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica a covariância e restrições especiais de atual do parâmetro de tipo genérico.</summary>
        <value>Uma combinação bit a bit de valores <see cref="T:System.Reflection.GenericParameterAttributes" /> que descrevem a covariância e restrições especiais do parâmetro de tipo genérico atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public override int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a posição de um parâmetro de tipo na lista de parâmetros de tipo do tipo genérico que declarou o parâmetro.</summary>
        <value>Se o atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto representa um parâmetro de tipo genérico, a posição do parâmetro de tipo na lista de parâmetros de tipo do tipo genérico que declarou o parâmetro; caso contrário, indefinido.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Se o atual <xref:System.Reflection.Emit.TypeBuilder> não representa um parâmetro de tipo genérico, o valor dessa propriedade é indefinido. Use o <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propriedade para determinar se o atual <xref:System.Reflection.Emit.TypeBuilder> representa um parâmetro de tipo genérico.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public override Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public override int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetArrayRank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetAttributeFlagsImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public static System.Reflection.ConstructorInfo GetConstructor (Type type, System.Reflection.ConstructorInfo constructor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.ConstructorInfo GetConstructor(class System.Type type, class System.Reflection.ConstructorInfo constructor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructor(System.Type,System.Reflection.ConstructorInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="constructor" Type="System.Reflection.ConstructorInfo" />
      </Parameters>
      <Docs>
        <param name="type">O tipo genérico construído cujo construtor será retornado.</param>
        <param name="constructor">Um construtor na definição de tipo genérico de <c>tipo</c>, que especifica qual construtor de <c>tipo</c> para retornar.</param>
        <summary>Retorna o construtor do tipo genérico construído especificado que corresponde ao construtor especificado da definição de tipo genérico.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa o construtor de <paramref name="type" /> correspondente a <paramref name="constructor" />, que especifica um construtor pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método fornece uma maneira de obter um <xref:System.Reflection.ConstructorInfo> objeto que representa um construtor de um tipo genérico construído cuja definição de tipo genérico é representada por um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Por exemplo, suponha que você tenha um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo `G<T>` na sintaxe do c# (`G(Of T)` no Visual Basic, `generic <T> ref class G` em C++) e um <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa um construtor de `G<T>`. Suponha que `G<T>` tem um método genérico com parâmetro de tipo `U` que cria uma instância do tipo construído `G<U>`. Para emitir o código para criar uma instância do tipo construído, é necessário um <xref:System.Reflection.ConstructorInfo> tipo de objeto que representa o construtor deste construído — em outras palavras, que cria uma instância de `G<U>`. Para fazer isso, primeiro chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método o <xref:System.Reflection.Emit.TypeBuilder> do objeto, especificando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como o argumento de tipo. Em seguida, chame o <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método com o valor de retorno a <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parâmetro `type` e o <xref:System.Reflection.Emit.ConstructorBuilder> objeto que representa o construtor de `G<U>` como parâmetro `constructor`. O valor de retorno é a <xref:System.Reflection.ConstructorInfo> precisar emitir a chamada de função do objeto. O exemplo de código demonstra esse cenário.  
  
   
  
## Examples  
 O exemplo de código a seguir contém o código-fonte para uma classe genérica denominado `Sample` que tem um parâmetro de tipo denominado `T`. A classe tem um campo chamado `Field`, do tipo `T`e um método genérico chamado `GM` com seu próprio parâmetro de tipo, denominado `U`. Método `GM` cria uma instância de `Sample`, substituindo seu próprio parâmetro de tipo `U` para o parâmetro de tipo de `Sample`e armazena seu parâmetro de entrada em `Field`. Este código-fonte é compilado, mas não utilizado; Você pode exibi-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e compará-lo com o código emitido pela classe `Example`.  
  
 O código na classe `Example` demonstra o uso de <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método emitir código genérico. O `Main` método da classe `Example` cria um assembly dinâmico que contém uma classe denominada `Sample` e usa o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método torná-la genérica adicionando um parâmetro de tipo denominado `T`. Um construtor padrão e um campo denominado `Field`, do tipo `T`, são adicionados à classe `Sample`. Um método `GM` é adicionada e convertido em um método genérico, usando o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método. O parâmetro de tipo de `GM` chamado `U`. Depois que o parâmetro de tipo é definido, a assinatura de `GM` é adicionado usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método. Não há nenhum tipo de retorno e sem a necessidade de ou modificadores personalizados, então todos os parâmetros desse método são `null` exceto `parameterTypes`; `parameterTypes` define o tipo de um único parâmetro do método para `U`, o parâmetro de tipo genérico do método. O corpo do método cria uma instância do tipo construído `Sample<U>` (`Sample(Of U)` no Visual Basic), atribui o parâmetro do método para `Field`e imprime o valor de `Field`. O <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%2A> método é usado para criar um <xref:System.Reflection.ConstructorInfo> que representa o construtor padrão do tipo genérico construído `Sample<U>` no <xref:System.Reflection.Emit.OpCodes.Newobj?displayProperty=nameWithType> instrução que cria a instância.  
  
 Um tipo fictício está definido para conter o método de ponto de entrada `Main`. No corpo da `Main`, estático `GM` método é invocado no tipo genérico construído `Sample<int>` (`Sample(Of Integer)` no Visual Basic), com o tipo <xref:System.String> substituídos por `U`.  
  
 Quando o exemplo de código é executado, ele salva o assembly emitido como TypeBuilderGetFieldExample.exe. Você pode executar TypeBuilderGetFieldExample.exe, e você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar o código emitido com o código para o `Sample` classe que é compilado para o exemplo de código.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não representa um tipo genérico.  
  
 -ou-  
  
 <paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 -ou-  
  
 O tipo declarativo de <paramref name="constructor" /> não é uma definição de tipo genérico.  
  
 -ou-  
  
 O tipo declarativo de <paramref name="constructor" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public override System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" /> como no <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna uma matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representam os construtores públicos e não público definidos para esta classe, conforme especificado.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Reflection.ConstructorInfo" /> objetos que representam os construtores especificados definidos para esta classe. Se nenhum construtor for definida, uma matriz vazia será retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">Especifica se deve pesquisar a cadeia de herança deste membro para encontrar os atributos.</param>
        <summary>Retorna todos os atributos personalizados definidos para esse tipo.</summary>
        <returns>Retorna uma matriz de objetos que representam todos os atributos personalizados desse tipo.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte para tipos incompletos. Recuperar o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public override object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">O tipo de atributo a ser pesquisado. Somente os atributos pode ser atribuídos a esse tipo são retornados.</param>
        <param name="inherit">Especifica se deve pesquisar a cadeia de herança deste membro para encontrar os atributos.</param>
        <summary>Retorna todos os atributos personalizados do tipo atual que estão atribuídos a um tipo especificado.</summary>
        <returns>Uma matriz de atributos personalizados definidos no tipo atual.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte para tipos incompletos. Recuperar o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> no <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O tipo deve ser um tipo fornecido pelo sistema em tempo de execução subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public override Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetElementType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>A chamada desse método sempre lança <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Não há suporte para o método. Nenhum valor é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">O nome do evento a ser pesquisado.</param>
        <param name="bindingAttr">Uma combinação bit a bit de <see cref="T:System.Reflection.BindingFlags" /> valores que limita a pesquisa.</param>
        <summary>Retorna o evento com o nome especificado.</summary>
        <returns>Um <see cref="T:System.Reflection.EventInfo" /> de objeto que representa o evento declarado ou herdada por esse tipo com o nome especificado, ou <see langword="null" /> se não houver nenhuma correspondência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os eventos públicos declarado ou herdada por esse tipo.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Reflection.EventInfo" /> objetos que representa os eventos públicos declarado ou herdada por esse tipo. Uma matriz vazia é retornada se não houver nenhum evento público.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A> ou <xref:System.Reflection.Assembly.GetType%2A> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public override System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetEvents(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Uma combinação bit a bit de <see cref="T:System.Reflection.BindingFlags" /> valores que limita a pesquisa.</param>
        <summary>Retorna os eventos públicos e não-públicos que são declarados por este tipo.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Reflection.EventInfo" /> objetos que representa os eventos declarados ou herdada por este tipo corresponde os sinalizadores de associação especificada. Uma matriz vazia é retornada se não houver nenhum evento correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">O nome do campo a ser obtido.</param>
        <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" /> como no <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna o campo especificado pelo nome.</summary>
        <returns>Retorna o <see cref="T:System.Reflection.FieldInfo" /> de objeto que representa o campo declarado ou herdada por esse tipo com o nome especificado e o modificador público ou não público. Se não houver nenhuma correspondência, em seguida, <see langword="null" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public static System.Reflection.FieldInfo GetField (Type type, System.Reflection.FieldInfo field);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.FieldInfo GetField(class System.Type type, class System.Reflection.FieldInfo field) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetField(System.Type,System.Reflection.FieldInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="field" Type="System.Reflection.FieldInfo" />
      </Parameters>
      <Docs>
        <param name="type">O tipo genérico construído cujo campo será retornado.</param>
        <param name="field">Um campo na definição de tipo genérico de <c>tipo</c>, que especifica qual campo de <c>tipo</c> para retornar.</param>
        <summary>Retorna o campo de tipo genérico construído especificado que corresponde ao campo especificado da definição de tipo genérico.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.FieldInfo" /> que representa o campo de <paramref name="type" /> correspondente a <paramref name="field" />, que especifica um campo pertencente à definição de tipo genérico de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método fornece uma maneira de obter um <xref:System.Reflection.FieldInfo> objeto que representa um campo de um tipo genérico construído cuja definição de tipo genérico é representada por um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Por exemplo, suponha que você tenha um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo `G<T>` na sintaxe do c# (`G(Of T)` no Visual Basic, `generic <T> ref class G` em C++) e um <xref:System.Reflection.Emit.FieldBuilder> objeto que representa um campo `public T F` na sintaxe do c# (`Public F As T` no Visual Basic, `public: T F` em C++) que é definido por `G<T>`. Suponha que `G<T>` tem um método genérico com parâmetro de tipo `U` que cria uma instância do tipo construído `G<U>` e o campo de chamadas `F` nessa instância. Para emitir a chamada de função, é necessário um <xref:System.Reflection.FieldInfo> objeto que representa `F` no tipo construído — em outras palavras, que é do tipo `U` em vez do tipo `T`. Para fazer isso, primeiro chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método o <xref:System.Reflection.Emit.TypeBuilder> do objeto, especificando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como o argumento de tipo. Em seguida, chame o <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método com o valor de retorno a <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parâmetro `type` e o <xref:System.Reflection.Emit.FieldBuilder> objeto que representa `F` como parâmetro `field`. O valor de retorno é a <xref:System.Reflection.FieldInfo> precisar emitir a chamada de função do objeto. O exemplo de código demonstra esse cenário.  
  
   
  
## Examples  
 O exemplo de código a seguir contém o código-fonte para uma classe genérica denominado exemplo que tem um parâmetro de tipo denominado `T`. A classe tem um campo chamado `Field`, do tipo `T`e um método genérico chamado `GM` com seu próprio parâmetro de tipo, denominado `U`. Método `GM` cria uma instância de `Sample`, substituindo seu próprio parâmetro de tipo `U` para o parâmetro de tipo de `Sample`e armazena seu parâmetro de entrada em `Field`. Este código-fonte é compilado, mas não utilizado; Você pode exibi-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e compará-lo com o código emitido pela classe `Example`.  
  
 O código na classe `Example` demonstra o uso de <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método emitir código genérico. O `Main` método da classe `Example` cria um assembly dinâmico que contém uma classe denominada `Sample`e usa o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método torná-la genérica adicionando um parâmetro de tipo denominado `T`. Um construtor padrão e um campo denominado `Field`, do tipo `T`, são adicionados à classe `Sample`. Um método `GM` é adicionada e convertido em um método genérico, usando o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método. O parâmetro de tipo de `GM` chamado `U`. Depois que o parâmetro de tipo é definido, a assinatura de `GM` é adicionado usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método. Não há nenhum tipo de retorno e sem a necessidade de ou modificadores personalizados, então todos os parâmetros desse método são `null` exceto `parameterTypes`; `parameterTypes` define o tipo de um único parâmetro do método para `U`, o parâmetro de tipo genérico do método. O corpo do método cria uma instância do tipo construído `Sample<U>` (`Sample(Of U)` no Visual Basic), atribui o parâmetro do método para `Field`e imprime o valor de `Field`. O <xref:System.Reflection.Emit.TypeBuilder.GetField%2A> método é usado para criar um <xref:System.Reflection.FieldInfo> que representa o campo do tipo genérico construído `Sample<U>` no <xref:System.Reflection.Emit.OpCodes.Stfld?displayProperty=nameWithType> e <xref:System.Reflection.Emit.OpCodes.Ldfld?displayProperty=nameWithType> instruções.  
  
 Um tipo fictício está definido para conter o método de ponto de entrada `Main`. No corpo da `Main`, estático `GM` método é invocado no tipo genérico construído `Sample<int>` (`Sample(Of Integer)` no Visual Basic), com o tipo <xref:System.String> substituídos por `U`.  
  
 Quando o exemplo de código é executado, ele salva o assembly emitido como TypeBuilderGetFieldExample.exe. Você pode executar TypeBuilderGetFieldExample.exe, e você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar o código emitido com o código para o `Sample` classe que é compilado para o exemplo de código.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não representa um tipo genérico.  
  
 -ou-  
  
 <paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 -ou-  
  
 O tipo declarativo de <paramref name="field" /> não é uma definição de tipo genérico.  
  
 -ou-  
  
 O tipo declarativo de <paramref name="field" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public override System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetFields(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna os campos públicos e não-públicos que são declarados por este tipo.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Reflection.FieldInfo" /> objetos que representa os campos públicos e não público declarado ou herdada por esse tipo. Uma matriz vazia é retornada se houver campos, conforme especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.GetFields%2A> método não retornar campos em uma ordem específica, como em ordem alfabética ou ordem de declaração. Seu código deve não dependam da ordem na qual os campos são retornados, como ordem pode variar.  
  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de <see cref="T:System.Type" /> objetos representando os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</summary>
        <returns>Uma matriz de objetos de <see cref="T:System.Type" />. Os elementos da matriz representam os argumentos de tipo de um tipo genérico ou os parâmetros de tipo de uma definição de tipo genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos da matriz retornada estão na ordem em que aparecem na lista de parâmetros de tipo para a definição de tipo genérico.  
  
 Um <xref:System.Reflection.Emit.TypeBuilder> objeto representa uma definição de tipo genérico se o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método foi usado para que ela tenha parâmetros de tipo genérico. Esse método recupera o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objetos que representam os parâmetros de tipo genérico.  
  
 Para obter mais informações sobre tipos genéricos em reflexão e uma lista de condições invariáveis para termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericParameterConstraints" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Type" /> objeto que representa uma definição de tipo genérico do qual o tipo atual pode ser obtido.</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa uma definição de tipo genérico do qual o tipo atual pode ser obtido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você chamar o <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> método em um <xref:System.Reflection.Emit.TypeBuilder> objeto para o qual o <xref:System.Reflection.Emit.TypeBuilder.IsGenericType%2A> propriedade retorna `true`, o <xref:System.Reflection.Emit.TypeBuilder.GetGenericTypeDefinition%2A> propriedade retorna a instância atual. Um <xref:System.Reflection.Emit.TypeBuilder> que representa um tipo genérico é sempre uma definição de tipo genérico.  
  
 Se você usou o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método para construir um tipo genérico de um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa uma definição de tipo genérico, usando o <xref:System.Type.GetGenericTypeDefinition%2A?displayProperty=nameWithType> método do tipo construído obtém de volta a <xref:System.Reflection.Emit.TypeBuilder> objeto que representa a definição de tipo genérico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não é genérico. Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> retorna <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public override Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterface(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">O nome da interface.</param>
        <param name="ignoreCase">Se <see langword="true" />, a pesquisa diferencia maiusculas de minúsculas. Se <see langword="false" />, a pesquisa diferencia maiusculas de minúsculas.</param>
        <summary>Retorna a interface implementada (direta ou indiretamente) por esta classe com o nome totalmente qualificado correspondente ao nome de interface especificado.</summary>
        <returns>Retorna um <see cref="T:System.Type" /> objeto que representa a interface implementada. Retorna nulo se nenhum nome de interface correspondente foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public override System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaceMap(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">O <see cref="T:System.Type" /> da interface para o qual o mapeamento é a ser recuperado.</param>
        <summary>Retorna um mapeamento de interface para a interface solicitada.</summary>
        <returns>Retorna o mapeamento de interface solicitada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public override Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetInterfaces" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz de todas as interfaces implementadas sobre esse tipo e seus tipos base.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Type" /> objetos que representam as interfaces implementadas. Se nenhum for definida, uma matriz vazia será retornada.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">O nome do membro.</param>
        <param name="type">O tipo do membro para retornar.</param>
        <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, como em <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna todos os membros públicos e não público declarado ou herdado por este tipo, conforme especificado.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos e não público definidos neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os membros públicos são retornados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMembers(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, como <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna os membros para os membros públicos e não público declarado ou herdada por esse tipo.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Reflection.MemberInfo" /> objetos que representam os membros públicos e não público declarado ou herdada por esse tipo. Uma matriz vazia é retornada se não houver nenhum membro correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodInfo GetMethod (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodInfo GetMethod(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethod(System.Type,System.Reflection.MethodInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">O tipo genérico construído cujo método será retornado.</param>
        <param name="method">Um método de definição de tipo genérico do <c>tipo</c>, que especifica qual método de <c>tipo</c> para retornar.</param>
        <summary>Retorna o método do construído genérico tipo especificado que corresponde ao método especificado da definição de tipo genérico.</summary>
        <returns>Um <see cref="T:System.Reflection.MethodInfo" /> objeto que representa o método de <paramref name="type" /> correspondente para <paramref name="method" />, que especifica um método que pertencem à definição de tipo genérico de <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método fornece uma maneira de obter um <xref:System.Reflection.MethodInfo> objeto que representa um método de um tipo genérico construído cuja definição de tipo genérico é representada por um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 Por exemplo, suponha que você tenha um <xref:System.Reflection.Emit.TypeBuilder> objeto que representa o tipo `G<T>` na sintaxe do c# (`G(Of T)` no Visual Basic, `generic <T> ref class G` em C++) e um <xref:System.Reflection.Emit.MethodBuilder> objeto que representa um método `T M()` na sintaxe do c# (`Function M() As T` no Visual Basic, `T M()` em C++) que é definido por `G<T>`. Suponha que `G<T>` tem um método genérico com parâmetro de tipo `U` que cria uma instância do tipo construído `G<U>` e chama o método `M` nessa instância. Para emitir a chamada de função, é necessário um <xref:System.Reflection.MethodInfo> objeto que representa `M` no tipo construído — em outras palavras, que retorna tipo `U` em vez do tipo `T`. Para fazer isso, primeiro chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método o <xref:System.Reflection.Emit.TypeBuilder> do objeto, especificando o <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto que representa `U` como o argumento de tipo. Em seguida, chame o <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método com o valor de retorno a <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método como parâmetro `type` e o <xref:System.Reflection.Emit.MethodBuilder> objeto que representa `T M()` como parâmetro `method`. O valor de retorno é a <xref:System.Reflection.MethodInfo> precisar emitir a chamada de função do objeto. O exemplo de código demonstra um cenário semelhante a este.  
  
   
  
## Examples  
 O exemplo de código a seguir contém o código-fonte para uma classe genérica denominado `Sample` que tem um parâmetro de tipo denominado `T`. A classe tem um campo chamado `Field`, do tipo `T`e um método genérico chamado `GM` com seu próprio parâmetro de tipo, denominado `U`. Método `GM` cria uma instância de `Sample`, substituindo seu próprio parâmetro de tipo `U` para o parâmetro de tipo de `Sample`e armazena seu parâmetro de entrada em `Field`. Este código-fonte é compilado, mas não utilizado; Você pode exibi-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) e compará-lo com o código emitido pela classe `Example`.  
  
 O código na classe `Example` demonstra o uso de <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método emitir código genérico. O `Main` método da classe `Example` cria um assembly dinâmico que contém uma classe denominada `Sample` e usa o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método torná-la genérica adicionando um parâmetro de tipo denominado `T`. Um construtor padrão e um campo denominado `Field`, do tipo `T`, são adicionados à classe `Sample`. Um método `GM` é adicionada e convertido em um método genérico, usando o <xref:System.Reflection.Emit.MethodBuilder.DefineGenericParameters%2A?displayProperty=nameWithType> método. O parâmetro de tipo de `GM` chamado `U`. Depois que o parâmetro de tipo é definido, a assinatura de `GM` é adicionado usando o <xref:System.Reflection.Emit.MethodBuilder.SetSignature%2A?displayProperty=nameWithType> método. Não há nenhum tipo de retorno e sem a necessidade de ou modificadores personalizados, então todos os parâmetros desse método são `null` exceto `parameterTypes`; `parameterTypes` define o tipo de um único parâmetro do método para `U`, o parâmetro de tipo genérico do método. O corpo do método cria uma instância do tipo construído `Sample<U>` (`Sample(Of U)` no Visual Basic), atribui o parâmetro do método para `Field`e imprime o valor de `Field`. Um tipo fictício está definido para conter o método de ponto de entrada `Main`. No corpo da `Main`, estático `GM` método é invocado no tipo genérico construído `Sample<int>` (`Sample(Of Integer)` no Visual Basic), com o tipo <xref:System.String> substituídos por `U`. O <xref:System.Reflection.Emit.TypeBuilder.GetMethod%2A> método é usado para criar um <xref:System.Reflection.MethodInfo> para estático `GM` método do tipo genérico construído `Sample<U>`e o <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> método é usado para criar um <xref:System.Reflection.MethodInfo> que pode ser emitido em uma chamada de método.  
  
 Quando o exemplo de código é executado, ele salva o assembly emitido como TypeBuilderGetFieldExample.exe. Você pode executar TypeBuilderGetFieldExample.exe, e você pode usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para comparar o código emitido com o código para o `Sample` classe que é compilado para o exemplo de código.  
  
 [!code-csharp[TypeBuilder.GetField_Generic#1](~/samples/snippets/csharp/VS_Snippets_CLR/TypeBuilder.GetField_Generic/cs/source.cs#1)]
 [!code-vb[TypeBuilder.GetField_Generic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TypeBuilder.GetField_Generic/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="method" />é um método genérico que não é uma definição de método genérico.  
  
 -ou-  
  
 <paramref name="type" /> não representa um tipo genérico.  
  
 -ou-  
  
 <paramref name="type" /> não é do tipo <see cref="T:System.Reflection.Emit.TypeBuilder" />.  
  
 -ou-  
  
 O tipo declarativo de <paramref name="method" /> não é uma definição de tipo genérico.  
  
 -ou-  
  
 O tipo declarativo de <paramref name="method" /> não é a definição de tipo genérico de <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public override System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetMethods(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" /> como no <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna todos os públicos e não público métodos declarados ou herdada por este tipo, conforme especificado.</summary>
        <returns>Retorna uma matriz de <see cref="T:System.Reflection.MethodInfo" /> objetos que representam os métodos públicos e não público definidos neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente os métodos públicos são retornados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public override Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">O <see cref="T:System.String" /> que contém o nome do tipo aninhado para obter.</param>
        <param name="bindingAttr">Um bitmask composto de um ou mais <see cref="T:System.Reflection.BindingFlags" /> que especificam como a pesquisa é realizada.  
  
 -ou-  
  
 Zero, para realizar uma pesquisa diferencia maiusculas de minúsculas para métodos públicos.</param>
        <summary>Retorna os tipos aninhados públicos e não público que são declarados por este tipo.</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa o tipo aninhado que atenda aos requisitos especificados, se encontrado; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 Se esse tipo é concluído, por exemplo, se `CreateType` foi chamado neste tipo, mas há tipos aninhados que não estão concluídos, em seguida, `GetNestedTypes` retornará apenas os tipos aninhados para o qual `CreateType` foi chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public override Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" />, como em <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna os tipos aninhados públicos e não-públicos que são declarados ou herdados por esse tipo.</summary>
        <returns>Uma matriz de <see cref="T:System.Type" /> objetos que representam todos os tipos aninhados atual <see cref="T:System.Type" /> que correspondam às restrições de associação especificada.  
  
 Uma matriz vazia do tipo <see cref="T:System.Type" />, se nenhum tipo é aninhado na atual <see cref="T:System.Type" />, ou se nenhum dos tipos aninhados corresponder às restrições de associação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 Se esse tipo é concluído, por exemplo, se `CreateType` foi chamado neste tipo, mas há tipos aninhados que não estão concluídos, em seguida, `GetNestedTypes` retornará apenas os tipos aninhados para o qual `CreateType` foi chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public override System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetProperties(System.Reflection.BindingFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Esse atributo de invocação. Isso deve ser um sinalizador de bit de <see cref="T:System.Reflection.BindingFlags" /> : <see langword="InvokeMethod" />, <see langword="NonPublic" />e assim por diante.</param>
        <summary>Retorna todas as públicas e não público propriedades declaradas ou herdada por este tipo, conforme especificado.</summary>
        <returns>Retorna uma matriz de <see langword="PropertyInfo" /> objetos que representam as propriedades públicas e não público definidas neste tipo se <paramref name="nonPublic" /> for usado; caso contrário, somente as propriedades públicas são retornadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Este método não está implementado para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected override System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="returnType">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public override Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.GUID" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o GUID desse tipo.</summary>
        <value>Somente leitura. Recupera o GUID desse tipo</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.HasElementTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public override object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">O nome do membro para invocar. Isso pode ser um construtor, método, propriedade ou campo. Um atributo de invocação adequado deve ser especificado. Observe que é possível chamar o membro padrão de uma classe, passando uma cadeia de caracteres vazia como o nome do membro.</param>
        <param name="invokeAttr">O atributo de invocação. Isso deve ser um sinalizador de bit de <see langword="BindingFlags" />.</param>
        <param name="binder">Um objeto que permite a associação, a coerção de tipos de argumento, a invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> usando reflexão. Se o fichário é <see langword="null" />, o associador padrão é usado. Consulte <see cref="T:System.Reflection.Binder" />.</param>
        <param name="target">O objeto no qual invocar o membro especificado. Se o membro é estático, esse parâmetro é ignorado.</param>
        <param name="args">Uma lista de argumentos. Isso é uma matriz de objetos que contém o número, ordem e tipo dos parâmetros do membro a ser invocado. Se não houver nenhum parâmetro, isso deve ser nulo.</param>
        <param name="modifiers">Uma matriz do mesmo comprimento que <c>args</c> com elementos que representam os atributos associados com os argumentos do membro a ser invocado. Um parâmetro com atributos associados a ele nos metadados. Eles são usados por vários serviços de interoperabilidade. Consulte as especificações de metadados para obter mais detalhes.</param>
        <param name="culture">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos. Se for nulo, o <see langword="CultureInfo" /> para o segmento atual é usado. (Observe que isso é necessário para, por exemplo, converter uma cadeia de caracteres que representa a 1000 para um valor duplo, desde que 1000 é representado de forma diferente por diferentes culturas.)</param>
        <param name="namedParameters">Cada parâmetro de <c>namedParameters</c> matriz obtém o valor do elemento correspondente no <c>args</c> matriz. Se o comprimento de <c>args</c> é maior que o comprimento de <c>namedParameters</c>, os valores de argumento restantes são passados na ordem.</param>
        <summary>Invoca o membro especificado. O método a ser invocado deve ser acessível e forneça a correspondência mais específica com a lista de argumento especificado, sob as restrições de atributos especificados de fichário e invocação.</summary>
        <returns>Retorna o valor de retorno do membro chamado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um método será chamado se o número de parâmetros na declaração de método é igual ao número de argumentos na lista de argumentos especificada e o tipo de cada argumento pode ser convertido pelo associador para o tipo do parâmetro.  
  
 O associador encontrará todos os métodos correspondentes. Esses métodos são encontrados com base no tipo de associação solicitada (BindingFlags, BindingFlags.GetProperties, etc.). O conjunto de métodos é filtrado pelo nome, número de argumentos e um conjunto de modificadores de pesquisa definidos associador. Depois que o método for selecionado, ele será invocado. Acessibilidade é verificada nesse ponto. A pesquisa pode controlar qual conjunto de métodos são pesquisadas com base no atributo acessibilidade associado com o método. O `IBinder.BindToMethod` método é responsável para selecionar o método a ser invocado. O associador padrão seleciona a correspondência mais específica.  
  
> [!NOTE]
>  Restrições de acesso são ignoradas por código totalmente confiável. Ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e invocados usando reflexão sempre que o código é totalmente confiável.  
  
 Esse método não tem suporte no momento. Você pode recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte para tipos incompletos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected override bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsArrayImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (System.Reflection.TypeInfo typeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Reflection.TypeInfo typeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Reflection.TypeInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeInfo" Type="System.Reflection.TypeInfo" />
      </Parameters>
      <Docs>
        <param name="typeInfo">O objeto a ser testado.</param>
        <summary>Obtém um valor que indica se um especificado <see cref="T:System.Reflection.TypeInfo" /> objeto pode ser atribuído a este objeto.</summary>
        <returns>
          <see langword="true" />Se <paramref name="typeInfo" /> pode ser atribuído a este objeto; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public override bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsAssignableFrom(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">O objeto a ser testado.</param>
        <summary>Obtém um valor que indica se um <see cref="T:System.Type" /> especificado pode ser atribuído a esse objeto.</summary>
        <returns>
          <see langword="true" /> se o parâmetro <paramref name="c" /> e o tipo atual representarem o mesmo tipo, se o tipo atual estiver na hierarquia de herança de <paramref name="c" /> ou se o tipo atual for uma interface à qual <paramref name="c" /> dá suporte. <see langword="false" /> se nenhuma dessas condições for válida ou se <paramref name="c" /> for <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected override bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsByRefImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected override bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCOMObjectImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public override bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este objeto representa um tipo genérico construído.</summary>
        <value>
          <see langword="true" /> se este objeto representar um tipo genérico construído; caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCreated">
      <MemberSignature Language="C#" Value="public bool IsCreated ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsCreated() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsCreated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor que indica se o tipo dinâmico atual foi criado.</summary>
        <returns>
          <see langword="true" />Se o <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> método foi chamado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Após o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método foi chamado, o tipo representado pelo <xref:System.Reflection.Emit.TypeBuilder> objeto for concluído. Exceções são geradas em quaisquer outras tentativas de adicionar membros ou alterar outras características do tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public override bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsDefined(System.Type,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">O tipo de atributo a ser pesquisado. Somente os atributos pode ser atribuídos a esse tipo são retornados.</param>
        <param name="inherit">Especifica se deve pesquisar a cadeia de herança deste membro para encontrar os atributos.</param>
        <summary>Determina se um atributo personalizado é aplicado para o tipo atual.</summary>
        <returns>
          <see langword="true" />Se uma ou mais instâncias de <paramref name="attributeType" />, ou um atributo derivado <paramref name="attributeType" />, está definido neste tipo; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não tem suporte para parâmetros de tipo genérico incompleta. Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Atualmente, esse método não tem suporte para tipos incompletos. Recuperar o tipo usando <see cref="M:System.Type.GetType" /> e chame <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /> no <see cref="T:System.Type" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="attributeType" />não foi definida.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="attributeType" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public override bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsEnum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public override bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é um parâmetro de tipo genérico.</summary>
        <value>
          <see langword="true" />Se o atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto representa um parâmetro de tipo genérico; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Ao emitir código, um parâmetro de tipo genérico é representado por um <xref:System.Reflection.Emit.GenericTypeParameterBuilder> objeto em vez de um <xref:System.Reflection.Emit.TypeBuilder> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public override bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é um tipo genérico.</summary>
        <value>
          <see langword="true" />Se o tipo representado pelo atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto é genérico; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Reflection.Emit.TypeBuilder> objeto representa uma definição de tipo genérico se o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método foi usado para que ela tenha parâmetros de tipo genérico. Uma instância do <xref:System.Reflection.Emit.TypeBuilder> classe genérica é sempre uma definição de tipo genérico.  
  
 Para obter mais informações sobre tipos genéricos em reflexão e uma lista de condições invariáveis para termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o atual <see cref="T:System.Reflection.Emit.TypeBuilder" /> representa uma definição de tipo genérico do que outros tipos genéricos podem ser criados.</summary>
        <value>
          <see langword="true" />Se este <see cref="T:System.Reflection.Emit.TypeBuilder" /> objeto representa uma definição de tipo genérico; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Reflection.Emit.TypeBuilder> objeto representa uma definição de tipo genérico se o <xref:System.Reflection.Emit.TypeBuilder.DefineGenericParameters%2A> método foi usado para que ela tenha parâmetros de tipo genérico. Uma instância do <xref:System.Reflection.Emit.TypeBuilder> classe genérica é sempre uma definição de tipo genérico.  
  
 Um <xref:System.Reflection.Emit.TypeBuilder> pode ser usado para criar definições de tipo genérico, mas tipos genéricos construídos não. Para obter um tipo genérico construído, chame o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método em um <xref:System.Reflection.Emit.TypeBuilder> que representa uma definição de tipo genérico.  
  
 Para obter mais informações sobre tipos genéricos em reflexão e uma lista de condições invariáveis para termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPointerImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected override bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsPrimitiveImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é crítico de segurança ou segurança crítica segura e, portanto, pode realizar operações críticas.</summary>
        <value>
          <see langword="true" />Se o tipo atual é crítico de segurança ou segurança-crítico para segurança; <see langword="false" /> se é transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriedades de relatório o nível de transparência do tipo, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico para segurança|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
 O tempo de execução começa a avaliar os níveis de transparência no assembly. Por exemplo, se o assembly dinâmico é crítico de segurança, as anotações em tipos são ignoradas e todos os tipos são críticas de segurança.  
  
 Por padrão, um assembly dinâmico herda a transparência do assembly que emite a ele. Você pode substituir esse padrão usando o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga de método e a especificação de atributos de segurança. Não é possível elevar os níveis de segurança por fazer isso. ou seja, o código transparente não é possível emitir código crítico de segurança ou segurança crítica safe. Atributos devem ser especificados quando o assembly dinâmico é criado, ou eles não têm efeito até que o assembly foi salvo em disco e recarregado.  
  
> [!NOTE]
>  Herança padrão é limitada a avaliação do tempo de execução de transparência. Não há atributos são aplicados ao assembly dinâmico. Se você deseja adicionar os atributos de segurança, você mesmo deve aplicá-los.  
  
 Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O tipo dinâmico atual não foi criado chamando o <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> método.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public override bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é safe-crítico de segurança; ou seja, se ele pode realizar operações críticas e pode ser acessado pelo código de transparência.</summary>
        <value>
          <see langword="true" />Se o tipo atual é safe-crítico de segurança; <see langword="false" /> se ele é crítico de segurança ou transparente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriedades de relatório o nível de transparência do tipo, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico para segurança|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
 O tempo de execução começa a avaliar os níveis de transparência no assembly. Por exemplo, se o assembly dinâmico é crítico de segurança, as anotações em tipos são ignoradas e todos os tipos são críticas de segurança.  
  
 Por padrão, um assembly dinâmico herda a transparência do assembly que emite a ele. Você pode substituir esse padrão usando o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga de método e a especificação de atributos de segurança. Não é possível elevar os níveis de segurança por fazer isso. ou seja, o código transparente não é possível emitir código crítico de segurança ou segurança crítica safe. Atributos devem ser especificados quando o assembly dinâmico é criado, ou eles não têm efeito até que o assembly foi salvo em disco e recarregado.  
  
> [!NOTE]
>  Herança padrão é limitada a avaliação do tempo de execução de transparência. Não há atributos são aplicados ao assembly dinâmico. Se você deseja adicionar os atributos de segurança, você mesmo deve aplicá-los.  
  
 Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O tipo dinâmico atual não foi criado chamando o <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> método.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public override bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o tipo atual é transparente e, portanto, não é possível realizar operações críticas.</summary>
        <value>
          <see langword="true" />Se o tipo é transparente de segurança; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.IsSecurityCritical%2A>, <xref:System.Reflection.Emit.TypeBuilder.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.Emit.TypeBuilder.IsSecurityTransparent%2A> propriedades de relatório o nível de transparência do tipo, conforme determinado pelo common language runtime (CLR). As combinações destas propriedades são mostradas na seguinte tabela:  
  
|Nível de segurança|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Crítico|`true`|`false`|`false`|  
|Crítico para segurança|`true`|`true`|`false`|  
|Transparente|`false`|`false`|`true`|  
  
 Usar essas propriedade é muito mais simples que examinar as anotações de segurança de um assembly e seus tipos, verificando o nível de confiança atual e tentando duplicar as regras do tempo de execução.  
  
 O tempo de execução começa a avaliar os níveis de transparência no assembly. Por exemplo, se o assembly dinâmico é crítico de segurança, as anotações em tipos são ignoradas e todos os tipos são críticas de segurança.  
  
 Por padrão, um assembly dinâmico herda a transparência do assembly que emite a ele. Você pode substituir esse padrão usando o <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType>, ou <xref:System.AppDomain.DefineDynamicAssembly%28System.Reflection.AssemblyName%2CSystem.Reflection.Emit.AssemblyBuilderAccess%2CSystem.String%2CSystem.Security.Policy.Evidence%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Security.PermissionSet%2CSystem.Boolean%2CSystem.Collections.Generic.IEnumerable%7BSystem.Reflection.Emit.CustomAttributeBuilder%7D%29?displayProperty=nameWithType> sobrecarga de método e a especificação de atributos de segurança. Não é possível elevar os níveis de segurança por fazer isso. ou seja, o código transparente não é possível emitir código crítico de segurança ou segurança crítica safe. Atributos devem ser especificados quando o assembly dinâmico é criado, ou eles não têm efeito até que o assembly foi salvo em disco e recarregado.  
  
> [!NOTE]
>  Herança padrão é limitada a avaliação do tempo de execução de transparência. Não há atributos são aplicados ao assembly dinâmico. Se você deseja adicionar os atributos de segurança, você mesmo deve aplicá-los.  
  
 Para obter mais informações sobre reflexão emitir e transparência, consulte [problemas de segurança na emissão de reflexão](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md). Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O tipo dinâmico atual não foi criado chamando o <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> método.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public override bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSerializable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public override bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsSubclassOf(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">Um <see cref="T:System.Type" /> que é a ser verificada.</param>
        <summary>Determina se esse tipo é derivado de um tipo especificado.</summary>
        <returns>Somente leitura. Retorna <see langword="true" /> se esse tipo é o mesmo que o tipo <paramref name="c" />, ou é um subtipo do tipo <paramref name="c" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public override bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public override bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected override bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.IsValueTypeImpl" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public override bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Type" /> objeto que representa uma matriz unidimensional do tipo atual, com um limite inferior de zero.</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa um tipo de matriz unidimensional cujo tipo de elemento é o tipo atual, com um limite inferior de zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método fornece uma maneira de gerar um tipo de matriz com qualquer tipo de elemento possíveis, incluindo tipos genéricos.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`. `TestMethod`leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`. Retorna uma matriz bidimensional de tipo `Sample`. O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public override Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeArrayType(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">O número de dimensões da matriz.</param>
        <summary>Retorna um <see cref="T:System.Type" /> objeto que representa uma matriz do tipo atual, com o número especificado de dimensões.</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa uma matriz unidimensional do tipo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.MakeArrayType%2A> método fornece uma maneira de gerar um tipo de matriz com qualquer tipo de elemento possíveis, incluindo tipos genéricos.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`. `TestMethod`leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`. Retorna uma matriz bidimensional de tipo `Sample`. O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="rank" />não é uma dimensão de matriz válida.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public override Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeByRefType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Type" /> objeto que representa o tipo atual quando transmitido como um <see langword="ref" /> parâmetro (<see langword="ByRef" /> no Visual Basic).</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa o tipo atual quando transmitido como um <see langword="ref" /> parâmetro (<see langword="ByRef" /> no Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.MakeByRefType%2A> método fornece uma maneira de gerar `ref` tipos (`ByRef` no Visual Basic) para o parâmetro de lista.  
  
> [!NOTE]
>  Usando a sintaxe do Microsoft intermediate language (MSIL), se o atual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, o tipo retornado por este método será `MyType&`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`. `TestMethod`leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`. Retorna uma matriz bidimensional de tipo `Sample`. O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public override Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakeGenericType(System.Type[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Uma matriz de tipos a serem substituídos por parâmetros de tipo de definição de tipo genérico atual.</param>
        <summary>Substitui os elementos de uma matriz de tipos para os parâmetros de tipo de definição de tipo genérico atual e retorna o tipo construído resultante.</summary>
        <returns>Um <see cref="T:System.Type" /> representando o tipo construído formado substituindo os elementos do <paramref name="typeArguments" /> pelos parâmetros de tipo do tipo genérico atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método quando seu código emitido requer um tipo construído da definição do tipo genérico. Não é necessário chamar o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método antes de chamar o <xref:System.Reflection.Emit.TypeBuilder.MakeGenericType%2A> método em um <xref:System.Reflection.Emit.TypeBuilder> que representa uma definição de tipo genérico. Se o atual <xref:System.Reflection.Emit.TypeBuilder> não representa a definição de um tipo genérico, um <xref:System.InvalidOperationException> é gerada.  
  
 O objeto retornado pelas funções método como um espaço reservado para um tipo genérico construído no seu código emitido. É uma instância de uma classe derivada de <xref:System.Type> que tem recursos limitados. Em particular:  
  
-   Para obter os construtores, métodos e campos para esses tipos genéricos construídos, use o <xref:System.Reflection.Emit.TypeBuilder.GetMethod%28System.Type%2CSystem.Reflection.MethodInfo%29>, <xref:System.Reflection.Emit.TypeBuilder.GetField%28System.Type%2CSystem.Reflection.FieldInfo%29>, e <xref:System.Reflection.Emit.TypeBuilder.GetConstructor%28System.Type%2CSystem.Reflection.ConstructorInfo%29> sobrecargas do método.  
  
-   Duas instâncias que representam o mesmo tipo construído não são comparados como iguais. Por exemplo, no código a seguir `t1.Equals(t2)` retorna `false`:  
  
 [!code-cpp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Reflection.Emit.TypeBuilder.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.emit.typebuilder.makegenerictype/vb/remarks.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo atual não representa a definição de um tipo genérico. Ou seja, <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> retorna <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeArguments" /> é <see langword="null" />.  
  
 -ou-  
  
 Qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Type.Module" /> propriedade de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.  
  
 -ou-  
  
 O <see cref="P:System.Reflection.Module.Assembly" /> propriedade do módulo de qualquer elemento de <paramref name="typeArguments" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public override Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.MakePointerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Type" /> objeto que representa o tipo de um ponteiro não gerenciado para o tipo atual.</summary>
        <returns>Um <see cref="T:System.Type" /> objeto que representa o tipo de um ponteiro não gerenciado para o tipo atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Reflection.Emit.TypeBuilder.MakePointerType%2A> método fornece uma maneira de gerar tipos de ponteiro para listas de parâmetros.  
  
> [!NOTE]
>  Usando a sintaxe do Microsoft intermediate language (MSIL), se o atual <xref:System.Reflection.Emit.TypeBuilder> representa `MyType`, o tipo retornado por este método será `MyType*`.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um módulo dinâmico, um tipo abstrato denominado `Sample`e um método abstrato denominado `TestMethod`. `TestMethod`leva um `ref` parâmetro (`ByRef` no Visual Basic) do tipo `Sample`, um ponteiro para o tipo `Sample`e uma matriz do tipo `Sample`. Retorna uma matriz bidimensional de tipo `Sample`. O exemplo de código salva o módulo dinâmico no disco, para que você possa examiná-lo com o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md).  
  
 [!code-csharp[MakeXxxTypeBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/MakeXxxTypeBuilder/CS/source.cs#1)]
 [!code-vb[MakeXxxTypeBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MakeXxxTypeBuilder/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public override System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Module" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o módulo dinâmico que contém esta definição de tipo.</summary>
        <value>Somente leitura. Recupera o módulo dinâmico que contém esta definição de tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o nome desse tipo.</summary>
        <value>Somente leitura. Recupera o <see cref="T:System.String" /> nome deste tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public override string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Namespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o namespace onde isso <see langword="TypeBuilder" /> está definido.</summary>
        <value>Somente leitura. Recupera o namespace onde isso <see langword="TypeBuilder" /> está definido.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PackingSize">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.PackingSize PackingSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.PackingSize PackingSize" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.PackingSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.PackingSize</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o tamanho de remessa desse tipo.</summary>
        <value>Somente leitura. Recupera o tamanho de remessa desse tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.ReflectedType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o tipo que foi usado para obter esse tipo.</summary>
        <value>Somente leitura. O tipo que foi usado para obter esse tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.Emit.CustomAttributeBuilder customBuilder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="customBuilder" Type="System.Reflection.Emit.CustomAttributeBuilder" />
      </Parameters>
      <Docs>
        <param name="customBuilder">Uma instância de uma classe auxiliar para definir o atributo personalizado.</param>
        <summary>Defina um atributo personalizado usando um construtor de atributos personalizados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="customBuilder" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCustomAttribute">
      <MemberSignature Language="C#" Value="public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCustomAttribute(class System.Reflection.ConstructorInfo con, unsigned int8[] binaryAttribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetCustomAttribute(System.Reflection.ConstructorInfo,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="con" Type="System.Reflection.ConstructorInfo" />
        <Parameter Name="binaryAttribute" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="con">O construtor para o atributo personalizado.</param>
        <param name="binaryAttribute">Um blob de byte que representa os atributos.</param>
        <summary>Define um atributo personalizado usando um blob de atributo personalizado especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter mais informações sobre como formatar `binaryAttribute`, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente "partição II: metadados definição e semântica". A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
> [!NOTE]
>  Começando com o [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse membro não requer mais <xref:System.Security.Permissions.ReflectionPermission> com o <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=nameWithType> sinalizador. (Consulte [problemas de segurança em reflexão emitir](~/docs/framework/reflection-and-codedom/security-issues-in-reflection-emit.md).) Para usar essa funcionalidade, seu aplicativo deve ter como destino o [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="con" /> ou <paramref name="binaryAttribute" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetParent">
      <MemberSignature Language="C#" Value="public void SetParent (Type parent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetParent(class System.Type parent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.SetParent(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parent" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="parent">O novo tipo de base.</param>
        <summary>Define o tipo base do tipo atualmente em construção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `parent` é `null`, <xref:System.Object> é usado como o tipo base.  
  
 Nas versões do .NET Framework 1.0 e 1.1, nenhuma exceção é lançada se `parent` é um tipo de interface, mas um <xref:System.TypeLoadException> é gerada quando o <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método é chamado.  
  
 O <xref:System.Reflection.Emit.TypeBuilder.SetParent%2A> método não verifica se a maioria dos tipos de pai inválido. Por exemplo, ele não rejeitar um tipo de pai que não possui construtor padrão quando o tipo atual tiver um construtor padrão, ele não rejeitar tipos lacrados e não rejeitar o <xref:System.Delegate> tipo. Nesses casos, as exceções são geradas pelo <xref:System.Reflection.Emit.TypeBuilder.CreateType%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.  
  
 -ou-  
  
 <paramref name="parent" />é <see langword="null" />, e a instância atual representa uma interface não incluir cujos atributos <see cref="F:System.Reflection.TypeAttributes.Abstract" />.  
  
 -ou-  
  
 Para o tipo dinâmico atual, a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericType" /> é <see langword="true" />, mas a propriedade <see cref="P:System.Reflection.Emit.TypeBuilder.IsGenericTypeDefinition" /> é <see langword="false" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="parent" />é uma interface. Essa condição de exceção é nova no .NET Framework versão 2.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o tamanho total de um tipo.</summary>
        <value>Somente leitura. Recupera o tamanho total desse tipo.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">Matriz passada de nomes a serem mapeados.</param>
        <param name="cNames">Contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</param>
        <summary>Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Recebe um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _TypeBuilder.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#GetTypeInfoCount(System.UInt32@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</param>
        <summary>Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._TypeBuilder.Invoke">
      <MemberSignature Language="C#" Value="void _TypeBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._TypeBuilder.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.System#Runtime#InteropServices#_TypeBuilder#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica o membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Ponteiro para o local onde o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Fornece acesso a propriedades e métodos expostos por um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Acesso de associação tardia usando o COM <c>IDispatch</c> interface não é suportada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.TypeBuilder.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o nome do tipo excluindo o namespace.</summary>
        <returns>Somente leitura. O nome do tipo excluindo o namespace.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public override RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Não tem suporte em módulos dinâmicos.</summary>
        <value>Somente leitura.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recuperar o tipo usando <xref:System.Type.GetType%2A?displayProperty=nameWithType> ou <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> e usar reflexão no tipo recuperado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Não tem suporte em módulos dinâmicos.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeToken">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.TypeToken TypeToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.Emit.TypeToken TypeToken" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.TypeToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.TypeToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o token de tipo deste tipo.</summary>
        <value>Somente leitura. Retorna o <see langword="TypeToken" /> desse tipo.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">O tipo foi criado anteriormente usando <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public override Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Emit.TypeBuilder.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o tipo subjacente do sistema para este <see langword="TypeBuilder" />.</summary>
        <value>Somente leitura. Retorna o tipo de sistema subjacente.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Esse tipo é uma enumeração, mas não há nenhum tipo de sistema subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="UnspecifiedTypeSize">
      <MemberSignature Language="C#" Value="public const int UnspecifiedTypeSize = 0;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 UnspecifiedTypeSize = (0)" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.TypeBuilder.UnspecifiedTypeSize" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Emit</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>0</MemberValue>
      <Docs>
        <summary>Representa que o tamanho total para o tipo não for especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
