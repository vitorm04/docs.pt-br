<Type Name="OpCodes" FullName="System.Reflection.Emit.OpCodes">
  <TypeSignature Language="C#" Value="public class OpCodes" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit OpCodes extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Emit.OpCodes" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece representações de campo das instruções da MSIL (Microsoft intermediate language) para emissão por membros da classe <see cref="T:System.Reflection.Emit.ILGenerator" /> (como <see cref="M:System.Reflection.Emit.ILGenerator.Emit(System.Reflection.Emit.OpCode)" />).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter uma descrição detalhada do que a operação de membro, consulte a documentação de infra-estrutura de linguagem comum (CLI), especialmente "Partição III: conjunto de instruções CIL" e "Partição II: metadados definição e semântica". A documentação está disponível online; confira [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212), no MSDN, e [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552), no site internacional da Ecma.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a construção de um método dinâmico usando <xref:System.Reflection.Emit.ILGenerator> emitir `OpCodes` em um <xref:System.Reflection.Emit.MethodBuilder>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.OpCodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.OpCodes Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adiciona dois valores e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|58|adicionar|Adiciona dois valores numéricos, retornando um novo valor numérico.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é adicionado ao `value2`.  
  
4.  O resultado é inserido na pilha.  
  
 Estouro não é detectado para operações de inteiro (para manipulação de estouro adequada, consulte <xref:System.Reflection.Emit.OpCodes.Add_Ovf>).  
  
 Adição de inteiro é quebrada, em vez de esteja saturado. Por exemplo, supondo que inteiros de 8 bits onde `value1` é definido como 255 e `value2` é definido como 1, o resultado encapsulado é 0, em vez de 256.  
  
 Estouro de ponto flutuante retorna `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).  
  
 Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir. Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é um inválido idioma MSIL (Microsoft Intermediate) e gera um erro.  
  
|operando|tipo de value1|tipo de value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|adicionar|`int32`|`int32`|`int32`|  
|adicionar|`int32`|`native int`|`native int`|  
|adicionar|`int32`|`&`|`&`|  
|adicionar|`int32`|`*`|`*`|  
|adicionar|`int64`|`int64`|`int64`|  
|adicionar|`native int`|`int32`|`native int`|  
|adicionar|`native int`|`native int`|`native int`|  
|adicionar|`native int`|`&`|`&`|  
|adicionar|`native int`|`*`|`*`|  
|adicionar|`F`|`F`|`F`|  
|adicionar|`&`|`int32`|`&`|  
|adicionar|`&`|`native int`|`&`|  
|adicionar|`*`|`int32`|`*`|  
|adicionar|`*`|`native int`|`*`|  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adiciona dois números inteiros, executa uma verificação de estouro e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D6|Add.OVF|Adiciona dois valores de inteiro assinado com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é adicionado ao `value2` com uma verificação de estouro.  
  
4.  O resultado é inserido na pilha.  
  
 <xref:System.OverflowException>é gerada se o resultado não é representado no tipo de resultado.  
  
 Você pode executar esta operação em inteiros com sinal. Para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir. Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.  
  
|operando|tipo de value1|tipo de value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|adicionar|`int32`|`int32`|`int32`|  
|adicionar|`int32`|`native int`|`native int`|  
|adicionar|`int32`|`&`|`&`|  
|adicionar|`int32`|`*`|`*`|  
|adicionar|`int64`|`int64`|`int64`|  
|adicionar|`native int`|`int32`|`native int`|  
|adicionar|`native int`|`native int`|`native int`|  
|adicionar|`native int`|`&`|`&`|  
|adicionar|`native int`|`*`|`*`|  
|adicionar|`F`|`F`|`F`|  
|adicionar|`&`|`int32`|`&`|  
|adicionar|`&`|`native int`|`&`|  
|adicionar|`*`|`int32`|`*`|  
|adicionar|`*`|`native int`|`*`|  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Add_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Add_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Add_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Adiciona dois valores inteiros sem sinal, executa uma verificação de estouro e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D7|Add.OVF.Un|Adiciona dois valores inteiros sem sinal com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é adicionado ao `value2` com uma verificação de estouro.  
  
4.  O resultado é inserido na pilha.  
  
 <xref:System.OverflowException>é gerada se o resultado não é representado no tipo de resultado.  
  
 Você pode executar esta operação em inteiros com sinal. Para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Add>.  
  
 Os tipos de operando aceitável e seu tipo de dados de resultado correspondente são listados na tabela a seguir. Se não houver nenhuma entrada para uma combinação de tipo específico (por exemplo, `int32` e `float`; `int32` e `int64`), ele é uma instrução inválida do Microsoft Intermediate Language (MSIL) e gera um erro.  
  
|operando|tipo de value1|tipo de value2|tipo de resultado|  
|-------------|-----------------|-----------------|-----------------|  
|adicionar|`int32`|`int32`|`int32`|  
|adicionar|`int32`|`native int`|`native int`|  
|adicionar|`int32`|`&`|`&`|  
|adicionar|`int32`|`*`|`*`|  
|adicionar|`int64`|`int64`|`int64`|  
|adicionar|`native int`|`int32`|`native int`|  
|adicionar|`native int`|`native int`|`native int`|  
|adicionar|`native int`|`&`|`&`|  
|adicionar|`native int`|`*`|`*`|  
|adicionar|`F`|`F`|`F`|  
|adicionar|`&`|`int32`|`&`|  
|adicionar|`&`|`native int`|`&`|  
|adicionar|`*`|`int32`|`*`|  
|adicionar|`*`|`native int`|`*`|  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `add.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="And">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode And;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode And" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.And" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula o AND bit a bit de dois valores e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Instrução|Descrição|  
|------------|-----------------|-----------------|  
|5F|e|Determina o AND bit a bit de dois valores inteiros.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value1`e `value2` são disparados da pilha; AND bit a bit de dois valores é computado.  
  
4.  O resultado é inserido na pilha.  
  
 O `and` instrução calcula o AND bit a bit dos valores de duas primeiras na pilha e deixa o resultado na pilha.  
  
 `And`é uma operação de inteiro específico.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `and` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Arglist">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Arglist;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Arglist" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Arglist" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna um ponteiro não gerenciado para a lista de argumentos do método atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 00|arglist|Retorna um identificador de lista de argumento para o método atual.|  
  
 Não há comportamentos de pilha de avaliação são executados por essa operação.  
  
 O `arglist` instrução retorna um identificador opaco (um ponteiro não gerenciado, do tipo `native int`) que representa a lista de argumento do método atual. Esse identificador é válido somente durante o tempo de vida do método atual. No entanto, você pode, passar o identificador de outros métodos de como o método atual está no thread de controle. Você pode executar somente a `arglist` instrução dentro de um método que usa um número variável de argumentos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `arglist` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino se dois valores são iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|3B <`int32` >|beq`target`|Ramificação a instrução de destino no deslocamento `target` se os dois valores são iguais.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é igual a `value2`, a operação de ramificação é executada.  
  
 O `beq` instrução transfere o controle para a instrução de destino especificado se `value1` é igual a `value2`. O efeito é o mesmo que executar uma `ceq` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Os tipos de operando aceitáveis são encapsulados abaixo:  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.  
  
 O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução (essas transferências são restritas severos e deve usar o <xref:System.Reflection.Emit.OpCodes.Leave> instrução em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `beq` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Beq_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Beq_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Beq_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Beq_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino (forma abreviada) se dois valores são iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|2E <`int8` >|beq.s`target`|Ramificação a instrução de destino no deslocamento `target` se igual, forma abreviada|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é igual a `value2`, a operação de ramificação é executada.  
  
 O `beq.s` instrução transfere o controle para a instrução de destino especificado se `value1` é igual a `value2`. O efeito é o mesmo que executar uma `ceq` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Os tipos de operando aceitáveis são encapsulados abaixo:  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.  
  
 O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução (essas transferências são restritas severos e deve usar o <xref:System.Reflection.Emit.OpCodes.Leave> instrução em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `beq.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino se o primeiro valor é maior que ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|3C`<int32>`|bge`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`. O efeito é idêntico ao executar uma `clt.un` instrução seguida por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino (forma abreviada) se o primeiro valor é maior que ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|2F`<int8>`|bge.s`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`. O efeito é idêntico ao executar uma `clt.un` instrução seguida por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino se o primeiro valor é maior que o segundo valor, ao comparar valores inteiros sem sinal ou valores float não ordenado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|41 `<int32>`|bge.Un`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao segundo valor (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge.un` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `clt` instrução seguida por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bge_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bge_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bge_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bge_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino (forma abreviada) se o primeiro valor é maior que o segundo valor, ao comparar valores inteiros sem sinal ou valores float não ordenado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|34 < `int8` >|bge.un.s`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que ou igual ao valor (valores sem sinal), segunda forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `bge.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior que ou igual a `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `clt` instrução seguida por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bge.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino se o primeiro valor é maior que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|3D <`int32` >|bgt`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior do que `value2`, a operação de ramificação é executada.  
  
 O `bgt` instrução transfere o controle para a instrução de destino especificado se `value1` é maior do que `value2`. O efeito é idêntico ao executar uma `cgt` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino (forma abreviada) se o primeiro valor é maior que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|30 < `int8` >|bgt.s`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o segundo valor, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior do que `value2`, a operação de ramificação é executada.  
  
 O `bgt.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior do que `value2`. O efeito é idêntico ao executar uma `cgt` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino se o primeiro valor é maior que o segundo valor, ao comparar valores inteiros sem sinal ou valores float não ordenado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|42 < `int32` >|bgt.Un`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o valor de segundo (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior do que `value2`, a operação de ramificação é executada.  
  
 O `bgt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é maior do que `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `cgt.un` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bgt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bgt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bgt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bgt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino (forma abreviada) se o primeiro valor é maior que o segundo valor, ao comparar valores inteiros sem sinal ou valores float não ordenado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|35 < `int8` >|bgt.un.s`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é maior que o valor de segundo (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é maior do que `value2`, a operação de ramificação é executada.  
  
 O `bgt.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é maior do que `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `cgt.un` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bgt.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino se o primeiro valor é menor ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|3E`<int32>`|var`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`. O efeito é idêntico ao executar uma `cgt` instrução (`cgt.un` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino (forma abreviada) se o primeiro valor é menor ou igual ao segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|31 `<int8>`|ble.s`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`. O efeito é idêntico ao executar uma `cgt` instrução (`cgt.un` para flutuações) instrução seguida por um`brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino se o primeiro valor é menor ou igual ao segundo valor, quando a comparação não assinado valores de inteiro ou float não ordenado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|43 `<int32>`|ble.Un`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `cgt.un` instrução (`cgt` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ble_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ble_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ble_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ble_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino (forma abreviada) se o primeiro valor é menor ou igual ao segundo valor, quando a comparação não assinado valores de inteiro ou float não ordenado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|36 `<int8>`|ble.un.s`target`|Ramificação a instrução de destino no deslocamento especificado se o primeiro valor é menor ou igual ao segundo valor (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que ou igual a `value2`, a operação de ramificação é executada.  
  
 O `ble.un.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `cgt.un` instrução (`cgt` para flutuações) seguido por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ble.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino se o primeiro valor é menor que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|3F <`int32` >|blt`target`|Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que ou igual a `value2`. O efeito é idêntico ao executar uma `clt` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino (forma abreviada) se o primeiro valor é menor que o segundo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|32 < `int8` >|blt.s`target`|Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt.s` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`. O efeito é idêntico ao executar uma `clt` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino se o primeiro valor é menor que o segundo valor, ao comparar valores inteiros sem sinal ou valores float não ordenado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|44 < `int32` >|blt.Un`target`|Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o valor de segundo (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `clt.un` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Blt_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Blt_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Blt_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Blt_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controlam para uma instrução de destino (forma abreviada) se o primeiro valor é menor que o segundo valor, quando a comparação não assinado valores de inteiro ou float não ordenada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|37 < `int8` >|blt.un.s`target`|Ramificação para a instrução de destino no deslocamento especificado se o primeiro valor é menor que o segundo valor (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` é menor que `value2`, a operação de ramificação é executada.  
  
 O `blt.un` instrução transfere o controle para a instrução de destino especificado se `value1` é menor que `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `clt.un` instrução seguida por um `brtrue` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `blt.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferências de controle para uma instrução de destino quando dois valores inteiros sem sinal ou valores float não ordenada não são iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|40 < `int32` >|bne.Un`target`|Ramificação para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` não é igual a `value2`, a operação de ramificação é executada.  
  
 O `bne.un` instrução transfere o controle para a instrução de destino especificado se `value1` não é igual a `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `ceq` instrução seguida por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bne.un` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Bne_Un_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Bne_Un_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Bne_Un_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Bne_Un_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino (forma abreviada) quando dois valores inteiros sem sinal ou valores de float não ordenados não são iguais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|33 < `int8` >|bne.un.s`target`|Ramificação para o destino de instrução no deslocamento especificado se dois valores inteiros sem sinal são não igual (valores sem sinal), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; se `value1` não é igual a `value2`, a operação de ramificação é executada.  
  
 O `bne.un` instrução transfere o controle para a instrução de destino especificado se `value1` não é igual a `value2`, quando comparados com valores de float não ordenada ou inteiro não assinado. O efeito é idêntico ao executar uma `ceq` instrução seguida por um `brfalse` ramificação para a instrução de destino específico. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `bne.un.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Box">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Box;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Box" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Box" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte um tipo de valor em uma referência de objeto (tipo <see langword="O" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|8C <`T` >|caixa`valTypeToken`|Converter um tipo de valor (do tipo especificado em `valTypeToken`) para uma referência de objeto true.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um tipo de valor é inserido na pilha.  
  
2.  O tipo de valor é exibido da pilha; o `box` operação é executada.  
  
3.  Uma referência de objeto para o tipo de valor "box" resultante é inserida na pilha.  
  
 Um tipo de valor tem duas representações separadas no Common Language Infrastructure (CLI):  
  
-   Uma forma 'bruta' usada quando um tipo de valor é inserido em outro objeto ou na pilha.  
  
-   Uma forma 'boxed', onde os dados no tipo de valor são encapsulados (boxed) em um objeto para que ele pode existir de modo independente.  
  
 O `box` instrução converte o tipo de valor (não demarcado) 'brutas' em uma referência de objeto (tipo `O`). Isso é feito criando um novo objeto e copiar os dados do tipo de valor para o objeto recentemente alocado. `valTypeToken`um token de metadados que indica o tipo do tipo de valor na pilha.  
  
 <xref:System.OutOfMemoryException>é gerada se há memória suficiente para atender à solicitação.  
  
 <xref:System.TypeLoadException>é gerada se a classe não pode ser encontrada. Normalmente, isso é detectado quando Microsoft Intermediate Language (MSIL) é convertido em código nativo, em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `box` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle 	incondicionalmente para uma instrução de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|38 < `int32` >|br`target`|Ramificações de uma instrução de destino no deslocamento especificado.|  
  
 Não há comportamentos de pilha de avaliação são executados por essa operação.  
  
 O `br` instrução incondicionalmente transfere o controle para uma instrução de destino. A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `br` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Br_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Br_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Br_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Br_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle de forma incondicional para uma instrução de destino (forma abreviada).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|2B <`int8` >|br.s`target`|Ramificações de uma instrução de destino no deslocamento especificado, de forma abreviada.|  
  
 Não há comportamentos de pilha de avaliação são executados por essa operação.  
  
 O `br.s` instrução incondicionalmente transfere o controle para uma instrução de destino. A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `br.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Break;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Break" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Break" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sinaliza a infraestrutura de linguagem comum (CLI) para informar o depurador um ponto de interrupção foi ultrapassado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|01|break|Informe um depurador um ponto de interrupção foi atingido.|  
  
 Não há comportamentos de pilha de avaliação são executados por essa operação.  
  
 O `break` instrução é para suporte à depuração. Ele sinaliza o CLI para informar o depurador um ponto de interrupção foi ultrapassado. Não tem nenhum outro efeito sobre o estado do interpretador.  
  
 O `break` instrução tem o menor possível tamanho habilitar código de instrução de aplicação de patches com um ponto de interrupção e gerando interferência no mínimo para o código ao redor.  
  
 O `break` instrução pode interceptar a um depurador, não fazer nada ou gerar uma exceção de segurança. O comportamento exato é definido pela implementação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `break` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se <paramref name="value" /> for <see langword="false" />, uma referência nula (<see langword="Nothing" /> no Visual Basic) ou zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|39 < `int32` >|brfalse`target`<br /><br /> brnull`target`<br /><br /> brzero`target`|Ramificações de uma instrução de destino no deslocamento especificado se `false`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha por uma operação anterior.  
  
2.  `value`é exibido da pilha; if `value` is `false`, branch to `target`.  
  
 O `brfalse` instrução (e seus aliases `brnull` e `brzero`) transfere o controle para a instrução de destino especificado se `value` (do tipo `int32`, `int64`, referência de objeto `O`gerenciado ponteiro `&`, ponteiro transitório `*`, `native int`) é zero (`false`). Se `value` é diferente de zero (`true`) a execução continua na próxima instrução.  
  
 A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brfalse` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brfalse_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brfalse_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brfalse_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brfalse_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transferirá o controle para uma instrução de destino se <paramref name="value" /> for <see langword="false" />, uma referência nula ou zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|2C <`int8` >|brfalse.s`target`<br /><br /> brnull.s`target`<br /><br /> brzero.s`target`|Ramificações de uma instrução de destino no deslocamento especificado se `false`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha por uma operação anterior.  
  
2.  `value`é exibido da pilha; if `value` is `false`, branch to `target`.  
  
 O `brfalse.s` instrução (e seus aliases `brnull` e `brzero`) transfere o controle para a instrução de destino especificado se `value` (do tipo `int32`, `int64`, referência de objeto `O`gerenciado ponteiro `&`, ponteiro transitório `*`, `native int`) é zero (`false`). Se `value` é diferente de zero (`true`) a execução continua na próxima instrução.  
  
 A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brfalse.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino se <paramref name="value" /> for <see langword="true" />, não nulo ou diferente de zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|3A <`int32` >|brtrue`target`<br /><br /> brinst`target`|Ramificar para uma instrução de destino no deslocamento especificado se diferente de zero (`true`).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha por uma operação anterior.  
  
2.  `value`é exibido da pilha; if `value` is `true`, branch to `target`.  
  
 O `brtrue` instrução transfere o controle para a instrução de destino especificado se `value` (tipo `native int`) é diferente de zero (`true`). Se `value` é zero (`false`) a execução continua na próxima instrução.  
  
 Se `value` é uma referência de objeto (tipo `O`), em seguida, `brinst` (um alias para `brtrue`) transfere o controle se ele representa uma instância de um objeto (por exemplo, se não for a referência de objeto nulo; consulte <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 A instrução de destino é representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brtrue` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Brtrue_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Brtrue_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Brtrue_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Brtrue_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle para uma instrução de destino (forma abreviada) se <paramref name="value" /> for <see langword="true" />, não nulo ou diferente de zero.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|2D <`int8` >|brtrue.s`target`<br /><br /> brinst.s`target`|Ramificar para uma instrução de destino no deslocamento especificado se diferente de zero (`true`), forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha por uma operação anterior.  
  
2.  `value`é exibido da pilha; if `value` is `true`, branch to `target`.  
  
 O `brtrue.s` instrução transfere o controle para a instrução de destino especificado se `value` (tipo `native int`) é diferente de zero (`true`). Se `value` é zero (`false`) a execução continua na próxima instrução.  
  
 Se `value` é uma referência de objeto (tipo `O`), em seguida, `brinst` (um alias para `brtrue`) transfere o controle se ele representa uma instância de um objeto (por exemplo, se não for a referência de objeto nulo; consulte <xref:System.Reflection.Emit.OpCodes.Ldnull>).  
  
 A instrução de destino é representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos. O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `brtrue.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Call">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Call;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Call" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Call" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chama o método indicado pelo descritor de método passado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|28 < `T` >|chamada`methodDesc`|Chame o método descrito pelo `methodDesc`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Argumentos de método `arg1` por meio de `argN` são colocados na pilha.  
  
2.  Argumentos de método `arg1` por meio de `argN` são disparados da pilha; a chamada do método é executada com estes argumentos e o controle é transferido para o método chamado pelo descritor de método. Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado para o chamador.  
  
3.  O valor de retorno é inserido na pilha.  
  
 O `call` instrução chama o método indicado pelo descritor de método passado com a instrução. O descritor de método é um token de metadados que indica o método de chamada e o número, tipo e ordem dos argumentos que foram colocadas na pilha a serem passados para esse método, bem como a convenção de chamada a ser usado. O `call` instrução pode ser imediatamente precedida por um `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefixo instrução para especificar que o estado atual do método deve ser liberado antes da transferência de controle. Se a chamada transfere o controle para um método de confiança mais alto que o método de origem, o quadro de pilha não está liberado. Em vez disso, a execução continua silenciosamente como se o `tail` não tinha sido fornecido. O token de metadados contém informações suficientes para determinar se a chamada é um método estático, um método de instância, um método virtual ou uma função global. Em todos esses casos, o endereço de destino é determinado inteiramente do descritor de método (Compare isso com o <xref:System.Reflection.Emit.OpCodes.Callvirt> instrução para chamar métodos virtuais, em que o endereço de destino também depende do tipo de tempo de execução da referência de instância enviada por push antes do <xref:System.Reflection.Emit.OpCodes.Callvirt>).  
  
 Os argumentos são colocados na pilha na ordem da esquerda para direita. Ou seja, o primeiro argumento é calculado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários forem sobre a pilha em ordem decrescente. Há três casos especiais importantes:  
  
 1. Chamadas para uma instância (ou virtuais) método deve enviar por push essa referência de instância antes de qualquer um dos argumentos visível pelo usuário. A referência de instância não deve ser uma referência nula. A assinatura executada nos metadados não contém uma entrada na lista de parâmetros para o `this` ponteiro; em vez disso, ele usa um bit para indicar se o método requer passando o `this` ponteiro.  
  
 2. É válido chamar um método virtual usando `call` (em vez de `callvirt`); isso indica que o método deve ser resolvido com a classe especificada pelo método em vez de como especificado dinamicamente a partir do objeto a ser chamado.  
  
 3. Observe que um representante `Invoke` método pode ser chamado com um o `call` ou `callvirt` instrução.  
  
 <xref:System.Security.SecurityException>pode ser acionada se a segurança do sistema não concede o acesso externo para o método chamado. A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
> [!NOTE]
>  Ao chamar métodos de System. Object em tipos de valor, considere o uso de `constrained` com prefixo o `callvirt` instrução, em vez de emitir um `call` instrução. Isso elimina a necessidade de emissão de IL diferente dependendo se o tipo de valor substitui o método, evitando um possível problema de controle de versão. Considere o uso de `constrained` prefixo ao chamar métodos em tipos de valor, como o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`. Esses problemas são descritos mais detalhadamente o <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `call` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (código de operação, MethodInfo, Type[])  
  
> [!NOTE]
>  O <xref:System.Reflection.Emit.ILGenerator.EmitCall%2A> método é fornecido para `varargs` chamadas. Use o <xref:System.Reflection.Emit.ILGenerator.Emit%2A> método para chamadas normais.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Calli">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Calli;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Calli" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Calli" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chama o método indicado na pilha de avaliação (como um ponteiro para um ponto de entrada) com argumentos descritos por uma convenção de chamada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|29 < `T` >|calli`callSiteDescr`|Chama o método apontado com argumentos descritos pela convenção de chamada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Argumentos de método `arg1` por meio de `argN` são colocados na pilha.  
  
2.  O ponteiro de entrada do método é inserido na pilha.  
  
3.  Argumentos de método `arg1` por meio de `argN` e o ponteiro de entrada do método são disparados da pilha; a chamada ao método é executada. Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado para o chamador.  
  
4.  O valor de retorno é inserido na pilha.  
  
 O `calli` instrução chama o ponteiro de entrada do método com os argumentos `arg1` por meio de `argN`. Os tipos desses argumentos são descritos pela convenção de chamada específica (`callSiteDesc`). O `calli` instrução pode ser imediatamente precedida por um `tail` prefixo (<xref:System.Reflection.Emit.OpCodes.Tailcall>) para especificar que o estado atual do método deve ser liberado antes da transferência de controle. Se a chamada transfere controle a um método de confiança mais alto que o método de origem do quadro de pilha não será liberado; em vez disso, a execução continuará silenciosamente como se o `tail` não tinha sido fornecido.  
  
 O ponteiro de entrada do método deve para ser um ponteiro específico para código nativo (da máquina de destino) que pode ser chamado de forma legítima com os argumentos descritos pela convenção de chamada (um token de metadados para uma assinatura autônoma). Um ponteiro esse pode ser criado usando o <xref:System.Reflection.Emit.OpCodes.Ldftn> ou <xref:System.Reflection.Emit.OpCodes.Ldvirtftn> instruções, ou transmitida de código nativo.  
  
 A convenção de chamada não é verificada dinamicamente, portanto código que usa um `calli` instrução não funcionarão corretamente se o destino não usa, na verdade, a convenção de chamada especificada.  
  
 Os argumentos são colocados na pilha na ordem da esquerda para direita. Ou seja, o primeiro argumento é calculado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários forem sobre a pilha em ordem decrescente. A sequência de código de construção de argumento para uma instância ou um método virtual deve enviar por push essa referência de instância (que não deve ser uma referência nula) antes de qualquer um dos argumentos visível pelo usuário.  
  
 <xref:System.Security.SecurityException>pode ser acionada se a segurança do sistema não concede o acesso externo para o método chamado. A verificação de segurança pode ocorrer quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.EmitCalli%2A> métodos podem ser usados para executar um `calli` instrução na pilha. Observe que `calli` deve ser chamado por meio de abaixo métodos em vez de usar o <xref:System.Reflection.Emit.ILGenerator.Emit%2A> classe para inserir a instrução diretamente na pilha.  
  
-   ILGenerator.EmitCalli (Opcode, CallingConventions, tipo, tipo [], Type[]) para chamadas usando uma convenção de chamada gerenciada.  
  
-   ILGenerator.EmitCalli (código de operação, Type[]) CallingConvention, tipo, para chamadas usando uma convenção de chamada não gerenciada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Callvirt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Callvirt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Callvirt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Callvirt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Chama um método de associação tardia em um objeto, enviando o valor retornado por push para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|6F <`T` >|callvirt`method`|Chama um método específico associado `obj`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `obj` é inserido na pilha.  
  
2.  Argumentos de método `arg1` por meio de `argN` são colocados na pilha.  
  
3.  Argumentos de método `arg1` por meio de `argN` e a referência de objeto `obj` são disparados da pilha; a chamada do método é executada com estes argumentos e o controle é transferido para o método `obj` chamado pelo token de metadados de método. Ao concluir, um valor de retorno é gerado pelo método de receptor e enviado para o chamador.  
  
4.  O valor de retorno é inserido na pilha.  
  
 O `callvirt` instrução chama um método de associação tardia em um objeto. Ou seja, o método é escolhido com base no tipo de tempo de execução do `obj` em vez da classe de tempo de compilação visível no ponteiro de método. `Callvirt`pode ser usado para chamar virtual e métodos de instância. O `callvirt` instrução pode ser imediatamente precedida por um `tail` (<xref:System.Reflection.Emit.OpCodes.Tailcall>) prefixo para especificar que o quadro de pilhas atual deve ser liberado antes da transferência de controle. Se a chamada transfere controle para um método de confiança superior do método original de quadro de pilha não seja liberado.  
  
 O token de metadados de método fornece o nome, a classe e a assinatura do método a ser chamado. A classe associada `obj` é a classe do qual ele é uma instância. Se a classe define um método não estático que corresponde ao nome do método indicado e a assinatura, este método é chamado. Caso contrário, todas as classes na cadeia de classe base desta classe são verificadas em ordem. É um erro se nenhum método foi encontrado.  
  
 `Callvirt`Exibe o objeto e os argumentos associados na pilha de avaliação antes de chamar o método. Se o método tiver um valor de retorno, ela é enviada por push na pilha após a conclusão do método. No lado receptor, o `obj` parâmetro é acessado como argumento 0, `arg1` como argumento 1 e assim por diante.  
  
 Os argumentos são colocados na pilha na ordem da esquerda para direita. Ou seja, o primeiro argumento é calculado e colocado na pilha, em seguida, o segundo argumento e o terceiro, até que todos os argumentos necessários forem sobre a pilha em ordem decrescente. A referência de instância `obj` (sempre necessário para `callvirt`) deve ser enviado antes de qualquer um dos argumentos visível pelo usuário. A assinatura (executada no token de metadados) não precisa conter uma entrada na lista de parâmetros para este ponteiro.  
  
 Observe que um método virtual também pode ser chamado usando o <xref:System.Reflection.Emit.OpCodes.Call> instrução.  
  
 <xref:System.MissingMethodException>é gerada se um método não estático com o nome indicado e a assinatura não pôde ser encontrado na classe associada `obj` ou qualquer uma de suas classes base. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.  
  
 <xref:System.NullReferenceException>é gerada se o obj for null.  
  
 <xref:System.Security.SecurityException>é gerada se a segurança do sistema não concede o acesso externo para o método chamado. A verificação de segurança pode ocorrer quando a CIL é convertida em código nativo em vez de em tempo de execução.  
  
> [!NOTE]
>  Ao chamar métodos de System. Object em tipos de valor, considere o uso de `constrained` prefixo com o `callvirt` instrução. Isso elimina a necessidade de emissão de IL diferente dependendo se o tipo de valor substitui o método, evitando um possível problema de controle de versão. Considere o uso de `constrained` prefixo ao chamar métodos em tipos de valor, como o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`. Esses problemas são descritos mais detalhadamente o <xref:System.Reflection.Emit.OpCodes.Constrained> opcode.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `callvirt` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.EmitCall (código de operação, MethodInfo, Type[])  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Castclass">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Castclass;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Castclass" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Castclass" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tenta converter um objeto passado por referência à classe especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|74 < `T` >|castclass`class`|Converte um objeto para um novo objeto do tipo `class`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é exibida da pilha; o objeto referenciado é convertido conforme o especificado `class`.  
  
3.  Se for bem-sucedido, uma nova referência de objeto é inserida na pilha.  
  
 O `castclass` instrução tenta converter a referência de objeto (tipo `O`) sobre a pilha para uma determinada classe. A nova classe é especificada por um token de metadados que indica a classe desejada. Se a classe do objeto no topo da pilha não implementa a nova classe (supondo que a nova classe é uma interface) e não é uma classe derivada da nova classe e um <xref:System.InvalidCastException> é gerada. Se a referência de objeto é uma referência nula, `castclass` for bem-sucedida e retorna o novo objeto como uma referência nula.  
  
 <xref:System.InvalidCastException>é gerada se o obj não pode ser convertido em classe.  
  
 <xref:System.TypeLoadException>é gerada se a classe não pode ser encontrada. Normalmente, isso é detectado quando uma instrução Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `castclass` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ceq">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ceq;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ceq" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ceq" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois valores. Se eles forem iguais, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 01|ceq|Envia 1 se `value1` é igual a `value2`; caso contrário envia 0.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é comparado ao `value2`.  
  
4.  Se `value1` é igual a `value2`, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.  
  
 O `ceq` instrução compara `value1` e `value2`. Se `value1` é igual a `value2`, em seguida, 1 (do tipo `int32`) é enviada por push na pilha. Caso contrário, 0 (do tipo `int32`) é enviada por push na pilha.  
  
 Número de ponto flutuante, `ceq` retornará 0 se os números são classificados (um ou ambos são NaN). Os valores de infinitos são iguais entre si.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ceq` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois valores. Se o primeiro valor for maior que o segundo, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 02|cgt|Envia 1 se `value1` é maior do que `value2`; caso contrário envia 0.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `cgt` testa se `value1` é maior do que `value2`.  
  
4.  Se `value1` é maior do que `value2`, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.  
  
 O `cgt` instrução compara `value1` e `value2`. Se `value1` é estritamente maior que `value2`, então um `int32` valor 1 é enviada por push na pilha. Caso contrário, um `int32` valor de 0 é enviada por push na pilha.  
  
-   Para números de ponto flutuante, `cgt` retornará 0 se os números são classificados (ou seja, se um ou ambos os argumentos forem NaN).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cgt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cgt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cgt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cgt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cgt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois sem sinal ou não ordenados. Se o primeiro valor for maior que o segundo, o valor inteiro 1 <see langword="(int32" />) será enviado para a pilha de avaliação; caso contrário, 0 (<see langword="int32" />) será enviada para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 03|cgt.Un|Envia 1 se `value1` é maior do que `value2`; caso contrário envia 0 (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `cgt.un` testa se `value1` é maior do que `value2`.  
  
4.  Se `value1` é maior do que `value2`, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.  
  
 Um `int32` valor 1 é enviada por push na pilha se qualquer um dos seguintes for `true` :  
  
 Para números de ponto flutuante, `value1` não for ordenado em relação ao `value2`.  
  
 Para valores inteiros, `value1` é estritamente maior que `value2` quando considerados como números sem sinal.  
  
 Caso contrário, um `int32` valor de 0 é enviada por push na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cgt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ckfinite">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ckfinite;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ckfinite" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ckfinite" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gera <see cref="T:System.ArithmeticException" /> se o valor não é um número finito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|C3|ckfinite|lançar <xref:System.ArithmeticException> se o valor não é um número finito.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido da pilha e a `ckfinite` instrução é executada nele.  
  
3.  `value`é enviada de volta para a pilha se nenhuma exceção for lançada.  
  
 O `ckfinite instruction` lança <xref:System.ArithmeticException> se `value` (um número de ponto flutuante) é um valor de "não é um número" (NaN) ou um `+-` valor infinito. `Ckfinite`deixa o valor na pilha se nenhuma exceção for lançada. A execução não for especificada, se `value` não é um número de ponto flutuante.  
  
 <xref:System.ArithmeticException>será gerada se `value` não é um número 'normal'.  
  
 Observe que uma exceção especial ou uma classe derivada de <xref:System.ArithmeticException> pode ser mais apropriado, passando o valor incorreto para o manipulador de exceção.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ckfinite` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara dois valores. Se o primeiro valor é menor que o segundo, o valor inteiro 1 <see langword="(int32" />) é enviada para a pilha de avaliação; Caso contrário, 0 (<see langword="int32" />) é enviada para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 04|CLT|Envia 1 se `value1` é menor que `value2`; caso contrário envia 0.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é: `value1` é inserido na pilha.  
  
1.  `value2`é inserido na pilha.  
  
2.  `value2`e `value1` são disparados da pilha; `clt` testa se `value1` é menor que `value2`.  
  
3.  Se `value1` é menor que `value2`, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.  
  
 O `clt` instrução compara `value1` e `value2`. Se `value1` é estritamente menor que `value2`, então um `int32` valor 1 é enviada por push na pilha. Caso contrário, um `int32` valor de 0 é enviada por push na pilha.  
  
-   Para números de ponto flutuante, `clt` retornará 0 se os números são classificados (ou seja, se um ou ambos os argumentos forem NaN).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `clt` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clt_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Clt_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Clt_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Clt_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Compara os valores não assinados ou não ordenados <paramref name="value1" /> e <paramref name="value2" />. Se <paramref name="value1" /> é menor que <paramref name="value2" />, em seguida, o valor inteiro 1 <see langword="(int32" />) é enviada para a avaliação de pilha; caso contrário, 0 (<see langword="int32" />) é enviada para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 05|CLT.Un|Envia 1 se `value1` é menor que `value2`; caso contrário envia 0 (valores sem sinal).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `clt.un` testa se `value1` é menor que `value2`.  
  
4.  Se `value1` é menor que `value2`, 1 é inserido na pilha; caso contrário, 0 é inserido na pilha.  
  
 O `clt.un` instrução compara `value1` e `value2`. Um `int32` valor 1 é enviada por push na pilha se qualquer um dos seguintes for verdadeiro:  
  
-   `value1`é estritamente menor que `value2` (como `clt`).  
  
-   Para números de ponto flutuante, `value1` não for ordenado em relação ao `value2`.  
  
-   Para valores inteiros, `value1` é estritamente menor que `value2` quando considerados como números sem sinal.  
  
 Caso contrário, um `int32` valor de 0 é enviada por push na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `clt.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Constrained">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Constrained;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Constrained" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Constrained" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Restringe o tipo no qual uma chamada de método virtual é feita.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 16 <`T` >|restrito. `thisType`|Chamada de um método virtual em um tipo restrito a ser do tipo `T`.|  
  
 O `constrained` prefixo é permitido somente em um `callvirt` instrução.  
  
 O estado da pilha de MSIL agora deve ser da seguinte maneira:  
  
1.  Um ponteiro gerenciado, `ptr`, é inserido na pilha. O tipo de `ptr` deve ser um ponteiro gerenciado (`&`) para `thisType`. Observe que isso é diferente do caso de uma sem-prefixo `callvirt` instrução, que espera uma referência de `thisType`.  
  
2.  Argumentos de método `arg1` por meio de `argN` são enviados por push para a pilha, assim como ocorre com um sem-prefixo `callvirt` instrução.  
  
 O `constrained` prefixo foi projetado para permitir `callvirt` instruções a serem feitas em um uniforme maneira independente de se `thisType` é um tipo de valor ou um tipo de referência.  
  
 Quando um `callvirt` `method` instrução foi antecedida `constrained` `thisType`, a instrução é executada da seguinte maneira:  
  
-   Se `thisType` é um tipo de referência (em vez de um tipo de valor), em seguida, `ptr` é cancelada e passado como o ponteiro 'this' para o `callvirt` de `method`.  
  
-   Se `thisType` é um tipo de valor e `thisType` implementa `method` , em seguida, `ptr` é passado não modificado como o ponteiro 'this' para uma `call` `method` instruções para a implementação de `method` por `thisType`.  
  
-   Se `thisType` é um tipo de valor e `thisType` não implementa `method` , em seguida, `ptr` é cancelada, box e passado como o ponteiro 'this' para o `callvirt` `method` instrução.  
  
 Esse último caso pode ocorrer apenas quando `method` foi definido em <xref:System.Object>, <xref:System.ValueType>, ou <xref:System.Enum> e não é substituído por `thisType`. Nesse caso, a conversão boxing faz com que uma cópia do objeto original a ser feita. No entanto, porque nenhum dos métodos de <xref:System.Object>, <xref:System.ValueType>, e <xref:System.Enum> modificar o estado do objeto, esse fato não pode ser detectado.  
  
 O `constrained` prefixo suporta geradores de IL que cria o código genérico. Normalmente o `callvirt` instrução não é válida em tipos de valor. Em vez disso, é necessário que os compiladores de IL efetivamente executam a 'this' transformação descrita acima no tempo de compilação, dependendo do tipo de `ptr` e o método que está sendo chamado. No entanto, quando `ptr` é um tipo genérico que é desconhecido no tempo de compilação, não é possível fazer essa transformação em tempo de compilação.  
  
 O `constrained` opcode permite que os compiladores de IL fazer uma chamada para uma função virtual de um uniforme maneira independente de se `ptr` é um tipo de valor ou um tipo de referência. Embora seja destinado para o caso onde `thisType` é uma variável de tipo genérico, o `constrained` prefixo também funciona para tipos não genéricos e pode reduzir a complexidade de gerar chamadas virtuais em idiomas que ocultam a distinção entre tipos de valor e tipos de referência.  
  
 Usando o `constrained` prefixo também evita possíveis problemas de controle de versão com tipos de valor. Se o `constrained` prefixo não for usado, deve ser emitido IL diferente dependendo se um tipo de valor substitui um método de System. Object. Por exemplo, se um tipo de valor `V` substitui o método Object.ToString(), um `call` `V.ToString()` instrução é emitida; se não, uma `box` instrução e um `callvirt` `Object.ToString()` instrução são emitidos. Pode haver problemas de controle de versão no primeiro caso, se a substituição é removida posteriormente e no último caso se uma substituição for adicionada mais tarde.  
  
 O `constrained` prefixo também pode ser usado para a invocação de métodos de interface em tipos de valor, porque o método de tipo de valor implementando o método de interface pode ser alterado usando um `MethodImpl`. Se o `constrained` prefixo não for usado, o compilador é forçado a escolher a que o valor de métodos tipos de para associar em tempo de compilação. Usando o `constrained` prefixo permite que o MSIL ligar para o método que implementa o método de interface em tempo de execução, em vez de em tempo de compilação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `constrained` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D3|Conv.i|Converter em `native int`, envio `native int` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.i` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="int8" />, estende (pads) para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|67|Conv.I1|Converter em `int8`, envio `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.i1` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="int16" />, estende (pads) para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|68|Conv.I2|Converter em `int16`, envio `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.i2` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|69|Conv.i4|Converter em `int32`, envio `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.i4` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|6A|Conv.I8|Converter em `int64`, envio `int64` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.i8` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado no topo da pilha de avaliação assinados <see langword="native int" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D4|Conv.OVF.i|Converter em um `native int` (na pilha como `native int`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado no topo da pilha de avaliação assinados <see langword="native int" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|8|Conv.OVF.i.Un|Converte um valor sem sinal em um `native int` (na pilha como `native int`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado no topo da pilha de avaliação assinados <see langword="int8" /> e estende a <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|B3|Conv.OVF.I1|Converter em um `int8` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i1` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado no topo da pilha de avaliação assinados <see langword="int8" /> e estende a <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|82|Conv.OVF.I1.Un|Converte um valor sem sinal em um `int8` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i1.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado no topo da pilha de avaliação assinados <see langword="int16" /> e estendê-lo para <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|B5|Conv.OVF.I2|Converter em um `int16` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i2` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado no topo da pilha de avaliação assinados <see langword="int16" /> e estende a <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|83|Conv.OVF.I2.Un|Converte um valor sem sinal em um `int16` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i2.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado no topo da pilha de avaliação assinados <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|B7|Conv.OVF.i4|Converter em um `int32` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i4` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado no topo da pilha de avaliação assinados <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|84|Conv.OVF.i4.Un|Converte um valor sem sinal em um `int32` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i4.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado no topo da pilha de avaliação assinados <see langword="int64" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|B9|Conv.OVF.I8|Converter em um `int64` (na pilha como `int64`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i8` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_I8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_I8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_I8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado no topo da pilha de avaliação assinados <see langword="int64" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|85|Conv.OVF.I8.Un|Converte um valor sem sinal em um `int64` (na pilha como `int64`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.i8.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.i8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado na parte superior da pilha de avaliação para <see langword="unsigned native int" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D5|Conv.OVF.u|Converter em um `unsigned native int` (na pilha como `native int`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado na parte superior da pilha de avaliação para <see langword="unsigned native int" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|8B|Conv.OVF.u.Un|Converte Cancelar não assinado de valor para um `unsigned native int` (na pilha como `native int`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.uvf.u.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado na parte superior da pilha de avaliação para <see langword="unsigned int8" /> e estende a <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|B4|Conv.OVF.U1|Converter em um `unsigned int8` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u1` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U1_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U1_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U1_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U1_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado na parte superior da pilha de avaliação para <see langword="unsigned int8" /> e estende a <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|86|Conv.OVF.U1.Un|Converte um valor sem sinal em um `unsigned int8` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u1.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u1.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado na parte superior da pilha de avaliação para <see langword="unsigned int16" /> e estende a <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|B6|Conv.OVF.U2|Converter em um `unsigned int16` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u2` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U2_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U2_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U2_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U2_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado na parte superior da pilha de avaliação para <see langword="unsigned int16" /> e estende a <see langword="int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|87|Conv.OVF.U2.Un|Converte um valor sem sinal em um `unsigned int16` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u2.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u2.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado na parte superior da pilha de avaliação para <see langword="unsigned int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|B8|Conv.OVF.U4|Converter em um `unsigned int32` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u4` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U4_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U4_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U4_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U4_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado na parte superior da pilha de avaliação para <see langword="unsigned int32" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|88|Conv.OVF.U4.Un|Converte um valor sem sinal em um `unsigned int32` (na pilha como `int32`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u4.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u4.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor assinado na parte superior da pilha de avaliação para <see langword="unsigned int64" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|BA|Conv.OVF.U8|Converter em um `unsigned int64` (na pilha como `int64`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u8` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_Ovf_U8_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_Ovf_U8_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_Ovf_U8_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_Ovf_U8_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor não assinado na parte superior da pilha de avaliação para <see langword="unsigned int64" />, sendo lançada <see cref="T:System.OverflowException" /> no estouro.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|89|Conv.OVF.U8.Un|Converte um valor sem sinal em um `unsigned int64` (na pilha como `int64`) e gerará uma exceção no estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação. Se ocorrer estouro, uma exceção será lançada.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.ovf.u8.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e coloca convertidos valor na parte superior da pilha. Se o valor for muito grande ou muito pequeno para ser representado pelo tipo de destino, uma exceção será lançada.  
  
 Conversões de números de ponto flutuante para valores inteiros truncam o número em direção a zero. Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.ovf.i` ou `conv.ovf.u` forem usados, caso em que o resultado é também `native int`).  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.ovf.u8.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor de inteiro na parte superior da pilha de avaliação para <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|76|Conv.r.Un|Converter inteiro sem sinal de ponto flutuante, enviar por push `F` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.r.un` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro de `result` retornado é especificado. O `conv.r.un` operação assume um número inteiro na pilha, interpreta como não assinado e o substitui por um número de ponto flutuante para representar o número inteiro: ou um `float32`, se isso for grande o suficiente para representar o inteiro sem perda de precisão, ou então um `float64`.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="float32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|6B|Conv.R4|Converter em `float32`, envio `F` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.r4` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="float64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|6C|Conv.R8|Converter em `float64`, envio `F` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.r8` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="unsigned native int" />, e a estende para <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|E0|Conv.u|Converter em `unsigned native int`, envio `native int` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.u` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="unsigned int8" />, e a estende para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D2|Conv.U1|Converter em `int8`, envio `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.u1` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I1_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="unsigned int16" />, e a estende para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D1|Conv.U2|Converter em `int16`, envio `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.u2` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I2_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="unsigned int32" />, e a estende para <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|6D|Conv.U4|Converter em `unsigned int32`, envio `int32` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.u4` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I4_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Conv_U8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Conv_U8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Conv_U8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Conv_U8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte o valor na parte superior da pilha de avaliação para <see langword="unsigned int64" />, e a estende para <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|6E|Conv.U8|Converter em `int64`, envio `int64` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e a conversão de tentativa de operação.  
  
3.  Se a conversão for bem-sucedida, o valor resultante é inserido na pilha.  
  
 O `conv.u8` opcode converte o `value` na parte superior da pilha para o tipo especificado no opcode e deixe que converter o valor no topo da pilha. Valores de inteiro de menos de 4 bytes são estendidos para `int32` quando eles são carregados para a pilha de avaliação (a menos que `conv.i` ou `conv.u` for usado, caso em que o resultado é também `native int`). Valores de ponto flutuante são convertidos para o `F` tipo.  
  
 A conversão de números de ponto flutuante em valores inteiros trunca o número em direção a zero. Ao converter de um `float64` para um `float32`, precisão pode ser perdida. Se `value` é muito grande para caber em uma `float32 (F)`, infinito positivo (se `value` for positivo) ou negativo infinito (se `value` for negativo) será retornado. Se estouro ocorre conversão de tipo de um inteiro para outro, os bits de ordem mais alta serão truncados. Se o resultado for menor do que um `int32`, o valor é de assinatura estendida para preencher o slot.  
  
 Se ocorrer estouro de converter um tipo de ponto flutuante para um inteiro, o valor retornado é especificada.  
  
 Nenhuma exceção nunca é geradas quando o uso desse campo. Consulte <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8> e <xref:System.Reflection.Emit.OpCodes.Conv_Ovf_I8_Un> para obter instruções equivalentes que lançará uma exceção quando o tipo de resultado pode não representar corretamente o valor do resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `conv.u8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia bytes de número especificados de um endereço de origem para um endereço de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 17|cpblk|Copie dados do bloco de memória para outra.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço de destino é inserido na pilha.  
  
2.  O endereço de origem é inserido na pilha.  
  
3.  O número de bytes a serem copiados é inserido na pilha.  
  
4.  O número de bytes, o endereço de origem e o endereço de destino é disparado da pilha; o número especificado de bytes é copiado do endereço de origem para o endereço de destino.  
  
 O `cpblk` instrução copia um número (tipo `unsigned int32`) de bytes de um endereço de origem (do tipo `*`, `native int`, ou `&`) para um endereço de destino (do tipo `*`, `native int`, ou `&`). O comportamento de `cpblk` for especificado, se as áreas de origem e de destino se sobrepõem.  
  
 `cpblk`pressupõe-se de que a origem e destino endereçado são alinhados com o tamanho natural da máquina. O `cpblk` instrução pode ser imediatamente precedida pelo `unaligned.<prefix>` instrução para indicar que a origem ou o destino é não alinhado.  
  
 A operação do `cpblk` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cpblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cpobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Cpobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Cpobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Cpobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>O tipo de valor localizado no endereço de um objeto de cópias (tipo <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />) para o endereço do objeto de destino (tipo <see langword="&amp;" />, <see langword="*" /> ou <see langword="native int" />).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|70 < `T` >|cpobj`classTok`|Cópias de um valor de tipo de um objeto de origem para um objeto de destino.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  A referência de objeto de destino é inserida na pilha.  
  
2.  A referência de objeto de origem é inserida na pilha.  
  
3.  As duas referências de objeto são disparadas da pilha; o tipo de valor no endereço do objeto de origem é copiado para o endereço do objeto de destino.  
  
 O comportamento de `cpobj` for especificado, se as referências não são ponteiros para instâncias da classe representada pelo token de classe de objeto de origem e destino `classTok` (uma `typeref` ou `typedef`), ou se `classTok` não representa um tipo de valor.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `cpobj` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores e envia o resultado como um ponto flutuante (tipo <see langword="F" />) ou o quociente (tipo <see langword="int32" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|5B|div|Divide dois valores para retornar um resultado de ponto flutuante ou o quociente.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é dividida por `value2`.  
  
4.  O resultado é inserido na pilha.  
  
 `result` = `value1`div value2 satisfaz as condições a seguir:  
  
 &#124; `result` &#124; = &#124; `value1` &#124; / &#124; `value2` &#124; e:  
  
 sinal (`result`) = +, se entrar (`value1`) = sinal (`value2`), ou-, se sinal (`value1`) ~ = sinal (`value2`)  
  
 O `div` instrução calcula o resultado e envia por push na pilha.  
  
 Divisão de inteiro trunca em direção a zero.  
  
 Divisão de um número finito por zero produz o valor infinito assinado corretamente.  
  
 Dividindo o zero por zero ou infinito por infinito produz o valor NaN (não-um número). Qualquer número dividido por infinito produzirá um valor igual a zero.  
  
 Operações integrais lançam <xref:System.ArithmeticException> se o resultado não pode ser representado no tipo de resultado. Isso pode acontecer se `value1` é o valor negativo máximo, e `value2` é -1.  
  
 Operações integrais lançam <xref:System.DivideByZeroException> se `value2` é zero.  
  
 Observe que em plataformas baseadas em Intel em um <xref:System.OverflowException> é gerada quando a computação (minint div -1). Operações de ponto flutuante nunca lançam uma exceção (geram NaNs ou pontos em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `div` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Div_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Div_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Div_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Div_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores inteiros sem sinal e envia o resultado (<see langword="int32" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|5C|div.Un|Divide dois valores, não assinados, retornando um quociente.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é dividida por `value2`.  
  
4.  O resultado é inserido na pilha.  
  
 O `div.un` calcula a instrução `value1` dividido por `value2`, ambos assumida como inteiros sem sinal e coloca o `result` na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `div.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dup">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Dup;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Dup" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Dup" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia o valor atual mais alto na pilha de avaliação e, em seguida, envia a cópia para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|25|DUP|Duplica o valor na parte superior da pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido fora a pilha para eliminação de duplicação.  
  
3.  `value`é enviada de volta para a pilha.  
  
4.  Um valor duplicado é inserido na pilha.  
  
 O `dup` instrução duplica o elemento superior da pilha e deixa de dois valores idênticos sobre ele.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `dup` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfilter">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfilter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfilter" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfilter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle da cláusula <see langword="filter" /> de uma exceção para o manipulador de exceção da CLI (Common Language Infrastructure).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 11|Endfilter|Cláusula de filtro de final de tratamento de exceções de SEH.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido da pilha; `endfilter` é executado e o controle é transferido para o manipulador de exceção.  
  
 `Value`(que deve ser do tipo `int32` e é parte de um conjunto específico de valores) é retornado na cláusula de filtro. Ele deve ser um destes:  
  
-   `exception_continue_search`(`value` = 0) para continuar a pesquisa de um manipulador de exceção  
  
-   `exception_execute_handler`(`value` = 1) para iniciar a segunda fase da manipulação de exceção onde finalmente blocos são executados até que o manipulador associado a essa cláusula de filtro está localizado. Após a descoberta, o manipulador é executado.  
  
 Outros valores inteiros produzirá resultados não especificados.  
  
 O ponto de entrada de um filtro, como mostrado na tabela de exceção do método, deve ser a primeira instrução no bloco de código do filtro. O `endfilter` instrução deve ser a última instrução no bloco de código do filtro (portanto, pode haver apenas um `endfilter` para qualquer bloco único filtro). Depois de executar o `endfilter` instrução, logicamente fluxos de controle para o mecanismo de tratamento de exceções de CLI.  
  
 Controle não pode ser transferido para um bloco de filtro, exceto pelo mecanismo de exceção. Não é possível transferir controle fora de um bloco de filtro, exceto por meio do uso de um `throw` instrução ou executando o último `endfilter` instrução. Não é possível inserir um `try` bloquear dentro de um `filter` bloco. Se uma exceção é gerada dentro de `filter` bloco, isso será interceptado e um valor de 0 (`exception_continue_search`) será retornado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `endfilter` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Endfinally">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Endfinally;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Endfinally" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Endfinally" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Transfere o controle do <see langword="fault" /> ou <see langword="finally" /> cláusula de um bloco de exceção para o manipulador de exceção de infraestrutura de linguagem comum (CLI).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|DC|Endfinally<br /><br /> endfault|Termina o `finally` ou `fault` cláusula de um bloco de exceção.|  
  
 Não há nenhuma pilha comportamentos de transição para essa instrução.  
  
 `Endfinally`e `endfault` sinalizar o final do `finally` ou `fault` cláusula para que o desenrolamento de pilha pode continuar até que o manipulador de exceção é invocado. O `endfinally` ou `endfault` instrução transfere o controle volta para o mecanismo de exceção CLI. Em seguida, o mecanismo procura a próxima `finally` cláusula na cadeia se o bloco protegido foi encerrado com uma instrução de licença. Se o bloco protegido foi encerrado com uma exceção, a CLI procurará o próximo `finally` ou `fault`, ou insira o manipulador de exceção escolhido durante a primeira passagem de manipulação de exceção.  
  
 Um `endfinally` instrução só pode aparecer lexicalmente dentro um `finally` bloco. Diferentemente de `endfilter` instrução, não há nenhum requisito para que o bloco terminar com um `endfinally` instrução e pode haver tantos `endfinally` instruções dentro do bloco conforme necessário. Essas restrições se aplicam ao `endfault` instrução e o `fault` bloco.  
  
 Controle não pode ser transferido em uma `finally` (ou `fault`) bloquear exceto pelo mecanismo de exceção. Não é possível transferir controle fora de um `finally` (ou `fault`) bloquear exceto por meio do uso de um `throw` instruções ou executar o `endfinally` (ou `endfault`) instrução. Em particular, você não pode "se" de um `finally` (ou `fault`) bloco ou execute um <xref:System.Reflection.Emit.OpCodes.Ret> ou <xref:System.Reflection.Emit.OpCodes.Leave> instrução dentro de um `finally` (ou `fault`) bloco.  
  
 Observe que o `endfault` e `endfinally` instruções são aliases - elas correspondem ao mesmo código.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `endfinally` (`endfault`) opcode, bem como o `ILGenerator` método <xref:System.Reflection.Emit.ILGenerator.EndExceptionBlock%2A>.  
  
-   ILGenerator.Emit(OpCode)  
  
-   ILGenerator.EndExceptionBlock()  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initblk">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initblk;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initblk" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initblk" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicializa um bloco de memória especificado em um endereço específico e em um tamanho e valor inicial especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 18|initblk|Defina cada local em um bloco de memória para um determinado valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço inicial é inserido na pilha.  
  
2.  Um valor de inicialização é inserido na pilha.  
  
3.  O número de bytes para inicializar é inserido na pilha.  
  
4.  O número de bytes, o valor de inicialização e o endereço inicial é disparado da pilha e a inicialização é executada de acordo com seus valores.  
  
 O `initblk` instrução define o número (`unsigned int32`) de bytes, começando no endereço especificado (do tipo `native int`, `&`, ou `*`) para o valor de inicialização (do tipo `unsigned int8`). `initblk`pressupõe-se de que o endereço inicial é alinhado ao tamanho natural da máquina.  
  
 A operação do `initblk` instruções podem ser alteradas por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `initblk` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Initobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Initobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Initobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Inicializa cada campo do tipo de valor em um endereço especificado como uma referência nula ou 0 do tipo primitivo apropriado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 15 <`T` >|`initobj` `typeTok`|Inicializa um tipo de valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço do tipo de valor para inicializar é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o tipo de valor no endereço especificado é inicializado como tipo `typeTok`.  
  
 O `initobj` instrução inicializa cada campo do tipo de valor especificado pelo endereço enviadas por push (do tipo `native int`, `&`, ou `*`) para uma referência nula ou 0 do tipo primitivo apropriado. Depois que este método é chamado, a instância está pronta para um método de construtor a ser chamado. Se `typeTok` é um tipo de referência, esta instrução tem o mesmo efeito que `ldnull` seguido por `stind.ref`.  
  
 Ao contrário de <xref:System.Reflection.Emit.OpCodes.Newobj>, `initobj` não chama o método de construtor. `Initobj`é destinado ao inicializar os tipos de valor, enquanto `newobj` é usada para alocar e inicializar objetos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `initobj` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Isinst">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Isinst;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Isinst" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Isinst" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Testa se uma referência de objeto (tipo <see langword="O" />) é uma instância de uma classe específica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|75 < `T` >|isinst`class`|Testa se uma referência de objeto é uma instância de `class`, retornando uma referência nula ou uma instância dessa classe ou interface.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é exibida da pilha e testada para ver se ele é uma instância da classe passada `class`.  
  
3.  O resultado (uma referência de objeto ou uma referência nula) é inserido na pilha.  
  
 `Class`um token de metadados que indica a classe desejada. Se a classe do objeto no topo da pilha implementa `class` (se `class` é uma interface) ou é uma classe derivada de `class` (se `class` é uma classe regular), em seguida, ela será convertida para o tipo `class` e o resultado é enviada por push na pilha, exatamente como se <xref:System.Reflection.Emit.OpCodes.Castclass> tivesse sido chamada. Caso contrário, uma referência nula é enviada por push na pilha. Se a referência de objeto é uma referência nula, em seguida, `isinst` da mesma forma, retorna uma referência nula.  
  
 <xref:System.TypeLoadException>é gerada se a classe não pode ser encontrada. Normalmente, isso é detectado quando as instruções da Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `isinst` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Jmp">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Jmp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Jmp" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Jmp" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sai do método atual e vai para o método especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|27 < `T` >|jmp`method`|Saia do método atual e ir para o método especificado.|  
  
 Não há nenhuma pilha comportamentos de transição para essa instrução.  
  
 O `jmp` instrução (salto) transfere o controle para o método especificado pelo `method`, que é um token de metadados para uma referência de método. Os argumentos atuais são transferidos para o método de destino.  
  
 A pilha de avaliação deve estar vazia quando essa instrução é executada. A chamada convenção, número e tipo de argumentos no endereço de destino devem corresponder do método atual.  
  
 O `jmp` instrução não pode ser usada transferido controle fora de um `try`, `filter`, `catch`, ou `finally` bloco.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `jmp` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um argumento (referenciado por um valor de índice especificado) na pilha.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 09 <`unsigned int16` >|ldarg`index`|Carregar o argumento na `index` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor de argumento `index` é inserido na pilha.  
  
 O `ldarg` instrução envia o argumento indexado em `index`, em que os argumentos são indexados de 0 em diante, para a pilha de avaliação. O `ldarg` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Para procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarg` instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura (consulte o <xref:System.Reflection.Emit.OpCodes.Arglist> instrução para obter mais detalhes).  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 0 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|02|ldarg.0|Carregar o argumento 0 para pilha|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 0 é inserido na pilha.  
  
 O `ldarg.0` instrução é uma codificação eficiente para carregar o valor do argumento no índice 0.  
  
 O `ldarg.0` instrução envia o argumento indexado a 0 para a pilha de avaliação. O `ldarg.0` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 1 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|03|ldarg.1|Carregar o argumento 1 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 1 é inserido na pilha.  
  
 O `ldarg.1` instrução é uma codificação eficiente para carregar o valor do argumento no índice 1.  
  
 O `ldarg.1` instrução envia o argumento indexado em 1 para a pilha de avaliação. O `ldarg.1` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 2 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|04|ldarg.2|Carregar argumento 2 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 2 é inserido na pilha.  
  
 O `ldarg.2` instrução é uma codificação eficiente para carregar o valor do argumento no índice 2.  
  
 O `ldarg.2` instrução envia o argumento indexado em 2 para a pilha de avaliação. O `ldarg.2` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento no índice 3 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|05|ldarg.3|Carregar argumento 3 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do argumento no índice 3 é inserido na pilha.  
  
 O `ldarg.3` instrução é uma codificação eficiente para carregar o valor do argumento no índice 3.  
  
 O `ldarg.3` instrução envia o argumento indexado em 3 para a pilha de avaliação. O `ldarg.3` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o argumento (referenciado por um índice de forma curta especificado) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|0E <`unsigned int8` >|ldarg.s`index`|Carregar o argumento na `index` na pilha, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor de argumento `index` é inserido na pilha.  
  
 O `ldarg.s` instrução é uma codificação eficiente para carregar argumentos indexados de 4 a 255.  
  
 O `ldarg.s` instrução envia o argumento indexado em `index`, em que os argumentos são indexados de 0 em diante, para a pilha de avaliação. O `ldarg.s` instrução pode ser usada para carregar um tipo de valor ou um valor primitivo na pilha, copiando-os de um argumento de entrada. O tipo do valor do argumento é o mesmo que o tipo do argumento, conforme especificado pela assinatura do método atual.  
  
 Para procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarg.s` instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura (consulte o <xref:System.Reflection.Emit.OpCodes.Arglist> instrução para obter mais detalhes).  
  
 Argumentos que contêm um valor inteiro menor que 4 bytes de comprimento são expandidos para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarg.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carregar um endereço de argumento para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0A <`unsigned int16` >|ldarga`index`|Obter o endereço do argumento indexado por `index`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço `addr` do argumento indexado por `index` é inserido na pilha.  
  
 O `ldarga` instrução busca o endereço (do tipo `*`) do argumento indexado por `index`, em que os argumentos são indexados de 0 em diante. O endereço `addr` sempre é alinhada a um limite natural no computador de destino.  
  
 Para procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarga` instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.  
  
 `ldarga`é usado para a passagem de parâmetro pelo ref. Em outros casos, <xref:System.Reflection.Emit.OpCodes.Ldarg> e <xref:System.Reflection.Emit.OpCodes.Starg> devem ser usados.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarga` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldarga_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldarga_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldarga_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldarga_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carregar um endereço de argumento, na forma abreviada, para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|0F <`unsigned int8` >|ldarga.s`index`|Obter o endereço do argumento indexado por `index`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço `addr` do argumento indexado por `index` é inserido na pilha.  
  
 `ldarga.s`(a forma abreviada `ldarga`) deve ser usado para números de argumento de 0 a 255, e é uma codificação mais eficiente.  
  
 O `ldarga.s` instrução busca o endereço (do tipo`*`) do argumento indexado por `index`, em que os argumentos são indexados de 0 em diante. O endereço `addr` sempre é alinhada a um limite natural no computador de destino.  
  
 Para procedimentos que usam uma lista de argumentos de comprimento variável, o `ldarga.s` instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.  
  
 `ldarga.s`é usado para a passagem de parâmetro pelo ref. Em outros casos, <xref:System.Reflection.Emit.OpCodes.Ldarg_S> e <xref:System.Reflection.Emit.OpCodes.Starg_S> devem ser usados.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldarga.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push um valor do tipo <see langword="int32" /> fornecido para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|20 < `int32` >|ldc.i4`num`|Envia o valor `num` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é inserido na pilha.  
  
 Observe que há codificações curtas (e, portanto, é mais eficientes) especiais para inteiros de -128 através de 127 e especialmente curtos codificações de -1 a 8. Todas as codificações curtas push inteiros de 4 bytes na pilha. Codificações mais são usadas para números inteiros de 8 bytes e 4 e 8 bytes, bem como valores de 4 bytes que não cabem em formulários de curto. Há três maneiras de enviar por push uma constante de inteiro de 8 bytes para a pilha  
  
 1. Use o <xref:System.Reflection.Emit.OpCodes.Ldc_I8> instruções para constantes que deve ser expressa em mais de 32 bits.  
  
 2. Use o <xref:System.Reflection.Emit.OpCodes.Ldc_I4> instrução seguida por um <xref:System.Reflection.Emit.OpCodes.Conv_I8> para constantes que exigem 9 de 32 bits.  
  
 3. Use uma instrução de forma abreviada, seguida por um <xref:System.Reflection.Emit.OpCodes.Conv_I8> para constantes que podem ser expressos em 8 ou menos bits.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4` opcode:  
  
-   ILGenerator.Emit (código de operação, int)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor inteiro de 0 para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|16|ldc.i4.0|Envia 0 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 0 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor inteiro 1 por push para a pilha de avaliação como um <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|17|ldc.i4.1|Verificações em 1 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 1 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de 2 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|18|ldc.i4.2|Envia o 2 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 2 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de 3 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|19|ldc.i4.3|Envia 3 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 3 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de 4 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|1A|ldc.i4.4|Envia 4 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 4 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de 5 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|1B|ldc.i4.5|Envia a 5 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 5 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.5` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de 6 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|1C|ldc.i4.6|Envia a 6 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 6 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.6` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de 7 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|1-D|ldc.i4.7|Envia a 7 na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 7 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.7` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de 8 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|1E|ldc.i4.8|Envia a 8 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor 8 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_M1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_M1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_M1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_M1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de inteiro de -1 para a pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|15|ldc.i4.M1|Envia -1 para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor -1 é inserido na pilha.  
  
 Isso é uma codificação especial curto para o envio por push de valor inteiro de 0. Todas as codificações curtas especiais push inteiros de 4 bytes na pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.m1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I4_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I4_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I4_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I4_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o valor de <see langword="int8" /> fornecido para a pilha de avaliação como um <see langword="int32" />, na forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|1F <`int8` >|ldc.i4.s`num`|Envia `num` na pilha como `int32`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é inserido na pilha.  
  
 `ldc.i4.s`é uma codificação mais eficiente para enviar os inteiros de -128 a 127 para a pilha de avaliação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i4.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push um valor do tipo <see langword="int64" /> fornecido para a pilha de avaliação como um <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|21 < `int64` >|ldc.I8`num`|Envia `num` na pilha como `int64`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é inserido na pilha.  
  
 Essa codificação envia um `int64` valor para a pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.i8` opcode:  
  
-   ILGenerator.Emit (OpCode, long)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia um valor fornecido do tipo <see langword="float32" /> para a pilha de avaliação como tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|22 < `float32` >|ldc.R4`num`|Envia `num` na pilha como `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é inserido na pilha.  
  
 Essa codificação envia um `float32` valor para a pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.r4` opcode:  
  
-   ILGenerator.Emit (OpCode, único)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldc_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldc_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldc_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldc_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia um valor fornecido do tipo <see langword="float64" /> para a pilha de avaliação como tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|23 < `float64` >|ldc.R8`num`|Envia `num` na pilha como `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor `num` é inserido na pilha.  
  
 Essa codificação envia um `float64` valor para a pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldc.r8` opcode:  
  
-   ILGenerator.Emit (OpCode, double)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento a um índice de matriz especificado na parte superior da pilha de avaliação como o tipo especificado na instrução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|A3 <`T` >|Ldelem`typeTok`|Carrega o elemento no `index` na parte superior da pilha como tipo `typeTok`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O tipo do valor de retorno é especificado pelo token `typeTok` na instrução.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite superior de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="native int" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="native int" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|97|Ldelem.i|Carrega o elemento com o tipo `native int` em `index` na parte superior da pilha de como um `native int`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.i` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i` é `native int`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int8" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|90|Ldelem.I1|Carrega o elemento com o tipo `int8` em `index` na parte superior da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.i1` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i1` é `int8`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int16" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|92|Ldelem.I2|Carrega o elemento com o tipo `int16` em `index` na parte superior da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.i2` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i2` é `int16`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int32" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|94|Ldelem.i4|Carrega o elemento com o tipo `int32` em `index` na parte superior da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.i4` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i4` é `int32`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="int64" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="int64" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|96|Ldelem.I8|Carrega o elemento com o tipo `int64` em `index` na parte superior da pilha de como um `int64`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.i8` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.i8` é `int64`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="float32" /> em um índice de matriz especificada para o topo da pilha de avaliação como tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|98|Ldelem.R4|Carrega o elemento com o tipo `float32` em `index` na parte superior da pilha de como um tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.r4` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.r4` é `float32`.  
  
 Valores de ponto flutuante são convertidos para o tipo `F` quando carregado para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="float64" /> em um índice de matriz especificada para o topo da pilha de avaliação como tipo <see langword="F" /> (float).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|99|Ldelem.R8|Carrega o elemento com o tipo `float64` em `index` na parte superior da pilha como tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.r8` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.r8` é `float64`.  
  
 Valores de ponto flutuante são convertidos para o tipo `F` quando carregado para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento que contém uma referência de objeto em um índice de matriz especificada para o topo da pilha de avaliação como tipo <see langword="O" /> (referência de objeto).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|9A|Ldelem.ref|Carrega o elemento com uma referência de objeto em `index` na parte superior da pilha como tipo `O`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.ref` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.ref` é do tipo `O` (referência de objeto).  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="unsigned int8" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|91|Ldelem.U1|Carrega o elemento com o tipo `unsigned int8` em `index` na parte superior da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.u1` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.u1` é `int8`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="unsigned int16" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|93|Ldelem.U2|Carrega o elemento com o tipo `unsigned int16` no índice para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.u2` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.u2` é `int16`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelem_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelem_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelem_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelem_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o elemento com o tipo <see langword="unsigned int32" /> em um índice de matriz especificada para o topo da pilha de avaliação como uma <see langword="int32" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|95|Ldelem.U4|Carrega o elemento com o tipo `unsigned int32` no índice para o topo da pilha de como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o valor armazenado na posição `index` em `array` é pesquisada.  
  
4.  O valor é inserido na pilha.  
  
 O `ldelem.u4` instrução carrega o valor do elemento com index `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`.  
  
 O valor de retorno `ldelem.u4` é `int32`.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>é gerada se a matriz não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelem.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldelema">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldelema;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldelema" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldelema" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o endereço do elemento da matriz em um índice de matriz especificado no topo da pilha de avaliação como o tipo <see langword="&amp;" /> (ponteiro gerenciado).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|8F <`T` >|faltando ldelema`class`|Carrega o endereço do elemento da matriz em `index` na parte superior da pilha de avaliação como tipo `&` (ponteiro gerenciado).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `array` é inserido na pilha.  
  
2.  Um valor de índice `index` é inserido na pilha.  
  
3.  `index`e `array` são disparados da pilha; o endereço armazenado na posição `index` em `array` é pesquisada.  
  
4.  O endereço é inserido na pilha.  
  
 O `ldelema` é usado para recuperar o endereço de um objeto em um determinado índice em uma matriz de objetos (do tipo `class`). O `ldelema` instrução carrega o endereço do valor de índice `index` (tipo `native int`) na matriz unidimensional de base zero `array` e o coloca na parte superior da pilha. Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O valor deve ser do tipo `class` passado com a instrução.  
  
 O valor de retorno `ldelema` é um ponteiro gerenciado (tipo `&`).  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldelema` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Localiza o valor de um campo no objeto cuja referência está na pilha de avaliação no momento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|7B <`T` >|ldfld`field`|Envia o valor de um campo em um objeto especificado para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto (ou o ponteiro) é inserido na pilha.  
  
2.  A referência de objeto (ou o ponteiro) é exibido da pilha; o valor do campo especificado no objeto está localizado.  
  
3.  O valor armazenado no campo é inserido na pilha.  
  
 O `ldfld` instrução envia o valor de um campo localizado em um objeto para a pilha. O objeto deve estar na pilha como uma referência de objeto (tipo `O`), um ponteiro gerenciado (tipo `&`), um ponteiro não gerenciado (tipo `native int`), um ponteiro transitório (tipo `*`), ou uma instância de um tipo de valor. O uso de um ponteiro não gerenciado não é permitido no código verificável. Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo. O tipo de retorno é o mesmo que o associados ao campo. O campo pode ser um campo de instância (caso o objeto não deve ser uma referência nula) ou um campo estático.  
  
 O `ldfld` instruções podem ser precedidas por uma ou ambas as <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefixos.  
  
 <xref:System.NullReferenceException>é gerada se o objeto é nulo e o campo não é estático.  
  
 <xref:System.MissingFieldException>é gerada se o campo especificado não foi encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldfld` opcode:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Localiza o endereço de um campo no objeto cuja referência está na pilha de avaliação no momento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|7C <`T` >|ldflda`field`|Envia o endereço de `field` em um objeto especificado para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto (ou o ponteiro) é inserido na pilha.  
  
2.  A referência de objeto (ou o ponteiro) é exibido da pilha; o endereço do campo especificado no objeto foi encontrado.  
  
3.  O endereço do campo especificado é inserido na pilha.  
  
 O `ldflda` instrução envia o endereço de um campo localizado em um objeto para a pilha. O objeto deve estar na pilha como uma referência de objeto (tipo `O`), um ponteiro gerenciado (tipo `&`), um ponteiro não gerenciado (tipo `native int`), um ponteiro transitório (tipo `*`), ou uma instância de um tipo de valor. O uso de um ponteiro não gerenciado não é permitido no código verificável. Campo do objeto é especificado por um token de metadados que deve se referir a um membro de campo.  
  
 O valor retornado por `ldflda` é um ponteiro gerenciado (tipo `&`), a menos que o objeto é inserido na pilha como um ponteiro não gerenciado, caso em que o endereço de retorno também é um ponteiro não gerenciado (tipo `native int`).  
  
 O `ldflda` instruções podem ser precedidas por uma ou ambas as <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile> prefixos.  
  
 <xref:System.InvalidOperationException>é gerada se o objeto não está dentro do domínio de aplicativo do qual ele está sendo acessado. Não é possível carregar o endereço de um campo que não está dentro do domínio de aplicativo ao acessar.  
  
 <xref:System.NullReferenceException>é gerada se o objeto é nulo e o campo não é estático.  
  
 <xref:System.MissingFieldException>é gerada se o campo especificado não foi encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldflda` opcode:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia um ponteiro não gerenciado (tipo <see langword="native int" />) para o código nativo implementando um método específico na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 06 <`T` >|ldftn`method`|Envia um ponteiro para um método referenciado por `method` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O ponteiro não gerenciado para um método específico é inserido na pilha.  
  
 O método específico (`method`) pode ser chamado usando o <xref:System.Reflection.Emit.OpCodes.Calli> instrução se faz referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).  
  
 O valor retornado pontos para código nativo usando a convenção de chamada de CLR. Este ponteiro de método não deve ser passado para código nativo não gerenciado, como uma rotina de retorno de chamada.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldftn` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="native int" /> como um <see langword="native int" /> para a avaliação de pilha indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|4D|ldind.i|Carrega o `native int` valor no endereço `addr` na pilha como um `native int`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.i` instrução indiretamente carrega um `native int` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `native int`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int8" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|46|ldind.I1|Carrega o `int8` valor no endereço `addr` na pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.i1` instrução indiretamente carrega um `int8` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int16" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|48|ldind.I2|Carrega o `int16` valor no endereço `addr` na pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.i2` instrução indiretamente carrega um `int16` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int32" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|4A|ldind.i4|Carrega o `int32` valor no endereço `addr` na pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.i4` instrução indiretamente carrega um `int32` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="int64" /> como um <see langword="int64" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|4C|ldind.I8|Carrega o `int64` valor no endereço `addr` na pilha como um `int64`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.i8` instrução indiretamente carrega um `int64` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int64`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="float32" /> como um tipo <see langword="F" /> (float) para a pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|4E|ldind.R4|Carrega o `float32` valor no endereço `addr` na pilha como um tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.r4` instrução indiretamente carrega um `float32` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um tipo `F`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="float64" /> como um tipo <see langword="F" /> (float) para a pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|4F|ldind.R8|Carrega o `float64` valor no endereço `addr` na pilha como um tipo `F`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.r8` instrução indiretamente carrega um `float64` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `float64`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega uma referência de objeto como um tipo <see langword="O" /> (referência de objeto) para a avaliação de pilha indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|50|ldind.ref|Carrega a referência de objeto no endereço `addr` para a pilha como um tipo`O`|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; a referência de objeto localizada no endereço é buscada.  
  
3.  A referência de busca é inserida na pilha.  
  
 O `ldind.ref` instrução indiretamente carrega a referência de objeto, o endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como tipo `O`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="unsigned int8" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|47|ldind.U1|Carrega o `unsigned int8` valor no endereço `addr` na pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.u1` instrução indiretamente carrega um `unsigned int8` valor do endereço especificado (do tipo`native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="unsigned int16" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|49|ldind.U2|Carrega o `unsigned int16` valor no endereço `addr` na pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.u2` instrução indiretamente carrega um `unsigned int16` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldind_U4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldind_U4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldind_U4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldind_U4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega um valor do tipo <see langword="unsigned int32" /> como um <see langword="int32" /> na pilha de avaliação indiretamente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|4B|ldind.U4|Carrega o `unsigned int32` valor no endereço `addr` na pilha como um `int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  O endereço é exibido da pilha; o valor localizado no endereço é buscado.  
  
3.  O valor de busca é inserido na pilha.  
  
 O `ldind.u4` instrução indiretamente carrega um `unsigned int32` valor do endereço especificado (do tipo `native int`, `&`, ou *) para a pilha como um `int32`.  
  
 Todos os `ldind` instruções são atalhos para um <xref:System.Reflection.Emit.OpCodes.Ldobj> instrução que especifica a classe de valor interna correspondente.  
  
 Observe que os valores inteiros de menos de 4 bytes são estendidos para `int32` (não `native int`) quando eles são carregados para a pilha de avaliação. Valores de ponto flutuante são convertidos em `F` digite quando carregado para a pilha de avaliação.  
  
 Corretamente formado idioma MSIL (Microsoft Intermediate) garante que o `ldind` instruções são usadas de maneira consistente com o tipo do ponteiro.  
  
 O endereço inserido inicialmente na pilha deve estar alinhado para o tamanho natural dos objetos no computador ou um <xref:System.NullReferenceException> pode ocorrer (consulte o <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instruções para medidas preventivas). Os resultados de todas as instruções da MSIL que retornam endereços (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloca> e <xref:System.Reflection.Emit.OpCodes.Ldarga>) são alinhados com segurança. Para tipos de dados maiores do que 1 byte, a ordenação de bytes é dependente de CPU de destino. Código que depende da ordem de bytes não pode ser executado em todas as plataformas.  
  
 <xref:System.NullReferenceException>pode ser gerada se um endereço inválido foi detectado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldind.u4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldlen">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldlen;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldlen" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldlen" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o número de elementos de uma matriz unidimensional de base zero para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|8E|ldlen|Envia o comprimento (do tipo `natural unsigned int`) de uma matriz na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz é inserida na pilha.  
  
2.  A referência da matriz é exibida da pilha e o comprimento é calculado.  
  
3.  O comprimento é inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O comprimento é retornado como um `natural unsigned int`.  
  
 <xref:System.NullReferenceException>é gerada se a referência da matriz é uma referência nula.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldlen` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local em um índice específico na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0C <`unsigned int16` >|Ldloc`index`|Carrega a variável local no índice `index` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice especificado é inserido na pilha.  
  
 O `ldloc` instrução envia o conteúdo do número de variável local no índice passado para a pilha de avaliação, em que as variáveis locais são numerados de 0 em diante. Variáveis locais são inicializadas para 0 antes de inserir o método somente se o sinalizador de inicialização no método for verdadeiro. Há 65.535 (2 ^ 16 - 1) variáveis locais possíveis (0-65.534). 65.535 de índice não é válido porque implementações provavelmente usará um inteiro de 2 bytes para controlar o índice de um locais, juntamente com o número total de locais para um determinado método. Se um índice de 65535 tinha sido feito válido, ela requer um inteiro maior para controlar o número de locais em tal método.  
  
 O `ldloc.0`, `ldloc.1`, `ldloc.2`, e `ldloc.3` instruções fornecem uma codificação eficiente para acessar as primeiras quatro variáveis locais.  
  
 O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método. Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldloc` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 0 na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|06|Ldloc.0|Carrega a variável local no índice 0 na pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 0 é inserido na pilha.  
  
 `ldloc.0`é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 0.  
  
 O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 1 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|07|Ldloc. 1|Carrega a variável local no índice 1 para a pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 1 é inserido na pilha.  
  
 `ldloc.1`é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 1.  
  
 O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 2 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|08|Ldloc.2|Carrega a variável local no índice 2 para a pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 2 é inserido na pilha.  
  
 `ldloc.2`é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 2.  
  
 O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local no índice 3 para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|09|Ldloc.3|Carrega a variável local no índice 3 para a pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice 3 é inserido na pilha.  
  
 `ldloc.3`é uma codificação especialmente eficiente para <xref:System.Reflection.Emit.OpCodes.Ldloc>, permitindo o acesso à variável local no índice 3.  
  
 O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método. Variáveis locais que são menores que 4 bytes de comprimento são expandidas para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega a variável local em um índice específico na pilha de avaliação, de forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|11 < `unsigned int8` >|Ldloc.s`index`|Carrega a variável local no índice `index` na pilha, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor da variável local no índice especificado é inserido na pilha.  
  
 O `ldloc.s` instrução envia o conteúdo do número de variável local no índice passado para a pilha de avaliação, em que as variáveis locais são numerados de 0 em diante. Variáveis locais são inicializadas para 0 antes de inserir o método se o sinalizador de inicialização no método for true. Há 256 (2 ^ 8) variáveis locais possíveis (0-255) em forma abreviada, que é uma codificação mais eficiente que `ldloc`.  
  
 O tipo do valor é o mesmo que o tipo da variável local, que é especificado no cabeçalho de método. Consulte partição I. Local variáveis que são menores que 4 bytes de comprimento é expandido para o tipo `int32` quando eles são carregados para a pilha. Valores de ponto flutuante são expandidos para seu tamanho nativo (tipo `F`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldloc.s` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o endereço da variável local em um índice específico para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE OD <`unsigned int16` >|ldloca`index`|Carrega o endereço da variável local no `index` para a pilha de avaliação.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço armazenado na variável local no índice especificado é inserido na pilha.  
  
 O `ldloca` instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numerados de 0 em diante. O valor enviado na pilha é já alinhado corretamente para uso com instruções de como <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>. O resultado é um ponteiro transitório (tipo `*`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloca` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldloca_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldloca_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldloca_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldloca_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Carrega o endereço da variável local em um índice específico para a pilha de avaliação, em forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|12 < `unsigned int8` >|ldloca.s`index`|Carrega o endereço da variável local no `index` para a pilha de avaliação, de forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço armazenado na variável local no índice especificado é inserido na pilha.  
  
 O `ldloca.s` instrução envia o endereço do número de variável local no índice passado para a pilha, em que as variáveis locais são numerados de 0 em diante. O valor enviado na pilha é já alinhado corretamente para uso com instruções de como <xref:System.Reflection.Emit.OpCodes.Ldind_I> e <xref:System.Reflection.Emit.OpCodes.Stind_I>. O resultado é um ponteiro transitório (tipo `*`).  
  
 O `ldloca.s` instrução fornece uma codificação eficiente para uso com as variáveis locais de 0 a 255.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldloca.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldnull">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldnull;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldnull" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldnull" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia uma referência nula (tipo <see langword="O" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|14|ldnull|Enviar por push uma referência nula para a pilha|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto nulo é inserida na pilha.  
  
 `ldnull`envia uma referência nula (tipo `O`) na pilha. Isso é usado para inicializar locais antes de serem populados com dados, ou quando eles preterida.  
  
 `ldnull`Fornece uma referência nula é independente de tamanho.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldnull` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia o objeto de tipo de valor apontado por um endereço na parte superior da pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|71 < `T` >|ldobj`class`|Instância de cópia do tipo de valor `class` para a pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço de um objeto de tipo de valor é inserido na pilha.  
  
2.  O endereço é exibido da pilha e a instância nesse endereço específico é pesquisada.  
  
3.  O valor do objeto armazenado nesse endereço é inserido na pilha.  
  
 O `ldobj` instrução é usada para passar um tipo de valor como um parâmetro.  
  
 O `ldobj` instrução copia o valor apontado por `addrOfValObj` (do tipo `&`, `*`, ou `native int`) para a parte superior da pilha. O número de bytes copiados depende do tamanho da classe (conforme especificado pelo `class` parâmetro). O `class` parâmetro é um token de metadados que representa o tipo de valor.  
  
 A operação do `ldobj` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.TypeLoadException>é gerada se a classe não pode ser encontrada. Normalmente, isso é detectado quando a instrução Microsoft Intermediate Language (MSIL) é convertida em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldobj` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push o valor de um campo estático para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|7E <`T` >|ldsfld`field`|Enviar por push o valor de `field` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor do campo específico é inserido na pilha.  
  
 O `ldsfld` instrução envia o valor estático (compartilhado entre todas as instâncias de uma classe) campo na pilha. O tipo de retorno é associado ao token de metadados passado `field`.  
  
 O `ldsfld` instrução pode ter um <xref:System.Reflection.Emit.OpCodes.Volatile> prefixo.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldsfld` opcode:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldsflda">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldsflda;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldsflda" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldsflda" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o endereço de um campo estático para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|7F <`T` >|ldsflda`field`|Enviar por push o endereço do `field` na pilha|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O endereço de um campo específico é inserido na pilha.  
  
 O `ldsflda` instrução envia o endereço de um estático (compartilhado entre todas as instâncias de uma classe) campo na pilha. O endereço pode ser representado como um ponteiro transitório (tipo `*`) se o token de metadados `field` se refere a um tipo cuja memória é gerenciada. Caso contrário, ele corresponde a um ponteiro não gerenciado (tipo `native int`). Observe que `field` pode ser static global, com um endereço relativo virtual (o deslocamento do campo do endereço base no qual o arquivo PE contendo é carregado na memória) atribuído em que a memória é não gerenciada.  
  
 O `ldsflda` instrução pode ter um <xref:System.Reflection.Emit.OpCodes.Volatile> prefixo.  
  
 <xref:System.MissingFieldException>é gerada se o campo não for encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldsflda` opcode:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldstr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldstr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldstr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldstr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push uma nova referência de objeto para uma literal de cadeia de caracteres armazenada nos metadados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|72 < `T` >|ldstr`mdToken`|Envia um objeto de cadeia de caracteres para o token de cadeia de caracteres de metadados `mdToken`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma cadeia de caracteres é inserida na pilha.  
  
 O `ldstr` instrução envia uma referência de objeto (tipo `O`) para um novo objeto de cadeia de caracteres que representa a cadeia de caracteres literal armazenada nos metadados. O `ldstr` instrução aloca a quantidade necessária de memória e executa qualquer conversão de formato necessária para converter a literal de cadeia de caracteres de formato usado no arquivo para o formato de cadeia de caracteres necessário em tempo de execução.  
  
 A infraestrutura de linguagem comum (CLI) garante que o resultado de dois `ldstr` instruções que faz referência a dois tokens de metadados que têm a mesma sequência de caracteres de retorno exatamente o mesmo objeto de cadeia de caracteres (um processo conhecido como "cadeia de caracteres como internos").  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldstr` opcode:  
  
-   ILGenerator.Emit (código de operação, cadeia de caracteres)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldtoken">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldtoken;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldtoken" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldtoken" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte um token de metadados em sua representação de tempo de execução, enviando-o por push para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D0 <`T` >|Ldtoken`token`|Converte um token de metadados em sua representação de tempo de execução.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O token passado é convertido em um `RuntimeHandle` e inserido na pilha.  
  
 O `ldtoken` instrução coloca um `RuntimeHandle` para o token de metadados especificado. Um `RuntimeHandle` pode ser um `fieldref/fielddef`, um `methodref/methoddef`, ou um `typeref/typedef`.  
  
 O valor enviado na pilha pode ser usado em chamadas para `Reflection` métodos na biblioteca de classe do sistema.  
  
 Para obter informações sobre identificadores de tempo de execução, consulte as seguintes classes: <xref:System.RuntimeFieldHandle>, <xref:System.RuntimeTypeHandle>, e <xref:System.RuntimeMethodHandle>.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `ldtoken` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ldvirtftn">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ldvirtftn;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ldvirtftn" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ldvirtftn" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia um ponteiro não gerenciado (tipo <see langword="native int" />) para o código nativo implementar um método virtual específico associado ao objeto especificado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 07 <`T` >|ldvirtftn`method`|Envia o ponteiro para um método do objeto virtual `method` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é exibida na pilha e o endereço do ponto de entrada para o método (conforme especificado pelo token de metadados `method`) é pesquisada.  
  
3.  O ponteiro para `method` é inserido na pilha.  
  
 O ponteiro não gerenciado resultante é inserido na pilha, o `ldvirtftn` instrução pode ser chamada usando o <xref:System.Reflection.Emit.OpCodes.Calli> instrução se faz referência a um método gerenciado (ou um stub que faz a transição de código gerenciado para código não gerenciado).  
  
 Pontos do ponteiro não gerenciado para código nativo usando a convenção de chamada de CLR. Este ponteiro de método não deve ser passado para código nativo não gerenciado, como uma rotina de retorno de chamada.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ldvirtftn` opcode:  
  
-   ILGenerator.Emit (OpCode, MethodInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Fecha uma área protegida do código, incondicionalmente transferindo o controle para uma instrução de destino específico.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|DD <`int32` >|sair`target`|Fecha uma área protegida de código.|  
  
 Não há nenhum comportamento de transição de pilha especificado para essa instrução.  
  
 O `leave` instrução incondicionalmente transfere o controle para a instrução de destino específico, representada como um deslocamento assinado de 4 bytes do início da instrução após a instrução atual.  
  
 O `leave` instrução é semelhante do `br` instrução, mas ele pode ser usado para sair uma `try`, `filter`, ou `catch` bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir controle dentro dele. O `leave` instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor `finally` os blocos são executados.  
  
 Não é possível usar um `leave` instruções para sair um `finally` bloco. Para facilitar a geração de código para manipuladores de exceção é válido a partir de um bloco catch para usar um `leave` instrução para transferir controle para qualquer instrução em associado `try` bloco.  
  
 Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `leave` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Leave_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Leave_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Leave_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Leave_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sai de uma região protegida de código, transferindo o controle incondicionalmente para uma instrução de destino (forma abreviada).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|IR <`int8` >|Leave`target`|Sair de uma região protegida do código, de forma abreviada.|  
  
 Não há nenhum comportamento de transição de pilha especificado para essa instrução.  
  
 O `leave.s` instrução incondicionalmente transfere o controle para a instrução de destino passado, representada como um deslocamento de 1 byte assinado desde o início da instrução após a instrução atual.  
  
 O `leave.s` instrução é semelhante do `br` instrução, mas ele pode ser usado para sair uma `try`, `filter`, ou `catch` bloquear enquanto as instruções de ramificação comum só podem ser usadas em tal um bloco para transferir controle dentro dele. O `leave.s` instrução esvazia a pilha de avaliação e garante que o valor apropriado ao redor `finally` os blocos são executados.  
  
 Não é possível usar um `leave.s` instruções para sair um `finally` bloco. Para facilitar a geração de código para manipuladores de exceção é válido a partir de um bloco catch para usar um `leave.s` instrução para transferir controle para qualquer instrução em associado `try` bloco.  
  
 Se uma instrução tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `leave.s` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Localloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Localloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Localloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Localloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aloca um determinado número de bytes do pool de memória dinâmica local e envia o endereço (um ponteiro transitório, tipo <see langword="*" />) do primeiro byte alocado à pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0F|localloc|Alocar espaço de heap local.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O número de bytes a ser alocada é inserido na pilha.  
  
2.  É exibido o número de bytes da pilha; é alocada uma quantidade de memória correspondente ao tamanho do heap local.  
  
3.  Um ponteiro para o primeiro byte da memória alocada é inserido na pilha.  
  
 O `localloc` instrução aloca `size` (tipo `natural unsigned int`) pool de bytes de memória dinâmica local e retorna o endereço (um ponteiro transitório, o tipo `*`) do primeiro byte alocado. O bloco de memória retornado é inicializada em 0, apenas se o sinalizador de inicialização no método `true`. Quando o método atual executa um <xref:System.Reflection.Emit.OpCodes.Ret>, o pool de memória local é disponibilizado para reutilização.  
  
 O endereço resultante é alinhado para que qualquer tipo de dados primitivos pode ser armazenado lá usando o `stind` instruções (como <xref:System.Reflection.Emit.OpCodes.Stind_I4>) e carregados usando o `ldind` instruções (como <xref:System.Reflection.Emit.OpCodes.Ldind_I4>).  
  
 O `localloc` instrução não pode ocorrer dentro de um `filter`, `catch`, `finally`, ou `fault` bloco.  
  
 <xref:System.StackOverflowException>é gerada se há memória suficiente para atender à solicitação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `localloc` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mkrefany">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mkrefany;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mkrefany" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mkrefany" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia uma referência de tipo a uma instância de um tipo específico para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|C6 <`T` >|Mkrefany`class`|Envia uma referência de tipo do tipo `class` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um ponteiro para dados é inserido na pilha.  
  
2.  O ponteiro é exibido e convertido em uma referência de tipo do tipo `class`.  
  
3.  A referência de tipo é inserida na pilha.  
  
 O `mkrefany` instrução dá suporte à passagem de Referências tipadas dinamicamente. O ponteiro deve ser do tipo `&`, `*`, ou `native int`, mantenha o endereço válido de uma parte dos dados. `Class`o token de classe que descreve o tipo de dados referenciados pelo ponteiro. `Mkrefany`envia uma referência de tipo na pilha, fornecendo um descritor opaco do ponteiro e o tipo `class`.  
  
 A operação válida somente permitida em uma referência de tipo é passá-lo para um método que requer uma referência de tipo como um parâmetro. O receptor pode usar o <xref:System.Reflection.Emit.OpCodes.Refanytype> e <xref:System.Reflection.Emit.OpCodes.Refanyval> instruções para recuperar o tipo (classe) e o endereço, respectivamente.  
  
 <xref:System.TypeLoadException>será gerada se `class` não pode ser encontrado. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mkrefany` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dois valores e envia o resultado na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|5A|mul|Multiplica dois valores na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é multiplicada por `value2`.  
  
4.  O resultado é inserido na pilha.  
  
 O `mul` instrução multiplica `value1` por `value2` e envia o resultado na pilha. Operações de inteiro truncam silenciosamente bits superiores no estouro.  
  
 Consulte <xref:System.Reflection.Emit.OpCodes.Mul_Ovf> para um determinado inteiro multiplicar operação com a manipulação de estouro.  
  
 Para tipos de ponto flutuantes, 0 * infinito = NaN.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dois valores inteiros, executa uma verificação de estouro e envia por push o resultado na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D8|mul.OVF|Multiplica dois valores inteiros na pilha com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é multiplicada por `value2`, com uma verificação de estouro.  
  
4.  O resultado é inserido na pilha.  
  
 O `mul.ovf` instrução multiplica inteiro `value1` por inteiro `value2` e envia o resultado na pilha. Uma exceção é gerada se o resultado não cabe no tipo de resultado.  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Mul_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Mul_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Mul_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Mul_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Multiplica dois valores inteiros sem sinal, executa uma verificação de estouro e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|D9|mul.OVF.Un|Multiplica dois valores não assinados na pilha com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value1` é multiplicada por `value2`, com uma verificação de estouro.  
  
4.  O resultado é inserido na pilha.  
  
 O `mul.ovf.un` instrução multiplica inteiro sem sinal `value1` por inteiro sem sinal `value2` e envia o resultado na pilha. Uma exceção é gerada se o resultado não cabe no tipo de resultado.  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `mul.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Neg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Neg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Neg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Neg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Nega um valor e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|65|Neg|Nega o valor atualmente na parte superior da pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é inserido na pilha.  
  
2.  Um valor é exibido da pilha e negado.  
  
3.  O resultado é inserido na pilha.  
  
 O `neg` nega o valor de instrução e envia o resultado na parte superior da pilha. O tipo de retorno é o mesmo que o tipo de operando.  
  
 Negação de valores integrais é o padrão do complemento de dois negação. Em particular, eliminando o número mais negativo (que não tem um equivalente positivo) produz o número mais negativo. Para detectar esse uso de estouro de <xref:System.Reflection.Emit.OpCodes.Sub_Ovf> instrução em vez disso (ou seja, subtrair de 0).  
  
 Eliminando o número de ponto flutuante não será possível estourar e negar NaN retorna NaN.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `neg` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newarr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newarr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newarr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newarr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia por push uma referência de objeto para uma nova matriz unidimensional baseada em zero, cujos elementos são de um tipo específico na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|8D <`T` >|newarr`etype`|Cria uma nova matriz com elementos do tipo `etype`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O número de elementos na matriz é inserido na pilha.  
  
2.  É exibido o número de elementos da pilha e a matriz é criada.  
  
3.  Uma referência de objeto para a nova matriz é inserida na pilha.  
  
 O `newarr` instrução envia uma referência de objeto (tipo `O`) para uma nova matriz unidimensional, com base em zero cujos elementos são do tipo `etype` (um token de metadados que descreve o tipo). O número de elementos na nova matriz deve ser especificado como um `native int`. Intervalo de índices de matriz válida de zero para o número máximo de elementos menos um.  
  
 Os elementos de uma matriz podem ser qualquer tipo, incluindo tipos de valor.  
  
 Matrizes unidimensionais, com base em zero de números são criados usando um token de metadados, fazendo referência ao tipo de valor apropriado (<xref:System.Int32>, e assim por diante). Elementos da matriz são inicializados como 0 do tipo apropriado.  
  
 Matrizes unidimensionais NonZero-com base e matrizes multidimensionais são criados usando <xref:System.Reflection.Emit.OpCodes.Newobj> em vez de `newarr`. Mais comumente, eles são criados usando os métodos do <xref:System.Array> classe do .NET Framework.  
  
 <xref:System.OutOfMemoryException>é gerada se há memória suficiente para atender à solicitação.  
  
 <xref:System.OverflowException>será gerada se `numElems` é menor que 0.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `newarr` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Newobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Newobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Newobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Newobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Cria um novo objeto ou uma nova instância de um tipo de valor, enviando por push uma referência de objeto (tipo <see langword="O" />) para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|73 < `T` >|newobj`ctor`|Aloca um tipo de objeto ou valor não inicializado e chama o método de construtor `ctor`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Argumentos `arg1` por meio de `argn` são enviados por push na pilha na sequência.  
  
2.  Argumentos `argn` por meio de `arg1` são disparados da pilha e passados para `ctor` para a criação do objeto.  
  
3.  Uma referência ao novo objeto é inserida na pilha.  
  
 O `newobj` instrução cria um novo objeto ou uma nova instância de um tipo de valor. `Ctor`é um token de metadados (uma `methodref` ou `methoddef` que deve ser marcada como um construtor) que indica o nome, a classe e a assinatura de construtor para chamar.  
  
 O `newobj` instrução aloca uma nova instância da classe associada a `ctor` e inicializa todos os campos na nova instância como 0 (do tipo correto) ou referências nulas conforme apropriado. Depois, ele chama o construtor `ctor` com os argumentos fornecidos junto com a instância recém criada. Depois que o construtor foi chamado, o agora inicializado referência de objeto (tipo `O`) é enviada por push na pilha.  
  
 Do ponto de vista do construtor, o objeto não inicializado é o argumento 0 e os outros argumentos passados para newobj siga na ordem.  
  
 Todas as matrizes unidimensionais, com base em zero são criadas usando <xref:System.Reflection.Emit.OpCodes.Newarr>, não `newobj`. Por outro lado, todas as outras matrizes (mais de uma dimensão, ou unidimensional, mas não com base em zero) são criados usando `newobj`.  
  
 Tipos de valor não são geralmente criados usando `newobj`. Elas geralmente são alocadas como argumentos ou variáveis locais, usando `newarr` (para matrizes unidimensionais, com base em zero), ou como campos de objetos. Uma vez alocada, eles são iniciados usando <xref:System.Reflection.Emit.OpCodes.Initobj>. No entanto, o `newobj` instrução pode ser usada para criar uma nova instância de um tipo de valor na pilha, que pode ser passada como um argumento, armazenado em um local e assim por diante.  
  
 <xref:System.OutOfMemoryException>é gerada se há memória suficiente para atender à solicitação.  
  
 <xref:System.MissingMethodException>será gerada se um método de construtor `ctor` com o nome indicado, classe e a assinatura não podem ser encontrados. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `newobj` opcode:  
  
-   ILGenerator.Emit (OpCode, ConstructorInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Nop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Nop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Nop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Nop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Preencherá o espaço se os opcodes forem corrigidos. Nenhuma operação significativa será executada, embora um ciclo de processamento possa ser consumido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|00|Nop|Executa uma operação sem comportamento.|  
  
 Há um comportamento de transição de pilha definido para essa instrução.  
  
 O `nop` operação não fará nada. Ele destina-se para preencher o espaço se opcodes sejam corrigidos.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `nop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Not">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Not;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Not" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Not" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula o complemento bit a bit do valor inteiro na parte superior da pilha e envia o resultado para a pilha de avaliação como o mesmo tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|66|not|Calcula o complemento bit a bit de um valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value`é inserido na pilha.  
  
2.  `value`é exibido na pilha e o bit a bit complemento computado.  
  
3.  O resultado é inserido na pilha.  
  
 O `not` instrução calcula o complemento bit a bit de um valor inteiro e envia o resultado para a pilha. O tipo de retorno é o mesmo que o tipo de operando.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `not` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Or">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Or;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Or" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Or" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Computação de complemento bit a bit de inteiro de dois valores na parte superior da pilha e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|60|ou|Calcula o bit a bit ou de dois valores inteiros, retorna um inteiro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados de pilha e seu OR bit a bit computada.  
  
4.  O resultado é inserido na pilha.  
  
 O `or` instrução calcula o OR bit a bit de dois valores acima da pilha de envio por push o resultado para a pilha.  
  
 `Or`é uma operação de inteiro específico.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `or` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pop">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Pop;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Pop" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Pop" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Remove o valor atualmente no topo da pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|26|pop|Exibe o valor de nível superior da pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor de nível superior é exibido da pilha.  
  
 O `pop` instrução remove o elemento superior da pilha.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `pop` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix5">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix5;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix5" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix5" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix6">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix6;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix6" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix6" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefix7">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefix7;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefix7" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefix7" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Prefixref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Prefixref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Prefixref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Prefixref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Isso é uma instrução reservada.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Readonly">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Readonly;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Readonly" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Readonly" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que a operação de endereço da matriz subsequentes não executa nenhuma verificação de tipo em tempo de execução e que ela retorna um ponteiro gerenciado cuja Mutabilidade é restrito.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1E|somente leitura.|Especifique que a operação de endereço da matriz subsequentes não executa nenhuma verificação de tipo em tempo de execução e que ela retorna um ponteiro gerenciado com Mutabilidade restrita.|  
  
 Esse prefixo só pode aparecer imediatamente anterior a `ldelema` instrução e chamadas especiais `Address` método em matrizes. Seu efeito sobre a operação subsequente é dupla:  
  
1.  Em tempo de execução, nenhuma operação de verificação de tipo é executada. Observe que, normalmente, há uma verificação de tipo implícito para o `ldelema` e `stelem` instruções quando usado em referência matrizes de tipo. Nunca há uma verificação de tipo de tempo de execução para classes de valor, portanto `readonly` é não operacional nesse caso.  
  
2.  O verificador trata o resultado da operação de endereço como um ponteiro gerenciado com Mutabilidade restrita.  
  
 O ponteiro deve ter restringido Mutabilidade porque a definição de tipo controla se o valor pode ser modificado. Para classes de valor que expõem sem campos públicos ou métodos que atualizam o valor em vigor, o ponteiro é somente leitura (portanto, o nome do prefixo). Em particular, as classes que representam tipos primitivos (por exemplo, System. Int32) não expõem modificadores e, portanto, são somente leitura.  
  
 Um ponteiro gerenciado restringido dessa maneira pode ser usado somente em das seguintes maneiras:  
  
-   Como o `object` parâmetro para o `ldfld`, `ldflda`, `stfld`, `call`, ou`constrained callvirt` instruções.  
  
-   Como o `pointer` parâmetro para o `ldobj` instrução ou a uma da `ldind` instruções.  
  
-   Como o `source` parâmetro para o `cpobj` instrução.  
  
 Todas as outras operações não permitidas, incluindo o `stobj`, `initobj`, ou `mkrefany` operações ou qualquer o `stind` instruções.  
  
 A finalidade de `readonly` prefixo é para evitar uma verificação de tipo ao buscar um elemento de uma matriz em código genérico. Por exemplo, a expressão `arr[i].m()`, onde o tipo de elemento da matriz `arr` é um tipo genérico foi restringido para que uma interface com o método `m`, pode compilar a seguir MSIL.  
  
```  
ldloc arr  
ldloc i  
readonly.  
ldelema !0    // Loads the pointer to the object.  
…             // Load the arguments to the call.  
constrained. !0  
callvirt m  
```  
  
 Sem o `readonly` prefixo, o `ldelema` instrução executará uma verificação de tipo no caso onde! 0 era de um tipo de referência. Não só é essa verificação de tipo ineficientes, mas é semanticamente incorreto. A verificação de tipo para `ldelema` é uma correspondência exata, que é muito forte. Se a matriz mantidos subclasses de tipo! 0, o código acima falhará na verificação de tipo.  
  
 O endereço do elemento da matriz é buscado, em vez do elemento em si, para ter um identificador para o `arr[i]` que funciona para ambos os tipos de valor e tipos de referência e, portanto, pode ser passada para o `constrained callvirt` instrução.  
  
 Em geral seria inseguro para ignorar a verificação de tempo de execução se a matriz de elementos de um tipo de referência. Para ter segurança, é necessário garantir que nenhuma modificação para a matriz é feitas por este ponteiro. As regras de verificação garantem isso. O ponteiro gerenciado restrito pode ser passado como o objeto de chamadas de método de instância, portanto ele não é estritamente somente leitura para tipos de valor, mas não há nenhum problema de segurança de tipo para tipos de valor.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `readonly` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanytype">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanytype;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanytype" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanytype" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o token de tipo inserido em uma referência de tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1D|refanytype|Envia o token de tipo armazenado em uma referência de tipo.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de tipo de valor é inserida na pilha.  
  
2.  A referência de tipo é exibida da pilha e recuperado de seu token de tipo correspondente.  
  
3.  O token de tipo é inserido na pilha.  
  
 Uma referência de tipo contém um token de tipo e um endereço para uma instância do objeto.  
  
 O `refanytype` instrução recupera o token de tipo incorporado na referência de tipo. Consulte o <xref:System.Reflection.Emit.OpCodes.Mkrefany> referências de tipo de instrução para obter informações sobre a criação.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `refanytype` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Refanyval">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Refanyval;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Refanyval" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Refanyval" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Recupera o endereço (tipo <see langword="&amp;" />) inserido em uma referência de tipo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|C2 <`T` >|refanyval`type`|Envia o endereço armazenado em uma referência de tipo.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de tipo de valor é inserida na pilha.  
  
2.  A referência de tipo é exibida da pilha e recuperar o endereço correspondente.  
  
3.  O endereço é inserido na pilha.  
  
 Uma referência de tipo contém um token de tipo e um endereço para uma instância do objeto.  
  
 O `refanyval` instrução recupera o endereço inserido na uma referência de tipo. O tipo inserido na referência do tipo fornecida na pilha deve corresponder ao tipo especificado pelo `type` (token de metadados, ou um `typedef` ou `typeref`). Consulte o <xref:System.Reflection.Emit.OpCodes.Mkrefany> a instrução para o conteúdo relacionado.  
  
 <xref:System.InvalidCastException>será gerada se `type` não é idêntico para o tipo armazenado na referência de tipo (nesse caso, `type` a classe que é fornecida para o <xref:System.Reflection.Emit.OpCodes.Mkrefany> instrução construído disse referência de tipo).  
  
 <xref:System.TypeLoadException>será gerada se `type` não pode ser encontrado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `refanyval` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores e envia o restante para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|5D|REM|Envia o resto da divisão `value1` por `value2` na pilha.|  
  
> [!NOTE]
>  ReplaceThisText  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um `value1` é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados de pilha e o restante do `value1` `div` `value2` computada.  
  
4.  O resultado é inserido na pilha.  
  
 `result` = `value1``rem` `value2` satisfaz as condições a seguir:  
  
 `result` = `value1` - `value2``×` (`value1` `div` `value2`), and:  
  
 0 = &#124; `result` &#124; < &#124; `value2` &#124; entrada (`result`) = sinal (`value1`), onde `div` é a instrução de divisão que trunca em direção a zero.  
  
 Se `value2` for zero ou `value1` é infinito, o resultado é NaN. Se `value2` é infinito, o resultado é `value1` (negadas para `-infinity`).  
  
 Operações integrais lançam <xref:System.DivideByZeroException> se `value2` é zero.  
  
 Observe que nas plataformas baseados no Intel um <xref:System.OverflowException> é gerada quando a computação (minint `rem` -1).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rem` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rem_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rem_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rem_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rem_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Divide dois valores não assinados e envia o restante para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|5E|REM.Un|Envia o resto da divisão não assinados `value1` por não assinados `value2` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados de pilha e o restante do `value1` `div` `value2` computada.  
  
4.  O resultado é inserido na pilha.  
  
 `result` = `value1``rem.un` `value2` satisfaz as condições a seguir:  
  
 `result` = `value1` - `value2`x(`value1` `div.un` `value2`), and:  
  
 0 = `result`  <  `value2`, onde `div.un` é a instrução de divisão não assinados.  
  
 O `rem.un` calcula a instrução `result` e envia por push na pilha. `Rem.un`trata os argumentos como inteiros sem sinal, enquanto <xref:System.Reflection.Emit.OpCodes.Rem> trata assinados como inteiros.  
  
 `Rem.un`não é especificado para números de ponto flutuante.  
  
 Operações integrais lançam <xref:System.DivideByZeroException> se `value2` é zero.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rem.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ret">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Ret;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Ret" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Ret" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna do método atual, enviando um valor retornado (se houver) da pilha de avaliação do computador chamado para a pilha de avaliação do chamador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|2A|RET|Retorna um método, possivelmente, retornando um valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor de retorno é exibido da pilha de avaliação do receptor.  
  
2.  O valor de retorno obtido na etapa 1 é enviado para a pilha de avaliação do chamador.  
  
 Se o valor de retorno não está presente na pilha de avaliação de receptor, nenhum valor será retornado (nenhum comportamentos de transição de pilha para o chamador ou receptor de método).  
  
 O tipo do valor de retorno, se houver, do método atual determina o tipo de valor a ser obtido da parte superior da pilha e copiado para a pilha do método que chamou o método atual. A pilha de avaliação para o método atual deve ser vazia, exceto o valor a ser retornado.  
  
 O `ret` instrução não pode ser usada para transferir controle fora de um`try`, `filter`, `catch`, ou `finally` bloco. De dentro uma `try` ou `catch`, use o <xref:System.Reflection.Emit.OpCodes.Leave> instrução com um destino de um `ret` instrução que está fora do delimitador de todos os blocos de exceção. Porque o `filter` e `finally` blocos logicamente fazem parte da manipulação de exceção e não o método no qual o código é inserido, instruções de linguagem intermediária da Microsoft (MSIL) corretamente geradas não executam um método de retorno de dentro de um `filter` ou `finally`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `ret` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rethrow">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Rethrow;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Rethrow" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Rethrow" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Lança novamente a exceção atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1A|relançar|Lança novamente a exceção atual|  
  
 Nenhum comportamento de transição de pilha é definido para essa instrução.  
  
 O `rethrow` instrução só é permitida dentro do corpo de um `catch` manipulador. Ele gera a mesma exceção foi detectada para este manipulador.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `rethrow` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shl">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shl;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shl" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shl" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desloca um valor inteiro para a esquerda (em zeros) em um número especificado de bits, enviar por push o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|62|Shl|Desloca um número inteiro para a esquerda (deslocamento em zeros).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é inserido na pilha.  
  
2.  A quantidade de bits a ser deslocado é inserida na pilha.  
  
3.  O número de bits a ser deslocado e o valor são disparados da pilha; o valor é deslocado à esquerda pelo número especificado de bits.  
  
4.  O resultado é inserido na pilha.  
  
 O `shl` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à esquerda pelo número especificado de bits. O número de bits é um valor do tipo `int32` ou `native int`. O valor de retorno não for especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.  
  
 `Shl`Insere um bit zero na posição mais baixa em cada turno.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shl` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desloca um valor inteiro (no logon) para a direita em um número especificado de bits, enviar por push o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|63|SHR|Desloca um número inteiro para a direita (deslocado no logon).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é inserido na pilha.  
  
2.  A quantidade de bits a ser deslocado é inserida na pilha.  
  
3.  O número de bits a ser deslocado e o valor são disparados da pilha; o valor é deslocado à direita pelo número especificado de bits.  
  
4.  O resultado é inserido na pilha.  
  
 O `shr.un` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à direita pelo número especificado de bits. O número de bits é um valor do tipo `int32` ou `native int`. O valor de retorno não for especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.  
  
 `Shr`replica a ordem de alto bit em cada turno, preservando o sinal do valor original no `result`.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shr` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shr_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Shr_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Shr_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Shr_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Desloca um valor inteiro sem sinal (em zeros) à direita em um número especificado de bits, enviar por push o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|64|SHR.Un|Desloca um número inteiro para a direita (deslocamento em zeros).|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é inserido na pilha.  
  
2.  A quantidade de bits a ser deslocado é inserida na pilha.  
  
3.  O número de bits a ser deslocado e o valor são disparados da pilha; o valor é deslocado à direita pelo número especificado de bits.  
  
4.  O resultado é inserido na pilha.  
  
 O `shr.un` instrução desloca o valor (tipo `int32`, `int64` ou `native int`) à direita pelo número especificado de bits. O número de bits é um valor do tipo `int32`, `int64` ou `native int`. O valor de retorno não for especificado, se o número de bits de deslocamento é maior que ou igual à largura (em bits) do valor fornecido.  
  
 `Shr.un`Insere um bit zero na posição mais alta em cada turno.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `shr.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sizeof">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sizeof;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sizeof" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sizeof" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Envia o tamanho, em bytes, de um tipo de valor fornecido para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 1C <`T` >|sizeof`valType`|Enviar por push o tamanho, em bytes, de um tipo de valor como um `unsigned int32`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O tamanho (em bytes) do tipo de valor fornecido (`valType`) é inserido na pilha.  
  
 `valType`deve ser um token de metadados (uma `typeref` ou `typedef`) que especifica um tipo de valor, o tipo de referência ou o parâmetro de tipo genérico.  
  
 Para um tipo de referência, o tamanho retornado é o tamanho de um valor de referência do tipo (4 bytes em sistemas de 32 bits), não o tamanho dos dados armazenados em objetos referenciados pelo valor de referência. Um parâmetro de tipo genérico pode ser usado apenas no corpo do tipo ou método que o define. Quando o tipo ou método é instanciado, o parâmetro de tipo genérico é substituído por um tipo de valor ou tipo de referência.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sizeof` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena o valor no topo da pilha de avaliação no slot de argumento em um índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0B <`unsigned int16` >|StarG`num`|Aparece o valor de nível superior da pilha e a armazena no slot de argumento `num`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor atualmente na parte superior da pilha é exibido e colocado no slot de argumento `num`.  
  
 O `starg` instrução aparece um valor da pilha e o coloca no slot de argumento `num`. O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.  
  
 Para procedimentos que usam uma lista de argumentos de variável, o `starg` instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.  
  
 Execução de um repositório para argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor e avança da pilha para o argumento. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `starg` opcode:  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Starg_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Starg_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Starg_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Starg_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena o valor localizado no topo da pilha de avaliação no slot de argumento em um índice especificado, de forma abreviada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|10 < `unsigned int8` >|StarG.s`num`|Aparece o valor de nível superior da pilha e a armazena no slot de argumento `num`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  O valor atualmente na parte superior da pilha é exibido e colocado no slot de argumento `num`.  
  
 O `starg.s` instrução aparece um valor da pilha e o coloca no slot de argumento `num`. O tipo do valor deve corresponder ao tipo do argumento, conforme especificado na assinatura do método atual.  
  
 O `starg.s` instrução fornece uma codificação eficiente para uso com os primeiros 256 argumentos.  
  
 Para procedimentos que usam uma lista de argumentos de variável, o `starg.s` instrução pode ser usada apenas para inicial fixa argumentos, não os na variável parte da assinatura.  
  
 Execução de um repositório para argumentos que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor e avança da pilha para o argumento. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `starg.s` opcode:  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um índice especificado pelo valor na pilha de avaliação, cujo tipo é especificado na instrução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|A4 <`T` >|Stelem`typeTok`|Substitui o elemento de matriz no índice fornecido com um valor do tipo `typeTok` na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um valor de índice, `index`, para um elemento `array` é inserido na pilha.  
  
3.  Um valor do tipo especificado na instrução é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem` instrução substitui o valor do elemento no índice fornecido com base em zero na matriz unidimensional `array` com o valor. O valor tem o tipo especificado pelo token `typeTok` na instrução.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um determinado índice com o <see langword="native int" /> valor na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|9B|Stelem.i|Substitui um elemento de matriz no índice fornecido com o `native int` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.i` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `native int` valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um determinado índice com o <see langword="int8" /> valor na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|9C|Stelem.I1|Substitui um elemento de matriz no índice fornecido com o `int8` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.i1` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int8` valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um determinado índice com o <see langword="int16" /> valor na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|9D|Stelem.I2|Substitui um elemento de matriz no índice fornecido com o `int16` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.i2` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int16` valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um determinado índice com o <see langword="int32" /> valor na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|9E|Stelem.i4|Substitui um elemento de matriz no índice fornecido com o `int32` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.i4` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int32` valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um determinado índice com o <see langword="int64" /> valor na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|9F|Stelem.I8|Substitui um elemento de matriz no índice fornecido com o `int64` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.i8` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `int64` valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um determinado índice com o <see langword="float32" /> valor na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|A0|Stelem.R4|Substitui um elemento de matriz no índice fornecido com o `float32` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.r4` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `float32` valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento de matriz de um determinado índice com o <see langword="float64" /> valor na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|A1|Stelem.R8|Substitui um elemento de matriz no índice fornecido com o `float64` valor na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.r8` instrução substitui o valor do elemento `index` na matriz unidimensional `array` com o `float64` valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stelem_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stelem_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stelem_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stelem_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o elemento da matriz de um determinado índice com o valor de referência de objeto (tipo <see langword="O" />) na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|A2|Stelem.ref|Substitui um elemento de matriz no índice fornecido com o `ref` valor (tipo `O`) na pilha.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto para uma matriz, `array`, é inserido na pilha.  
  
2.  Um índice válido para um elemento `array` é inserido na pilha.  
  
3.  Um valor é inserido na pilha.  
  
4.  O valor, o índice e a referência da matriz são disparados da pilha; o valor é colocado no elemento de matriz no índice especificado.  
  
 O `stelem.ref` instrução substitui o valor do elemento no índice fornecido na matriz unidimensional `array` com o `ref` (tipo `O`) valor inserido na pilha.  
  
 Matrizes de objetos e, portanto, é representado por um valor do tipo `O`. O índice é tipo `native int`.  
  
 Observe que `stelem.ref` converte implicitamente o valor fornecido para o tipo de elemento `array` antes de atribuir o valor para o elemento da matriz. Esta conversão pode falhar, mesmo para código verificado. Portanto, o `stelem.ref` instrução pode lançar <xref:System.InvalidCastException>. Para matrizes unidimensionais que não estão com base em zero e para matrizes multidimensionais, o <xref:System.Array> classe fornece um <xref:System.Array.SetValue%2A> método.  
  
 <xref:System.NullReferenceException>será gerada se `array` é uma referência nula.  
  
 <xref:System.IndexOutOfRangeException>será gerada se `index` é negativo ou maior que o limite de `array`.  
  
 <xref:System.ArrayTypeMismatchException>será gerada se `array` não contém elementos do tipo necessário.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stelem.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o valor armazenado no campo de uma referência de objeto ou de um ponteiro por um novo valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|7D <`T` >|stfld`field`|Substitui o valor de `field` do objeto com um novo valor.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto ou ponteiro é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o referência de objeto/ponteiro são disparados da pilha; o valor de `field` no objeto é substituído com o valor fornecido.  
  
 O `stfld` instrução substitui o valor de um campo de um objeto (tipo `O`) ou por meio de um ponteiro (tipo `native int`, `&`, ou `*`) com um determinado valor. `Field`é um token de metadados que se refere a uma referência de membro do campo. O `stfld` instrução pode ter um prefixo de um ou ambos <xref:System.Reflection.Emit.OpCodes.Unaligned> e <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.NullReferenceException>é gerada se o ponteiro ou referência de objeto é uma referência nula e o campo não é estático.  
  
 <xref:System.MissingFieldException>será gerada se `field` não foi encontrado nos metadados. Normalmente, isso é verificado quando a instrução Microsoft Intermediate Language (MSIL) é convertida em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stfld` opcode:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="native int" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|DF|stind.i|Armazena um `native int` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.i` instrução armazena um `native int` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.i` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.i` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int8" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|52|stind.I1|Armazena um `int8` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.i1` instrução armazena um `int8` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.i1` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.i1` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int16" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|53|stind.I2|Armazena um `int16` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.i2` instrução armazena um `int16` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.2i` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.i2` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int32" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|54|stind.i4|Armazena um `int32` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.i4` instrução armazena um `int32` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.i4` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.i4` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_I8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_I8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_I8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_I8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="int64" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|55|stind.I8|Armazena um `int64` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.i8` instrução armazena um `int64` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.i8` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.i` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.i8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R4">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R4;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R4" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R4" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="float32" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|56|stind.R4|Armazena um `float32` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.r4` instrução armazena um `float32` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.r4` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.r4` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.r4` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_R8">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_R8;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_R8" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_R8" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor do tipo <see langword="float64" /> em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|57|stind.R8|Armazena um `float64` valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.r8` instrução armazena um `float64` valor no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.r8` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.r8` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.r8` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stind_Ref">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stind_Ref;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stind_Ref" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stind_Ref" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Armazena um valor de referência de objeto em um endereço fornecido.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|51|stind.ref|Armazena uma referência de objeto (tipo `O`) valor em um determinado endereço.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um valor é inserido na pilha.  
  
3.  O valor e o endereço são disparados da pilha; o valor é armazenado no endereço.  
  
 O `stind.ref` instrução armazena um valor de referência de objeto no endereço fornecido (tipo `native int`, `*`, ou `&`).  
  
 Operação de tipo segura requer que o `stind.ref` instrução ser usados de maneira consistente com o tipo do ponteiro. A operação do `stind.ref` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.NullReferenceException>será gerada se `addr` naturalmente não está alinhado para o tipo de argumento indicado pelo sufixo de instrução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stind.ref` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e a armazena em uma lista de variáveis locais em um índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 0E <`unsigned int16` >|stloc`index`|Aparece um valor da pilha e a armazena na variável local `index`.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é exibido fora da pilha e colocado na variável local `index`.  
  
 O `stloc` instrução aparece o valor de nível superior na pilha de avaliação e a move para o número de variável local `index`, onde as variáveis locais são numerados de 0 em diante. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 Instruções corretas do Microsoft Intermediate Language (MSIL) exigem que `index` ser um índice de local válido. Para o `stloc` instrução `index` devem estar no intervalo de 0 a 65534 inclusiva (especificamente, 65535 não é válido). A razão para excluir a 65535 é pragmática: implementações provavelmente usará um inteiro de 2 bytes para controlar os índice do local, bem como o número total de locais para um determinado método. Se um índice de 65535 tinha sido feito válido, ela requer um inteiro maior para controlar o número de locais em tal método.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `stloc` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, short)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_0">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_0;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_0" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_0" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 0.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|0A|stloc.0|Exibe um valor da pilha para variável local 0.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é exibido fora da pilha e colocado na variável local indexada por 0.  
  
 O `stloc.0` instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 0. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.  
  
 `stloc.0`é uma codificação especialmente eficiente para armazenar valores de variável local 0.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.0` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_1">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_1;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_1" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_1" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 1.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|0B|stloc.1|Exibe um valor da pilha em 1 de variável local.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é exibido fora da pilha e colocado na variável local indexada por 1.  
  
 O `stloc.1` instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 1. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.  
  
 `stloc.1`é uma codificação especialmente eficiente para armazenar valores de variável local 1.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.1` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_2">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_2;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_2" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_2" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aparece o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 2.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|0C|stloc.2|Aparece um valor da pilha para variável local 2|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é exibido fora da pilha e colocado na variável local indexada por 2.  
  
 O `stloc.2` instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 2. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.  
  
 `stloc.2`é uma codificação especialmente eficiente para armazenar valores de variável local 2.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.2` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_3">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_3;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_3" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_3" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aparece o valor atual da parte superior da pilha de avaliação e armazena em uma lista de variáveis local no índice 3.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|0D|stloc.3|Aparece um valor da pilha para variável local 3|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é exibido fora da pilha e colocado na variável local indexada por 3.  
  
 O `stloc.3` instrução aparece o valor de nível superior na pilha de avaliação e a move para a variável local indexada por 3. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.  
  
 `stloc.3`é uma codificação especialmente eficiente para armazenar valores em 3 de variável local.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stloc.3` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stloc_S">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stloc_S;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stloc_S" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stloc_S" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Exibe o valor atual da parte superior da pilha de avaliação e o armazena em uma lista de variáveis locais em <paramref name="index" /> (forma abreviada).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|13 < `unsigned int8` >|stloc.s`index`|Aparece um valor da pilha e a armazena na variável local `index`, forma abreviada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é exibido fora da pilha e colocado na variável local `index`.  
  
 O `stloc.s` instrução aparece o valor de nível superior na pilha de avaliação e a move para o número de variável local `index`, onde as variáveis locais são numerados de 0 em diante. O tipo do valor deve corresponder ao tipo da variável local, conforme especificado na assinatura local do método atual.  
  
 O `stloc.s` instrução fornece uma codificação eficiente para variáveis locais 0 a 255.  
  
 Armazenando em locais que contêm um valor inteiro menor que 4 bytes de comprimento trunca o valor conforme avança da pilha para a variável local. Valores de ponto flutuante são arredondados de seu tamanho nativo (tipo `F`) para o tamanho associado com o argumento.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `stloc.s` opcode:  
  
-   ILGenerator.Emit (OpCode, LocalBuilder)  
  
-   ILGenerator.Emit (OpCode, byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stobj">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stobj;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stobj" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stobj" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Copia um endereço de memória fornecido um valor de um tipo especificado da pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|81 < `T` >|stobj`class`|Armazena um valor do tipo `class` da pilha na memória.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
2.  Um objeto de tipo de valor do tipo `class` é inserido na pilha.  
  
3.  O objeto e o endereço são disparados da pilha; o objeto de tipo de valor é armazenado no endereço.  
  
 O `stobj` instrução copia o objeto de tipo de valor para o endereço especificado pelo endereço (um ponteiro de tipo `native int`, `*`, ou `&`). O número de bytes copiados depende do tamanho da classe representada pelo `class`, um token de metadados que representa um tipo de valor.  
  
 A operação do `stobj` instrução pode ser alterada por um imediatamente anterior <xref:System.Reflection.Emit.OpCodes.Volatile> ou <xref:System.Reflection.Emit.OpCodes.Unaligned> prefixo instrução.  
  
 <xref:System.TypeLoadException>é gerada se a classe não pode ser encontrada. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stobj` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stsfld">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Stsfld;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Stsfld" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Stsfld" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Substitui o valor de um campo estático por um valor da pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|80 < `T` >|stsfld`field`|Substitui o valor em `field` com um valor fornecido.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é inserido na pilha.  
  
2.  Um valor é exibido da pilha e armazenado em `field`.  
  
 O `stsfld` instrução substitui o valor de um campo estático com um valor da pilha. `field`é um token de metadados que deve se referir a um membro do campo estático.  
  
 O `stsfld` instruções podem ser prefixadas pelo <xref:System.Reflection.Emit.OpCodes.Volatile>.  
  
 <xref:System.MissingFieldException>é gerada se o campo não for encontrado nos metadados. Normalmente, isso é verificado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, não em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `stsfld` opcode:  
  
-   ILGenerator.Emit (OpCode, FieldInfo)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrai um valor de outro e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|59|sub|Subtrai um valor de outro, retornando um novo valor numérico.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value2` é subtraído de `value1`.  
  
4.  O resultado é inserido na pilha.  
  
 Estouro não é detectado para operações de inteiro (para manipulação de estouro adequada, consulte <xref:System.Reflection.Emit.OpCodes.Sub_Ovf>).  
  
 Subtração de inteiro é quebrada, em vez de esteja saturado. Por exemplo: supondo inteiros de 8 bits, onde `value1` é definido como 0 e `value2` é definido como 1, o resultado "encapsulado" será 255.  
  
 Estouro de ponto flutuante retorna `+inf` (`PositiveInfinity`) ou `-inf` (`NegativeInfinity`).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrai um valor de inteiro de outro, executa uma verificação de estouro e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|DA|sub.OVF|Subtrai um valor de inteiro de outro com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value2` é subtraído de `value1` com uma verificação de estouro.  
  
4.  O resultado é inserido na pilha.  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub.ovf` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sub_Ovf_Un">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Sub_Ovf_Un;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Sub_Ovf_Un" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Sub_Ovf_Un" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Subtrai um valor inteiro não assinado de outro, executa uma verificação de estouro e envia o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|DB|sub.OVF.Un|Subtrai um valor de inteiro não assinado de outro com uma verificação de estouro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados da pilha; `value2` é subtraído de `value1` com uma verificação de estouro.  
  
4.  O resultado é inserido na pilha.  
  
 <xref:System.OverflowException>é gerada se o resultado não pode ser representado no tipo de resultado.  
  
 Esta operação é executada em inteiros com sinal; para valores de ponto flutuantes, use <xref:System.Reflection.Emit.OpCodes.Sub>.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `sub.ovf.un` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Switch;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Switch" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Switch" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Implementa uma tabela de atalhos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|45 < `unsigned int32` > < `int32` >... < `int32` >|Alternar (`N`, `t1`, `t2`... `tN`)|Vai para um dos `N` valores.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um valor é inserido na pilha.  
  
2.  O valor é retirado da pilha e a execução será transferida para a instrução no deslocamento indexado por valor, onde o valor é menor que `N`.  
  
 O `switch` instrução implementa uma tabela de salto. O formato da instrução é um `unsigned int32` que representa o número de destinos `N`, seguido por `N` valores int32 especificando destinos de salto. Esses destinos são representados como deslocamentos (positivos ou negativos) desde o início da instrução a seguir isso `switch` instrução.  
  
 O `switch` instrução aparece um valor da pilha e o compara, como um inteiro sem sinal, como `N`. Se o valor é menor que `N`, a execução será transferida para o destino indexado por valor, em que os destinos são numerados de 0 (por exemplo, o primeiro destino entra em um valor de 0, um valor 1 faz o destino de segundo e assim por diante). Se o valor for maior que ou igual a `N`, a execução continua na próxima instrução (falha).  
  
 Se a instrução de destino tem um ou mais códigos de prefixo, o controle só pode ser transferido para o primeiro desses prefixos.  
  
 O controle transfere dentro e fora do `try`, `catch`, `filter`, e `finally` blocos não podem ser executados por essa instrução. (Essas transferências são restritas severos em devem usar a instrução de licença em vez disso).  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `switch` opcode. O `Label[]` argumento é uma matriz dos rótulos que representa os deslocamentos de 32 bits.  
  
-   ILGenerator.Emit (OpCode, Label[])  
  
   
  
## Examples  
 O exemplo de código a seguir ilustra o uso do `Switch` opcode para gerar uma tabela de salto usando uma matriz de <xref:System.Reflection.Emit.Label>.  
  
 [!code-cpp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.ILGenerator.Emit Example 2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.ILGenerator.Emit Example 2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tailcall">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Tailcall;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Tailcall" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Tailcall" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Executa uma instrução de chamada de método pós-fixada, de modo que o registro de ativação do método atual é removido antes da execução da instrução de chamada real.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 14|final.|Chamada subsequente encerra métodos atuais|  
  
 Há um comportamento de transição de pilha definido para essa instrução.  
  
 O `tail` instrução de prefixo deve preceder imediatamente um <xref:System.Reflection.Emit.OpCodes.Call>, <xref:System.Reflection.Emit.OpCodes.Calli>, ou <xref:System.Reflection.Emit.OpCodes.Callvirt> instrução. Ele indica que o quadro de pilha do método atual deve ser removido antes que a instrução de chamada é executada. Isso também significa que o valor retornado da chamada a seguir também é o valor retornado pelo método atual, e a chamada, portanto, pode ser convertida em um salto cruzado método.  
  
 A pilha deve estar vazia, exceto os argumentos que estão sendo transferidos, a chamada a seguir. A instrução após a instrução de chamada deve ser um ret. Assim, a sequência de código só é válida é `tail. call` (ou `calli` ou `callvirt`). Instruções Microsoft Intermediate Language (MSIL) corretas não devem fazer branch para o `call` instrução, mas eles podem ramificar próximos <xref:System.Reflection.Emit.OpCodes.Ret>.  
  
 O quadro atual não pode ser descartado quando o controle é transferido de código não confiável para o código confiável, pois isso poderia comprometer a segurança de identidade do código. Verifica se a segurança do .NET Framework, portanto, pode fazer com que o `tail` sejam ignorados, deixando um padrão <xref:System.Reflection.Emit.OpCodes.Call> instrução. Da mesma forma, em ordem para permitir que a saída de uma região sincronizada a ocorrer após a chamada retorna, o `tail` prefixo é ignorado quando usado para sair de um método que está marcado como sincronizado.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `tail` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TakesSingleByteArgument">
      <MemberSignature Language="C#" Value="public static bool TakesSingleByteArgument (System.Reflection.Emit.OpCode inst);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TakesSingleByteArgument(valuetype System.Reflection.Emit.OpCode inst) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Emit.OpCodes.TakesSingleByteArgument(System.Reflection.Emit.OpCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inst" Type="System.Reflection.Emit.OpCode" />
      </Parameters>
      <Docs>
        <param name="inst">Uma instância de um objeto de código de operação.</param>
        <summary>Retorna true ou false se o código de operação fornecido tem um argumento de byte único.</summary>
        <returns>
          <see langword="True" /> ou <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode ser usado para descobrir quais opcodes MSIL são "forma abreviada," para uso em código otimizado.  
  
 `TakesSingleByteArgument`Retorna `true` se o <xref:System.Reflection.Emit.OpCode> instância usa um argumento de byte único nos seguintes casos:  
  
-   O opcode executa uma instrução de ramificação para um endereço de tamanho de byte (por exemplo, <xref:System.Reflection.Emit.OpCodes.Br_S> e <xref:System.Reflection.Emit.OpCodes.Bgt_S>).  
  
-   O código de operação envia um valor de byte para a pilha (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldc_I4_S>).  
  
-   O código de operação faz referência a uma variável ou argumento via o tamanho em bytes "curtas" (por exemplo, <xref:System.Reflection.Emit.OpCodes.Ldloc_S> e <xref:System.Reflection.Emit.OpCodes.Stloc_S>).  
  
 Caso contrário, retornará `false`.  
  
 O exemplo a seguir demonstra o uso de `TakesSingleByteArgument` refletindo para o `OpCodes` classe e teste para ver se cada `OpCode` campo usa um argumento de byte único.  
  
 [!code-cpp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CPP/source.cpp#1)]
 [!code-csharp[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/CS/source.cs#1)]
 [!code-vb[System.Reflection.Emit.OpCodes.TakesSingleByteArgument Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Emit.OpCodes.TakesSingleByteArgument Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Throw">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Throw;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Throw" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Throw" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gera o objeto de exceção no momento na pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|7A|throw|Gerencie uma exceção.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto (uma exceção) é inserida na pilha.  
  
2.  A referência de objeto é exibida na pilha e a exceção é gerada.  
  
 O `throw` instrução gera o objeto de exceção (tipo `O`) atualmente na pilha.  
  
 <xref:System.NullReferenceException>é gerada se a referência de objeto é uma referência nula.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `throw` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unaligned">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unaligned;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unaligned" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unaligned" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que um endereço atualmente sobre a pilha de avaliação pode não estar alinhado ao tamanho natural de imediatamente após <see langword="ldind" />, <see langword="stind" />, <see langword="ldfld" />, <see langword="stfld" />, <see langword="ldobj" />, <see langword="stobj" />, <see langword="initblk" />, ou <see langword="cpblk" /> instrução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 12 <`unsigned int8` >|não alinhado. `alignment`|Indica que a instrução de ponteiro subsequentes pode ser não alinhada.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
 `Unaligned`Especifica que o endereço (um ponteiro não gerenciado, `native int`) na pilha pode não estar alinhado ao tamanho natural de imediatamente após `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução. Ou seja, para um <xref:System.Reflection.Emit.OpCodes.Ldind_I4> instrução não pode ser o alinhamento do endereço de um limite de 4 bytes. Para `initblk` e `cpblk` o alinhamento padrão é dependente de arquitetura (4 bytes em CPUs de 32 bits, 8 bytes em CPUs de 64 bits). Geradores de código que não restringem a saída para um tamanho de palavra de 32 bits devem usar `unaligned` se o alinhamento não é conhecido em tempo de compilação para ser 8 bytes.  
  
 O valor de alinhamento deve ser 1, 2 ou 4 e significa que o código gerado deve presumir que o endereço é byte, byte duplo, ou quad-bytes alinhados, respectivamente. Observe que transitório ponteiros (tipo `*`) sempre são alinhados.  
  
 Enquanto o alinhamento de um `cpblk` instrução logicamente exigem dois números (um para a origem) e outro para o destino, não há nenhum impacto perceptível no desempenho se apenas o número mais baixo é especificado.  
  
 O `unaligned` e `volatile` prefixos podem ser combinados em qualquer ordem. Deve preceder imediatamente um `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução. Somente o <xref:System.Reflection.Emit.OpCodes.Volatile> é permitido um prefixo para o <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> instruções.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecargas de método podem usar o `unaligned` opcode:  
  
-   ILGenerator.Emit (OpCode, rótulo)  
  
-   ILGenerator.Emit (Opcode, Byte)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte a representação demarcada de um tipo de valor em sua forma não marcada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|79 < `T` >|Converter`valType`|Extrai os dados de tipo de valor de `obj`, sua representação de processador.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto é inserida na pilha.  
  
2.  A referência de objeto é exibida da pilha e desencaixotada para um ponteiro de tipo de valor.  
  
3.  O ponteiro de tipo de valor é inserido na pilha.  
  
 Um tipo de valor tem duas representações separadas no Common Language Infrastructure (CLI):  
  
-   Uma forma 'bruta' usada quando um tipo de valor é inserido em outro objeto.  
  
-   Uma forma 'boxed', onde os dados no tipo de valor são encapsulados (boxed) em um objeto para que ele pode existir de modo independente.  
  
 O `unbox` instrução converte a referência de objeto (tipo `O`), o box representação de um tipo de valor, para um ponteiro de tipo de valor (um ponteiro gerenciado, tipo `&`), sua desencaixotado formulário. O tipo de valor fornecido (`valType`) é um token de metadados que indica o tipo do tipo de valor contido no objeto Demarcado.  
  
 Ao contrário de <xref:System.Reflection.Emit.OpCodes.Box>, que é necessário para fazer uma cópia de um tipo de valor para uso no objeto, `unbox` não é necessário para copiar o tipo de valor do objeto. Normalmente, ele simplesmente computa o endereço do tipo de valor que já está presente no objeto Demarcado.  
  
 <xref:System.InvalidCastException>será gerada se o objeto não é demarcado como `valType`.  
  
 <xref:System.NullReferenceException>é gerada se a referência de objeto é uma referência nula.  
  
 <xref:System.TypeLoadException>será gerada se o valor do tipo `valType` não pode ser encontrado. Normalmente, isso é detectado quando instruções Microsoft Intermediate Language (MSIL) são convertidas em código nativo, em vez de em tempo de execução.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `unbox` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Unbox_Any">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Unbox_Any;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Unbox_Any" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Unbox_Any" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Converte a representação demarcada de um tipo especificado na instrução em sua forma não demarcada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista a instrução hexadecimal e formato de assembly Microsoft intermediate language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|A5 <`T` >|unbox.Any`typeTok`|Extrair os dados de `obj`, sua representação de processador.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Uma referência de objeto `obj` é inserido na pilha.  
  
2.  A referência de objeto é exibida da pilha e desencaixotada para o tipo especificado na instrução.  
  
3.  O tipo de valor ou referência de objeto resultante é inserido na pilha.  
  
 Quando aplicado a forma boxed do tipo de valor, o `unbox.any` instrução extrai o valor contido em `obj` (do tipo `O`) e, portanto, é equivalente a `unbox` seguido por `ldobj`.  
  
 Quando aplicado a um tipo de referência, o `unbox.any` instrução tem o mesmo efeito que `castclass` `typeTok`.  
  
 Se o operando `typeTok` é um parâmetro de tipo genérico, em seguida, o comportamento de tempo de execução é determinado pelo tipo que é especificado para esse parâmetro de tipo genérico.  
  
 <xref:System.InvalidCastException>será gerada se `obj` não é um tipo Demarcado.  
  
 <xref:System.NullReferenceException>será gerada se `obj` é uma referência nula.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `unbox.any` opcode:  
  
-   ILGenerator.Emit (código de operação, digite)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Volatile">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Volatile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Volatile" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Volatile" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que um endereço atualmente sobre a pilha de avaliação pode ser volátil e os resultados de leitura que local não pode ser armazenado em cache ou que várias lojas para esse local não pode ser suprimidas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|FE 13|voláteis.|Indica que a referência de ponteiro subsequente é volátil.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  Um endereço é inserido na pilha.  
  
 `volatile`. Especifica que o endereço é um endereço volátil (isto é, ele pode ser referenciado externamente para o segmento atual de execução) e os resultados de leitura que local não pode ser armazenado em cache ou que várias lojas para esse local não pode ser suprimidas. Marcar um acesso como `volatile` afeta somente essa único; outros acessa no mesmo local deve ser marcado separadamente. Acesso a locais volátil não precisa ser executado atomicamente.  
  
 O <xref:System.Reflection.Emit.OpCodes.Unaligned> e `volatile` prefixos podem ser combinados em qualquer ordem. Deve preceder imediatamente um `ldind`, `stind`, `ldfld`, `stfld`, `ldobj`, `stobj`, `initblk`, ou `cpblk` instrução. Somente o `volatile` é permitido um prefixo para o <xref:System.Reflection.Emit.OpCodes.Ldsfld> e <xref:System.Reflection.Emit.OpCodes.Stsfld> instruções.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `volatile` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Xor">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.Emit.OpCode Xor;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Reflection.Emit.OpCode Xor" />
      <MemberSignature Language="DocId" Value="F:System.Reflection.Emit.OpCodes.Xor" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.OpCode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Calcula o XOR bit a bit dos dois valores superiores na pilha de avaliação, enviar por push o resultado para a pilha de avaliação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista as instruções hexadecimal e formato de assembly do Microsoft Intermediate Language (MSIL), junto com um resumo breve de referência:  
  
|Formatar|Formato de assembly|Descrição|  
|------------|---------------------|-----------------|  
|61|xor|Calcula o XOR bit a bit de dois valores inteiros e retorna um inteiro.|  
  
 O comportamento de transição de pilha, em ordem sequencial, é:  
  
1.  `value1`é inserido na pilha.  
  
2.  `value2`é inserido na pilha.  
  
3.  `value2`e `value1` são disparados de pilha e o bit a bit XOR computada.  
  
4.  O XOR bit a bit de `value2` e `value1` é inserido na pilha.  
  
 O `xor` instrução calcula o XOR bit a bit dos dois principais valores na pilha e deixa o resultado na pilha.  
  
 `Xor`é uma operação de inteiro específico.  
  
 O seguinte <xref:System.Reflection.Emit.ILGenerator.Emit%2A> sobrecarga de método pode usar o `xor` opcode:  
  
-   ILGenerator.Emit(OpCode)  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
