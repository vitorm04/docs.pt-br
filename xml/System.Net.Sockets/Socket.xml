<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementa a interface de soquetes Berkeley.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket> classe fornece um conjunto rico de métodos e propriedades para as comunicações de rede. O <xref:System.Net.Sockets.Socket> classe permite que você execute ambos síncrona e transferência de dados assíncrona usando qualquer um dos protocolos de comunicação listados no <xref:System.Net.Sockets.ProtocolType> enumeração.  
  
 O <xref:System.Net.Sockets.Socket> classe segue o padrão de nomenclatura do .NET Framework para métodos assíncronos. Por exemplo, o síncrona <xref:System.Net.Sockets.Socket.Receive%2A> método corresponde à assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos.  
  
 Se seu aplicativo requer apenas um thread durante a execução, use os métodos a seguir, que são projetados para o modo de operação síncrona.  
  
-   Se você estiver usando um protocolo orientado a conexão como TCP, o servidor pode escutar conexões usando o <xref:System.Net.Sockets.Socket.Listen%2A> método. O <xref:System.Net.Sockets.Socket.Accept%2A> processos de método solicitações de qualquer conexão de entrada e retorna um <xref:System.Net.Sockets.Socket> que você pode usar para se comunicar dados com o host remoto. Use este retornado <xref:System.Net.Sockets.Socket> para chamar o <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> método. Chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método antes de chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método se você deseja especificar o número de porta e endereço IP local. Use um número de porta de zero se quiser que o provedor de serviço subjacente para atribuir uma porta disponível para você. Se você quiser se conectar a um host de escutando, chame o <xref:System.Net.Sockets.Socket.Connect%2A> método. Para se comunicar dados, chame o <xref:System.Net.Sockets.Socket.Send%2A> ou <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
-   Se você estiver usando um protocolo sem-conexão como UDP, você não precisa escutar conexões em todos os. Chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método para aceitar a entrada datagramas. Use o <xref:System.Net.Sockets.Socket.SendTo%2A> método enviar datagramas para um host remoto.  
  
 Para processar comunicações usando threads separados durante a execução, use os métodos a seguir, que são projetados para o modo de operação assíncrona.  
  
-   Se você estiver usando um protocolo orientado a conexão como TCP, use o <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, e <xref:System.Net.Sockets.Socket.EndConnect%2A> métodos para se conectar com um host de escutando. Use o <xref:System.Net.Sockets.Socket.BeginSend%2A> e <xref:System.Net.Sockets.Socket.EndSend%2A> ou <xref:System.Net.Sockets.Socket.BeginReceive%2A> e <xref:System.Net.Sockets.Socket.EndReceive%2A> métodos para se comunicar dados de forma assíncrona. Solicitações de conexão de entrada podem ser processadas usando <xref:System.Net.Sockets.Socket.BeginAccept%2A> e <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Se você estiver usando um protocolo sem-conexão como UDP, você pode usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.EndSendTo%2A> para enviar datagramas, e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> e <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> para receber datagramas.  
  
 Se você executar várias operações assíncronas em um soquete, não sejam necessariamente concluídas na ordem em que eles são iniciados.  
  
 Quando tiver terminado de enviar e receber dados, use o <xref:System.Net.Sockets.Socket.Shutdown%2A> método para desativar o <xref:System.Net.Sockets.Socket>. Depois de chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos os recursos associados a <xref:System.Net.Sockets.Socket>.  
  
 O <xref:System.Net.Sockets.Socket> classe permite que você configure seu <xref:System.Net.Sockets.Socket> usando o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método. Recuperar essas configurações usando o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
> [!NOTE]
>  Se você estiver escrevendo um aplicativo relativamente simples e não requerem desempenho máximo, considere o uso de <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, e <xref:System.Net.Sockets.UdpClient>. Essas classes fornecem uma interface simples e mais amigável para <xref:System.Net.Sockets.Socket> comunicações.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como o <xref:System.Net.Sockets.Socket> classe pode ser usada para enviar dados para um servidor HTTP e receber a resposta. Este exemplo bloqueia até que a página inteira seja recebida.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">para estabelecer uma conexão de saída ou aceitar uma solicitação de entrada.</permission>
    <threadsafe>As instâncias dessa classe serão thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">As informações de soquete retornadas por <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.Sockets.Socket" />, usando o valor especificado de <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você chamar o <xref:System.Net.Sockets.Socket.%23ctor%2A> construtor várias vezes com a mesma matriz de bytes como o argumento para cada chamada, você criará vários gerenciado <xref:System.Net.Sockets.Socket>s com o mesmo soquete subjacente. Essa prática é altamente desaconselhável.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.Sockets.Socket" /> usando o tipo de soquete e o protocolo especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `socketType` parâmetro especifica o tipo do <xref:System.Net.Sockets.Socket> classe e o `protocolType` parâmetro especifica o protocolo usado pelo <xref:System.Net.Sockets.Socket>. Os dois parâmetros não são independentes. Geralmente o <xref:System.Net.Sockets.Socket> tipo está implícito no protocolo. Se a combinação de <xref:System.Net.Sockets.Socket> tipo e o protocolo digite resultados inválido <xref:System.Net.Sockets.Socket>, este construtor lança um <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se este construtor lança um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">A combinação de <paramref name="socketType" /> e <paramref name="protocolType" /> resulta em um soquete inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Um dos valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</param>
        <param name="socketType">Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Net.Sockets.Socket" /> usando a família de endereços, o tipo de soquete e o protocolo especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `addressFamily` parâmetro especifica o esquema de endereçamento que o <xref:System.Net.Sockets.Socket> classe usos, o `socketType` parâmetro especifica o tipo do <xref:System.Net.Sockets.Socket> classe e o `protocolType` parâmetro especifica o protocolo usado pelo <xref:System.Net.Sockets.Socket>. Os três parâmetros não são independentes. Algumas famílias de endereço restringem quais protocolos podem ser usados com eles e geralmente o <xref:System.Net.Sockets.Socket> tipo está implícito no protocolo. Se a combinação de família de endereço, <xref:System.Net.Sockets.Socket> tipo e resultados de tipo inválido do protocolo <xref:System.Net.Sockets.Socket>, este construtor lança um <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se este construtor lança um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como criar uma instância do <xref:System.Net.Sockets.Socket> classe.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">A combinação de <paramref name="addressFamily" />, <paramref name="socketType" /> e <paramref name="protocolType" /> resulta em um soquete inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo <see cref="T:System.Net.Sockets.Socket" /> para uma conexão recém-criada.</summary>
        <returns>Um <see cref="T:System.Net.Sockets.Socket" /> para uma conexão recém-criada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A>modo síncrono extrai a primeira solicitação de conexão pendente da fila de solicitações de conexão de soquete de escuta e, em seguida, cria e retorna um novo <xref:System.Net.Sockets.Socket>. Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais. No entanto, você pode chamar o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> método retornado <xref:System.Net.Sockets.Socket> para identificar o número de porta e endereço de rede do host remoto.  
  
 No modo de bloqueio, <xref:System.Net.Sockets.Socket.Accept%2A> bloqueia até que uma tentativa de conexão de entrada está na fila. Depois que uma conexão é aceita, o original <xref:System.Net.Sockets.Socket> continua a conexão de enfileiramento de mensagens de entrada solicitações até que você feche-lo.  
  
 Se você chamar este método usando sem bloqueio <xref:System.Net.Sockets.Socket>e nenhuma conexão solicitações são enfileiradas, <xref:System.Net.Sockets.Socket.Accept%2A> lança um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Antes de chamar o <xref:System.Net.Sockets.Socket.Accept%2A> método, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir aceita um simples <xref:System.Net.Sockets.Socket> conexão.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.InvalidOperationException">O soquete de aceitação não está escutando conexões. É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.Accept" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será acionado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> tentativas de método para processar a conexão de entrada de forma assíncrona. Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado. Antes de chamar o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.  
  
 Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e associá-lo para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 O chamador pode especificar opcionalmente um existente <xref:System.Net.Sockets.Socket> a ser usado para a conexão de entrada, especificando o <xref:System.Net.Sockets.Socket> para usar com o <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriedade.  
  
 Se o <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriedade for nula, uma nova <xref:System.Net.Sockets.Socket> é construído com o mesmo <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, e <xref:System.Net.Sockets.Socket.ProtocolType%2A> atual <xref:System.Net.Sockets.Socket> e defina como o <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> propriedade.  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Opcionalmente, um buffer pode ser fornecido no qual deseja receber o bloco inicial de dados no soquete após o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método for bem-sucedido. Nesse caso, o <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriedade deve ser definida para o buffer que contém os dados para receber e <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade precisa ser definido como o número máximo de bytes de dados para o buffer de recebimento. Essas propriedades podem ser definidas usando o <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> método. Parte do buffer transmitido será consumido internamente para uso pela chamada de Winsock AcceptEx subjacente. Isso significa que a quantidade de dados retornados será sempre menor que o valor da <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade o <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instância fornecida. A quantidade de buffer usado internamente varia de acordo com a família de endereços do soquete. O tamanho de buffer mínimo necessário é 288 bytes. Se um tamanho de buffer maior for especificado, o <xref:System.Net.Sockets.Socket> esperam que alguns dados adicionais que não sejam os dados de endereço recebidos pela chamada Winsock AcceptEx e aguardará até que esses dados extras são recebidos. Se ocorrer uma expiração, a conexão será redefinida. Então se dados extras esperados de um valor específico, o tamanho do buffer deve ser definido para o tamanho do buffer mínimo mais esse valor.  
  
 O método de retorno de chamada de conclusão deve examinar o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> para determinar se o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> a operação foi bem-sucedida.  
  
 O <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento pode ocorrer em alguns casos, quando nenhuma conexão foi aceito e fazer com que o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> propriedade a ser definida <xref:System.Net.Sockets.SocketError.ConnectionReset>. Isso pode ocorrer como resultado da verificação de portas com uma verificação de tipo entreaberto sin (um SYN -> SYN ACK-> sequência da primeira). Aplicativos que usam o <xref:System.Net.Sockets.Socket.AcceptAsync%2A> método deve estar preparado para tratar essa condição.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um argumento não é válido. Essa exceção ocorre se o buffer fornecido não for grande o suficiente. O buffer deve ter pelo menos 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.  
  
 Essa exceção também ocorre se vários buffers forem especificados e a propriedade <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> não for nula.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Um argumento está fora do intervalo. A exceção ocorre se o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> for menor que 0.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação inválida foi solicitada. Essa exceção ocorre se o <see cref="T:System.Net.Sockets.Socket" /> aceito não estiver escutando conexões ou se o soquete aceito estiver associado.  
  
 Você deve chamar o método <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar o método <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />.  
  
 Essa exceção também ocorre se o soquete já estiver conectado ou se uma operação de soquete já estivesse em andamento usando o parâmetro <paramref name="e" /> especificado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a família de endereços do <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Um dos valores de <see cref="T:System.Net.Sockets.AddressFamily" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.AddressFamily> Especifica o esquema de endereçamento que uma instância do <xref:System.Net.Sockets.Socket> pode usar a classe. Essa propriedade é somente leitura e é definida quando o <xref:System.Net.Sockets.Socket> é criado.  
  
   
  
## Examples  
 O código a seguir exemplo exibe o <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> para o console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de dados recebidos da rede e disponíveis para leitura.</summary>
        <value>O número de bytes de dados recebidos da rede e disponíveis para serem lidos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando sem bloqueio <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> é uma boa maneira de determinar se a dados está na fila para leitura, antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. Os dados disponíveis serão a quantidade total de dados no buffer de rede para leitura. Se nenhum dado é enfileirado no buffer de rede, <xref:System.Net.Sockets.Socket.Available%2A> retornará 0.  
  
 Se o host remoto é desligado ou fecha a conexão, <xref:System.Net.Sockets.Socket.Available%2A> pode lançar um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir compara os resultados da chamada IOControl com FIONREAD e a propriedade disponível.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à criação assíncrona do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> tentativas de método para processar a conexão de entrada de forma assíncrona. Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado. Antes de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.  
  
 Você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Para fazer isso, no mínimo, você deve passar a escuta <xref:System.Net.Sockets.Socket> do objeto para <xref:System.Net.Sockets.Socket.BeginAccept%2A> por meio de `state` parâmetro. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndAccept%2A> até que uma conexão pendente seja recuperada. <xref:System.Net.Sockets.Socket.EndAccept%2A>Retorna um novo <xref:System.Net.Sockets.Socket> do objeto que você pode usar para enviar e receber dados com o host remoto. Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.  
  
 O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada. Nesse caso, o <xref:System.IAsyncResult.CompletedSynchronously%2A> propriedade retornado <xref:System.IAsyncResult> será definida para indicar que o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método concluído de forma síncrona.  
  
 Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, feche o <xref:System.Net.Sockets.Socket>. Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método é chamado.  Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndAccept%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.  
  
> [!NOTE]
>  Você pode usar o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade retornado <xref:System.Net.Sockets.Socket> para identificar o número de porta e endereço de rede do host remoto.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a Windows Sockets versão 2 API documentação códigos de erro no MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir tenta receber uma conexão de entrada de forma assíncrona.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT é necessário para esse método.</exception>
        <exception cref="T:System.InvalidOperationException">O soquete de aceitação não está escutando conexões. É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
 -ou-  
  
 O soquete aceito está associado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> é menor que 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">O número de bytes a serem aceitos do remetente.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada e recebe o primeiro bloco de dados enviado pelo aplicativo cliente.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à criação assíncrona do <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> tentativas de método para processar a conexão de entrada de forma assíncrona. Aceitando conexões de forma assíncrona permite enviar e receber dados dentro de um thread de execução separado. Essa sobrecarga permite que você especifique o número de bytes para aceitar a transferência inicial no `receiveSize` parâmetro.  
  
 Antes de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.  
  
 Você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Para fazer isso, no mínimo, você deve passar a escuta <xref:System.Net.Sockets.Socket> do objeto para <xref:System.Net.Sockets.Socket.BeginAccept%2A> por meio de `state` parâmetro. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndAccept%2A> até que uma conexão pendente seja recuperada.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Retorna um novo <xref:System.Net.Sockets.Socket> que você pode usar para enviar e receber dados com o host remoto. Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.  
  
 O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada. Nesse caso, o <xref:System.IAsyncResult.CompletedSynchronously%2A> propriedade retornado <xref:System.IAsyncResult> será definida para indicar que o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método concluído de forma síncrona.  
  
 Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, feche o <xref:System.Net.Sockets.Socket>.  Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método é chamado.  Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndAccept%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.  
  
> [!NOTE]
>  Você pode chamar o uso de <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade retornado <xref:System.Net.Sockets.Socket> objeto para identificar o número de porta e endereço de rede do host remoto.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir abre um soquete e aceita uma conexão assíncrona. Neste exemplo, o soquete aceita inicias 10 bytes de dados. O número de bytes recebidos e os dados são exibidos no console, o representante de retorno de chamada. Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obter uma descrição de como os dados restantes são recebidos.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT é necessário para esse método.</exception>
        <exception cref="T:System.InvalidOperationException">O soquete de aceitação não está escutando conexões. É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
 -ou-  
  
 O soquete aceito está associado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> é menor que 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">O objeto <see cref="T:System.Net.Sockets.Socket" /> aceito. Este valor pode ser <see langword="null" />.</param>
        <param name="receiveSize">O número máximo de bytes a serem recebidos.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Inicia uma operação assíncrona para aceitar uma tentativa de conexão de entrada de um soquete especificado e recebe o primeiro bloco de dados enviado pelo aplicativo cliente.</summary>
        <returns>Um objeto <see cref="T:System.IAsyncResult" /> que faz referência à criação do objeto <see cref="T:System.Net.Sockets.Socket" /> assíncrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Protocolos orientados a Conexão podem usar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> tentativas de método para processar a conexão de entrada de forma assíncrona. Aceitando conexões de forma assíncrona fornece a capacidade de enviar e receber dados dentro de um thread de execução separado. Essa sobrecarga permite que você especifique o soquete aceito o `acceptSocket` parâmetro. Se esse parâmetro for `null`, o soquete aceito é criado pelo <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Você pode especificar o número de bytes para aceitar a transferência inicial no `receiveSize` parâmetro.  
  
 Antes de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, você deve chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método para escutar e a fila de solicitações de conexão de entrada.  
  
 Você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Para fazer isso, no mínimo, você deve passar a escuta <xref:System.Net.Sockets.Socket> do objeto para <xref:System.Net.Sockets.Socket.BeginAccept%2A> por meio de `state` parâmetro. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginAccept%2A>, geralmente, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndAccept%2A> até que uma conexão pendente seja recuperada.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>Retorna um novo <xref:System.Net.Sockets.Socket> do objeto que você pode usar para enviar e receber dados com o host remoto. Você não pode usar isso retornado <xref:System.Net.Sockets.Socket> para aceitar conexões da fila de conexão adicionais. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar.  
  
 O sistema também pode usar o thread de chamada para invocar o método de retorno de chamada. Nesse caso, o <xref:System.IAsyncResult.CompletedSynchronously%2A> propriedade retornado <xref:System.IAsyncResult> será definida para indicar que o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método concluído de forma síncrona.  
  
 Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, feche o <xref:System.Net.Sockets.Socket>. Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método é chamado.  Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndAccept%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.  
  
> [!NOTE]
>  Você pode usar o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade retornado <xref:System.Net.Sockets.Socket> objeto para identificar o número de porta e endereço de rede do host remoto.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir abre um soquete e aceita uma conexão assíncrona. Neste exemplo, o soquete aceita inicias 10 bytes de dados e o `acceptSocket` parâmetro é `null`, que força o <xref:System.Net.Sockets.Socket.BeginAccept%2A> método para criar o soquete aceito. O número de bytes recebidos e os dados são exibidos no console, o representante de retorno de chamada. Consulte <xref:System.Net.Sockets.Socket.BeginReceive%2A> para obter uma descrição de como os dados restantes são recebidos.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT é necessário para esse método.</exception>
        <exception cref="T:System.InvalidOperationException">O soquete de aceitação não está escutando conexões. É necessário chamar <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> e <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> antes de chamar <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.  
  
 -ou-  
  
 O soquete aceito está associado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="receiveSize" /> é menor que 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="end_point">To be added.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Inicia uma solicitação assíncrona para uma conexão de host remoto.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à conexão assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método inicia uma solicitação assíncrona para uma conexão para o `remoteEP` parâmetro. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.BeginConnect%2A> estabelece um host remoto padrão. Conectar ou configurar o host remoto padrão assincronamente fornece a capacidade de enviar e receber dados dentro de um thread de execução separado.  
  
 Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método. No mínimo, você deve passar o <xref:System.Net.Sockets.Socket> para <xref:System.Net.Sockets.Socket.BeginConnect%2A> por meio de `state` parâmetro. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket>e as outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginConnect%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndConnect%2A> até que o <xref:System.Net.Sockets.Socket> se conecta com êxito ou gera uma exceção. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A>. Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A> antes de enviar e receber dados. Você pode usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> e <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> para se comunicar com um host remoto. Se você chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas. Se você deseja definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e defina a transmissão para `true`. Se não for possível, <xref:System.Net.Sockets.Socket.BeginConnect%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você estiver usando um protocolo orientado a conexão e não chame <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado. Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até que você chame o <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. Se você quiser alterar o host remoto padrão, chame o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método novamente com o ponto de extremidade desejado.  
  
 Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>. Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.  Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída. Essa é uma limitação do provedor subjacente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou uma operação assíncrona já está em andamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address">O <see cref="T:System.Net.IPAddress" /> do host remoto.</param>
        <param name="port">O número da porta do host remoto.</param>
        <param name="callback">To be added.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações sobre a operação de conexão. Este objeto é passado para o <c>requestCallback</c> delegar quando a operação for concluída.</param>
        <summary>Inicia uma solicitação assíncrona para uma conexão de host remoto. O host é especificado por um <see cref="T:System.Net.IPAddress" /> e um número de porta.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à conexão assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Normalmente, o método é invocado pelo `requestCallback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas de método ou <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>. Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.  Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída. Essa é uma limitação do provedor subjacente. Também o <xref:System.Net.EndPoint> que é usado deve ser diferente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Net.Sockets.Socket" /> não está na família de soquete.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número da porta é inválido.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="address" /> é zero.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou uma operação assíncrona já está em andamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="addresses">Pelo menos um <see cref="T:System.Net.IPAddress" />, designando o host remoto.</param>
        <param name="port">O número da porta do host remoto.</param>
        <param name="callback">To be added.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações sobre a operação de conexão. Este objeto é passado para o <c>requestCallback</c> delegar quando a operação for concluída.</param>
        <summary>Inicia uma solicitação assíncrona para uma conexão de host remoto. O host é especificado por uma matriz <see cref="T:System.Net.IPAddress" /> e um número da porta.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência a conexões assíncronas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Normalmente, o método é invocado pelo `requestCallback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas do método.  
  
 Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>. Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.  Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída. Essa é uma limitação do provedor subjacente. Também o <xref:System.Net.EndPoint> que é usado deve ser diferente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Este método é válido para soquetes que usam <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número da porta é inválido.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="address" /> é zero.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou uma operação assíncrona já está em andamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="host">O nome do host remoto.</param>
        <param name="port">O número da porta do host remoto.</param>
        <param name="callback">To be added.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações sobre a operação de conexão. Este objeto é passado para o <c>requestCallback</c> delegar quando a operação for concluída.</param>
        <summary>Inicia uma solicitação assíncrona para uma conexão de host remoto. O host é especificado por um nome do host e um número da porta.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à conexão assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Normalmente, o método é invocado pelo `requestCallback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Connect%2A> sobrecargas do método.  
  
 Para cancelar uma chamada pendente para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método, feche o <xref:System.Net.Sockets.Socket>. Quando o <xref:System.Net.Sockets.Socket.Close%2A> método é chamado durante uma operação assíncrona está em andamento, o retorno de chamada fornecido para o <xref:System.Net.Sockets.Socket.BeginConnect%2A> método é chamado.  Uma chamada subsequente para a <xref:System.Net.Sockets.Socket.EndConnect%2A> método lançará um <xref:System.ObjectDisposedException> para indicar que a operação foi cancelada.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Se este soquete anteriormente foi desconectado, em seguida, <xref:System.Net.Sockets.Socket.BeginConnect%2A> deve ser chamado em um thread que não sairá até que a operação seja concluída. Essa é uma limitação do provedor subjacente. Também o <xref:System.Net.EndPoint> que é usado deve ser diferente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma tentativa de conexão assíncrona.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número da porta é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, ou uma operação assíncrona já está em andamento.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> se o soquete puder ser reutilizado após a conexão ser fechada; caso contrário, <see langword="false" />.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Inicia uma solicitação assíncrona para se desconectar de um ponto de extremidade remoto.</summary>
        <returns>Um objeto <see cref="T:System.IAsyncResult" /> que faz referência à operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão, você pode chamar o <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método para solicitar uma desconexão de um ponto de extremidade remoto. Se `reuseSocket` é `true`, você pode reutilizar o soquete.  
  
 O <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> método usa um thread separado para invocar o método de retorno de chamada especificada. O <xref:System.Net.Sockets.Socket.EndDisconnect%2A> blocos de método até a desconexão pendente é concluída. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um soquete para comunicação assíncrona e envia alguns dados para um host remoto. Quando os dados foram enviados, <xref:System.Net.Sockets.Socket.Shutdown%2A> é chamado para parar o envio e a atividade de recebimento. Em seguida, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> é chamado para iniciar uma solicitação de desconexão. Quando a solicitação é concluída, o <xref:System.Net.Sockets.Socket.Connected%2A> propriedade será consultada para testar se o soquete está desconectado.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento. Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</param>
        <summary>Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, o método é invocado pelo `callback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.  
  
 Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">
          O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <param name="callback">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento. Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</param>
        <summary>Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, o método é invocado pelo `callback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.  
  
 Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">
          O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">A posição de base zero no <c>buffer</c> parâmetro no qual armazenar os dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento. Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</param>
        <summary>Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, o método é invocado pelo `callback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.  
  
 Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir começa assincronamente receba dados de um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">
          O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">O local na <c>buffer</c> para armazenar os dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="flags">To be added.</param>
        <param name="error">To be added.</param>
        <param name="callback">Um delegado <see cref="T:System.AsyncCallback" /> que faz referência ao método a ser invocado quando a operação é concluída.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações sobre a operação de recebimento. Esse objeto é passado para o delegado <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> quando a operação é concluída.</param>
        <summary>Começa a receber de maneira assíncrona dados de um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O assíncrona <xref:System.Net.Sockets.Socket.BeginReceive%2A> operação deve ser concluída chamando o <xref:System.Net.Sockets.Socket.EndReceive%2A> método. Normalmente, o método é invocado pelo `callback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até que a operação for concluída, use um do <xref:System.Net.Sockets.Socket.Receive%2A> sobrecargas do método.  
  
 Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">
          O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">A posição de base zero no <c>buffer</c> parâmetro no qual armazenar os dados.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Começa a receber dados de um dispositivo de rede especificado de maneira assíncrona.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método inicia de forma assíncrona lendo datagramas sem conexão de um host remoto. Chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método lhe oferece a capacidade de receber dados dentro de um thread de execução separado.  
  
 Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e ela bloqueará <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> até que o <xref:System.Net.Sockets.Socket> lê os dados ou gera uma exceção. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método, ou <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Esse método lê os dados para o `buffer` parâmetro e capturas de ponto de extremidade do qual os dados são enviados de host remoto. Para obter informações sobre como recuperar esse ponto de extremidade, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Esse método é mais útil se você pretende assincronamente receber datagramas sem conexão de um host desconhecido ou vários hosts. Nesses casos, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local. Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido. Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método com um buffer grande o suficiente.  
  
 Para garantir que o ponto de extremidade do host remoto é sempre retornado, um aplicativo deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método e em seguida, chame o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método com o `optionLevel` parâmetro definido como <xref:System.Net.Sockets.SocketOptionLevel.IP> ou <xref:System.Net.Sockets.SocketOptionLevel.IPv6> conforme apropriado, o `optionName` parâmetro definido como <xref:System.Net.Sockets.SocketOptionName.PacketInformation>e o `optionValue` parâmetro para habilitar essa opção antes de chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Caso contrário, é possível que o ponto de extremidade do host remoto para não ser retornado quando o remetente enviou um número de datagramas antes que o destinatário tem o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.  
  
 Embora <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também. Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> método ou aceitar uma solicitação de conexão de entrada ao chamar o <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. Se você chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método antes de estabelecer ou aceitar uma conexão, você obterá um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Em ambos os casos, o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.  
  
 Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> lerá a quantidade de dados está disponível até o número de bytes especificado pelo `size` parâmetro.  
  
 Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir recebe de maneira assíncrona datagramas sem conexão de um host remoto.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">A posição de base zero no <c>buffer</c> parâmetro no qual armazenar os dados.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Um <see cref="T:System.Net.EndPoint" /> que representa a fonte de dados.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Inicia o recebimento de forma assíncrona do número especificado de bytes de dados no local especificado do buffer de dados, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena as informações de ponto de extremidade e de pacote.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência à leitura assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Operação de recebimento assíncronos devem ser concluídas por chamar o <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> método. Normalmente, o método é invocado pelo `asyncCallback` delegate.  
  
 Esse método não bloqueia até que a operação seja concluída. Para bloquear até a conclusão da operação, use o <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.  
  
 Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
 Para obter informações detalhadas sobre como usar o modelo de programação assíncrono, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Esse método lê os dados para o `buffer` parâmetro e capturas de ponto de extremidade do qual os dados são enviados de host remoto, bem como informações sobre o pacote recebido. Para obter informações sobre como recuperar esse ponto de extremidade, consulte <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Esse método é mais útil se você pretende assincronamente receber datagramas sem conexão de um host desconhecido ou vários hosts.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A>lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.  
  
 Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão. Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> está vazio.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A>lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.  
  
 Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Chame o método de conjunto em um <xref:System.Threading.ManualResetEvent> no método de retorno de chamada quando o thread original para continuar a executar. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão. Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> está vazio.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="offset">A posição de base zero no <c>buffer</c> parâmetro no qual começar a enviar dados.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socket_flags">To be added.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A>lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.  
  
 Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão. Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir começa assincronamente enviar dados para um host remoto.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é menor que o tamanho de <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="offset">A posição de base zero no <c>buffer</c> parâmetro no qual começar a enviar dados.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Envia dados de forma assíncrona para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.BeginSend%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método. <xref:System.Net.Sockets.Socket.BeginSend%2A>lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.  
  
 Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSend%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSend%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSend%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSend%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão. Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. É okey usar <xref:System.Net.Sockets.Socket.BeginSendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Com protocolos sem conexão, você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.BeginSend%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  `state`é uma instanciação de uma classe definida pelo usuário.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é menor que o tamanho de <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Uma cadeia de caracteres que contém o caminho e o nome do arquivo a ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Envia o arquivo <paramref name="fileName" /> para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado usando o sinalizador <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <returns>Um objeto <see cref="T:System.IAsyncResult" /> que representa o envio assíncrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga envia o arquivo `fileName` para o soquete conectado. Se `fileName` está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados. Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados. Se o arquivo não for encontrado, a exceção <xref:System.IO.FileNotFoundException> é lançada.  
  
 Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2. Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.  
  
 O <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos. <xref:System.Net.Sockets.Socket.BeginSendFile%2A>gera uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Chamar o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método permite que você envie um arquivo em um thread de execução separado.  
  
 Para concluir a operação, você pode criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegar o parâmetro. Para fazer isso, no mínimo, o `state` parâmetro deve conter o <xref:System.Net.Sockets.Socket> do objeto que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância do objeto personalizado para o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSendFile%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndSendFile%2A> até que o <xref:System.Net.Sockets.Socket> envia todo o arquivo ou gera uma exceção. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão. Com protocolos sem conexão, você deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lança um <xref:System.Net.Sockets.SocketException> exceção.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona. Primeiro, o arquivo "Test.txt" é enviado de forma assíncrona ao host remoto. O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndSendFile%2A> para concluir a transmissão.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">O soquete não está conectado a um host remoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo <paramref name="fileName" /> não foi encontrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Uma cadeia de caracteres que contém o caminho e o nome do arquivo a ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="preBuffer">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados antes de o arquivo ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="postBuffer">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados depois de o arquivo ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="flags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <param name="callback">Um delegado <see cref="T:System.AsyncCallback" /> a ser invocado quando a operação for concluída. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="state">Um objeto definido pelo usuário que contém informações de estado para essa solicitação. Esse parâmetro pode ser <see langword="null" />.</param>
        <summary>Envia um arquivo e buffers de dados de forma assíncrona para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Um objeto <see cref="T:System.IAsyncResult" /> que representa a operação assíncrona.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga requer o nome do arquivo que deseja enviar e uma combinação bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores. O `preBuffer` parâmetro contiver dados deve preceder o arquivo. `postBuffer`contém dados que você deseja que execute o arquivo. Se `fileName` está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados. Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados. Se o arquivo não for encontrado, a exceção <xref:System.IO.FileNotFoundException> é lançada.  
  
 O `flags` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos. Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2. Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.  
  
 O <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> métodos. <xref:System.Net.Sockets.Socket.BeginSendFile%2A>gera uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Chamar o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método lhe oferece a capacidade de enviar um arquivo em um thread de execução separado.  
  
 Para concluir a operação, você pode criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegar o parâmetro. Para fazer isso, no mínimo, o `state` parâmetro deve conter o <xref:System.Net.Sockets.Socket> do objeto que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma classe ou estrutura para manter o <xref:System.Net.Sockets.Socket> e outras informações necessárias. Passar uma instância do objeto personalizado para o <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSendFile%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, o sistema usa um thread separado para executar o método de retorno de chamada especificada e blocos em <xref:System.Net.Sockets.Socket.EndSendFile%2A> até que o <xref:System.Net.Sockets.Socket> envia todo o arquivo ou gera uma exceção. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Embora destinado protocolos orientados a conexão, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método para estabelecer um host remoto padrão. Com protocolos sem conexão, você também deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.BeginSendFile%2A> lança um <xref:System.Net.Sockets.SocketException> exceção.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona e começa a enviar o arquivo "Test.txt" assincronamente para o host remoto. Neste exemplo, um `preBuffer` e um `postBuffer` de dados é criado para enviar o arquivo e o padrão <xref:System.Net.Sockets.TransmitFileOptions> valor é usado. O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndSendFile%2A> para concluir a transmissão.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
        <exception cref="T:System.NotSupportedException">O sistema operacional não é o Windows NT ou posterior.  
  
 \- ou -  
  
 O soquete não está conectado a um host remoto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo <paramref name="fileName" /> não foi encontrado.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="offset">A posição de base zero em <c>buffer</c> no qual começar a enviar dados.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socket_flags">To be added.</param>
        <param name="remote_end">To be added.</param>
        <param name="callback">O delegado <see cref="T:System.AsyncCallback" />.</param>
        <param name="state">Um objeto que contém informações de estado para essa solicitação.</param>
        <summary>Envia dados de maneira assíncrona para um host remoto específico.</summary>
        <returns>Um <see cref="T:System.IAsyncResult" /> que faz referência ao envio assíncrono.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método inicia uma operação de envio assíncrono para o host remoto especificado no `remoteEP` parâmetro. Chamar o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado. Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> funciona com protocolos sem conexão e orientada a conexão.  
  
 Você pode criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegar e passar o nome para o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método. Para fazer isso, no mínimo, o `state` parâmetro deve conter conectado ou padrão <xref:System.Net.Sockets.Socket> que está sendo usada para comunicação. Se o retorno de chamada precisa de mais informações, você pode criar uma pequena classe para manter o <xref:System.Net.Sockets.Socket>e as outras informações necessárias. Passar uma instância dessa classe para o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método por meio de `state` parâmetro.  
  
 O método de retorno de chamada deve chamar o <xref:System.Net.Sockets.Socket.EndSendTo%2A> método. Quando o aplicativo chama <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, o sistema usará um thread separado para executar o método de retorno de chamada especificada e bloqueará <xref:System.Net.Sockets.Socket.EndSendTo%2A> até que o <xref:System.Net.Sockets.Socket> envia o número de bytes solicitado ou gera uma exceção. Se você quiser que o thread original para bloquear depois de chamar o <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método, use o <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método. Chame o método de conjunto em um t: System.Threading.ManualResetEvent no método de retorno de chamada quando o thread original para continuar a executar. Para obter informações adicionais sobre métodos de retorno de chamada de gravação, consulte [Marshaling de um delegado como um método de retorno de chamada](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Se você estiver usando um protocolo orientado a conexão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método, ou <xref:System.Net.Sockets.Socket.BeginSendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A>ignorará a `remoteEP` parâmetro e enviar dados para o <xref:System.Net.EndPoint> estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.  
  
 Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>. Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> método. Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.BeginConnect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação. Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método. Nesse caso, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado. Use um número de porta de zero se quiser que o provedor de serviço subjacente para selecionar uma porta livre. Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.EndSendTo%2A> concluído com êxito.  
  
 Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. -Você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.EndSendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O contexto de execução (o contexto de segurança, o usuário representado e o contexto de chamada) é armazenado em cache para o assíncrona <xref:System.Net.Sockets.Socket> métodos. Após o primeiro uso de um contexto específico (um determinado assíncrono <xref:System.Net.Sockets.Socket> método, uma determinada <xref:System.Net.Sockets.Socket> instância e um retorno de chamada específico), usos subsequentes de contexto verá uma melhoria de desempenho.  
  
   
  
## Examples  
 O exemplo de código a seguir assincronamente envia dados para o host remoto especificado.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">O local <see cref="T:System.Net.EndPoint" /> para associar ao <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Associa um <see cref="T:System.Net.Sockets.Socket" /> a um ponto de extremidade local.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Net.Sockets.Socket.Bind%2A> método se você precisa usar um ponto de extremidade local específico. Você deve chamar <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar o <xref:System.Net.Sockets.Socket.Listen%2A> método. Você não precisa chamar <xref:System.Net.Sockets.Socket.Bind%2A> antes de usar o <xref:System.Net.Sockets.Socket.Connect%2A> método, a menos que você precisa usar um ponto de extremidade local específico. Você pode usar o <xref:System.Net.Sockets.Socket.Bind%2A> método nos protocolos sem conexão e orientada a conexão.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.Bind%2A>, você deve primeiro criar o local <xref:System.Net.IPEndPoint> do qual você pretende comunicação de dados. Se você não fizer a qual o endereço local é atribuído, você pode criar um <xref:System.Net.IPEndPoint> usando <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> como o parâmetro de endereço e o serviço subjacente provedor atribuirá o endereço de rede mais apropriado. Isso pode ajudar a simplificar seu aplicativo, se você tiver várias interfaces de rede. Se você não fizer a porta local é usada, você pode criar um <xref:System.Net.IPEndPoint> usar 0 como o número da porta. Nesse caso, o provedor de serviços atribuirá um número de porta entre 1024 e 5000.  
  
 Se você usar a abordagem acima, você pode descobrir o número de porta e endereço de rede local foi atribuído ao chamar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> não retornará o endereço de rede atribuído localmente até depois que você fez uma chamada para o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.EndConnect%2A> método. Se você estiver usando um protocolo sem-conexão, você não terá acesso a essas informações até que você concluiu um envio ou recebimento.  
  
 Se um soquete UDP deseja receber informações de interface em pacotes recebidos, o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método deve ser chamado explicitamente com a opção de soquete definida como <xref:System.Net.Sockets.SocketOptionName.PacketInformation> imediatamente depois de chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método.  
  
> [!NOTE]
>  Se você pretende receber datagramas multicast, você deve chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método com um número de porta de multicast.  
  
> [!NOTE]
>  Você deve chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método se desejar receber datagramas sem conexão usando o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O código a seguir exemplo associa um <xref:System.Net.Sockets.Socket> usando o ponto de extremidade local especificado.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de host definidos por <paramref name="localEP" />. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o <see cref="T:System.Net.Sockets.Socket" /> está no modo de bloqueio.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> for bloqueado; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade indica se um <xref:System.Net.Sockets.Socket> está no modo de bloqueio.  
  
 Se você estiver no modo de bloqueio, e você faz com que um método de chamada que não for concluída imediatamente, seu aplicativo bloqueará a execução até que a operação solicitada seja concluída. Se você deseja que a execução continuar mesmo que a operação solicitada não foi concluída, altere o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false`. O <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade não tem efeito sobre os métodos assíncronos. Se você for enviar e receber dados de forma assíncrona e para bloquear a execução, use o <xref:System.Threading.ManualResetEvent> classe.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> usado para solicitar a conexão com o host remoto chamando um dos métodos <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />.</param>
        <summary>Cancela uma solicitação assíncrona de uma conexão de host remoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> método cancela uma solicitação assíncrona para uma conexão do host remoto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="e" /> e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não podem ser nulos.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha a conexão <see cref="T:System.Net.Sockets.Socket" /> e libera todos os recursos associados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Close%2A> método fecha a conexão do host remoto e versões de todos os recursos gerenciados e associados a <xref:System.Net.Sockets.Socket>. No fechamento, a <xref:System.Net.Sockets.Socket.Connected%2A> está definida como `false`.  
  
 Para protocolos orientados a conexão, é recomendável que você chamar <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de chamar o <xref:System.Net.Sockets.Socket.Close%2A> método. Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.  
  
 Se você precisar chamar <xref:System.Net.Sockets.Socket.Close%2A> sem primeiro chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, você pode garantir que dados na fila de transmissão de saída será enviada, definindo o <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opção para `false` e especificando um intervalo de tempo-limite diferente de zero. <xref:System.Net.Sockets.Socket.Close%2A>em seguida, bloqueia até que esses dados são enviados ou expira o tempo limite especificado. Se você definir <xref:System.Net.Sockets.SocketOptionName.DontLinger> para `false` e especificar um zero intervalo de tempo limite, <xref:System.Net.Sockets.Socket.Close%2A> libera a conexão e descarta automaticamente os dados na fila de saída.  
  
> [!NOTE]
>  Para definir o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para `false`, criar um <xref:System.Net.Sockets.LingerOption>, defina a propriedade enabled como `true`e defina o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade para o período de tempo limite desejado. Use este <xref:System.Net.Sockets.LingerOption> juntamente com o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O código a seguir exemplo fecha um <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Aguarde até <c>tempo limite</c> segundos para enviar todos os dados restantes, em seguida, fechar o soquete.</param>
        <summary>Fecha a conexão de <see cref="T:System.Net.Sockets.Socket" /> e libera todos os recursos associados com um tempo limite especificado para permitir que os dados em fila sejam enviados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Close%2A> método fecha a conexão do host remoto e versões de todos os recursos gerenciados e associados a <xref:System.Net.Sockets.Socket>. No fechamento, a <xref:System.Net.Sockets.Socket.Connected%2A> está definida como `false`.  
  
 Para protocolos orientados a conexão, é recomendável que você chamar <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de chamar <xref:System.Net.Sockets.Socket.Close%2A>. Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.  
  
 Se você precisar chamar <xref:System.Net.Sockets.Socket.Close%2A> sem primeiro chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, você pode garantir que dados na fila de transmissão de saída será enviada, definindo o <xref:System.Net.Sockets.SocketOptionName.DontLinger> opção para `false` e especificando um intervalo de tempo-limite diferente de zero. <xref:System.Net.Sockets.Socket.Close%2A>em seguida, bloqueia até que esses dados são enviados ou expira o tempo limite especificado. Se você definir <xref:System.Net.Sockets.SocketOptionName.DontLinger> para `false` e especificar um zero intervalo de tempo limite, <xref:System.Net.Sockets.Socket.Close%2A> libera a conexão e descarta automaticamente os dados na fila de saída.  
  
> [!NOTE]
>  Para definir o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para `false`, criar um <xref:System.Net.Sockets.LingerOption>, defina a propriedade enabled como `true`e defina o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade para o período de tempo limite desejado. Use este <xref:System.Net.Sockets.LingerOption> juntamente com o <xref:System.Net.Sockets.SocketOptionName.DontLinger> soquete opção para chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como fechar uma <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Um <see cref="T:System.Net.EndPoint" /> que representa o dispositivo remoto.</param>
        <summary>Estabelece uma conexão com o host remoto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o ponto de extremidade remoto especificado. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão. Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto. Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas. Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
 O <xref:System.Net.Sockets.Socket.Connect%2A> método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>. Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão. Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão. Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro. Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito. Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.  
  
> [!NOTE]
>  Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local. Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento. Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.  
  
> [!NOTE]
>  Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão. Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar. Essa é uma limitação do provedor subjacente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
        <permission cref="T:System.Net.SocketPermission">para conectar-se ao host remoto. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">O endereço IP do host remoto.</param>
        <param name="port">O número da porta do host remoto.</param>
        <summary>Estabelece uma conexão com o host remoto. O host é especificado por um endereço IP e um número da porta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o ponto de extremidade remoto especificado. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão. Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A> você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto. Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas. Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>. Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão. Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão. Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro. Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito. Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.  
  
> [!NOTE]
>  Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local. Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento. Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.  
  
> [!NOTE]
>  Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão. Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar. Essa é uma limitação do provedor subjacente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="address" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número da porta é inválido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="address" /> é zero.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Os endereços IP do host remoto.</param>
        <param name="port">O número da porta do host remoto.</param>
        <summary>Estabelece uma conexão com o host remoto. O host é especificado por uma matriz de endereços IP e um número da porta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é geralmente usado imediatamente após uma chamada para <xref:System.Net.Dns.GetHostAddresses%2A>, que pode retornar vários endereços IP para um único host. Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o ponto de extremidade remoto especificado. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão. Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A> você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto. Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas. Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>. Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão. Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão. Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro. Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito. Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.  
  
> [!NOTE]
>  Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local. Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento. Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.  
  
> [!NOTE]
>  Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão. Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar. Essa é uma limitação do provedor subjacente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="addresses" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número da porta é inválido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="address" /> é zero.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">O nome do host remoto.</param>
        <param name="port">O número da porta do host remoto.</param>
        <summary>Estabelece uma conexão com o host remoto. O host é especificado por um nome do host e um número da porta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão como TCP, o <xref:System.Net.Sockets.Socket.Connect%2A> método sincronicamente estabelece uma conexão de rede entre <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> e o host remoto especificado. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.Connect%2A> estabelece um host remoto padrão. Depois de chamar <xref:System.Net.Sockets.Socket.Connect%2A> você pode enviar dados para o dispositivo remoto com o <xref:System.Net.Sockets.Socket.Send%2A> método, ou receber dados do dispositivo remoto com o <xref:System.Net.Sockets.Socket.Receive%2A> método.  
  
 Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de enviar e receber dados. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> e <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> para se comunicar de forma síncrona com um host remoto. Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> datagramas que chegam de um endereço diferente do padrão especificado serão descartadas. Se você quiser definir seu host remoto padrão para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>, ou <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A>método será bloqueada, a menos que você defina especificamente o <xref:System.Net.Sockets.Socket.Blocking%2A> propriedade `false` antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>. Se você estiver usando um protocolo orientado a conexão como TCP e você desativar o bloqueio, <xref:System.Net.Sockets.Socket.Connect%2A> lançará um <xref:System.Net.Sockets.SocketException> porque ele precisa de tempo para fazer a conexão. Sem conexão protocolos não lançará uma exceção porque eles simplesmente estabelecer um host remoto padrão. Você pode usar <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro. Se o erro retornado WSAEWOULDBLOCK, a conexão do host remoto foi iniciada por uma conexão orientada <xref:System.Net.Sockets.Socket>, mas ainda não foi concluído com êxito. Use o <xref:System.Net.Sockets.Socket.Poll%2A> método para determinar quando o <xref:System.Net.Sockets.Socket> for concluído se conectar.  
  
 Se o IPv6 estiver habilitado e o <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> método é chamado para se conectar a um host que resolve para ambos IPv6 e endereços IPv4, a conexão do IPv6 endereço será tentada primeiro antes do endereço IPv4. Isso pode ter o efeito do atraso de tempo para estabelecer a conexão, se o host não está escutando no endereço IPv6.  
  
> [!NOTE]
>  Se você estiver usando um protocolo orientado a conexão e não chamou <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.Connect%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local. Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço de rede local até você concluir um envio ou operação de recebimento. Se você quiser alterar o host remoto padrão, chame <xref:System.Net.Sockets.Socket.Connect%2A> novamente com o ponto de extremidade desejado.  
  
> [!NOTE]
>  Se o soquete foi desconectado anteriormente, você não pode usar esse método para restaurar a conexão. Use um dos assíncrona <xref:System.Net.Sockets.Socket.BeginConnect%2A> métodos para se reconectar. Essa é uma limitação do provedor subjacente.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a um ponto de extremidade remoto e, em seguida, verifica a conexão.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="host" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número da porta é inválido.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">Este método é válido para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> foi colocado em um estado de escuta chamando <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Inicia uma solicitação assíncrona para uma conexão com um host remoto.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método inicia uma solicitação assíncrona para uma conexão com o host remoto. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> estabelece um host remoto padrão.  
  
 Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto para se conectar ao.  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar e receber dados. Você pode usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para se comunicar com um host remoto. Se você chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas. Se você quiser alterar o host remoto padrão, chame o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método novamente com o ponto de extremidade desejado.  
  
 Se você deseja definir o host remoto padrão para um endereço de difusão, você deve primeiro chamar <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e defina a transmissão para `true`. Se isso não for feito, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lançará um <xref:System.Net.Sockets.SocketException>.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcionalmente, um buffer pode ser fornecido que será enviado atomicamente no soquete após o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método for bem-sucedido. Nesse caso, o <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriedade deve ser definida para o buffer que contém os dados para enviar e <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade precisa ser definido como o número de bytes de dados para enviar do buffer. Quando uma conexão é estabelecida, esse buffer de dados é enviada.  
  
 Se você estiver usando um protocolo orientado a conexão e não chame <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.  
  
 Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço IP do local de rede até que você chame o <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.  
  
 O <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lança <xref:System.NotSupportedException> se a família de endereços do <xref:System.Net.Sockets.Socket> e <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> não são da mesma família de endereço.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar esse método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um argumento não é válido. Essa exceção ocorrerá se vários buffers forem especificados e a propriedade <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> não for nula.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="e" /> e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não podem ser nulos.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> está escutando ou uma operação de soquete já estava em andamento usando o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método. Essa exceção também ocorrerá se o ponto de extremidade local e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não forem da mesma família de endereços.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</param>
        <param name="protocolType">Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</param>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Inicia uma solicitação assíncrona para uma conexão com um host remoto.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão, o método M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) inicia uma solicitação assíncrona para uma conexão com o host remoto. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> estabelece um host remoto padrão especificado pelo `socketType` e `protocolType` parâmetros.  
  
 Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto para se conectar ao.  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Se você estiver usando um protocolo sem-conexão como UDP, você não precisa chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A> antes de enviar e receber dados. Você pode usar <xref:System.Net.Sockets.Socket.SendToAsync%2A> e <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> para se comunicar com um host remoto. Se você chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, datagramas que chegam de um endereço diferente do padrão especificado serão descartadas. Se você quiser alterar o host remoto padrão, chame o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método novamente com o ponto de extremidade desejado.  
  
 Se você deseja definir o host remoto padrão para um endereço de difusão, você deve primeiro chamar <xref:System.Net.Sockets.Socket.SetSocketOption%2A> e defina a transmissão para `true`. Se isso não for feito, o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lançará um <xref:System.Net.Sockets.SocketException>.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Opcionalmente, um buffer pode ser fornecido que será enviado atomicamente no soquete após o <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método for bem-sucedido. Nesse caso, o <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> propriedade deve ser definida para o buffer que contém os dados para enviar e <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> propriedade precisa ser definido como o número de bytes de dados para enviar do buffer. Quando uma conexão é estabelecida, esse buffer de dados é enviada.  
  
 Se você estiver usando um protocolo orientado a conexão e não chame <xref:System.Net.Sockets.Socket.Bind%2A> antes de chamar <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado.  
  
 Se você estiver usando um protocolo sem conexão, o provedor de serviços não atribuirá um número de porta e endereço IP do local de rede até que você chame o <xref:System.Net.Sockets.Socket.SendAsync%2A> ou <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> métodos.  
  
 O <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método lança <xref:System.NotSupportedException> se a família de endereços do <xref:System.Net.Sockets.Socket> e <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> não são da mesma família de endereço.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar esse método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um argumento não é válido. Essa exceção ocorrerá se vários buffers forem especificados e a propriedade <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> não for nula.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="e" /> e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não podem ser nulos.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Net.Sockets.Socket" /> está escutando ou uma operação de soquete já estava em andamento usando o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método. Essa exceção também ocorrerá se o ponto de extremidade local e o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não forem da mesma família de endereços.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador mais alto na pilha de chamadas não tem permissão para a operação solicitada.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se um <see cref="T:System.Net.Sockets.Socket" /> está conectado a um host remoto desde a última operação <see cref="Overload:System.Net.Sockets.Socket.Send" /> ou <see cref="Overload:System.Net.Sockets.Socket.Receive" />.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> tiver sido conectado a um recurso remoto desde a operação mais recente; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Connected` propriedade obtém o estado de conexão do <xref:System.Net.Sockets.Socket> desde a última operação de e/s. Quando ele retorna `false`, o <xref:System.Net.Sockets.Socket> nunca foi conectado ou não está mais conectado.  
  
 O valor de <xref:System.Net.Sockets.Socket.Connected%2A> propriedade reflete o estado da conexão a partir da operação mais recente. Se você precisar determinar o estado atual da conexão, fazer com que um envio sem bloqueio, zero bytes chamada. Se a chamada retorna com êxito ou gera um código de erro WAEWOULDBLOCK (10035), o soquete ainda está conectado; Caso contrário, o soquete não está mais conectado.  
  
 Se você chamar <xref:System.Net.Sockets.Socket.Connect%2A> em um soquete do protocolo UDP (User Datagram), o <xref:System.Net.Sockets.Socket.Connected%2A> propriedade sempre retorna `true`; no entanto, essa ação não altera a natureza sem-conexão inerente de UDP.  
  
   
  
## Examples  
 O exemplo de código a seguir se conecta a um ponto de extremidade remoto, as verificações de <xref:System.Net.Sockets.Socket.Connected%2A> propriedade e verifica o estado atual da conexão.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket">
          <see langword="true" /> se o soquete puder ser reutilizado após a conexão atual ser fechada; caso contrário, <see langword="false" />.</param>
        <summary>Fecha a conexão de soquete e permite a reutilização do soquete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão, você pode usar esse método para fechar o soquete. Este termina de método de conexão e os conjuntos de <xref:System.Net.Sockets.Socket.Connected%2A> propriedade para `false`. No entanto, se `reuseSocket` é `true`, você pode reutilizar o soquete.  
  
 Para garantir que todos os dados são enviadas e recebidas antes do fechamento de soquete, você deve chamar <xref:System.Net.Sockets.Socket.Shutdown%2A> antes de chamar o <xref:System.Net.Sockets.Socket.Disconnect%2A> método.  
  
 Se você precisar chamar <xref:System.Net.Sockets.Socket.Disconnect%2A> sem primeiro chamar <xref:System.Net.Sockets.Socket.Shutdown%2A>, você pode definir o <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> opção para `false` e especificar um intervalo de tempo limite diferente de zero para garantir que dados na fila de transmissão de saída é enviada. <xref:System.Net.Sockets.Socket.Disconnect%2A>em seguida, bloqueia até que os dados são enviados ou expira o tempo limite especificado. Se você definir <xref:System.Net.Sockets.SocketOptionName.DontLinger> para `false` e especificar um zero intervalo de tempo limite, <xref:System.Net.Sockets.Socket.Close%2A> libera a conexão e descarta automaticamente os dados na fila de saída.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um soquete para comunicação síncrona e envia alguns dados para um host remoto. Depois, ele chama <xref:System.Net.Sockets.Socket.Shutdown%2A>, para parar o envio e recebimento de atividade, e <xref:System.Net.Sockets.Socket.Disconnect%2A>para fechar a conexão de soquete.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Esse método requer o Windows 2000 ou anterior, ou a exceção será gerada.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Inicia uma solicitação assíncrona para se desconectar de um ponto de extremidade remoto.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao usar um protocolo orientado a conexão, chamar o <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> método solicita uma desconexão de um ponto de extremidade remoto. Se você definir <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> para `true` no `e` parâmetro, o soquete pode ser reutilizado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="e" /> não pode ser nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar `Dispose` quando tiver terminado de usar o <xref:System.Net.Sockets.Socket>. O `Dispose` método deixa o <xref:System.Net.Sockets.Socket> em um estado inutilizável. Depois de chamar `Dispose`, você deve liberar todas as referências para o <xref:System.Net.Sockets.Socket> para o coletor de lixo possa recuperar a memória que o <xref:System.Net.Sockets.Socket> estava ocupando.  
  
 Para obter mais informações, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Sempre chamar `Dispose` antes de liberar sua última referência para o <xref:System.Net.Sockets.Socket>. Caso contrário, os recursos que está usando não serão liberados até que o coletor de lixo chame o <xref:System.Net.Sockets.Socket> do objeto `Finalize` método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Net.Sockets.Socket" /> e, opcionalmente, descarta os recursos gerenciados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é chamado pelo método público `Dispose()` e pelo método <xref:System.Object.Finalize%2A>. `Dispose()` invoca o método `Dispose(Boolean)` protegido com o parâmetro `disposing` definido como `true`. <xref:System.Object.Finalize%2A> invoca `Dispose` com `disposing` definido como `false`.  
  
 Quando o `disposing` parâmetro é `true`, esse método libera todos os recursos mantidos por qualquer objeto gerenciado que este <xref:System.Net.Sockets.Socket> referências. Este método invoca o método `Dispose()` de cada objeto referenciado.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see langword="Dispose" /> pode ser chamado várias vezes por outros objetos. Ao substituir <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, tome cuidado para não referenciar objetos que tenham sido descartados anteriormente em uma chamada anterior para <see langword="Dispose" />. Para obter mais informações sobre como implementar <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, consulte [implementar um método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Para obter mais informações sobre <see langword="Dispose" /> e <see cref="M:System.Object.Finalize" />, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md) e [substituindo o método Finalize](http://msdn.microsoft.com/en-us/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> permite que datagramas de protocolo IP sejam fragmentados.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> permite a fragmentação de datagramas; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramas requerem fragmentação quando seu tamanho excede a transferência de unidade máxima (MTU) da mídia de transmissão. Datagramas podem ser fragmentadas, o host de envio (todas as versões de protocolo de Internet) ou um roteador intermediário (protocolo IP versão 4 somente). Se um datagrama deve ser fragmentado e o <xref:System.Net.Sockets.Socket.DontFragment%2A> opção for definida, o datagrama é descartado e uma mensagem de erro de protocolo de mensagem de controle da Internet (ICMP) é enviada para o remetente do datagrama.  
  
 A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.DontFragment%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Essa propriedade pode ser definida apenas para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor de <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> é um soquete de modo duplo, usado para IPv4 e IPv6.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> for um soquete de modo duplo; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">A ID do processo de destino em que uma duplicata da referência de soquete é criada.</param>
        <summary>Duplica a referência de soquete para o processo de destino e fecha o soquete para esse processo.</summary>
        <returns>A referência de soquete a ser passada para o processo de destino.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processo de destino deve usar <xref:System.Net.Sockets.Socket.%23ctor%2A> para criar a instância de soquete duplicada.  
  
 Se você chamar o <xref:System.Net.Sockets.Socket.%23ctor%2A> construtor várias vezes com a mesma matriz de bytes como o argumento para cada chamada, você criará vários gerenciado <xref:System.Net.Sockets.Socket> instâncias com o mesmo soquete subjacente. Essa prática é altamente desaconselhável.  
  
 Se o processo de criar o soquete usa métodos assíncronos (<xref:System.Net.Sockets.Socket.BeginReceive%2A> ou <xref:System.Net.Sockets.Socket.BeginSend%2A>), o processo deve primeiro definir a <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> propriedade como true; caso contrário, o soquete está associado à porta de conclusão do processo de criação, que pode causar um <xref:System.ArgumentNullException> seja gerada no processo de destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="targetProcessID" /> não é uma ID de processo válida.  
  
 - ou -  
  
 Falha na duplicação de referência do soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> pode enviar ou receber pacotes de difusão.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> permitir pacotes de difusão; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Difusão é limitada a uma sub-rede específica e deve usar o protocolo de datagrama de usuário (UDP). Protocolo IP versão 4, você pode transmitir a sua sub-rede local, enviando um pacote para 255.255.255.255; ou você pode usar o endereço de difusão direcionado, o que é a parte da rede de um endereço IP (Internet Protocol) com todos os bits definidos na parte do host. Por exemplo, se seu endereço IP é 192.168.1.40 (um endereço de classe C, com uma máscara de rede de 255.255.255.0 – a parte de rede tem os três primeiros octetos e a parte do host é o último octeto), seu endereço de difusão direcionado é 192.168.1.255.  
  
 A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Essa opção é válida apenas para um soquete de datagrama.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</summary>
        <returns>Um <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Antes de chamar <xref:System.Net.Sockets.Socket.BeginAccept%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <xref:System.Net.Sockets.Socket.BeginAccept%2A> método retorna. Ele deve aceitar o `asyncResult` parâmetro retornado do <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o `asyncResult` parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método concluído com êxito a tentativa de conexão.  
  
 O <xref:System.Net.Sockets.Socket.EndAccept%2A> método bloqueia até que uma conexão está pendente na fila de conexão de entrada. O <xref:System.Net.Sockets.Socket.EndAccept%2A> método aceita a conexão de entrada e retorna um novo <xref:System.Net.Sockets.Socket> que pode ser usado para enviar e receber dados do host remoto.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir encerra uma solicitação assíncrona e cria um novo <xref:System.Net.Sockets.Socket> para aceitar uma solicitação de conexão de entrada. Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte [exemplos de código do soquete](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          O <paramref name="result" /> não foi criado por uma chamada para <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários para obter mais informações.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.InvalidOperationException">
          O método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> foi chamado anteriormente.</exception>
        <exception cref="T:System.NotSupportedException">Windows NT é necessário para esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os bytes transferidos.</param>
        <param name="asyncResult">Um objeto <see cref="T:System.IAsyncResult" /> que armazena as informações de estado dessa operação assíncrona, bem como os dados definidos pelo usuário.</param>
        <summary>Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações de host remoto. Esse método retorna um buffer que contém os dados iniciais transferidos.</summary>
        <returns>Um objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Antes de chamar <xref:System.Net.Sockets.Socket.BeginAccept%2A>, você precisa criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <xref:System.Net.Sockets.Socket.BeginAccept%2A> método retorna.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o `asyncResult` parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método concluído com êxito a tentativa de conexão. O `buffer` parâmetro essa sobrecarga contém os dados que foram recebidos na chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A> e `bytesTransferred` parâmetro contém o número de bytes que foram transferidos na chamada.  
  
 O <xref:System.Net.Sockets.Socket.EndAccept%2A> método bloqueia até que uma conexão está pendente na fila de conexão de entrada. O <xref:System.Net.Sockets.Socket.EndAccept%2A> método aceita a conexão de entrada e retorna um novo <xref:System.Net.Sockets.Socket> que pode ser usado para enviar e receber dados do host remoto.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para criar e conectar-se a um soquete e aceitar inicias 10 bytes de dados. O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndAccept%2A> para encerrar a solicitação assíncrona. O número de bytes transmitidos e os dados são retornados no `buffer` e `bytesTransferred` parâmetros desse método e são exibidos no console.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT é necessário para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> está vazio.</exception>
        <exception cref="T:System.ArgumentException">
          O <paramref name="asyncResult" /> não foi criado por uma chamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> foi chamado anteriormente.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o<see cref="T:System.Net.Sockets.Socket" /></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]&amp;" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os bytes transferidos.</param>
        <param name="bytesTransferred">O número de bytes transferidos.</param>
        <param name="asyncResult">Um objeto <see cref="T:System.IAsyncResult" /> que armazena as informações de estado dessa operação assíncrona, bem como os dados definidos pelo usuário.</param>
        <summary>Aceita de forma assíncrona uma tentativa de conexão de entrada e cria um novo objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações de host remoto. Esse método retorna um buffer que contém os dados iniciais e o número de bytes transferidos.</summary>
        <returns>Um objeto <see cref="T:System.Net.Sockets.Socket" /> para manipular as comunicações com o host remoto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A>conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Antes de chamar <xref:System.Net.Sockets.Socket.BeginAccept%2A>, você precisa criar um método de retorno de chamada é invocado pelo <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após a <xref:System.Net.Sockets.Socket.BeginAccept%2A> método retorna. Ele deve aceitar o `asyncResult` parâmetro retornado do <xref:System.Net.Sockets.Socket.BeginAccept%2A> método.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o `asyncResult` parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndAccept%2A> método concluído com êxito a tentativa de conexão. O `buffer` parâmetro essa sobrecarga contém os dados que foram recebidos na chamada para <xref:System.Net.Sockets.Socket.BeginAccept%2A> e `bytesTransferred` parâmetro contém o número de bytes que foram transferidos na chamada.  
  
 O <xref:System.Net.Sockets.Socket.EndAccept%2A> método bloqueia até que uma conexão está pendente na fila de conexão de entrada. O <xref:System.Net.Sockets.Socket.EndAccept%2A> método aceita a conexão de entrada e retorna um novo <xref:System.Net.Sockets.Socket> que pode ser usado para enviar e receber dados do host remoto.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.BeginAccept%2A> para criar e conectar-se a um soquete e aceitar inicias 10 bytes de dados. O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndAccept%2A> para encerrar a solicitação assíncrona. O número de bytes transmitidos e os dados são retornados no `buffer` e `bytesTransferred` parâmetros desse método e são exibidos no console.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT é necessário para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> está vazio.</exception>
        <exception cref="T:System.ArgumentException">
          O <paramref name="asyncResult" /> não foi criado por uma chamada a <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O método <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> foi chamado anteriormente.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Encerra uma solicitação de conexão assíncrona pendente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A>é um método de bloqueio que conclui a solicitação de conexão do host remoto assíncrono iniciado no <xref:System.Net.Sockets.Socket.BeginConnect%2A> método.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginConnect%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginConnect%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginConnect%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o <xref:System.Net.Sockets.Socket> no qual a tentativa de conexão está sendo feita. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndConnect%2A> método concluído com êxito a tentativa de conexão.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir encerra a tentativa de conexão assíncrona. Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte [exemplos de código do soquete](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> foi chamado anteriormente para a conexão assíncrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Um objeto <see cref="T:System.IAsyncResult" /> que armazena as informações de estado e os dados definidos pelo usuário para esta operação assíncrona.</param>
        <summary>Encerra uma solicitação de desconexão assíncrona pendente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A>conclui uma chamada para <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. O <xref:System.Net.Sockets.Socket.EndDisconnect%2A> método bloqueia até que seja concluída a desconexão. Para obter informações sobre as operações assíncronas, consulte o tópico de visão de geral de programação assíncrona na biblioteca MSDN.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um soquete para comunicação assíncrona e envia alguns dados para um host remoto. Quando os dados foram enviados, <xref:System.Net.Sockets.Socket.Shutdown%2A> é chamado para parar o envio e a atividade de recebimento. Em seguida, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> é chamado para iniciar uma solicitação de desconexão. O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndDisconnect%2A> para encerrar a solicitação assíncrona. Quando a solicitação é concluída, o <xref:System.Net.Sockets.Socket.Connected%2A> propriedade será consultada para testar se o soquete está desconectado.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> foi chamado anteriormente para a conexão assíncrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.Net.WebException">A solicitação de desconexão atingiu o tempo limite.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Encerra uma leitura assíncrona pendente.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.EndReceive%2A> a operação de leitura assíncrona iniciada conclusão do método de <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceive%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceive%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> para obter o objeto de estado passado para o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Extrair o recebimento <xref:System.Net.Sockets.Socket> deste objeto de estado. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndReceive%2A> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.  
  
 O <xref:System.Net.Sockets.Socket.EndReceive%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndReceive%2A> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede. Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método lerá a quantidade de dados está disponível até o número de bytes especificado no `size` parâmetro o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Para obter os dados recebidos, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult>e extraia o buffer contido no objeto de estado resultante.  
  
 Para cancelar um pendente <xref:System.Net.Sockets.Socket.BeginReceive%2A>, chame o <xref:System.Net.Sockets.Socket.Close%2A> método.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir encerra uma leitura assíncrona pendente. Para obter um exemplo completo que demonstra a comunicação assíncrona com soquetes, consulte [exemplos de código do soquete](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> foi chamado anteriormente para a leitura assíncrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Um <see cref="T:System.IAsyncResult" /> que armazena informações de estado e dados definidos pelo usuário para essa operação assíncrona.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <summary>Encerra uma leitura assíncrona pendente.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.EndReceive%2A> a operação de leitura assíncrona iniciada conclusão do método de <xref:System.Net.Sockets.Socket.BeginReceive%2A> método.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceive%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceive%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginReceive%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> para obter o objeto de estado passado para o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Extrair o recebimento <xref:System.Net.Sockets.Socket> deste objeto de estado. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndReceive%2A> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.  
  
 O <xref:System.Net.Sockets.Socket.EndReceive%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndReceive%2A> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede. Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método lerá a quantidade de dados está disponível até o número de bytes especificado no `size` parâmetro o <xref:System.Net.Sockets.Socket.BeginReceive%2A> método. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.EndReceive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Para obter os dados recebidos, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult>e extraia o buffer contido no objeto de estado resultante.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> foi chamado anteriormente para a leitura assíncrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <param name="end_point">To be added.</param>
        <summary>Termina uma leitura assíncrona pendente de um ponto de extremidade específico.</summary>
        <returns>Se tiver êxito, o número de bytes recebidos. Caso contrário, retornará 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> a operação de leitura assíncrona iniciada conclusão do método de <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> para obter o objeto de estado passado para o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Extrair o recebimento <xref:System.Net.Sockets.Socket> deste objeto de estado. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método para concluir a operação de leitura e retornar o número de bytes lidos com êxito.  
  
 O <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> lerá o datagrama enfileiradas primeiro disponível no buffer de entrada de rede. Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método lerá a quantidade de dados está disponível até o número de bytes especificado no `size` parâmetro o <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> método. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes. Para obter os dados recebidos, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> objeto e, em seguida, extrair o buffer contido no objeto de estado resultante. Para identificar o host de origem, extrair o <xref:System.Net.EndPoint> e convertê-lo para um <xref:System.Net.IPEndPoint>. Use o <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para obter o endereço IP e o <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para obter o número da porta.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir encerra uma leitura assíncrona pendente de um determinado <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> foi chamado anteriormente para a leitura assíncrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Um <see cref="T:System.IAsyncResult" /> que armazena informações de estado e dados definidos pelo usuário para essa operação assíncrona.</param>
        <param name="socketFlags">Uma combinação bit a bit do <see cref="T:System.Net.Sockets.SocketFlags" /> valores para o pacote recebido.</param>
        <param name="endPoint">A fonte de <see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">O <see cref="T:System.Net.IPAddress" /> e a interface do pacote recebido.</param>
        <summary>Termina uma leitura assíncrona pendente de um ponto de extremidade específico. Esse método também revela obter mais informações sobre o pacote que <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</summary>
        <returns>Se tiver êxito, o número de bytes recebidos. Caso contrário, retornará 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a operação não foi concluída, esse método bloqueia até que ele faz.  
  
 Para executar esta operação síncrona, use o <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.  
  
 Examine `ipPacketInformation` se você precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />  
  
 -ou-  
  
 <paramref name="endPoint" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> foi chamado anteriormente para a leitura assíncrona.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Encerra um envio assíncrono pendente.</summary>
        <returns>Se for bem-sucedido, o número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />; caso contrário, um erro <see cref="T:System.Net.Sockets.Socket" /> inválido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginSend%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginSend%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.  
  
 Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueada até que o datagrama seja enviado. Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueado até que algumas do buffer foi enviada. Se o valor de retorno de <xref:System.Net.Sockets.Socket.EndSend%2A> indica que o buffer não foi completamente enviadas, chame o <xref:System.Net.Sockets.Socket.BeginSend%2A> método novamente, modificando o buffer para armazenar os dados não enviados.  
  
 Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir encerra um envio assíncrono pendente.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> foi chamado anteriormente para o envio assíncrono.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Um <see cref="T:System.IAsyncResult" /> que armazena as informações de estado dessa operação assíncrona.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <summary>Encerra um envio assíncrono pendente.</summary>
        <returns>Se for bem-sucedido, o número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />; caso contrário, um erro <see cref="T:System.Net.Sockets.Socket" /> inválido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A>conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginSend%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginSend%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginSend%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSend%2A> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.  
  
 Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueada até que o datagrama seja enviado. Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSend%2A> será bloqueado até que algumas do buffer foi enviada. Se o valor de retorno de <xref:System.Net.Sockets.Socket.EndSend%2A> indica que o buffer não foi completamente enviadas, chame o <xref:System.Net.Sockets.Socket.BeginSend%2A> método novamente, modificando o buffer para armazenar os dados não enviados.  
  
 Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSend%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  E/s iniciada por um determinado thread é cancelada quando que sai do thread. Uma operação assíncrona pendente pode falhar se o thread for encerrado antes da conclusão da operação.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> foi chamado anteriormente para o envio assíncrono.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Um <see cref="T:System.IAsyncResult" /> objeto que armazena informações de estado para essa operação assíncrona.</param>
        <summary>Termina um envio assíncrono pendente de um arquivo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A>conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, você deve criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginSendFile%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> objeto retornado pelo <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSendFile%2A> método concluído com êxito a operação de envio.  
  
 Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloqueia até que o datagrama seja enviado. Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bloqueia até que o arquivo inteiro seja enviado. Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSendFile%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria e se conecta a um soquete para comunicação assíncrona e começa a enviar o arquivo "Test.txt" assincronamente para o host remoto. O retorno de chamada delegar chamadas <xref:System.Net.Sockets.Socket.EndSendFile%2A> para concluir a transmissão.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Windows NT é necessário para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="asyncResult" /> está vazio.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="asyncResult" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />foi chamado anteriormente para o assíncrona <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="result">To be added.</param>
        <summary>Termina um envio assíncrono pendente para um local específico.</summary>
        <returns>Se for bem-sucedido, o número de bytes enviados; Caso contrário, inválido <see cref="T:System.Net.Sockets.Socket" /> erro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A>conclui a operação de envio assíncrono iniciada em <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Antes de chamar <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, você precisa criar um método de retorno de chamada que implementa o <xref:System.AsyncCallback> delegate. Esse método de retorno de chamada é executado em um thread separado e é chamado pelo sistema após <xref:System.Net.Sockets.Socket.BeginReceive%2A> retorna. O método de retorno de chamada deve aceitar o <xref:System.IAsyncResult> retornado pelo <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método como um parâmetro.  
  
 Dentro do método de retorno de chamada, chame o <xref:System.IAsyncResult.AsyncState%2A> método o <xref:System.IAsyncResult> parâmetro para obter o envio <xref:System.Net.Sockets.Socket>. Depois de obter o <xref:System.Net.Sockets.Socket>, você pode chamar o <xref:System.Net.Sockets.Socket.EndSendTo%2A> método para concluir a operação de envio e retornar o número de bytes enviados com êxito.  
  
 Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.EndSendTo%2A> será bloqueada até que o datagrama seja enviado. Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.EndSendTo%2A> será bloqueado até que o número solicitado de bytes é enviado. Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.BeginSendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir encerra um envio assíncrono para um local específico.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="result" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="result" /> não foi retornado por uma chamada ao método <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> foi chamado anteriormente para o envio assíncrono.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> permite que um único processo se associe a uma porta.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> permitir que apenas um soquete se associe a uma porta específica; caso contrário, <see langword="false" />. O padrão é <see langword="true" /> para Windows Server 2003 e Windows XP Service Pack 2, e <see langword="false" /> para todas as outras versões.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> é `false`, vários soquetes podem usar o <xref:System.Net.Sockets.Socket.Bind%2A> método para vincular a uma porta específica; no entanto, somente um dos soquetes de pode executar operações em que o tráfego de rede enviado para a porta. Se mais de um soquete tenta usar o <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> método para vincular a uma porta específica, em seguida, um com o endereço IP mais específico manipulará o tráfego de rede enviado a essa porta.  
  
 Se <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> é `true`, o primeiro uso do <xref:System.Net.Sockets.Socket.Bind%2A> método para tentar associar a uma porta específica, independentemente do endereço IP (Internet Protocol), será bem-sucedida; usos subsequentes do <xref:System.Net.Sockets.Socket.Bind%2A> método para tentar associar a porta falharão até que o original associado soquete é destruído.  
  
 Essa propriedade deve ser definida antes de <xref:System.Net.Sockets.Socket.Bind%2A> é chamado; caso contrário, um <xref:System.InvalidOperationException> será lançada.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> foi chamado para este <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera os recursos usados pela classe <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket> classe finalizador chamadas a <xref:System.Net.Sockets.Socket.Close%2A> método para fechar o <xref:System.Net.Sockets.Socket> e liberar recursos associados a <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <summary>Retorna o valor de uma opção <see cref="T:System.Net.Sockets.Socket" /> especificada, representada como um objeto.</summary>
        <returns>Um objeto que representa o valor da opção. Quando o parâmetro <paramref name="optionName" /> for definido como <see cref="F:System.Net.Sockets.SocketOptionName.Linger" />, o valor retornado é uma instância da classe <see cref="T:System.Net.Sockets.LingerOption" />. Quando <paramref name="optionName" /> for definido como <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> ou <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, o valor retornado é uma instância da classe <see cref="T:System.Net.Sockets.MulticastOption" />. Quando <paramref name="optionName" /> for qualquer outro valor, o valor retornado é um inteiro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>. Use essa sobrecarga para obter o <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opções. Para o <xref:System.Net.Sockets.SocketOptionName.Linger> opção, use <xref:System.Net.Sockets.Socket> para o `optionLevel` parâmetro. Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. Se você deseja definir o valor de qualquer uma das opções listadas acima, use o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> método.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte código de exemplo recupera o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite e exibe-as no console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.  
  
 -ou-  
  
 <paramref name="optionName" /> foi definido para o valor sem suporte <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Uma matriz do tipo <see cref="T:System.Byte" /> que está receber a configuração da opção.</param>
        <summary>Retorna a <see cref="T:System.Net.Sockets.Socket" /> opção de configuração, representada como uma matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>. Após a conclusão bem-sucedida desse método, a matriz especificada pelo `optionValue` parâmetro contém o valor especificado <xref:System.Net.Sockets.Socket> opção.  
  
 Quando o comprimento do `optionValue` matriz é menor do que o número de bytes necessários para armazenar o valor especificado <xref:System.Net.Sockets.Socket> opção <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro. Use essa sobrecarga para qualquer soquetes que são representados por valores boolianos ou inteiros.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte código de exemplo recupera o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite e exibe-as no console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.  
  
 \- ou -  
  
 Em aplicativos do .NET Compact Framework, o espaço de buffer do Windows CE padrão é definido como 32768 bytes. Você pode alterar o por espaço de buffer de soquete chamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionLength">O comprimento, em bytes, do valor de retorno esperado.</param>
        <summary>Retorna o valor especificado <see cref="T:System.Net.Sockets.Socket" /> opção em uma matriz.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Byte" /> que contém o valor da opção de soquete.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `optionLength` parâmetro define o tamanho máximo da matriz de bytes retornada. Se o valor da opção requer menos bytes, a matriz conterá apenas que número de bytes. Se o valor da opção requer mais bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> lançará um <xref:System.Net.Sockets.SocketException>. Use essa sobrecarga para qualquer soquetes que são representados por valores boolianos ou inteiros.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte código de exemplo recupera o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite e exibe-as no console.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.  
  
 \- ou -  
  
 Em aplicativos do .NET Compact Framework, o espaço de buffer do Windows CE padrão é definido como 32768 bytes. Você pode alterar o por espaço de buffer de soquete chamando <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de sistema operacional do <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Um <see cref="T:System.IntPtr" /> que representa o identificador de sistema operacional do <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Um valor <see cref="T:System.Int32" /> que especifica o código de controle da operação a ser executado.</param>
        <param name="optionInValue">Uma matriz <see cref="T:System.Byte" /> que contém os dados de entrada necessários para a operação.</param>
        <param name="optionOutValue">Uma matriz <see cref="T:System.Byte" /> que contém os dados de saída retornados para a operação.</param>
        <summary>Define os modos de operação de nível inferior do <see cref="T:System.Net.Sockets.Socket" /> usando códigos de controle numéricos.</summary>
        <returns>O número de bytes no parâmetro <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.IOControl%2A> método fornece acesso de baixo nível para o sistema operacional <xref:System.Net.Sockets.Socket> subjacente a instância atual do <xref:System.Net.Sockets.Socket> classe. Para obter mais informações, consulte a documentação de WSAIoctl na biblioteca MSDN.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir compara os resultados de FIONREAD e a propriedade disponível.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de alterar o modo de bloqueio sem usar a propriedade <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para executar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Um valor <see cref="T:System.Net.Sockets.IOControlCode" /> que especifica o código de controle da operação a ser executada.</param>
        <param name="optionInValue">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados de entrada necessários para a operação.</param>
        <param name="optionOutValue">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados de saída retornados pela operação.</param>
        <summary>Define modos de operação de nível inferior do <see cref="T:System.Net.Sockets.Socket" /> usando a enumeração <see cref="T:System.Net.Sockets.IOControlCode" /> para especificar códigos de controle.</summary>
        <returns>O número de bytes no parâmetro <paramref name="optionOutValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método fornece acesso de baixo nível para o sistema operacional <xref:System.Net.Sockets.Socket> subjacente a instância atual do <xref:System.Net.Sockets.Socket> classe. Para obter mais informações, consulte a documentação de WSAIoctl na biblioteca MSDN.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir compara os resultados da chamada <xref:System.Net.Sockets.Socket.IOControl%2A> com <xref:System.Net.Sockets.IOControlCode.DataToRead> e <xref:System.Net.Sockets.Socket.Available%2A> propriedade.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.InvalidOperationException">Foi feita uma tentativa de alterar o modo de bloqueio sem usar a propriedade <see cref="P:System.Net.Sockets.Socket.Blocking" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para executar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Net.Sockets.Socket" /> está associado a uma porta local específica.</summary>
        <value>
          <see langword="true" /> e o <see cref="T:System.Net.Sockets.Socket" /> for associado a uma porta local; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um soquete é considerado associada a uma porta local se ele está vinculado explicitamente chamando o <xref:System.Net.Sockets.Socket.Bind%2A> método, ou implicitamente associada chamando membros como <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, que usa uma porta efêmera local (uma porta livre maior do que 1024, selecionados pelo sistema operacional.) Os servidores usam o <xref:System.Net.Sockets.Socket.Bind%2A> método para vincular a uma porta conhecida para que os clientes podem se conectar a eles.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.IsBound%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se o <see cref="T:System.Net.Sockets.Socket" /> atrasará ao fechar um soquete em uma tentativa de enviar todos os dados pendentes.</summary>
        <value>Um <see cref="T:System.Net.Sockets.LingerOption" /> que especifica como perdurar ao fechar um soquete.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade altera o modo como <xref:System.Net.Sockets.Socket.Close%2A> método se comporta. Essa propriedade ao conjunto modifica as condições sob as quais a conexão pode ser redefinido com Winsock. Redefinições de Conexão ainda podem ocorrer com base no comportamento de protocolo IP.  
  
 Essa propriedade controla o período de tempo que uma conexão orientado a conexão permanecerá aberta após uma chamada para <xref:System.Net.Sockets.Socket.Close%2A> quando os dados permanecem para serem enviadas.  
  
 Quando você chamar métodos para enviar dados para uma ponto a ponto, esses dados são colocados no buffer de saída de rede. Essa propriedade pode ser usada para garantir que esses dados são enviados ao host remoto antes do <xref:System.Net.Sockets.TcpClient.Close%2A> método descarta a conexão.  
  
 Para habilitar remanescentes, crie um <xref:System.Net.Sockets.LingerOption> instância que contém os valores desejados e defina o <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade para essa instância.  
  
 A tabela a seguir descreve o comportamento do <xref:System.Net.Sockets.Socket.Close%2A> método para os valores possíveis do <xref:System.Net.Sockets.LingerOption.Enabled%2A> propriedade e o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade armazenada no <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade.  
  
|LingerState.Enabled|LingerState.LingerTime|Comportamento|  
|-------------------------|----------------------------|--------------|  
|`false`(desabilitado), o valor padrão|O tempo limite não é aplicável, (padrão).|Tentativas de enviar dados pendentes até expira o tempo limite de protocolo IP padrão.|  
|`true`(habilitado)|Um tempo limite diferente de zero|Tentativas de enviar dados pendentes até expira o tempo limite especificado, e se a tentativa falhar, o Winsock redefine a conexão.|  
|`true`(habilitado)|Um zero tempo limite.|Descarta qualquer dados pendentes. Para o soquete orientado a conexão (por exemplo, TCP), Winsock redefine a conexão.|  
  
 A pilha de IP calcula o período de tempo limite de protocolo IP padrão para usar com base no tempo de ida e volta da conexão. Na maioria dos casos, o tempo de limite calculado pela pilha é mais relevante do que um definido por um aplicativo. Esse é o comportamento padrão para um soquete quando o <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade não está definida.  
  
 Quando o <xref:System.Net.Sockets.LingerOption.LingerTime%2A> propriedade armazenada no <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade é definida maior que o tempo limite de protocolo IP padrão, o tempo limite de protocolo IP padrão ainda se aplicam e substituir.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.LingerState%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">O comprimento máximo da fila de conexões pendentes.</param>
        <summary>Coloca um <see cref="T:System.Net.Sockets.Socket" /> em um estado de escuta.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A>faz com que uma conexão orientada <xref:System.Net.Sockets.Socket> para escutar as tentativas de conexão de entrada. O `backlog` parâmetro especifica o número de conexões de entrada que podem ser enfileirados para aceitação. Para determinar o número máximo de conexões que você pode especificar, recuperar o <xref:System.Net.Sockets.SocketOptionName.MaxConnections> valor. <xref:System.Net.Sockets.Socket.Listen%2A>não bloquear.  
  
 Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro. Use <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.BeginAccept%2A> para aceitar uma conexão da fila.  
  
> [!NOTE]
>  Você deve chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método antes de chamar <xref:System.Net.Sockets.Socket.Listen%2A>, ou <xref:System.Net.Sockets.Socket.Listen%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  O parâmetro de lista de pendências é limitado a valores diferentes dependendo do sistema operacional. Você pode especificar um valor mais alto, mas a lista de pendências será limitada com base no sistema operacional.  
  
   
  
## Examples  
 O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket> para escutar conexões de entrada.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o ponto de extremidade local.</summary>
        <value>O <see cref="T:System.Net.EndPoint" /> que o <see cref="T:System.Net.Sockets.Socket" /> está usando para comunicações.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade obtém um <xref:System.Net.EndPoint> que contém o local IP endereço e número da porta para o qual seu <xref:System.Net.Sockets.Socket> está associado. Você deve converter isso <xref:System.Net.EndPoint> para um <xref:System.Net.IPEndPoint> antes de recuperar todas as informações. Em seguida, você pode chamar o <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar o local <xref:System.Net.IPAddress>e o <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar o número de porta local.  
  
 O <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade normalmente é definida depois de fazer uma chamada para o <xref:System.Net.Sockets.Socket.Bind%2A> método. Se você permitir que o sistema atribuir o endereço IP do soquete local e o número da porta, o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade será definida após a primeira operação de e/s. Para protocolos orientados a conexão, a primeira operação de e/s seria uma chamada para o <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Para protocolos sem conexão, a primeira operação de e/s deve ser qualquer enviar ou receber chamadas.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir recupera e exibe os pontos de extremidade locais e remotos.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica se os pacotes de multicast de saída são entregues para o aplicativo de envio.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> receber pacotes de multicast de saída; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multicast é um método escalonável para muitos-para-muitos comunicação na Internet. Um processo se inscreve para um endereço de multicast; em seguida, todos os pacotes enviados por um processo assinado são recebidos por todos os outros processos assinado ao endereço de multicast.  
  
 A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) não terá efeito.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor <see cref="T:System.Boolean" /> que especifica se o <see cref="T:System.Net.Sockets.Socket" /> do fluxo está usando o Algoritmo de Nagle.</summary>
        <value>
          <see langword="false" /> se o <see cref="T:System.Net.Sockets.Socket" /> usa o algoritmo de Nagle; caso contrário, <see langword="true" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O algoritmo Nagle foi projetado para reduzir o tráfego de rede, fazendo com que o soquete para o buffer de pacotes pequenos e, em seguida, combinar e enviá-los em um pacote em determinadas circunstâncias. Um pacote TCP consiste em 40 bytes de cabeçalho mais os dados sendo enviados. Quando pacotes pequenos de dados são enviados com o TCP, a sobrecarga resultante do cabeçalho TCP pode se tornar uma parte significativa do tráfego de rede. Em redes extremamente carregados, congestionamento resultante dessa sobrecarga pode resultar em datagramas perdidas e retransmissões, bem como tempo de propagação excessiva causada pelo congestionamento. O algoritmo Nagle não permite o envio de novos segmentswhen TCP novos dados de saída chega do usuário, se os dados previouslytransmitted a conexão permanecem não confirmados.  
  
 A maioria dos aplicativos de rede deve usar o algoritmo Nagle.  
  
 A definição dessa propriedade em um soquete do protocolo UDP (User Datagram) não terá efeito.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.NoDelay%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o sistema operacional subjacente e os adaptadores de rede dão suporte ao IPv4 (protocolo IP versão 4).</summary>
        <value>
          <see langword="true" /> se o sistema operacional e os adaptadores de rede derem suporte ao protocolo IPv4; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se o sistema operacional subjacente e os adaptadores de rede dão suporte ao IPv6 (protocolo IP versão 6).</summary>
        <value>
          <see langword="true" /> se o sistema operacional e os adaptadores de rede derem suporte ao protocolo IPv6; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">O tempo de espera por uma resposta, em microssegundos.</param>
        <param name="mode">Um dos valores de <see cref="T:System.Net.Sockets.SelectMode" />.</param>
        <summary>Determina o status do <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>O status do <see cref="T:System.Net.Sockets.Socket" /> com base no valor de modo de sondagem passado no parâmetro <paramref name="mode" />.  
  
 <list type="table"><listheader><term>Modo  
  
 </term><description>Valor de retorno  
  
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />Se <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> foi chamado e uma conexão está pendente;  
  
 -ou-  
  
 <see langword="true" /> se os dados estiverem disponíveis para leitura;  
  
 -ou-  
  
 <see langword="true" /> se a conexão foi fechada, redefinida ou terminada;  
  
 caso contrário, retornará <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, se o processamento de um <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, e a conexão foi bem-sucedida;  
  
 -ou-  
  
 <see langword="true" /> se for possível enviar os dados;  
  
 caso contrário, retornará <see langword="false" />.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />Se o processamento de um <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> que não bloqueia e a conexão falhou;  
  
 -ou-  
  
 <see langword="true" /> se <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> não estiver definido e dados fora de banda estiverem disponíveis;  
  
 caso contrário, retornará <see langword="false" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Poll%2A> método verificará o estado do <xref:System.Net.Sockets.Socket>. Especifique <xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType> para o `selectMode` parâmetro para determinar se o <xref:System.Net.Sockets.Socket> é legível. Especifique <xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType> para determinar se o <xref:System.Net.Sockets.Socket> é gravável. Use <xref:System.Net.Sockets.SelectMode?displayProperty=nameWithType> para detectar uma condição de erro. <xref:System.Net.Sockets.Socket.Poll%2A>bloqueará a execução até que o período de tempo especificado, medida em `microseconds`, expira. Definir o `microSeconds` parâmetro para um inteiro negativo se você gostaria de esperar indefinidamente por uma resposta. Se você quiser verificar o status de vários soquetes, talvez você prefira usar o <xref:System.Net.Sockets.Socket.Select%2A> método.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Este método não pode detectar determinados tipos de problemas de conexão, como um cabo de rede interrompido, ou que o host remoto foi desligado maneira brusca. Você deve tentar enviar ou receber dados para detectar esses tipos de erros.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria um soquete, se conecta a um servidor e usa <xref:System.Net.Sockets.Socket.Poll%2A> para verificar o status do soquete.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O parâmetro <paramref name="mode" /> não é um dos valores <see cref="T:System.Net.Sockets.SelectMode" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte os comentários abaixo.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo de protocolo do <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Um dos valores de <see cref="T:System.Net.Sockets.ProtocolType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ProtocolType%2A> propriedade é definida quando o <xref:System.Net.Sockets.Socket> é criado e especifica o protocolo usado pelo <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 O código a seguir exemplo exibe o <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> para o console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <summary>Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito. Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.  
  
 Essa sobrecarga exige somente que você forneça um buffer de recebimento. Deslocamento de buffer padrão é 0, o tamanho padrão é o comprimento do parâmetro buffer e o <xref:System.Net.Sockets.SocketFlags> valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir recebe dados sobre conectada <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados recebidos.</param>
        <summary>Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado na lista de buffers de recepção.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê dados para o parâmetro de buffers e retorna o número de bytes lidos com êxito. Você pode chamar de soquetes orientado por conexão e sem conexão.  
  
 Essa sobrecarga exige que você forneça um ou mais buffers de recepção.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método lerá apenas dados que chega da conexão do host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffers` parâmetro `buffers` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
 **Observação** esse membro gera informações de rastreamento, quando você habilita o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito. Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.  
  
 Essa sobrecarga exige somente que você fornecer um buffer de recebimento e necessários <xref:System.Net.Sockets.SocketFlags>. Deslocamento de buffer padrão é 0 e o tamanho padrão é o comprimento do parâmetro bytes.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver no modo sem bloqueio, e nenhum dado está disponível no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados está disponível até o tamanho do buffer. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir especifica um buffer de dados, e <xref:System.Net.Sockets.SocketFlags> para receber dados em um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado na lista de buffers de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê os dados para o `buffers` parâmetro e retorna o número de bytes lidos com êxito. Você pode chamar de soquetes orientado por conexão e sem conexão.  
  
 Essa sobrecarga exige que você forneça um ou mais buffers de recepção. O <xref:System.Net.Sockets.SocketFlags> valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método lerá apenas dados que chega da conexão do host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamar lança um <xref:System.Net.Sockets.SocketException>. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama enfileiradas primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffers` parâmetro `buffers` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como receber dados em um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="buffers" />.Count é zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recebe o número de bytes especificado de dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Receive%2A> método lê os dados para o `buffer` parâmetro e retorna o número de bytes lidos com êxito. Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.  
  
 Essa sobrecarga exige somente que você forneça um buffer de recepção, o número de bytes que você deseja receber e necessários <xref:System.Net.Sockets.SocketFlags>.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo `size` parâmetro. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 A seguir recebe os dados encontrados em `buffer`e especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="buffer" /> excede o tamanho de <paramref name="size" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <summary>Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado na lista de buffers de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê os dados para o `buffers` parâmetro e retorna o número de bytes lidos com êxito. Você pode chamar de soquetes orientado por conexão e sem conexão.  
  
 Essa sobrecarga exige que você forneça um ou mais buffers de recepção. O <xref:System.Net.Sockets.SocketFlags> valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método lerá apenas dados que chega da conexão do host remoto estabelecida no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamar lança um <xref:System.Net.Sockets.SocketException>. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o tamanho do buffer. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffers` parâmetro `buffers` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="buffers" />.Count é zero.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">O local na <c>buffer</c> para armazenar os dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Recebe o número de bytes especificado de um <see cref="T:System.Net.Sockets.Socket" /> associado na posição de deslocamento especificada do buffer de recepção usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito. Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Ocorreu um erro ao tentar acessar o soquete. Consulte os comentários abaixo. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo parâmetro de tamanho. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir especifica um buffer de dados, um deslocamento, um tamanho e um sinalizador de soquete antes de receber os dados em um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.  
  
 -ou-  
  
 Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">A posição no <c>buffer</c> parâmetro para armazenar os dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <summary>Recebe dados de um <see cref="T:System.Net.Sockets.Socket" /> associado em um buffer de recepção, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.Receive%2A> método lê dados para o parâmetro de buffer e retorna o número de bytes lidos com êxito. Você pode chamar <xref:System.Net.Sockets.Socket.Receive%2A> de soquetes orientado por conexão e sem conexão.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto, ou <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada antes de chamar <xref:System.Net.Sockets.Socket.Receive%2A>. O <xref:System.Net.Sockets.Socket.Receive%2A> método apenas lê os dados que chega a partir do host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estiver usando um protocolo sem-conexão, você também pode usar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>permitirá que você receba dados recebidos de qualquer host.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.Receive%2A> método será bloqueada até que os dados estejam disponíveis, a menos que um valor de tempo limite foi definido usando <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Ocorreu um erro ao tentar acessar o soquete. Consulte os comentários abaixo. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Se você estiver usando uma conexão orientada <xref:System.Net.Sockets.Socket>, o <xref:System.Net.Sockets.Socket.Receive%2A> método lerá a quantidade de dados estiver disponível, até o número de bytes especificado pelo parâmetro de tamanho. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.Receive%2A> método será concluída imediatamente e retornará zero bytes.  
  
 Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> lerá o datagrama em fila primeiro o endereço de destino que você especificar o <xref:System.Net.Sockets.Socket.Connect%2A> método. Se o datagrama receber é maior do que o tamanho do `buffer` parâmetro `buffer` é preenchida com a primeira parte da mensagem, o excesso de dados é perdido e um <xref:System.Net.Sockets.SocketException> é gerada.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.  
  
 -ou-  
  
 Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Inicia uma solicitação assíncrona para receber dados de um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método é usado em conectado soquetes ou vinculados soquetes sem conexão e é usado para ler os dados de entrada. Endereço local do soquete deve ser conhecido.  
  
 Para soquetes sem conexão associadas, esta função restringe os endereços de onde as mensagens recebidas são aceitas. A função retorna apenas as mensagens do endereço remoto especificado na conexão. Mensagens de outros endereços são descartadas silenciosamente.  
  
 O <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriedade o `e` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a solicitação de leitura. Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Para soquetes do estilo de fluxo de bytes, os dados de entrada são colocados no buffer até que o buffer é preenchido, a conexão é fechada ou os dados armazenados em buffer internamente são esgotados.  
  
 Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer associado a `e` parâmetro. Se a mensagem for maior do que o buffer, o buffer é preenchido com a primeira parte da mensagem.  
  
 Para soquetes orientados a conexão, o <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> método pode indicar que o encerramento amigável do circuito virtual em uma das duas maneiras que dependem de se o soquete é orientado a mensagem ou fluxo de bytes. Para fluxos de byte zero bytes foi lidos indica fechamento normal e que não há mais bytes nunca serão lidos. Para soquetes orientado a mensagens, em que uma mensagem de zero bytes geralmente é permitida, um <xref:System.Net.Sockets.SocketException> com o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> definido como o código de erro nativo do Winsock WSAEDISCON (10101) é usado para indicar o encerramento normal. Em qualquer caso, um <xref:System.Net.Sockets.SocketException> com o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> definido para o nativo WSAECONNRESET Winsock o código de erro (10054) indica um fechamento por anulação ocorreu.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um argumento era inválido. As propriedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no parâmetro <paramref name="e" /> devem referenciar buffers válidos. Uma ou a outra dessas propriedades poderá ser definida, mas não ambas ao mesmo tempo.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica o tamanho do buffer de recepção do <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Um <see cref="T:System.Int32" /> que contém o tamanho, em bytes, do buffer de recepção. O padrão é 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Potencialmente, um tamanho de buffer maior reduz o número de confirmações vazios (pacotes TCP com nenhuma parte de dados), mas também pode atrasar o reconhecimento de problemas de conexão. Considere aumentar o tamanho do buffer se estiver transferindo arquivos grandes ou se você estiver usando a largura de banda alta, a conexão de alta latência (como um satélite provedor de banda larga.)  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="remoteEP">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</param>
        <summary>Recebe um datagrama no buffer de dados e armazena o ponto de extremidade.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados. Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.  
  
 Essa sobrecarga exige somente que você fornecer um recebimento `buffer`e um <xref:System.Net.EndPoint> que representa o host remoto. Deslocamento de buffer padrão é 0. O tamanho padrão é o comprimento do `buffer` parâmetro e o `socketFlags` valor padrão é <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método. Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local. Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido. Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também. Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.  
  
 Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até o tamanho de `buffer`. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</param>
        <summary>Recebe um datagrama no buffer de dados, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena o ponto de extremidade.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados. Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.  
  
 Essa sobrecarga exige somente que você forneça um buffer de recepção, o necessário <xref:System.Net.Sockets.SocketFlags>e um <xref:System.Net.EndPoint> que representa o host remoto. O deslocamento padrão é 0 e o tamanho padrão é o comprimento do parâmetro de buffer.  
  
> [!NOTE]
>  Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método. Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local. Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido. Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também. Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.  
  
 Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até o tamanho de `buffer`. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto. <xref:System.Net.Sockets.SocketFlags>são passados para o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</param>
        <summary>Recebe o número especificado de bytes no buffer de dados, usando especificado <see cref="T:System.Net.Sockets.SocketFlags" />e armazena o ponto de extremidade.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados. Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.  
  
 Essa sobrecarga exige somente que você forneça um buffer de recepção, o número de bytes que você deseja receber as necessárias <xref:System.Net.Sockets.SocketFlags>e um <xref:System.Net.EndPoint> que representa o host remoto. Deslocamento de buffer padrão é 0.  
  
 Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local. Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido. Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também. Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.  
  
 Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até o número de bytes especificado pelo `size` parâmetro. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.  
  
> [!NOTE]
>  Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método. Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto. O tamanho do buffer e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento do <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.  
  
 -ou-  
  
 Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">A posição no <c>buffer</c> parâmetro para armazenar os dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</param>
        <summary>Recebe o número de bytes de dados no local especificado no buffer de dados usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena o ponto de extremidade.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados. Esse método é útil se você pretende receber datagramas sem conexão de um host desconhecido ou vários hosts.  
  
 Com protocolos sem conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá o datagrama enfileiradas primeiro recebido no buffer de rede local. Se o datagrama receber é maior que o tamanho de `buffer`, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método preencherá `buffer` com tanta da mensagem como é possível e lançar um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo não confiável, o excesso de dados serão perdido. Se você estiver usando um protocolo confiável, o excesso de dados será retido pelo provedor de serviço e você poderá recuperá-lo ao chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método com um buffer grande o suficiente.  
  
 Se nenhum dado está disponível para leitura, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será bloqueado até que os dados estão disponíveis. Se você estiver no modo sem bloqueio, e nenhum dado está disponível na no buffer de pilha de protocolo, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e lançar um <xref:System.Net.Sockets.SocketException>. Você pode usar o <xref:System.Net.Sockets.Socket.Available%2A> para determinar se os dados estão disponíveis para leitura. Quando <xref:System.Net.Sockets.Socket.Available%2A> é diferente de zero, repita a operação de recebimento.  
  
 Embora <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> destina-se para protocolos sem conexão, você pode usar um protocolo orientado a conexão também. Se você optar por fazer isso, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma entrada remota hospedar conexão chamando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você não estabelecer ou aceitar uma conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método, você obterá um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método. Em ambos os casos, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método irá ignorar o `remoteEP` parâmetro e recebam dados conectado ou host remoto padrão.  
  
 Com soquetes orientados a conexão, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lerá a quantidade de dados está disponível até a quantidade de bytes especificados pelo `size` parâmetro. Se o host remoto é desligado o <xref:System.Net.Sockets.Socket> conexão com o <xref:System.Net.Sockets.Socket.Shutdown%2A> método e todos os dados disponíveis foi recebida, o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método será concluída imediatamente e retornará zero bytes.  
  
> [!NOTE]
>  Antes de chamar <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, você deve associar explicitamente o <xref:System.Net.Sockets.Socket> para um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.Bind%2A> método. Se você não fizer isso, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir recebe um datagrama sem conexão de um host remoto. O deslocamento, o tamanho do buffer, e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento de <paramref name="buffer" /> menos o valor do parâmetro de deslocamento.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.  
  
 -ou-  
  
 Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Começa a receber dados de um dispositivo de rede especificado de maneira assíncrona.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método é usado principalmente para receber dados em um soquete sem conexão. Endereço local do soquete deve ser conhecido.  
  
 O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto do qual os dados são a ser recebida.  
  
 O <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriedade o `e` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a solicitação de leitura. Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer. O <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.  
  
 Para soquetes de fluxo estilo bytes, os dados de entrada são colocados no buffer até que o buffer é preenchido, a conexão é fechada ou os dados armazenados em buffer internamente são esgotados. O <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não pode ser nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags&amp;" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint&amp;" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que é o local de armazenamento dos dados recebidos.</param>
        <param name="offset">A posição no <c>buffer</c> parâmetro para armazenar os dados recebidos.</param>
        <param name="size">O número de bytes a serem recebidos.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">Um <see cref="T:System.Net.EndPoint" />, passado por referência, que representa o servidor remoto.</param>
        <param name="ipPacketInformation">Um <see cref="T:System.Net.Sockets.IPPacketInformation" /> que contém informações de endereço e de interface.</param>
        <summary>Recebe o número de bytes de dados no local especificado no buffer de dados usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado e armazena as informações de ponto de extremidade e pacote.</summary>
        <returns>O número de bytes recebidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método lê os dados para o `buffer` parâmetro, retorna o número de bytes lidos com êxito e captura o ponto de extremidade do host remoto do qual os dados foram enviados, bem como informações sobre o pacote recebido.  
  
 O <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método é usado principalmente para receber dados de mensagem em um soquete sem conexão. Endereço local do soquete deve ser conhecido. Esse método só pode ser usado com o datagrama e soquetes brutos. O soquete deve ser inicializado com o tipo de soquete definido como <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> antes de chamar esse método. Isso pode ser feito quando o soquete é construído usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no `buffer` parâmetro até o tamanho total especificado no `size` parâmetro. O `offset` parâmetro determina onde no `buffer` os dados são colocados. A quantidade real de dados colocados no `buffer` é retornado pelo <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método.  
  
 O <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método define automaticamente um método de <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para `true` na primeira vez que ele é chamado para um determinado <xref:System.Net.Sockets.Socket>. No entanto, retornado <xref:System.Net.Sockets.IPPacketInformation> objeto será válido apenas para pacotes que chegam ao computador local depois que a opção de soquete foi definida. Se um soquete é enviado pacotes entre quando ele está associado a um ponto de extremidade local (explicitamente, o <xref:System.Net.Sockets.Socket.Bind%2A> método ou implicitamente por uma da <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) e sua primeira chamada para o <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> chamadas de método, a <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> método retornará inválido <xref:System.Net.Sockets.IPPacketInformation> objetos para esses pacotes.  
  
 Para garantir que todos os <xref:System.Net.Sockets.IPPacketInformation> objetos sejam válidos, um aplicativo deve definir o <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para `true` antes que ele está associado a um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.  
  
 Um aplicativo pode examinar o `ipPacketInformation` parâmetro se ele precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.  
  
> [!NOTE]
>  O <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> deve corresponder a <xref:System.Net.Sockets.AddressFamily> do <xref:System.Net.EndPoint> usados em <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 \-ou -  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento de <paramref name="buffer" /> menos o valor do parâmetro de deslocamento.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 A propriedade <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> não foi definida.  
  
 - ou -  
  
 O .NET Framework está em execução em um processador AMD 64 bits.  
  
 -ou-  
  
 Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.NotSupportedException">O sistema operacional é o Windows 2000 ou anterior e esse método requer o Windows XP.</exception>
        <permission cref="T:System.Net.SocketPermission">para aceitar conexões de rede. Enumeração associada: <see cref="F:System.Net.NetworkAccess.Accept" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Inicia o recebimento de forma assíncrona do número especificado de bytes de dados no local especificado do buffer de dados, usando o <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> especificado e armazena as informações de ponto de extremidade e de pacote.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método é usado principalmente para receber dados de mensagem em um soquete sem conexão. Endereço local do soquete deve ser conhecido. Esse método só pode ser usado com o datagrama e soquetes brutos. O soquete deve ser inicializado com o tipo de soquete definido como <xref:System.Net.Sockets.SocketType.Dgram> ou <xref:System.Net.Sockets.SocketType.Raw> antes de chamar esse método. Isso pode ser feito quando o soquete é construído usando <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 O chamador deverá definir a <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade para o <xref:System.Net.IPEndPoint> do host remoto do qual os dados são a ser recebida.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Para soquetes orientado a mensagens, uma mensagem de entrada é colocada no buffer até o tamanho total do buffer. O <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> e <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> propriedades determinam onde o buffer de dados são colocados e a quantidade de dados.  
  
 O <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método define automaticamente o <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para `true` na primeira vez que ele é chamado para um determinado <xref:System.Net.Sockets.Socket>. No entanto, o <xref:System.Net.Sockets.IPPacketInformation> objeto será válido apenas para pacotes que chegam ao computador local depois que a opção de soquete foi definida. Se um soquete é enviado pacotes entre quando o soquete está associado a um ponto de extremidade local (explicitamente, o <xref:System.Net.Sockets.Socket.Bind%2A> método ou implicitamente por uma da <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, ou <xref:System.Net.Sockets.Socket.SendToAsync%2A> métodos) e a primeira chamada para o <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> chamadas de método, para <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> método resultará em inválido <xref:System.Net.Sockets.IPPacketInformation> objetos para esses pacotes.  
  
 Para garantir que todos os <xref:System.Net.Sockets.IPPacketInformation> objetos sejam válidos, um aplicativo deve definir o <xref:System.Net.Sockets.SocketOptionName.PacketInformation> soquete opção para`true` antes que ele está associado a um ponto de extremidade local usando o <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> método.  
  
 Um aplicativo pode examinar resultante <xref:System.Net.Sockets.IPPacketInformation> objetos se ele precisa saber se o datagrama foi enviado por meio de uma unicast, o endereço de difusão ou multicast.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não pode ser nulo.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica o tempo após o qual uma chamada <see cref="Overload:System.Net.Sockets.Socket.Receive" /> síncrona atingirá o tempo limite.</summary>
        <value>O valor de tempo limite, em milissegundos. O valor padrão é 0, que indica um período de tempo limite infinito. Especificar -1 também indica um período de tempo limite infinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa opção se aplica a síncrona <xref:System.Net.Sockets.Socket.Receive%2A> chama somente. Se o período de tempo limite for excedido, o <xref:System.Net.Sockets.Socket.Receive%2A> método lançará um <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o ponto de extremidade remoto.</summary>
        <value>O <see cref="T:System.Net.EndPoint" /> com o qual o <see cref="T:System.Net.Sockets.Socket" /> está se comunicando.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você estiver usando um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> propriedade obtém o <xref:System.Net.EndPoint> que contém o remoto IP endereço e número da porta para o qual o <xref:System.Net.Sockets.Socket> está conectado. Se você estiver usando um protocolo sem-conexão, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contém o padrão de endereço IP remoto e a porta número com o qual o <xref:System.Net.Sockets.Socket> se comunicará. Você deve converter isso <xref:System.Net.EndPoint> para um <xref:System.Net.IPEndPoint> antes de recuperar todas as informações. Em seguida, você pode chamar o <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> método para recuperar o controle remoto <xref:System.Net.IPAddress>e o <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> método para recuperar o número de porta remota.  
  
 O <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> é definido após uma chamada para a <xref:System.Net.Sockets.Socket.Accept%2A> ou <xref:System.Net.Sockets.Socket.Connect%2A>. Se você tentar acessar essa propriedade anterior, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir recupera e exibe os pontos de extremidade locais e remotos.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">Um <see cref="T:System.Collections.IList" /> de instâncias <see cref="T:System.Net.Sockets.Socket" /> a serem verificadas quanto à legibilidade.</param>
        <param name="checkWrite">Um <see cref="T:System.Collections.IList" /> de instâncias <see cref="T:System.Net.Sockets.Socket" /> a serem verificadas quanto à capacidade de gravação.</param>
        <param name="checkError">Um <see cref="T:System.Collections.IList" /> de instâncias <see cref="T:System.Net.Sockets.Socket" /> a serem verificadas quanto a erros.</param>
        <param name="microSeconds">O valor de tempo limite, em microssegundos. Um valor de -1 indica um tempo limite infinito.</param>
        <summary>Determina o status de um ou mais soquetes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A>é um método estático que determina o status de um ou mais <xref:System.Net.Sockets.Socket> instâncias. Você deve colocar um ou mais soquetes em um <xref:System.Collections.IList> antes de usar o <xref:System.Net.Sockets.Socket.Select%2A> método. Verificar para facilitar a leitura chamando <xref:System.Net.Sockets.Socket.Select%2A> com o <xref:System.Collections.IList> como o `checkRead` parâmetro. Para verificar seu soquetes para gravabilidade, use o `checkWrite` parâmetro. Para detectar condições de erro, use `checkError`. Depois de chamar <xref:System.Net.Sockets.Socket.Select%2A>, o <xref:System.Collections.IList> será preenchido com apenas esses soquetes que atendem às condições.  
  
 Se você estiver em um estado de escuta, legibilidade significa que uma chamada para <xref:System.Net.Sockets.Socket.Accept%2A> terá êxito sem bloqueio. Se você já aceitou a conexão, a legibilidade significa que os dados estão disponíveis para leitura. Nesses casos, todas as operações de recebimento terá êxito sem bloqueio. Legibilidade também pode indicar se o computador remoto <xref:System.Net.Sockets.Socket> foi encerrado para a conexão; nesse caso uma chamada para <xref:System.Net.Sockets.Socket.Receive%2A> retornará imediatamente, com zero bytes retornados.  
  
 <xref:System.Net.Sockets.Socket.Select%2A>Retorna quando pelo menos um dos soquetes de interesse (soquetes do `checkRead`, `checkWrite`, e `checkError` lista) atenda aos critérios especificados, ou o `microSeconds` parâmetro for excedido, o que ocorrer primeiro. Definindo `microSeconds` como -1 especifica um tempo limite infinito.  
  
 Se você fizer uma chamada sem bloqueio para <xref:System.Net.Sockets.Socket.Connect%2A>, gravabilidade significa que você se conectou com êxito. Se você já tiver uma conexão estabelecida, gravabilidade significa que todos os enviem operações terão êxito sem bloqueio.  
  
 Se você fez uma chamada sem-bloqueio para <xref:System.Net.Sockets.Socket.Connect%2A>, o `checkerror` parâmetro identifica que não tenha se conectado com êxito.  
  
> [!NOTE]
>  Use o <xref:System.Net.Sockets.Socket.Poll%2A> método se você quiser determinar o status de um único <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Este método não pode detectar determinados tipos de problemas de conexão, como um cabo de rede interrompido, ou que o host remoto foi desligado maneira brusca. Você deve tentar enviar ou receber dados para detectar esses tipos de erros.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
   
  
## Examples  
 O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.Select%2A> para determinar quais soquetes escuta tem uma solicitação de conexão.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="checkRead" /> é <see langword="null" /> ou está vazio.  
  
 -e-  
  
 O parâmetro <paramref name="checkWrite" /> é <see langword="null" /> ou está vazio  
  
 -e-  
  
 O parâmetro <paramref name="checkError" /> é <see langword="null" /> ou está vazio.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <summary>Envia dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>envia dados de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito. <xref:System.Net.Sockets.Socket.Send%2A>pode ser usado para protocolos e orientada a conexão e sem conexão.  
  
 Essa sobrecarga requer um buffer que contém os dados que você deseja enviar. O <xref:System.Net.Sockets.SocketFlags> o valor padrão é 0, deslocamento de buffer padrão é 0 e o número de bytes a enviar os padrões para o tamanho do buffer.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o envio de dados em um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <summary>Envia o conjunto de buffers na lista para um <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>pode ser usado para protocolos e orientada a conexão e sem conexão.  
  
 Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> está vazio.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Consulte a seção Comentários abaixo.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envia dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>envia dados de forma síncrona ao host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito. O <xref:System.Net.Sockets.Socket.Send%2A> método pode ser usado para protocolos e orientada a conexão e sem conexão.  
  
 Essa sobrecarga requer um buffer que contém os dados que você deseja enviar e uma combinação bit a bit de <xref:System.Net.Sockets.SocketFlags>. O buffer de deslocamento padrão é 0 e o número de bytes a enviar os padrões para o tamanho do buffer. Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` o valor do parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Certifique-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte[rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o envio de dados em um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envia o conjunto de buffers na lista para conectada <see cref="T:System.Net.Sockets.Socket" />, usando especificado <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar. O <xref:System.Net.Sockets.SocketFlags> valor padrão é 0. Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketFlags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> está vazio.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envia o número especificado de bytes de dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado, usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>envia dados de forma síncrona ao host remoto estabelecido no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito. <xref:System.Net.Sockets.Socket.Send%2A>pode ser usado para protocolos e orientada a conexão e sem conexão.  
  
 Essa sobrecarga requer um buffer que contém os dados que você deseja enviar, o número de bytes que você deseja enviar e uma combinação bit a bit de qualquer <xref:System.Net.Sockets.SocketFlags>. Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de cada chamada para o <xref:System.Net.Sockets.Socket.Send%2A> método. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Com um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Certifique-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir envia os dados encontrados no buffer e especifica <xref:System.Net.Sockets.SocketFlags.None> para <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="size" /> é menor que 0 ou excede o tamanho do buffer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 Ocorre um erro de sistema operacional ao acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Uma lista de <see cref="T:System.ArraySegment`1" />s do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <summary>Envia o conjunto de buffers na lista para conectada <see cref="T:System.Net.Sockets.Socket" />, usando especificado <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga requer pelo menos um buffer que contém os dados que você deseja enviar. O <xref:System.Net.Sockets.SocketFlags> valor padrão é 0. Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketFlags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Se você não usar o <xref:System.Net.Sockets.Socket.SendTo%2A> método, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>. Você pode usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que todos os bytes no buffer são enviados, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes no buffer. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia os bytes no buffer. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffers" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="buffers" /> está vazio.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="offset">A posição no buffer de dados na qual o envio de dados deve começar.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <summary>Envia o número especificado de bytes de dados para um <see cref="T:System.Net.Sockets.Socket" /> conectado, começando no deslocamento especificado e usando os <see cref="T:System.Net.Sockets.SocketFlags" /> especificados.</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>envia dados de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito. <xref:System.Net.Sockets.Socket.Send%2A>pode ser usado para protocolos e orientada a conexão e sem conexão.  
  
 Essa sobrecarga, se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar este método ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.SendTo%2A>. Se você não usar <xref:System.Net.Sockets.Socket.SendTo%2A>, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>. É okey usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir especifica o buffer de dados, um deslocamento, um tamanho, e <xref:System.Net.Sockets.SocketFlags> para enviar dados para um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="offset">A posição no buffer de dados na qual o envio de dados deve começar.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="errorCode">Um objeto <see cref="T:System.Net.Sockets.SocketError" /> que armazena o erro de soquete.</param>
        <summary>Envia o número especificado de bytes de dados a um <see cref="T:System.Net.Sockets.Socket" /> conectado, iniciando no deslocamento especificado e usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado</summary>
        <returns>O número de bytes enviados para o <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A>envia dados de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método e retorna o número de bytes enviados com êxito. <xref:System.Net.Sockets.Socket.Send%2A>pode ser usado para protocolos e orientada a conexão e sem conexão.  
  
 Essa sobrecarga, se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar este método ou <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo sem-conexão e um plano para enviar dados a vários hosts diferentes, você deve usar <xref:System.Net.Sockets.Socket.SendTo%2A>. Se você não usar <xref:System.Net.Sockets.Socket.SendTo%2A>, você terá que chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de cada chamada para <xref:System.Net.Sockets.Socket.Send%2A>. É okey usar <xref:System.Net.Sockets.Socket.SendTo%2A> mesmo depois de estabelecer um host remoto padrão com <xref:System.Net.Sockets.Socket.Connect%2A>. Você também pode alterar o host remoto padrão antes de chamar <xref:System.Net.Sockets.Socket.Send%2A> fazendo outra chamada para <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.Send%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.Send%2A> será bloqueado até que o número solicitado de bytes é enviado, a menos que um tempo limite foi definido usando <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Se o valor de tempo limite foi excedido, o <xref:System.Net.Sockets.Socket.Send%2A> chamada lançará um <xref:System.Net.Sockets.SocketException>. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.Send%2A> pode ser concluído com êxito mesmo que ele envia menor do que o número de bytes que você solicitar. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.Send%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  A conclusão bem-sucedida de um envio não indica que os dados foi entregue com êxito. Se nenhum espaço de buffer está disponível dentro do sistema de transporte para manter os dados sejam transmitidos, enviar bloqueará a menos que o soquete foi colocado no modo sem bloqueio.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte[rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir especifica o buffer de dados, um deslocamento, um tamanho, e <xref:System.Net.Sockets.SocketFlags> para enviar dados para um conectado <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Envia dados de forma assíncrona para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.SendAsync%2A> método é usado para gravar dados de saída de um ou mais buffers em um soquete orientado a conexão. Esse método também pode ser usado, no entanto, em soquetes sem conexão que especificou um host remoto em uma operação de conexão.  
  
 O <xref:System.Net.Sockets.Socket.SendAsync%2A> método inicia uma operação de envio assíncrono para o host remoto estabelecida no <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> ou <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>Se <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> está definido  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.SendAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 O <xref:System.Net.Sockets.Socket.SendAsync%2A> método lançará uma exceção se você não chama primeiro <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Chamar o <xref:System.Net.Sockets.Socket.SendAsync%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado.  
  
 Para soquetes orientado a mensagens, não exceda o tamanho máximo da mensagem do provedor de serviços de soquetes do Windows subjacente. Se os dados são muito longos para passar o provedor de serviço subjacente atomicamente, nenhum dado é transmitido e <xref:System.Net.Sockets.Socket.SendAsync%2A> método lança um <xref:System.Net.Sockets.SocketException> com o <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> definido como o código de erro de Winsock WSAEMSGSIZE nativo (10040).  
  
 Observe que a conclusão bem-sucedida do <xref:System.Net.Sockets.Socket.SendAsync%2A> método não indica que os dados foi entregue com êxito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">As propriedades <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> ou <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> no parâmetro <paramref name="e" /> devem referenciar buffers válidos. Uma ou a outra dessas propriedades poderá ser definida, mas não ambas ao mesmo tempo.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">O <see cref="T:System.Net.Sockets.Socket" /> ainda não está conectado ou não foi obtido por meio de um método <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> ou <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica o tamanho do buffer de envio do <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Um <see cref="T:System.Int32" /> que contém o tamanho, em bytes, do buffer de envio. O padrão é 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um tamanho de buffer maior pode atrasar o reconhecimento de problemas de conexão. Considere aumentar o tamanho do buffer se estiver transferindo arquivos grandes ou se você estiver usando a largura de banda alta, a conexão de alta latência (como um satélite provedor de banda larga.)  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.SendBufferSize%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Um <see cref="T:System.String" /> que contém o caminho e o nome do arquivo a ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <summary>Envia o arquivo <paramref name="fileName" /> para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado com o sinalizador de transmissão <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga envia o arquivo `fileName` para o soquete conectado. O `flags` parâmetro padrão <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0) e o `preBuffer` e `postBuffer` parâmetros padrão para `null`. Se `fileName` está no diretório local, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados. Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados. Se o arquivo não for encontrado, a exceção <xref:System.IO.FileNotFoundException> é lançada.  
  
 Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2. Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>envia um arquivo de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. <xref:System.Net.Sockets.Socket.SendFile%2A>pode ser usado para ambos orientado a conexão e protocolos sem conexão.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método, caso contrário, <xref:System.Net.Sockets.Socket.SendFile%2A> lança um <xref:System.Net.Sockets.SocketException> exceção. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.SendFile%2A> bloqueia até que o arquivo é enviado. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.SendFile%2A> pode ser concluído com êxito antes do arquivo inteiro foi enviado. Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria e se conecta a um soquete e, em seguida, envia um arquivo para o host remoto. O arquivo "test.txt" está localizado no diretório raiz da máquina local.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O soquete não está conectado a um host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.InvalidOperationException">O objeto <see cref="T:System.Net.Sockets.Socket" /> não está no modo de bloqueio e não pode aceitar essa chamada síncrona.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo <paramref name="fileName" /> não foi encontrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">Um <see cref="T:System.String" /> que contém o caminho e o nome do arquivo a ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="preBuffer">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados antes de o arquivo ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="postBuffer">Uma matriz <see cref="T:System.Byte" /> que contém dados a serem enviados depois de o arquivo ser enviado. Esse parâmetro pode ser <see langword="null" />.</param>
        <param name="flags">Um ou mais valores <see cref="T:System.Net.Sockets.TransmitFileOptions" />.</param>
        <summary>Envia o arquivo <paramref name="fileName" /> e buffers de dados a um <see cref="T:System.Net.Sockets.Socket" /> conectado usando o valor <see cref="T:System.Net.Sockets.TransmitFileOptions" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga requer o nome do arquivo que deseja enviar e uma combinação bit a bit de <xref:System.Net.Sockets.TransmitFileOptions> valores. O `preBuffer` parâmetro contiver dados deve preceder o arquivo. `postBuffer`contém dados que você deseja que execute o arquivo. Se `fileName` está no diretório de trabalho atual, que pode ser identificado somente com o nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados. Caracteres curinga ("... \\\myfile.txt ") e nomes de compartilhamento de UNC ("\\\\\\\shared diretório\\\myfile.txt ") são suportados.  
  
 O `flags` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos. Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Esse método usa o `TransmitFile` encontrar a função na API do Windows Sockets 2. Para obter mais informações sobre o `TransmitFile` função e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A>envia um arquivo de forma síncrona para o host remoto especificado no <xref:System.Net.Sockets.Socket.Connect%2A> ou <xref:System.Net.Sockets.Socket.Accept%2A> método. <xref:System.Net.Sockets.Socket.SendFile%2A>pode ser usado para ambos orientado a conexão e protocolos sem conexão.  
  
 Se você estiver usando um protocolo sem-conexão, você deve chamar <xref:System.Net.Sockets.Socket.Connect%2A> antes de chamar esse método; caso contrário, <xref:System.Net.Sockets.Socket.SendFile%2A> lança um <xref:System.Net.Sockets.SocketException>. Se você estiver usando um protocolo orientado a conexão, você deve usar <xref:System.Net.Sockets.Socket.Connect%2A> para estabelecer uma conexão de host remoto ou usar <xref:System.Net.Sockets.Socket.Accept%2A> para aceitar uma conexão de entrada.  
  
 Se você estiver usando um protocolo orientado a conexão, <xref:System.Net.Sockets.Socket.SendFile%2A> bloqueia até que o arquivo inteiro seja enviado. No modo sem bloqueio, <xref:System.Net.Sockets.Socket.SendFile%2A> pode ser concluído com êxito antes do arquivo inteiro foi enviado. Não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendFile%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir cria e se conecta a um soquete. O arquivo "test.txt" está localizado no diretório raiz da máquina local. Neste exemplo, criamos um prebuffer e postbuffer de dados e enviá-los ao host remoto com o arquivo. O padrão <xref:System.Net.Sockets.TransmitFileOptions> são usados.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O sistema operacional não é o Windows NT ou posterior.  
  
 \- ou -  
  
 O soquete não está conectado a um host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.InvalidOperationException">O objeto <see cref="T:System.Net.Sockets.Socket" /> não está no modo de bloqueio e não pode aceitar essa chamada síncrona.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo <paramref name="fileName" /> não foi encontrado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Envia uma coleção de arquivos ou buffers de dados na memória assincronamente para um objeto <see cref="T:System.Net.Sockets.Socket" /> conectado.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é usado para enviar uma coleção de arquivos ou na memória buffers de dados para o host remoto. O <xref:System.Net.Sockets.Socket> já deve estar conectado ao host remoto.  
  
 Se um <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> faz referência a um arquivo no diretório de trabalho, que pode ser identificado pelo nome do arquivo; caso contrário, o caminho completo e nome do arquivo devem ser especificados. Há suporte para curingas e nomes de compartilhamento UNC. Se o arquivo não for encontrado, <xref:System.IO.FileNotFoundException> é gerada.  
  
 Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 O <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriedade o `e` parâmetro fornece o provedor de serviços de soquetes de janela com informações adicionais sobre a transferência de arquivos. Para obter mais informações sobre como usar esse parâmetro, consulte <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Esse método usa a função TransmitPackets encontrada na API do Windows Sockets 2. Para obter mais informações sobre a função TransmitPackets e seus sinalizadores, consulte a documentação do Windows Sockets na biblioteca MSDN.  
  
 Embora destinado protocolos orientados a conexão, o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método também funciona para protocolos sem conexão, desde que você primeiro chamar o <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método para estabelecer um host remoto padrão. Com protocolos sem conexão, você também deve ser-se de que o tamanho do arquivo não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> lança um <xref:System.Net.Sockets.SocketException> exceção.  
  
 O <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é otimizado de acordo com o sistema operacional no qual ele é usado. Em edições do Windows server, o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é otimizado para alto desempenho.  
  
 Em edições de cliente do Windows, o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> método é otimizado para a utilização de recursos e de memória mínima.  
  
 Usar o <xref:System.Net.Sockets.TransmitFileOptions?displayProperty=nameWithType> sinalizador no <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> propriedade no `e` parâmetro pode fornecer benefícios significativos de desempenho. Se o thread iniciar o <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> chamada de método está sendo usada para cálculos pesados, é possível, embora seja improvável, que APCs podem ser impedidos de iniciar. Observe que há uma diferença entre APCs kernel e o modo de usuário. Inicie o kernel APCs quando um thread está em um estado de espera. Modo de usuário APCs iniciem quando um thread está em um estado de espera podem gerar alertas  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado na propriedade <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> não foi encontrado.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método. Essa exceção também ocorre se o <see cref="T:System.Net.Sockets.Socket" /> não estiver conectado a um host remoto.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Um <see cref="T:System.Net.Sockets.Socket" /> sem conexão está sendo usado e o arquivo sendo enviado excede o tamanho máximo do pacote de transporte subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica o tempo após o qual uma chamada <see cref="Overload:System.Net.Sockets.Socket.Send" /> síncrona atingirá o tempo limite.</summary>
        <value>O valor de tempo limite, em milissegundos. Se você definir a propriedade com um valor entre 1 e 499, o valor será alterado para 500. O valor padrão é 0, que indica um período de tempo limite infinito. Especificar -1 também indica um período de tempo limite infinito.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa opção se aplica a síncrona <xref:System.Net.Sockets.Socket.Send%2A> chama somente. Se o período de tempo limite for excedido, o <xref:System.Net.Sockets.Socket.Send%2A> método lançará um <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.SendTimeout%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor que -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="remoteEP">O <see cref="T:System.Net.EndPoint" /> que representa o destino dos dados.</param>
        <summary>Envia dados ao ponto de extremidade especificado.</summary>
        <returns>O número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga, o buffer de deslocamento padrão é 0, o número de bytes a enviar os padrões para o tamanho do `buffer` parâmetro e o <xref:System.Net.Sockets.SocketFlags> valor padrão é 0.  
  
 Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>. Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método. Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação. Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado. Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.  
  
 Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão. Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.  
  
 Bloquear soquetes será bloqueado até que todos os bytes no buffer são enviadas. Como um sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, ele pode enviar todos os bytes não o `buffer`. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envie todos os bytes de `buffer`. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados de saída é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
 Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado. Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">O <see cref="T:System.Net.EndPoint" /> que representa o local de destino dos dados.</param>
        <summary>Envia dados para um ponto de extremidade específico usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga, o buffer de deslocamento padrão é 0 e o número de bytes a enviar os padrões para o tamanho do `buffer`. Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>. Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método. Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação. Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado. Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.  
  
 Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão. Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.  
  
 Bloquear soquetes será bloqueado até que o solicitado todos os bytes de `buffer` são enviadas. Como um sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, ele pode enviar todos os bytes não o `buffer`. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envie todos os bytes de `buffer`. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
 Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado. Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado. <xref:System.Net.Sockets.SocketFlags>são passados para o <xref:System.Net.Sockets.Socket.SendTo%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">O <see cref="T:System.Net.EndPoint" /> que representa o local de destino dos dados.</param>
        <summary>Envia o número especificado de bytes de dados para um ponto de extremidade especificado usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga, o buffer de deslocamento padrão é 0. Se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>. Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método. Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação. Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado. Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.  
  
 Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão. Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.  
  
 Bloquear soquetes será bloqueado até que o número solicitado de bytes é enviado. Como um sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, pode não enviar todos os bytes solicitados em uma única operação. É responsabilidade do aplicativo para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
 Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado. Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Você também deve ser-se de que o número de bytes enviados não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado. O tamanho e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.SendTo%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O <paramref name="size" /> especificado excede o tamanho de <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz do tipo <see cref="T:System.Byte" /> que contém os dados a serem enviados.</param>
        <param name="offset">A posição no buffer de dados na qual o envio de dados deve começar.</param>
        <param name="size">O número de bytes a serem enviados.</param>
        <param name="socketFlags">Uma combinação bit a bit dos valores <see cref="T:System.Net.Sockets.SocketFlags" />.</param>
        <param name="remoteEP">O <see cref="T:System.Net.EndPoint" /> que representa o local de destino dos dados.</param>
        <summary>Envia o número especificado de bytes de dados para o ponto de extremidade especificado, começando no local especificado no buffer e usando o <see cref="T:System.Net.Sockets.SocketFlags" /> especificado.</summary>
        <returns>O número de bytes enviados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga, se você especificar o <xref:System.Net.Sockets.SocketFlags.DontRoute> sinalizador como o `socketflags` parâmetro, os dados que você está enviando não serão roteadas.  
  
 Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>. Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.Send%2A> método. Se você chamar o <xref:System.Net.Sockets.Socket.Connect%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendTo%2A>, o `remoteEP` parâmetro substituirá o host remoto padrão especificado para que enviar apenas a operação. Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método, porque o provedor de serviço subjacente atribuirá o número de porta e endereço de rede local mais adequado. Se for necessário identificar o número de porta e endereço de rede local atribuído, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.Socket.SendTo%2A> concluído com êxito.  
  
 Embora destinado protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendTo%2A> também funciona com protocolos orientados a conexão. Se você estiver usando um protocolo orientado a conexão, você deve primeiro estabelecer uma conexão de host remoto chamando o <xref:System.Net.Sockets.Socket.Connect%2A> método ou aceitar uma solicitação conexão entrada usando o <xref:System.Net.Sockets.Socket.Accept%2A> método. Se você estabelecer ou aceitar uma conexão de host remoto, não <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>. Você também pode estabelecer um host remoto padrão para um protocolo sem-conexão antes de chamar o <xref:System.Net.Sockets.Socket.SendTo%2A> método. Em ambos os casos, <xref:System.Net.Sockets.Socket.SendTo%2A> ignorará o `remoteEP` parâmetro e apenas enviar dados para o conectado ou host remoto padrão.  
  
 Bloquear soquetes será bloqueado até que o número solicitado de bytes é enviado. Desde sem bloqueio <xref:System.Net.Sockets.Socket> é concluída imediatamente, pode não enviar todos os bytes solicitados em uma única operação. É sua responsabilidade de aplicativos para controlar o número de bytes enviados e repita a operação até que o aplicativo envia o número solicitado de bytes. Também não há nenhuma garantia de que os dados que você enviar serão exibida imediatamente na rede. Para aumentar a eficiência da rede, o sistema subjacente pode atrasar transmissão até que uma quantidade significativa de dados out-indo é coletada. Uma execução bem-sucedida do <xref:System.Net.Sockets.Socket.SendTo%2A> método significa que o sistema subjacente tenha sido espaço para enviar seus dados para uma rede de buffer.  
  
 Se você estiver usando um protocolo sem-conexão no modo de bloqueio, <xref:System.Net.Sockets.Socket.SendTo%2A> será bloqueada até que o datagrama seja enviado. Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType>. Você também deve ser-se de que o tamanho não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendTo%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O exemplo de código a seguir envia um datagrama sem conexão com o host remoto especificado. O deslocamento, tamanho, e <xref:System.Net.Sockets.SocketFlags> são passados para o <xref:System.Net.Sockets.Socket.SendTo%2A> método.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="remoteEP" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="offset" /> é maior que o comprimento do <paramref name="buffer" />.  
  
 -ou-  
  
 <paramref name="size" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="size" /> é maior que o comprimento da subtração de <paramref name="buffer" /> e do valor do parâmetro <paramref name="offset" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">
          <paramref name="socketFlags" /> não é uma combinação válida de valores.  
  
 -ou-  
  
 Ocorre um erro de sistema operacional ao acessar o <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Security.SecurityException">Um chamador na pilha de chamadas não tem as permissões necessárias.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">O objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> a ser usado nessa operação de soquete assíncrono.</param>
        <summary>Envia dados de maneira assíncrona para um host remoto específico.</summary>
        <returns>Retorna <see langword="true" /> se a operação de E/S está pendente. O evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> será acionado após a conclusão da operação.  
  
 Retorna <see langword="false" /> se a operação de E/S foi concluída de forma síncrona. Nesse caso, o evento <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> no parâmetro <paramref name="e" /> não será gerado e o objeto <paramref name="e" /> passado como um parâmetro poderá ser examinado imediatamente depois que a chamada do método for retornada para recuperar o resultado da operação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.SendToAsync%2A> método inicia uma operação de envio assíncrono para o host remoto especificado no <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade o `e` parâmetro. Chamar o <xref:System.Net.Sockets.Socket.SendToAsync%2A> método lhe oferece a capacidade de enviar dados dentro de um thread de execução separado. Embora esse método destina-se a protocolos sem conexão, <xref:System.Net.Sockets.Socket.SendToAsync%2A> funciona com protocolos sem conexão e orientada a conexão.  
  
 Para ser notificado de conclusão, você deve criar um método de retorno de chamada que implementa EventHandler\<SocketAsyncEventArgs > delegar e anexe o retorno de chamada para o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento.  
  
 As seguintes propriedades e eventos no <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> objeto são necessárias para chamar com êxito este método:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 O chamador pode definir o <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> propriedade para qualquer objeto de estado do usuário desejado antes de chamar o <xref:System.Net.Sockets.Socket.SendToAsync%2A> método, para que as informações serão recuperáveis no método de retorno de chamada. Se o retorno de chamada precisa de mais informações do que um único objeto, uma pequena classe pode ser criada para manter as outras informações de estado necessárias como membros.  
  
 Se você estiver usando um protocolo orientado a conexão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método. Caso contrário, <xref:System.Net.Sockets.Socket.SendToAsync%2A> lançará um <xref:System.Net.Sockets.SocketException>. Ao usar um protocolo orientado a conexão, o <xref:System.Net.Sockets.Socket.SendToAsync%2A> método irá ignorar o <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade e enviar dados para o <xref:System.Net.EndPoint?displayProperty=nameWithType> estabelecido no <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método.  
  
 Se você estiver usando um protocolo sem-conexão, você não precisa estabelecer um host remoto padrão com o <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Você só precisa fazer isso se você pretende chamar o <xref:System.Net.Sockets.Socket.BeginSend%2A> ou <xref:System.Net.Sockets.Socket.SendAsync%2A> métodos. Se você chamar o <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, ou <xref:System.Net.Sockets.Socket.ConnectAsync%2A> método antes de chamar <xref:System.Net.Sockets.Socket.SendToAsync%2A>, o <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> propriedade substituirá o host remoto padrão especificado para que enviar apenas a operação. Também não é necessário chamar o <xref:System.Net.Sockets.Socket.Bind%2A> método. Nesse caso, o provedor de serviço subjacente atribuirá o mais apropriado local de rede IP endereço e número da porta. Use um número de porta de zero se quiser que o provedor de serviço subjacente para selecionar uma porta livre. Se for necessário identificar o número de porta e endereço IP atribuído de rede local, você pode usar o <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> propriedade após o <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> evento é sinalizado e delegados associados são chamados.  
  
 Se você deseja enviar dados para um endereço de difusão, você deve primeiro chamar o <xref:System.Net.Sockets.Socket.SetSocketOption%2A> opção de método e defina o soquete para <xref:System.Net.Sockets.SocketOptionName?displayProperty=nameWithType> como true. Você também deve ser-se de que o tamanho do buffer de não exceda o tamanho máximo do pacote do provedor de serviço subjacente. Se isso acontecer, o datagrama não será enviado e <xref:System.Net.Sockets.Socket.SendToAsync%2A> lançará um <xref:System.Net.Sockets.SocketException>.  
  
 Se você especificar o sinalizador de DontRoute a <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> propriedade, os dados que você está enviando não serão roteadas.  
  
 Para soquetes orientado a mensagens, deve-se ter cuidado para não exceder o tamanho máximo da mensagem de transporte subjacente. Se o tamanho do buffer excede o tamanho máximo do pacote do provedor de serviço subjacente, o datagrama não é enviado e <xref:System.Net.Sockets.Socket.SendToAsync%2A> lançará um <xref:System.Net.Sockets.SocketException>. A conclusão bem-sucedida de uma <xref:System.Net.Sockets.Socket.SendToAsync%2A> método não indica que os dados foi entregue com êxito.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> não pode ser nulo.</exception>
        <exception cref="T:System.InvalidOperationException">Uma operação de soquete já estava em andamento com o objeto <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> especificado no parâmetro <paramref name="e" />.</exception>
        <exception cref="T:System.NotSupportedException">É necessário o Windows XP ou posterior para esse método.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">O protocolo especificado é orientado para a conexão, mas o <see cref="T:System.Net.Sockets.Socket" /> ainda não está conectado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">O nível de proteção IP a ser definido nesse soquete.</param>
        <summary>Defina o nível de proteção IP em um soquete.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método permite restringir um um soquete IP ou IPv6 para escutar em um escopo especificado, como endereços com o mesmo locais do link ou prefixo local do site. Essa opção de soquete permite que os aplicativos colocar as restrições de acesso em soquetes IP ou IPv6. Essas restrições permitem que um aplicativo em execução em uma LAN privada proteja-se de modo simples e robusto contra ataques externos. Essa opção de soquete também pode ser usada para remover as restrições de acesso se o `level` parâmetro está definido como <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Essa opção de soquete amplia ou reduz o escopo de um soquete de escuta, permitindo acesso irrestrito de usuários públicos e privados, quando apropriado, ou restringindo o acesso somente ao mesmo site, conforme necessário.  
  
 Essa opção de soquete definiu os níveis de proteção especificados na enumeração <xref:System.Net.Sockets.IPProtectionLevel>.  
  
 O <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> método é usado para habilitar ou desabilitar a passagem de endereços de rede (NAT) para um <xref:System.Net.Sockets.Socket> instância. Percurso de NAT pode ser fornecido usando um túnel ISATAP, 6to4 ou Teredo.  
  
 Quando o `level` parâmetro está definido como <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, ou <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, isso desabilita o percurso de NAT para explicitamente um <xref:System.Net.Sockets.Socket> instância.  
  
 Quando o `level` parâmetro está definido como <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, isso pode permitir percurso de NAT para um <xref:System.Net.Sockets.Socket> dependendo de regras de firewall em vigor no sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="level" /> não pode ser <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />. O nível de proteção IP não pode ser definido como não especificado.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Net.Sockets.AddressFamily" /> do soquete deve ser <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">O valor da opção, representado como um <see cref="T:System.Boolean" />.</param>
        <summary>Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada para o valor especificado de <see cref="T:System.Boolean" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>. Definir `optionValue` para `true` para habilitar a opção, ou `false` para desabilitar a opção.  
  
 <xref:System.Net.Sockets.Socket>opções são agrupadas por nível de suporte de protocolo.  
  
 Abaixo estão as várias <xref:System.Net.Sockets.Socket> opções que podem ser definidas usando essa sobrecarga. Essas opções são agrupadas por apropriada <xref:System.Net.Sockets.SocketOptionLevel> valor. Se você pretende definir qualquer uma dessas opções, certifique-se de usar apropriada <xref:System.Net.Sockets.SocketOptionLevel> valor para o `optionLevel` parâmetro. A opção que você optar por definir deve ser especificada no `optionName` parâmetro. Se você deseja obter o valor atual de qualquer uma das opções listadas, use o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Para obter mais informações sobre essas opções, consulte o <xref:System.Net.Sockets.SocketOptionName> enumeração.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> exceção, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
   
  
## Examples  
 O exemplo de código a seguir abre um soquete e permite que o `DontLinger` e `OutOfBandInline` opções de soquete.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">O objeto <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Uma matriz do tipo <see cref="T:System.Byte" /> que representa o valor da opção.</param>
        <summary>Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada para o valor especificado, representado como uma matriz de bytes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>. Use essa sobrecarga de configurá-los <xref:System.Net.Sockets.Socket> opções que exigem uma matriz de bytes como um valor de opção.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Um valor da opção.</param>
        <summary>Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada para o valor inteiro especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>. Para uma opção com um <xref:System.Boolean> de tipo de dados, especifique um valor diferente de zero para habilitar a opção e um valor igual a zero para desabilitar a opção. Para uma opção com um tipo de dados inteiro, especifique o valor apropriado. <xref:System.Net.Sockets.Socket>opções são agrupadas por nível de suporte de protocolo.  
  
 Abaixo estão as várias <xref:System.Net.Sockets.Socket> opções que podem ser definidas usando essa sobrecarga. Essas opções são agrupadas por apropriada <xref:System.Net.Sockets.SocketOptionLevel>. Se você pretende definir qualquer uma dessas opções, certifique-se de usar apropriada <xref:System.Net.Sockets.SocketOptionLevel> para o `optionLevel` parâmetro. A opção que você optar por definir deve ser especificada no `optionName` parâmetro. Se você deseja obter o valor atual de qualquer uma das opções listadas, use o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=nameWithType>opções que podem ser definidas usando essa sobrecarga.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Para obter mais informações sobre essas opções, consulte o <xref:System.Net.Sockets.SocketOptionName> enumeração.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionLevel" />.</param>
        <param name="optionName">Um dos valores de <see cref="T:System.Net.Sockets.SocketOptionName" />.</param>
        <param name="optionValue">Uma <see cref="T:System.Net.Sockets.LingerOption" /> ou <see cref="T:System.Net.Sockets.MulticastOption" /> que contém o valor da opção.</param>
        <summary>Define a opção <see cref="T:System.Net.Sockets.Socket" /> especificada com o valor especificado, representado como um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket>opções determinam o comportamento do atual <xref:System.Net.Sockets.Socket>. Use essa sobrecarga para definir o <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, e <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> opções. Para o <xref:System.Net.Sockets.SocketOptionName.Linger> opção, use <xref:System.Net.Sockets.Socket> para o `optionLevel` parâmetro. Para <xref:System.Net.Sockets.SocketOptionName.AddMembership> e <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. Se você deseja obter o valor atual de qualquer uma das opções listadas acima, use o <xref:System.Net.Sockets.Socket.GetSocketOption%2A> método.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
   
  
## Examples  
 O seguinte exemplo de código define o <xref:System.Net.Sockets.LingerOption> e <xref:System.Net.Sockets.Socket.Send%2A> valores de tempo limite.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="optionValue" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Um dos valores <see cref="T:System.Net.Sockets.SocketShutdown" /> que especifica a operação que não será mais permitida.</param>
        <summary>Desabilita envios e recebimentos em um <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao usar uma conexão orientada <xref:System.Net.Sockets.Socket>, sempre chamar o <xref:System.Net.Sockets.Socket.Shutdown%2A> método antes de fechar o <xref:System.Net.Sockets.Socket>. Isso garante que todos os dados são enviadas e recebidas no soquete conectado antes de ser fechado.  
  
 Chamar o <xref:System.Net.Sockets.Socket.Close%2A> método para liberar todos os recursos gerenciados e associados a <xref:System.Net.Sockets.Socket>. Não tente reutilizar o <xref:System.Net.Sockets.Socket> após fechar.  
  
 A tabela a seguir mostra o <xref:System.Net.Sockets.SocketShutdown> valores de enumeração válidos para o `how` parâmetro.  
  
|Valor|Descrição|  
|-----------|-----------------|  
|Enviar|Desabilitar envio neste <xref:System.Net.Sockets.Socket>.|  
|Receber|Desabilitar o recebimento neste <xref:System.Net.Sockets.Socket>.|  
|Ambos|Desabilitar enviando e recebendo neste <xref:System.Net.Sockets.Socket>.|  
  
 Configuração `how` para <xref:System.Net.Sockets.SocketShutdown.Send> Especifica que subsequentes chamadas para <xref:System.Net.Sockets.Socket.Send%2A> não são permitidas. Se você estiver usando um sem-conexão <xref:System.Net.Sockets.Socket>, especificando <xref:System.Net.Sockets.SocketShutdown.Send> não terá efeito.  
  
 Configuração `how` para <xref:System.Net.Sockets.SocketShutdown.Receive> Especifica que subsequentes chamadas para <xref:System.Net.Sockets.Socket.Receive%2A> não são permitidas. Isso não tem nenhum efeito em camadas inferiores de protocolo. Se você estiver usando um protocolo orientado a conexão, a conexão será encerrada, se uma das seguintes condições for verdadeira após uma chamada para <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Dados estão no buffer de rede de entrada aguardando para ser recebida.  
  
-   Mais dados são recebidos.  
  
 Se você estiver usando um protocolo sem-conexão, datagramas são aceitos e em fila. No entanto, se nenhum espaço de buffer está disponível para os datagramas de entrada adicionais, eles serão descartados e nenhum erro será retornado para o remetente. Usando <xref:System.Net.Sockets.Socket.Shutdown%2A> em sem uma conexão <xref:System.Net.Sockets.Socket> não é recomendado.  
  
 Configuração `how` para <xref:System.Net.Sockets.SocketShutdown.Both> desabilita os dois envia e recebe conforme descrito acima.  
  
> [!NOTE]
>  Se você receber um <xref:System.Net.Sockets.SocketException> ao chamar o <xref:System.Net.Sockets.Socket.Shutdown%2A> método, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
> [!NOTE]
>  Esse membro emite o rastreamento de informações quando você ativa o rastreamento de rede em seu aplicativo. Para obter mais informações, consulte [rastreamento de rede no .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 O seguinte exemplo de código usa <xref:System.Net.Sockets.Socket.Shutdown%2A> para desabilitar o <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Um dos valores de <see cref="T:System.Net.Sockets.SocketType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A>é somente leitura e é definido quando o <xref:System.Net.Sockets.Socket> é criado.  
  
   
  
## Examples  
 O código a seguir exemplo exibe o <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, e <xref:System.Net.Sockets.ProtocolType> para o console.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o suporte para IPv4 está disponível e habilitado no host atual.</summary>
        <value>
          <see langword="true" />Se o host atual oferece suporte o protocolo IPv4. Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o Framework oferece suporte a IPv6 para determinados obsoleto <see cref="T:System.Net.Dns" /> membros.</summary>
        <value>
          <see langword="true" />Se o Framework oferece suporte a IPv6 para determinados obsoleto <see cref="T:System.Net.Dns" /> métodos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O sistema operacional pode oferecer suporte a protocolos IPv4 e IPv6.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que especifica o valor TTL (vida útil) de pacotes IP (Protocolo de Internet) enviados pelo <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>O valor TTL.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de TTL indica o número máximo de roteadores que o pacote pode percorrer antes do roteador descarta o pacote e uma mensagem de protocolo ICMP (Internet Control) "TTL excedido" mensagem de erro é retornada para o remetente.  
  
 O valor de TTL pode ser definido como um valor de 0 a 255. Quando essa propriedade não é definida, o valor TTL padrão para um soquete é 32.  
  
 A definição dessa propriedade em um soquete do protocolo de controle de transmissão (TCP) é ignorada pela pilha de TCP/IP, se foi estabelecida uma conexão bem-sucedida com o soquete.  
  
 Se você receber um <xref:System.Net.Sockets.SocketException>, use o <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> propriedade para obter o código de erro específico. Depois de obter esse código, consulte a versão do Windows Sockets 2 documentação de códigos de erro de API na biblioteca do MSDN para obter uma descrição detalhada do erro.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o uso do <xref:System.Net.Sockets.Socket.Ttl%2A> propriedade.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor TTL não pode ser definido como um número negativo.</exception>
        <exception cref="T:System.NotSupportedException">Essa propriedade pode ser definida apenas para soquetes nas famílias <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> ou <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ocorreu um erro ao tentar acessar o soquete. Esse erro também é retornado quando tiver sido feita uma tentativa para definir o TTL como um valor maior que 255.</exception>
        <exception cref="T:System.ObjectDisposedException">O <see cref="T:System.Net.Sockets.Socket" /> foi fechado.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica se o soquete deve usar apenas o modo de E/S Sobreposta.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Net.Sockets.Socket" /> usa apenas E/S sobreposta; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina essa propriedade como `true` para um <xref:System.Net.Sockets.Socket> você pretende chamar <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. Caso contrário, a estrutura pode atribuir uma porta de conclusão no soquete, o que impeça o uso de <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O soquete foi associado a uma porta de conclusão.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
