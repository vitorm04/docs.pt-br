<Type Name="Enumerable" FullName="System.Linq.Enumerable">
  <TypeSignature Language="C#" Value="public static class Enumerable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Enumerable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Enumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Linq</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um conjunto de métodos <see langword="static" /> (<see langword="Shared" /> no Visual Basic) para consultar objetos que implementam <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos nesta classe fornecem uma implementação de operadores de consulta padrão para consultar dados de fontes que implementam <xref:System.Collections.Generic.IEnumerable%601>. Os operadores de consulta padrão são métodos de finalidade geral que seguem o [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] padrão e permitem expressar operações de passagem, filtragem e projeção sobre os dados em qualquer um. Linguagem de programação baseado em rede.  
  
 A maioria dos métodos nesta classe são definidos como métodos de extensão que estendem <xref:System.Collections.Generic.IEnumerable%601>. Isso significa que pode ser chamados como um método de instância em qualquer objeto que implementa <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Métodos que são usados em uma consulta que retorna uma sequência de valores não consomem os dados de destino até que o objeto de consulta é enumerado. Isso é conhecido como execução adiada. Métodos que são usados em uma consulta que retorna um valor de singleton execute e consumam os dados de destino imediatamente.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Aggregate&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Aggregate&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TSource,TSource&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Aggregate&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, !!TSource, !!TSource&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``0,``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="func" Type="System.Func&lt;TSource,TSource,TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> no qual será feita a agregação.</param>
        <param name="func">Uma função de acumulador a ser invocada em cada elemento.</param>
        <summary>Aplica uma função de acumulador a uma sequência.</summary>
        <returns>O valor final do acumulador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> método simplifica a executar um cálculo em uma sequência de valores. Esse método funciona chamando `func` uma vez para cada elemento na `source` exceto a primeira delas. Cada vez que `func` é chamado, <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29> passa ambos o elemento da sequência e um valor agregado (como o primeiro argumento para `func`). O primeiro elemento da `source` é usado como o valor inicial de agregação. O resultado de `func` substitui o valor agregado anterior. <xref:System.Linq.Enumerable.Aggregate%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%600%2C%60%600%7D%29>Retorna o resultado final da `func`.  
  
 Esta sobrecarga do <xref:System.Linq.Enumerable.Aggregate%2A> método não é adequado para todos os casos porque ele usa o primeiro elemento da `source` como o valor inicial de agregação. Você deve escolher outra sobrecarga se o valor de retorno deve incluir somente os elementos de `source` que atendem a uma determinada condição. Por exemplo, essa sobrecarga não é confiável para calcular a soma dos números par `source`. O resultado será incorreto se o primeiro elemento é ímpar em vez do mesmo.  
  
 Para simplificar as operações de agregação comuns, os operadores de consulta padrão também incluem um método de contagem de uso geral, <xref:System.Linq.Enumerable.Count%2A>e quatro métodos de agregação numéricas, ou seja, <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, e <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como inverter a ordem das palavras em uma cadeia de caracteres usando <xref:System.Linq.Enumerable.Aggregate%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#1)]
 [!code-vb[System.Linq.Enumerable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="func" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate&gt;">
      <MemberSignature Language="C#" Value="public static TAccumulate Aggregate&lt;TSource,TAccumulate&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TAccumulate Aggregate&lt;TSource, TAccumulate&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TAccumulate</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TAccumulate">O tipo do valor do acumulador.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> no qual será feita a agregação.</param>
        <param name="seed">O valor inicial do acumulador.</param>
        <param name="func">Uma função de acumulador a ser invocada em cada elemento.</param>
        <summary>Aplica uma função de acumulador a uma sequência. O valor de semente especificado é usado como o valor inicial do acumulador.</summary>
        <returns>O valor final do acumulador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> método simplifica a executar um cálculo em uma sequência de valores. Esse método funciona chamando `func` uma vez para cada elemento na `source`. Cada vez que `func` é chamado, <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29> passa ambos o elemento da sequência e um valor agregado (como o primeiro argumento para `func`). O valor de `seed` parâmetro é usado como o valor inicial de agregação. O resultado de `func` substitui o valor agregado anterior. <xref:System.Linq.Enumerable.Aggregate%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%29>Retorna o resultado final da `func`.  
  
 Para simplificar as operações de agregação comuns, os operadores de consulta padrão também incluem um método de contagem de uso geral, <xref:System.Linq.Enumerable.Count%2A>e quatro métodos de agregação numéricas, ou seja, <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, e <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Aggregate%2A> para aplicar uma função acumulador e usar um valor de semente.  
  
 [!code-csharp[System.Linq.Enumerable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#2)]
 [!code-vb[System.Linq.Enumerable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="func" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Aggregate&lt;TSource,TAccumulate,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TAccumulate seed, Func&lt;TAccumulate,TSource,TAccumulate&gt; func, Func&lt;TAccumulate,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Aggregate&lt;TSource, TAccumulate, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TAccumulate seed, class System.Func`3&lt;!!TAccumulate, !!TSource, !!TAccumulate&gt; func, class System.Func`2&lt;!!TAccumulate, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Aggregate``3(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TAccumulate" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="seed" Type="TAccumulate" />
        <Parameter Name="func" Type="System.Func&lt;TAccumulate,TSource,TAccumulate&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TAccumulate,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TAccumulate">O tipo do valor do acumulador.</typeparam>
        <typeparam name="TResult">O tipo do valor resultante.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> no qual será feita a agregação.</param>
        <param name="seed">O valor inicial do acumulador.</param>
        <param name="func">Uma função de acumulador a ser invocada em cada elemento.</param>
        <param name="resultSelector">Uma função para transformar o valor final do acumulador no valor de resultado.</param>
        <summary>Aplica uma função de acumulador a uma sequência. O valor de semente especificado é usado como o valor inicial do acumulador e a função especificada é usada para selecionar o valor do resultado.</summary>
        <returns>O valor final do acumulador transformado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> método simplifica a executar um cálculo em uma sequência de valores. Esse método funciona chamando `func` uma vez para cada elemento na `source`. Cada vez que `func` é chamado, <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29> passa ambos o elemento da sequência e um valor agregado (como o primeiro argumento para `func`). O valor de `seed` parâmetro é usado como o valor inicial de agregação. O resultado de `func` substitui o valor agregado anterior. O resultado final da `func` é passado para `resultSelector` para obter o resultado final de <xref:System.Linq.Enumerable.Aggregate%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%601%2CSystem.Func%7B%60%601%2C%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%29>.  
  
 Para simplificar as operações de agregação comuns, os operadores de consulta padrão também incluem um método de contagem de uso geral, <xref:System.Linq.Enumerable.Count%2A>e quatro métodos de agregação numéricas, ou seja, <xref:System.Linq.Enumerable.Min%2A>, <xref:System.Linq.Enumerable.Max%2A>, <xref:System.Linq.Enumerable.Sum%2A>, e <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Aggregate%2A> para aplicar uma função acumulador e um seletor de resultado.  
  
 [!code-csharp[System.Linq.Enumerable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#3)]
 [!code-vb[System.Linq.Enumerable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="func" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="All&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool All&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool All&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.All``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos aos quais o predicado será aplicado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Determina se todos os elementos de uma sequência atendem a uma condição.</summary>
        <returns>
          <see langword="true" /> se todos os elementos da sequência de origem passarem no teste no predicado especificado ou se a sequência for vazia; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método não retorna todos os elementos de uma coleção. Em vez disso, ele determina se todos os elementos de uma coleção satisfazem uma condição.  
  
 A enumeração de `source` é interrompida assim que o resultado pode ser determinado.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into All()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.All%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.All%2A> para determinar se todos os elementos em uma sequência satisfazem uma condição. Variável `allStartWithB` é true se todos os nomes de animal de estimação começam com "B" ou se o `pets` matriz está vazia.  
  
 [!code-csharp[System.Linq.Enumerable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#4)]
 [!code-vb[System.Linq.Enumerable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#4)]  
  
 O valor booleano que o <xref:System.Linq.Enumerable.All%2A> método retorna normalmente é usada no predicado de um `where` cláusula (`Where` cláusula [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) ou uma chamada direta para o <xref:System.Linq.Enumerable.Where%2A> método. O exemplo a seguir demonstra esse uso do `All` método.  
  
 [!code-csharp[System.Linq.Enumerable#129](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#129)]
 [!code-vb[System.Linq.Enumerable#129](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#129)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> a ser verificado se está vazio.</param>
        <summary>Determina se uma sequência contém elementos.</summary>
        <returns>
          <see langword="true" /> se a sequência de origem contiver elementos; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método não retorna qualquer um elemento de uma coleção. Em vez disso, ele determina se a coleção contém elementos.  
  
 A enumeração de `source` é interrompida assim que o resultado pode ser determinado.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Any()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Any%2A> para determinar se uma sequência contém elementos.  
  
 [!code-csharp[System.Linq.Enumerable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#5)]
 [!code-vb[System.Linq.Enumerable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#5)]  
  
 O valor booleano que o <xref:System.Linq.Enumerable.Any%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método retorna normalmente é usada no predicado de um `where` cláusula (`Where` cláusula [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) ou uma chamada direta para o <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método. O exemplo a seguir demonstra esse uso do `Any` método.  
  
 [!code-csharp[System.Linq.Enumerable#130](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#130)]
 [!code-vb[System.Linq.Enumerable#130](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#130)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Any&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Any&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Any&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> a cujos elementos o predicado será aplicado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Determina se algum elemento de uma sequência atende a uma condição.</summary>
        <returns>
          <see langword="true" /> se algum elemento na sequência de origem for aprovado no teste do predicado especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Este método não retorna qualquer um elemento de uma coleção. Em vez disso, ele determina se os elementos de uma coleção satisfazem uma condição.  
  
 A enumeração de `source` é interrompida assim que o resultado pode ser determinado.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Any()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Any%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Any%2A> para determinar se qualquer elemento em uma sequência satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#6)]
 [!code-vb[System.Linq.Enumerable#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Append&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Append&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Append``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores.</param>
        <param name="element">O valor a ser acrescentado a <paramref name="source" />.</param>
        <summary>Acrescenta um valor ao final da sequência.</summary>
        <returns>Uma nova sequência que termina com <paramref name="element" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AsEnumerable&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; AsEnumerable&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; AsEnumerable&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.AsEnumerable``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">A sequência a ser digitada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Retorna a entrada digitada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>A sequência de entrada digitada como <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método não tem nenhum efeito diferente para alterar o tipo de tempo de compilação de `source` de um tipo que implementa <xref:System.Collections.Generic.IEnumerable%601> para <xref:System.Collections.Generic.IEnumerable%601> em si.  
  
 <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29>pode ser usado para escolher entre as implementações de consulta quando uma sequência implementa <xref:System.Collections.Generic.IEnumerable%601> , mas também tem um conjunto diferente de métodos de consulta pública disponíveis. Por exemplo, dada uma classe genérica `Table` que implementa <xref:System.Collections.Generic.IEnumerable%601> e tem seus próprios métodos como `Where`, `Select`, e `SelectMany`, uma chamada para `Where` invocaria público `Where` método `Table`. Um `Table` tipo que representa uma tabela de banco de dados pode ter um `Where` método que usa o argumento como uma árvore de expressão de predicado e converte a árvore para o SQL para execução remota. Se a execução remota não for desejada, por exemplo, porque o predicado invoca um método de local, o <xref:System.Linq.Enumerable.AsEnumerable%2A> método pode ser usado para ocultar os métodos personalizados e disponibilizar os operadores de consulta padrão em vez disso.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.AsEnumerable%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para ocultar um tipo do personalizado `Where` método quando a implementação do operador de consulta padrão é desejada.  
  
 [!code-csharp[System.Linq.Enumerable#108](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#108)]
 [!code-vb[System.Linq.Enumerable#108](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#108)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static decimal Average (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular a média de uma sequência de valores.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a soma dos elementos é grande demais para representar como um <xref:System.Double>, esse método retorna infinito positivo ou negativo.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static double Average (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a soma dos elementos é grande demais para representar como um <xref:System.Double>, esse método retorna infinito positivo ou negativo.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos para cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#12)]
 [!code-vb[System.Linq.Enumerable#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average">
      <MemberSignature Language="C#" Value="public static float Average (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> para realizar o cálculo da média.</param>
        <summary>Computa a média de uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#8)]
 [!code-vb[System.Linq.Enumerable#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Decimal" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Double" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int32" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos da fonte.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int64" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Decimal" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Double" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int32" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma dos elementos na sequência é maior do que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Int64" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#16)]
 [!code-vb[System.Linq.Enumerable#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Single" /> que permitem valor nulo obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores ou <see langword="null" />, se a sequência de origem estiver vazia ou contiver somente valores que são <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Average&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Average&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Average&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Average``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para cálculo da média.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a média de uma sequência de valores <see cref="T:System.Single" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A média da sequência de valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Average()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Average%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Average%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para calcular uma média.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#18)]
 [!code-vb[System.Linq.Enumerable#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cast&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Cast&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Cast&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Cast``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo para converter os elementos de <c>fonte</c> para.</typeparam>
        <param name="source">O <see cref="T:System.Collections.IEnumerable" /> que contém os elementos para ser convertido no tipo <c>TResult</c>.</param>
        <summary>Converte os elementos de um <see cref="T:System.Collections.IEnumerable" /> para o tipo especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém cada elemento da sequência de origem convertido para o tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> método permite que os operadores de consulta padrão a ser invocado em coleções não genéricas, fornecendo as informações do tipo necessário. Por exemplo, <xref:System.Collections.ArrayList> não implementa <xref:System.Collections.Generic.IEnumerable%601>, mas chamando <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> no <xref:System.Collections.ArrayList> do objeto, os operadores de consulta padrão, em seguida, podem ser usados para a sequência de consulta.  
  
 Se um elemento não pode ser convertido no tipo `TResult`, esse método lançará uma exceção. Para obter apenas os elementos que podem ser convertidos no tipo `TResult`, use o <xref:System.Linq.Enumerable.OfType%2A> método em vez de <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 Em uma expressão de consulta, uma variável de iteração tipada explicitamente se traduz em uma chamada de <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>. Este exemplo mostra a sintaxe para uma variável de intervalo de tipo explícito.  
  
```csharp  
from int i in objects  
```  
  
```vb  
From i As Integer In objects  
```  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29> para habilitar o uso de operadores de consulta padrão em um <xref:System.Collections.ArrayList>.  
  
 [!code-csharp[System.Linq.Enumerable#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#19)]
 [!code-vb[System.Linq.Enumerable#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">Um elemento na sequência não pode ser convertido para o tipo <paramref name="TResult" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Concat&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Concat&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Concat``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">A primeira sequência a ser concatenada.</param>
        <param name="second">A sequência a ser concatenada com a primeira sequência.</param>
        <summary>Concatena duas sequências.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos concatenados das duas sequências de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método difere de <xref:System.Linq.Enumerable.Union%2A> método porque o <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método retorna todos os elementos originais nas sequências de entrada. O <xref:System.Linq.Enumerable.Union%2A> método retorna apenas os elementos exclusivos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para concatenar duas sequências.  
  
 [!code-csharp[System.Linq.Enumerable#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#20)]
 [!code-vb[System.Linq.Enumerable#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#20)]  
  
 É uma maneira alternativa de concatenar duas sequências construir uma coleção, por exemplo uma matriz de sequências e, em seguida, aplicar o <xref:System.Linq.Enumerable.SelectMany%2A> método, passando a função de seletor de identidade. O exemplo a seguir demonstra esse uso do <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
 [!code-csharp[System.Linq.Enumerable#112](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#112)]
 [!code-vb[System.Linq.Enumerable#112](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#112)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência na qual um valor será localizado.</param>
        <param name="value">O valor a ser localizado na sequência.</param>
        <summary>Determina se uma sequência contém um elemento especificado usando o comparador de igualdade padrão.</summary>
        <returns>
          <see langword="true" /> se a sequência de origem contiver um elemento que tem o valor especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.ICollection%601>, o `Contains` método em que a implementação é chamado para obter o resultado. Caso contrário, este método determina se `source` contém o elemento especificado.  
  
 Enumeração é encerrada, assim como um elemento correspondente foi encontrado.  
  
 Elementos são comparados ao valor especificado usando o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Contains%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para determinar se uma matriz contém um elemento específico.  
  
 [!code-csharp[System.Linq.Enumerable#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#21)]
 [!code-vb[System.Linq.Enumerable#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool Contains&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource value, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Contains&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource value, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Contains``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="value" Type="TSource" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência na qual um valor será localizado.</param>
        <param name="value">O valor a ser localizado na sequência.</param>
        <param name="comparer">Um comparador de igualdade para comparar valores.</param>
        <summary>Determina se uma sequência contém um elemento especificado usando um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
        <returns>
          <see langword="true" /> se a sequência de origem contiver um elemento que tem o valor especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Enumeração é encerrada, assim como um elemento correspondente foi encontrado.  
  
 Se `comparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar os elementos para o valor especificado.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Contains%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar essa comparação, você pode usar uma sequência de `Product` objetos no <xref:System.Linq.Enumerable.Contains%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#6](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#6)]
 [!code-vb[CSLINQCustomComparer#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência que contém os elementos a serem contados.</param>
        <summary>Retorna o número de elementos em uma sequência.</summary>
        <returns>O número de elementos na sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.ICollection%601>, que a implementação é usada para obter a contagem de elementos. Caso contrário, este método determina a contagem.  
  
 Use o <xref:System.Linq.Enumerable.LongCount%2A> método quando você espera e deseja permitir que o resultado seja maior que <xref:System.Int32.MaxValue>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Count()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para contar os elementos em uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#22)]
 [!code-vb[System.Linq.Enumerable#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#22)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos no <paramref name="source" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Count&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Count&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Count&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Count``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência que contém os elementos a serem testados e contados.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna um número que representa quantos elementos na sequência especificada atendem a uma condição.</summary>
        <returns>Um número que representa quantos elementos na sequência atendem à condição na função de predicado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.ICollection%601>, que a implementação é usada para obter a contagem de elementos. Caso contrário, este método determina a contagem.  
  
 Você deve usar o <xref:System.Linq.Enumerable.LongCount%2A> método quando você espera e deseja permitir que o resultado seja maior que <xref:System.Int32.MaxValue>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Count()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Count%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para contar os elementos em uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#23)]
 [!code-vb[System.Linq.Enumerable#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos no <paramref name="source" /> é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">A sequência para a qual será retornado um valor padrão se ela estiver vazia.</param>
        <summary>Retornará os elementos da sequência especificada ou o valor padrão do parâmetro de tipo em uma coleção de singletons se a sequência estiver vazia.</summary>
        <returns>Um objeto <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém o valor padrão do tipo <paramref name="TSource" /> se <paramref name="source" /> estiver vazio; caso contrário, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
 Esse método pode ser usado para produzir uma junção externa esquerda quando ele é combinado com o <xref:System.Linq.Enumerable.GroupJoin%2A>) método.  
  
   
  
## Examples  
 Os exemplos de código a seguir demonstram como usar <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para fornecer um valor padrão caso a sequência de origem está vazia.  
  
 Este exemplo usa uma sequência não vazia.  
  
 [!code-csharp[System.Linq.Enumerable#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#24)]
 [!code-vb[System.Linq.Enumerable#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#24)]  
  
 Este exemplo usa uma sequência vazia.  
  
 [!code-csharp[System.Linq.Enumerable#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#25)]
 [!code-vb[System.Linq.Enumerable#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultIfEmpty&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; DefaultIfEmpty&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; DefaultIfEmpty&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.DefaultIfEmpty``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="defaultValue" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">A sequência para a qual será retornado o valor especificado se ela estiver vazia.</param>
        <param name="defaultValue">O valor a ser retornado se a sequência estiver vazia.</param>
        <summary>Retorna os elementos da sequência especificada ou o valor especificado em uma coleção de singletons se a sequência está vazia.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém <paramref name="defaultValue" /> se <paramref name="source" /> está vazio; caso contrário, <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Esse método pode ser usado para produzir uma junção externa esquerda quando ele é combinado com o <xref:System.Linq.Enumerable.GroupJoin%2A>) método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método e especificar um valor padrão. A primeira sequência não está vazia e a segunda sequência está vazia.  
  
 [!code-csharp[System.Linq.Enumerable#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#26)]
 [!code-vb[System.Linq.Enumerable#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#26)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Distinct&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna os elementos distintos de uma sequência.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A sequência de resultado está fora de ordem.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">A sequência da qual os elementos duplicados serão removidos.</param>
        <summary>Retorna os elementos distintos de uma sequência usando o comparador de igualdade padrão para comparar valores.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos distintos da sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método retorna uma sequência não ordenada que não contenha valores duplicados. Ele usa o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Distinct` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Distinct%2A>.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar os valores dos tipos que implementam o <xref:System.IEquatable%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar essa interface e fornecer sua própria <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
 Para obter um exemplo que usa <xref:System.Collections.Generic.IEqualityComparer%601> para definir um comparador personalizado, consulte <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para retornar elementos distintos de uma sequência de números inteiros.  
  
 [!code-csharp[System.Linq.Enumerable#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#27)]
 [!code-vb[System.Linq.Enumerable#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#27)]  
  
 Se você quiser retornar elementos distintos de sequências de objetos de um tipo de dados personalizado, você precisa implementar o <xref:System.IEquatable%601> interface genérica na classe. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#1)]
 [!code-vb[CSLINQEncapsulatedComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#1)]  
  
 Depois que você implementar essa interface, você pode usar uma sequência de `Product` objetos no <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#5)]
 [!code-vb[CSLINQEncapsulatedComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Distinct&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Distinct&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Distinct&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">A sequência da qual os elementos duplicados serão removidos.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Retorna os elementos distintos de uma sequência usando um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar valores.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos distintos da sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.Distinct%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método retorna uma sequência não ordenada que não contenha valores duplicados. Se c`omparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Distinct%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar essa comparação, você pode usar uma sequência de `Product` objetos no <xref:System.Linq.Enumerable.Distinct%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#5](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#5)]
 [!code-vb[CSLINQCustomComparer#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAt&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAt&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAt&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAt``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="index">O índice baseado em zero do elemento a ser recuperado.</param>
        <summary>Retorna o elemento de um índice especificado em uma sequência.</summary>
        <returns>O elemento na posição especificada na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.IList%601>, que a implementação é usada para obter o elemento no índice especificado. Caso contrário, esse método obtém o elemento especificado.  
  
 Este método lança uma exceção se `index` está fora do intervalo. Para retornar em vez disso, um valor padrão quando o índice especificado está fora do intervalo, use o <xref:System.Linq.Enumerable.ElementAtOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ElementAt%2A> para retornar um elemento em uma posição específica.  
  
 [!code-csharp[System.Linq.Enumerable#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#28)]
 [!code-vb[System.Linq.Enumerable#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0 ou maior ou igual ao número de elementos em <paramref name="source" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ElementAtOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource ElementAtOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource ElementAtOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ElementAtOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="index">O índice baseado em zero do elemento a ser recuperado.</param>
        <summary>Retorna o elemento em um índice especificado em uma sequência ou um valor padrão se o índice estiver fora do intervalo.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) se o índice estiver fora dos limites da sequência de origem; caso contrário, o elemento na posição especificada na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o tipo de `source` implementa <xref:System.Collections.Generic.IList%601>, que a implementação é usada para obter o elemento no índice especificado. Caso contrário, esse método obtém o elemento especificado.  
  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ElementAtOrDefault%2A>. Este exemplo usa um índice está fora dos limites da matriz.  
  
 [!code-csharp[System.Linq.Enumerable#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#29)]
 [!code-vb[System.Linq.Enumerable#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#29)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Empty&lt;TResult&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Empty&lt;TResult&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="TResult">O tipo a ser atribuído ao parâmetro de tipo genérico <see cref="T:System.Collections.Generic.IEnumerable`1" /> retornado.</typeparam>
        <summary>Retorna um <see cref="T:System.Collections.Generic.IEnumerable`1" /> vazio que tem o argumento do tipo especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> vazio cujo tipo de argumento é <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Empty%60%601> método armazena em cache uma sequência vazia do tipo `TResult`. Quando o objeto retorna é enumerado, ele gera elementos de nenhum.  
  
 Em alguns casos, esse método é útil para passar uma sequência vazia para um método definido pelo usuário que usa um <xref:System.Collections.Generic.IEnumerable%601>. Ele também pode ser usado para gerar um elemento neutro para métodos como <xref:System.Linq.Enumerable.Union%2A>. Consulte a seção de exemplo para obter um exemplo deste uso de <xref:System.Linq.Enumerable.Empty%60%601>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Empty%60%601> para gerar um vazio <xref:System.Collections.Generic.IEnumerable%601>.  
  
 [!code-csharp[System.Linq.Enumerable#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#30)]
 [!code-vb[System.Linq.Enumerable#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#30)]  
  
 O exemplo de código a seguir demonstra um aplicativo de possíveis de <xref:System.Linq.Enumerable.Empty%60%601> método. O <xref:System.Linq.Enumerable.Aggregate%2A> método é aplicado a uma coleção de matrizes de cadeia de caracteres. Os elementos de cada matriz na coleção são adicionados ao resultante <xref:System.Collections.Generic.IEnumerable%601> somente se essa matriz contém quatro ou mais elementos. <xref:System.Linq.Enumerable.Empty%2A>é usado para gerar o valor de semente para <xref:System.Linq.Enumerable.Aggregate%2A> porque se nenhuma matriz de na coleção tem quatro ou mais elementos, somente a sequência vazia será retornada.  
  
 [!code-csharp[System.Linq.Enumerable#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#31)]
 [!code-vb[System.Linq.Enumerable#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#31)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que não são também em <c>segundo</c> será retornado.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que também ocorrem na primeira sequência farão com que esses elementos sejam removidos da sequência retornada.</param>
        <summary>Produz a diferença de conjunto de duas sequências usando o comparador de igualdade padrão para comparar os valores.</summary>
        <returns>Uma sequência que contém a diferença de conjunto dos elementos das duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 A diferença de conjunto de dois conjuntos é definida como os membros do primeiro conjunto que não aparecem no segundo conjunto.  
  
> [!NOTE]
>  Este método retorna os elementos no `first` que não aparecem no `second`. Ele não retorna esses elementos também `second` que não aparecem no `first`.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar os valores dos tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar essa interface e fornecer sua própria <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método para comparar duas sequências de números e retorna elementos que aparecem somente na primeira sequência.  
  
 [!code-csharp[System.Linq.Enumerable#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#34)]
 [!code-vb[System.Linq.Enumerable#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#34)]  
  
 Se você quiser comparar sequências de objetos de um tipo de dados personalizado, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em um helperclass. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois que você implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.Except%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#7)]
 [!code-vb[CSLINQEncapsulatedComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Except&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Except&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Except&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que não são também em <c>segundo</c> será retornado.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos que também ocorrem na primeira sequência farão com que esses elementos sejam removidos da sequência retornada.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Produz a diferença de conjunto de duas sequências usando o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar os valores.</summary>
        <returns>Uma sequência que contém a diferença de conjunto dos elementos das duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se c`omparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Except%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar essa comparação, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.Except%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#7](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#7)]
 [!code-vb[CSLINQCustomComparer#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o primeiro elemento será retornado.</param>
        <summary>Retorna o primeiro elemento de uma sequência.</summary>
        <returns>O primeiro elemento na sequência especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método lançará uma exceção se `source` não contém elementos. Para retornar em vez disso, um valor padrão quando a sequência de origem estiver vazia, use o <xref:System.Linq.Enumerable.FirstOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para retornar o primeiro elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#35)]
 [!code-vb[System.Linq.Enumerable#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="First&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource First&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource First&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.First``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o primeiro elemento em uma sequência que satisfaz uma condição especificada.</summary>
        <returns>O primeiro elemento na sequência que passa o teste na função de predicado especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método lançará uma exceção se nenhum elemento correspondente foi encontrado em `source`. Para retornar em vez disso, um valor padrão quando nenhum elemento correspondente foi encontrado, use o <xref:System.Linq.Enumerable.FirstOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para retornar o primeiro elemento de uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#36)]
 [!code-vb[System.Linq.Enumerable#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#36)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum elemento satisfaz a condição na <paramref name="predicate" />.  
  
 -ou-  
  
 Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o primeiro elemento será retornado.</param>
        <summary>Retorna o primeiro elemento de uma sequência ou um valor padrão se a sequência não contém elementos.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) se <paramref name="source" /> estiver vazio; caso contrário, o primeiro elemento em <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
 O <xref:System.Linq.Enumerable.FirstOrDefault%2A> método não fornece uma maneira de especificar um valor padrão. Se você quiser especificar um valor padrão diferente de `default(TSource)`, use o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método conforme descrito na seção de exemplo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> em uma matriz vazia.  
  
 [!code-csharp[System.Linq.Enumerable#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#37)]
 [!code-vb[System.Linq.Enumerable#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#37)]  
  
 Às vezes, o valor de `default(TSource)` não é o valor padrão que você deseja usar se a coleção não contém elementos. Em vez de verificar o resultado para o valor padrão indesejado e, em seguida, alterá-la, se necessário, você pode usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método para especificar o valor padrão que você deseja usar se a coleção está vazia. Em seguida, chame <xref:System.Linq.Enumerable.First%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter o primeiro elemento. O exemplo de código a seguir usa a ambas as técnicas para obter um valor padrão de 1, se um conjunto de meses numéricos está vazio. Porque o valor padrão para um número inteiro é 0, que não corresponde a qualquer mês, o valor padrão deve ser especificado em vez disso, como 1. A primeira variável de resultado é verificada para o valor padrão indesejado após a conclusão da consulta em execução. A segunda variável de resultado é obtida usando <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para especificar um valor padrão de 1.  
  
 [!code-csharp[System.Linq.Enumerable#126](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#126)]
 [!code-vb[System.Linq.Enumerable#126](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#126)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FirstOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource FirstOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource FirstOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o primeiro elemento da sequência que satisfaz uma condição ou um valor padrão, caso esse elemento não seja encontrado.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) se <paramref name="source" /> estiver vazio ou se nenhum elemento for aprovado no teste especificado por <paramref name="predicate" />; caso contrário, o primeiro elemento em <paramref name="source" /> que for aprovado no teste especificado por <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.FirstOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> passando um predicado. A segunda chamada para o método, há nenhum elemento na matriz que atendem à condição.  
  
 [!code-csharp[System.Linq.Enumerable#38](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#38)]
 [!code-vb[System.Linq.Enumerable#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função de seletor de chave especificada.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> em c# ou <c>IEnumerable (Of IGrouping (Of TKey, TSource))</c> na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] onde cada <see cref="T:System.Linq.IGrouping`2" /> objeto contém uma sequência de objetos e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
> [!NOTE]
>  Para obter exemplos de `GroupBy`, consulte os tópicos a seguir.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Um <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerou em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerou na ordem em que aparecem no `source`.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 Na sintaxe de expressão de consulta, um `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.GroupBy%2A>. Para obter mais informações e exemplos de uso, consulte [cláusula group](~/docs/csharp/language-reference/keywords/group-clause.md) e [grupo pela cláusula](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt; GroupBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TSource&gt;&gt; GroupBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TSource&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e compara as chaves usando um comparador especificado.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TSource&gt; &gt; </c> em c# ou <c>IEnumerable (Of IGrouping (Of TKey, TSource))</c> na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] onde cada <see cref="T:System.Linq.IGrouping`2" /> objeto contém uma coleção de objetos e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
> [!NOTE]
>  Para obter exemplos de `GroupBy`, consulte os tópicos a seguir.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Um <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerou em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerou na ordem em que aparecem no `source`.  
  
 Se `comparer` é `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 Se duas chaves são consideradas iguais conforme `comparer`, a primeira chave é escolhida como a chave de agrupamento.  
  
 Na sintaxe de expressão de consulta, um `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.GroupBy%2A>. Para obter mais informações e exemplos de uso, consulte [cláusula group](~/docs/csharp/language-reference/keywords/group-clause.md) e [grupo pela cláusula](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo dos elementos no <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento no <see cref="T:System.Linq.IGrouping`2" />.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com a função de seletor de chave especificada e projeta os elementos de cada grupo usando uma função especificada.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> em c# ou <c>IEnumerable (Of IGrouping (Of TKey, TElement))</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] onde cada <see cref="T:System.Linq.IGrouping`2" /> objeto contém uma coleção de objetos do tipo <paramref name="TElement" /> e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Um <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerou em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerou na ordem em que os elementos que produziu aparecer em `source`.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> para agrupar os elementos de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#39)]
 [!code-vb[System.Linq.Enumerable#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#39)]  
  
 Na sintaxe de expressão de consulta, um `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.GroupBy%2A>. A conversão da expressão de consulta no exemplo a seguir é equivalente à consulta no exemplo acima.  
  
 [!code-csharp[System.Linq.Enumerable#122](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#122)]
 [!code-vb[System.Linq.Enumerable#122](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#122)]  
  
> [!NOTE]
>  Em um [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] expressão de consulta, o elemento e expressões de seleção chave ocorrerem na ordem inversa de suas posições de argumento em uma chamada para o <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt; GroupBy&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;class System.Linq.IGrouping`2&lt;!!TKey, !!TElement&gt;&gt; GroupBy&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Linq.IGrouping&lt;TKey,TElement&gt;&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo dos elementos no <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento em um <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função de seletor de chave. As chaves são comparadas usando um comparador e os elementos de cada grupo são projetados usando uma função especificada.</summary>
        <returns>Um <c>IEnumerable&lt;IGrouping&lt;TKey, TElement&gt; &gt; </c> em c# ou <c>IEnumerable (Of IGrouping (Of TKey, TElement))</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] onde cada <see cref="T:System.Linq.IGrouping`2" /> objeto contém uma coleção de objetos do tipo <paramref name="TElement" /> e uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
> [!NOTE]
>  Para obter exemplos de `GroupBy`, consulte os tópicos a seguir.  
>   
>  -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29>  
> -   <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29>  
  
 O <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna uma coleção de <xref:System.Linq.IGrouping%602> objetos, um para cada chave distinto que foi encontrado. Um <xref:System.Linq.IGrouping%602> é um <xref:System.Collections.Generic.IEnumerable%601> que também tem uma chave associada a seus elementos.  
  
 O <xref:System.Linq.IGrouping%602> objetos são gerou em uma ordem com base na ordem de elementos no `source` que produziu a primeira chave de cada <xref:System.Linq.IGrouping%602>. Elementos em um agrupamento são gerou na ordem em que os elementos que produziu aparecer em `source`.  
  
 Se `comparer` é `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 Se duas chaves são consideradas iguais conforme `comparer`, a primeira chave é escolhida como a chave de agrupamento.  
  
 Na sintaxe de expressão de consulta, um `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.GroupBy%2A>. Para obter mais informações e exemplos de uso, consulte [cláusula group](~/docs/csharp/language-reference/keywords/group-clause.md) e [grupo pela cláusula](~/docs/visual-basic/language-reference/queries/group-by-clause.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <c>resultSelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta, um `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupBy%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%602%7D%29> para agrupar os elementos de uma sequência e uma sequência de resultados do tipo de projeto `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#15)]
 [!code-vb[System.Linq.Enumerable#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``1,System.Collections.Generic.IEnumerable{``0},``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TSource&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <c>resultSelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> com o qual as chaves serão comparadas.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave. As chaves são comparadas usando um comparador especificado.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo dos elementos em cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <c>resultSelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento em um <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave. Os elementos de cada grupo são projetados usando uma função especificada.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na sintaxe de expressão de consulta, um `group by` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Group By Into` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.GroupBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupBy%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2CSystem.Collections.Generic.IEnumerable%7B%60%602%7D%2C%60%603%7D%29> para agrupar os elementos projetados de uma sequência e, em seguida, uma sequência de resultados do tipo de projeto `TResult`.  
  
 [!code-csharp[System.Linq.Enumerable#125](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#125)]
 [!code-vb[System.Linq.Enumerable#125](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#125)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupBy&lt;TSource,TKey,TElement,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupBy&lt;TSource,TKey,TElement,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupBy&lt;TSource, TKey, TElement, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Func`3&lt;!!TKey, class System.Collections.Generic.IEnumerable`1&lt;!!TElement&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupBy``4(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Func{``1,System.Collections.Generic.IEnumerable{``2},``3},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TKey,System.Collections.Generic.IEnumerable&lt;TElement&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo dos elementos em cada <see cref="T:System.Linq.IGrouping`2" />.</typeparam>
        <typeparam name="TResult">O tipo do valor de resultado retornado por <c>resultSelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos serão agrupados.</param>
        <param name="keySelector">Uma função para extrair a chave de cada elemento.</param>
        <param name="elementSelector">Uma função para mapear cada elemento de origem para um elemento em um <see cref="T:System.Linq.IGrouping`2" />.</param>
        <param name="resultSelector">Uma função para criar um valor de resultado de cada grupo.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> com o qual as chaves serão comparadas.</param>
        <summary>Agrupa os elementos de uma sequência de acordo com uma função do seletor de chave especificada e cria um valor de resultado de cada grupo e sua chave. Os valores da chave são comparados usando um comparador especificado e os elementos de cada grupo são projetados usando uma função especificada.</summary>
        <returns>Uma coleção de elementos do tipo <paramref name="TResult" />, em que cada elemento representa uma projeção em um grupo e sua chave.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de um elemento da primeira sequência e uma coleção de elementos correspondentes da segunda sequência.</param>
        <summary>Correlaciona os elementos de duas sequências com base na igualdade de chaves e agrupa os resultados. O comparador de igualdade padrão é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção agrupada em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparação de chaves.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>gera hierárquica resultados, que significa que os elementos de `outer` são emparelhados com coleções de correspondência de elementos de `inner`. `GroupJoin`permite que você basear seus resultados em todo um conjunto de correspondências para cada elemento de `outer`.  
  
> [!NOTE]
>  Se não houver nenhum elemento correlacionado na `inner` para um determinado elemento de `outer`, a sequência de correspondências para esse elemento estará vazia, mas ainda aparecerá nos resultados.  
  
 O `resultSelector` função é chamada apenas uma vez para cada `outer` elemento junto com uma coleção de todos os `inner` elementos que correspondem a `outer` elemento. Isso difere do <xref:System.Linq.Enumerable.Join%2A> método, no qual a função de seletor de resultado é invocada em pares que contêm um elemento de `outer` e um elemento de `inner`.  
  
 `GroupJoin`preserva a ordem dos elementos de `outer`e para cada elemento de `outer`, a ordem dos elementos correspondentes de `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>não tem nenhum equivalente direto em termos de banco de dados relacional tradicional. No entanto, esse método implementa um superconjunto de junções internas e externas esquerdas. Ambas essas operações podem ser gravadas em termos de uma junção agrupada. Consulte [operações Join](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 Na sintaxe de expressão de consulta, um `join … into` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Group Join` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.GroupJoin%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.GroupJoin%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2C%60%603%7D%29> para executar uma junção agrupada em duas sequências.  
  
 [!code-csharp[System.Linq.Enumerable#40](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#40)]
 [!code-vb[System.Linq.Enumerable#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#40)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GroupJoin&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; GroupJoin&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; GroupJoin&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt;, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.GroupJoin``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,System.Collections.Generic.IEnumerable{``1},``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,System.Collections.Generic.IEnumerable&lt;TInner&gt;,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de um elemento da primeira sequência e uma coleção de elementos correspondentes da segunda sequência.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para executar hash e comparar chaves.</param>
        <summary>Correlaciona os elementos de duas sequências com base na igualdade de chaves e agrupa os resultados. Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção agrupada em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Se c`omparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparação de chaves.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>gera hierárquica resultados, que significa que os elementos de `outer` são emparelhados com coleções de correspondência de elementos de `inner`. `GroupJoin`permite que você basear seus resultados em todo um conjunto de correspondências para cada elemento de `outer`.  
  
> [!NOTE]
>  Se não houver nenhum elemento correlacionado na `inner` para um determinado elemento de `outer`, a sequência de correspondências para esse elemento estará vazia, mas ainda aparecerá nos resultados.  
  
 O `resultSelector` função é chamada apenas uma vez para cada `outer` elemento junto com uma coleção de todos os `inner` elementos que correspondem a `outer` elemento. Isso difere do <xref:System.Linq.Enumerable.Join%2A> método no qual a função de seletor de resultado é invocada em pares que contêm um elemento de `outer` e um elemento de `inner`.  
  
 `GroupJoin`preserva a ordem dos elementos de `outer`e para cada elemento de `outer`, a ordem dos elementos correspondentes de `inner`.  
  
 <xref:System.Linq.Enumerable.GroupJoin%2A>não tem nenhum equivalente direto em termos de banco de dados relacional tradicional. No entanto, esse método implementa um superconjunto de junções internas e externas esquerdas. Ambas essas operações podem ser gravadas em termos de uma junção agrupada. Consulte [operações Join](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também são exibidas no <c>segundo</c> será retornado.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também aparecem na primeira sequência serão retornados.</param>
        <summary>Produz a interseção de conjunto de duas sequências usando o comparador de igualdade padrão para comparar os valores.</summary>
        <returns>Uma sequência que contém os elementos que formam a interseção de conjunto de duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 A interseção de dois conjuntos A e B é definida como o conjunto que contém todos os elementos de um também aparecem no B, mas nenhum outro elemento.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Intersect%2A> gera elementos distintos que ocorrem em ambas as sequências na ordem em que aparecem no `first`.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar os valores dos tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar essa interface e fornecer sua própria <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Intersect%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para retornar os elementos que aparecem em cada uma das duas sequências de inteiros.  
  
 [!code-csharp[System.Linq.Enumerable#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#41)]
 [!code-vb[System.Linq.Enumerable#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#41)]  
  
 Se você deseja comparar sequências de objetos de um tipo de dados personalizado, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em uma classe auxiliar. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois que você implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.Intersect%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#3)]
[!code-vb[CSLINQEncapsulatedComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Intersect&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Intersect&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Intersect&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Intersect``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também são exibidas no <c>segundo</c> será retornado.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos que também aparecem na primeira sequência serão retornados.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Produz a interseção de conjunto de duas sequências usando o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado para comparar os valores.</summary>
        <returns>Uma sequência que contém os elementos que formam a interseção de conjunto de duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 A interseção de dois conjuntos A e B é definida como o conjunto que contém todos os elementos de um também aparecem no B, mas nenhum outro elemento.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Intersect%2A> gera elementos distintos que ocorrem em ambas as sequências na ordem em que aparecem no `first`.  
  
 Se `comparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Intersect%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar essa comparação, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.Intersect%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#3](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#3)]
[!code-vb[CSLINQCustomComparer#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de dois elementos correspondentes.</param>
        <summary>Correlaciona os elementos de duas sequências com base em chaves de correspondência. O comparador de igualdade padrão é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> com elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção interna em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparação de chaves.  
  
 Uma junção refere-se a operação de correlacionar os elementos de duas fontes de informações com base em uma chave comum. <xref:System.Linq.Enumerable.Join%2A>oferece duas fontes de informações e as chaves que são combinados juntos na chamada de um método. Isso é diferente do uso de `SelectMany`, que requer mais de uma chamada de método para executar a mesma operação.  
  
 <xref:System.Linq.Enumerable.Join%2A>preserva a ordem dos elementos de `outer`e para cada um desses elementos, a ordem dos elementos de correspondência de `inner`.  
  
 Na sintaxe de expressão de consulta, um `join` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Join` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Join%2A>.  
  
 Em termos de banco de dados relacional, o <xref:System.Linq.Enumerable.Join%2A> método implementa uma junção por igualdade interna. 'Interna' significa que somente os elementos que têm uma correspondência na sequência de são incluídos nos resultados. Um ' equijoin' é uma junção na qual as chaves são comparadas quanto à igualdade. A esquerda a operação de junção externa não tem nenhum operador de consulta padrão dedicado, mas pode ser executada usando o <xref:System.Linq.Enumerable.GroupJoin%2A> método. Consulte [operações Join](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Join%60%604%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Func%7B%60%601%2C%60%602%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%603%7D%29> para executar uma junção interna de duas sequências, com base em uma chave comum.  
  
 [!code-csharp[System.Linq.Enumerable#42](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#42)]
 [!code-vb[System.Linq.Enumerable#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;TOuter,TInner,TKey,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Join&lt;TOuter,TInner,TKey,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TOuter&gt; outer, System.Collections.Generic.IEnumerable&lt;TInner&gt; inner, Func&lt;TOuter,TKey&gt; outerKeySelector, Func&lt;TInner,TKey&gt; innerKeySelector, Func&lt;TOuter,TInner,TResult&gt; resultSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Join&lt;TOuter, TInner, TKey, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TOuter&gt; outer, class System.Collections.Generic.IEnumerable`1&lt;!!TInner&gt; inner, class System.Func`2&lt;!!TOuter, !!TKey&gt; outerKeySelector, class System.Func`2&lt;!!TInner, !!TKey&gt; innerKeySelector, class System.Func`3&lt;!!TOuter, !!TInner, !!TResult&gt; resultSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Join``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``2},System.Func{``1,``2},System.Func{``0,``1,``3},System.Collections.Generic.IEqualityComparer{``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TOuter" />
        <TypeParameter Name="TInner" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="outer" Type="System.Collections.Generic.IEnumerable&lt;TOuter&gt;" RefType="this" />
        <Parameter Name="inner" Type="System.Collections.Generic.IEnumerable&lt;TInner&gt;" />
        <Parameter Name="outerKeySelector" Type="System.Func&lt;TOuter,TKey&gt;" />
        <Parameter Name="innerKeySelector" Type="System.Func&lt;TInner,TKey&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TOuter,TInner,TResult&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TOuter">O tipo dos elementos da primeira sequência.</typeparam>
        <typeparam name="TInner">O tipo dos elementos da segunda sequência.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornadas pelas funções de seletor de chave.</typeparam>
        <typeparam name="TResult">O tipo dos elementos de resultado.</typeparam>
        <param name="outer">A primeira sequência a ser ingressada.</param>
        <param name="inner">A sequência a ser ingressada à primeira sequência.</param>
        <param name="outerKeySelector">Uma função para extrair a chave de junção de cada elemento da primeira sequência.</param>
        <param name="innerKeySelector">Uma função para extrair a chave de junção de cada elemento da segunda sequência.</param>
        <param name="resultSelector">Uma função para criar um elemento de resultado de dois elementos correspondentes.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para executar hash e comparar chaves.</param>
        <summary>Correlaciona os elementos de duas sequências com base em chaves de correspondência. Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado é usado para comparar chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> com elementos do tipo <paramref name="TResult" /> obtidos pela execução de uma junção interna em duas sequências.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Se c`omparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para hash e comparação de chaves.  
  
 Uma junção refere-se a operação de correlacionar os elementos de duas fontes de informações com base em uma chave comum. <xref:System.Linq.Enumerable.Join%2A>oferece duas fontes de informações e as chaves que são combinados juntos na chamada de um método. Isso é diferente do uso de `SelectMany`, que requer mais de uma chamada de método para executar a mesma operação.  
  
 <xref:System.Linq.Enumerable.Join%2A>preserva a ordem dos elementos de `outer`e para cada um desses elementos, a ordem dos elementos de correspondência de `inner`.  
  
 Em termos de banco de dados relacional, o <xref:System.Linq.Enumerable.Join%2A> método implementa uma junção por igualdade interna. 'Interna' significa que somente os elementos que têm uma correspondência na sequência de são incluídos nos resultados. Um ' equijoin' é uma junção na qual as chaves são comparadas quanto à igualdade. A esquerda a operação de junção externa não tem nenhum operador de consulta padrão dedicado, mas pode ser executada usando o <xref:System.Linq.Enumerable.GroupJoin%2A> método. Consulte [operações Join](http://msdn.microsoft.com/library/442d176d-028c-4beb-8d22-407d4ef89107).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="outer" /> ou <paramref name="inner" /> ou <paramref name="outerKeySelector" /> ou <paramref name="innerKeySelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o último elemento será retornado.</param>
        <summary>Retorna o último elemento de uma sequência.</summary>
        <returns>O valor na última posição na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método lançará uma exceção se `source` não contém elementos. Para retornar em vez disso, um valor padrão quando a sequência de origem estiver vazia, use o <xref:System.Linq.Enumerable.LastOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para retornar o último elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#43)]
 [!code-vb[System.Linq.Enumerable#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#43)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Last&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Last&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Last&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Last``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o último elemento de uma sequência que satisfaz uma condição especificada.</summary>
        <returns>O último elemento na sequência que passa o teste na função de predicado especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método lançará uma exceção se nenhum elemento correspondente foi encontrado em `source`. Para retornar em vez disso, um valor padrão quando nenhum elemento correspondente foi encontrado, use o <xref:System.Linq.Enumerable.LastOrDefault%2A> método.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para retornar o último elemento de uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#44](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#44)]
 [!code-vb[System.Linq.Enumerable#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#44)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum elemento satisfaz a condição na <paramref name="predicate" />.  
  
 -ou-  
  
 Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o último elemento será retornado.</param>
        <summary>Retorna o último elemento de uma sequência ou um valor padrão se a sequência não contém elementos.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) se a sequência de origem estiver vazia; caso contrário, o último elemento no <see cref="T:System.Collections.Generic.IEnumerable`1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
 O <xref:System.Linq.Enumerable.LastOrDefault%2A> método não fornece uma maneira de especificar um valor padrão. Se você quiser especificar um valor padrão diferente de `default(TSource)`, use o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método conforme descrito na seção de exemplo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> em uma matriz vazia.  
  
 [!code-csharp[System.Linq.Enumerable#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#45)]
 [!code-vb[System.Linq.Enumerable#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#45)]  
  
 Às vezes, o valor de `default(TSource)` não é o valor padrão que você deseja usar se a coleção não contém elementos. Em vez de verificar o resultado para o valor padrão indesejado e, em seguida, alterá-la, se necessário, você pode usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método para especificar o valor padrão que você deseja usar se a coleção está vazia. Em seguida, chame <xref:System.Linq.Enumerable.Last%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter o último elemento. O exemplo de código a seguir usa ambas as técnicas para obter um valor padrão de 1 se uma coleção de numéricos dias do mês está vazia. Porque o valor padrão para um número inteiro é 0, que não corresponde a qualquer dia do mês, o valor padrão deve ser especificado em vez disso, como 1. A primeira variável de resultado é verificada para o valor padrão indesejado após a conclusão da consulta em execução. A segunda variável de resultado é obtida usando <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para especificar um valor padrão de 1.  
  
 [!code-csharp[System.Linq.Enumerable#127](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#127)]
 [!code-vb[System.Linq.Enumerable#127](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#127)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource LastOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource LastOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual um elemento será retornado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna o último elemento de uma sequência que satisfaz uma condição ou um valor padrão, caso esse elemento não seja encontrado.</summary>
        <returns>
          <see langword="default" />(<paramref name="TSource" />) se a sequência for vazia ou se nenhum elemento passar no teste na função de predicado; caso contrário, o último elemento que passar no teste na função de predicado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LastOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> passando um predicado. A segunda chamada para o método, há nenhum elemento na sequência que atendem à condição.  
  
 [!code-csharp[System.Linq.Enumerable#46](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#46)]
 [!code-vb[System.Linq.Enumerable#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#46)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos a serem contados.</param>
        <summary>Retorna um <see cref="T:System.Int64" /> que representa o número total de elementos em uma sequência.</summary>
        <returns>O número de elementos na sequência de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método em vez de <xref:System.Linq.Enumerable.Count%2A> quando você espera que o resultado seja maior que <xref:System.Int32.MaxValue>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into LongCount()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para contar os elementos em uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#47)]
 [!code-vb[System.Linq.Enumerable#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos excede <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongCount&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long LongCount&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 LongCount&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.LongCount``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos a serem contados.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna um <see cref="T:System.Int64" /> que representa quantos elementos na sequência atendem a uma condição.</summary>
        <returns>Um número que representa quantos elementos na sequência atendem à condição na função de predicado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método em vez de <xref:System.Linq.Enumerable.Count%2A> quando você espera que o resultado seja maior que <xref:System.Int32.MaxValue>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into LongCount()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.LongCount%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para contar os elementos em uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#48)]
 [!code-vb[System.Linq.Enumerable#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#48)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">O número de elementos correspondentes excede <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Decimal" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Decimal&gt; </c> em c# ou <c>Nullable (de Decimal)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Double" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;duplo&gt; </c> em c# ou <c>Nullable (de duplo)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int32" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int32&gt; </c> em c# ou <c>Nullable (de Int32)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Int64" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int64&gt; </c> em c# ou <c>Nullable (de Int64)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> anuláveis para determinar o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Single" /> anuláveis.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;único&gt; </c> em c# ou <c>Nullable (de único)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#54](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#54)]
 [!code-vb[System.Linq.Enumerable#54](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#54)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> da qual será determinado o valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> para determinar o valor máximo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#52](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#52)]
 [!code-vb[System.Linq.Enumerable#52](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <summary>Retorna o valor máximo em uma sequência genérica.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TSource` implementa <xref:System.IComparable%601>, o <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método usa essa implementação para comparar valores. Caso contrário, se tipo `TSource` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Se `TSource` é um tipo de referência e a sequência de origem está vazia ou contém somente os valores que são `null`, esse método retornará `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar o valor máximo em uma sequência de <xref:System.IComparable%601> objetos.  
  
 [!code-csharp[System.Linq.Enumerable#57](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#57)]
 [!code-vb[System.Linq.Enumerable#57](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#57)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Decimal>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Double>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Int32>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Int64>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Decimal&gt; </c> em c# ou <c>Nullable (de Decimal)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Decimal>` em c# ou `Nullable(Of Decimal)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;duplo&gt; </c> em c# ou <c>Nullable (de duplo)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Double>` em c# ou `Nullable(Of Double)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int32&gt; </c> em c# ou <c>Nullable (de Int32)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Int32>` em c# ou `Nullable(Of Int32)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int64&gt; </c> em c# ou <c>Nullable (de Int64)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Int64>` em c# ou `Nullable(Of Int64)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> máximo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;único&gt; </c> em c# ou <c>Nullable (de único)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Single>` em c# ou `Nullable(Of Single)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Max&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> máximo.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Single>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Max&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Max&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Max``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <c>seletor</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor máximo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência genérica e retorna o maior valor resultante.</summary>
        <returns>O valor máximo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TResult` implementa <xref:System.IComparable%601>, esse método usa a implementação para comparar valores. Caso contrário, se tipo `TResult` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Max()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Max%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Max%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor máximo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#58](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#58)]
 [!code-vb[System.Linq.Enumerable#58](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#58)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int32%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Int64%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de anulável <see cref="T:System.Decimal" /> valores para determinar o valor mínimo do.</param>
        <summary>Retorna o valor mínimo em uma sequência de anulável <see cref="T:System.Decimal" /> valores.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Decimal&gt; </c> em c# ou <c>Nullable (de Decimal)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Decimal%7D%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de anulável <see cref="T:System.Double" /> valores para determinar o valor mínimo do.</param>
        <summary>Retorna o valor mínimo em uma sequência de anulável <see cref="T:System.Double" /> valores.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;duplo&gt; </c> em c# ou <c>Nullable (de duplo)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Double%7D%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de anulável <see cref="T:System.Int32" /> valores para determinar o valor mínimo do.</param>
        <summary>Retorna o valor mínimo em uma sequência de anulável <see cref="T:System.Int32" /> valores.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int32&gt; </c> em c# ou <c>Nullable (de Int32)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de anulável <see cref="T:System.Int64" /> valores para determinar o valor mínimo do.</param>
        <summary>Retorna o valor mínimo em uma sequência de anulável <see cref="T:System.Int64" /> valores.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;Int64&gt; </c> em c# ou <c>Nullable (de Int64)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int64%7D%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de anulável <see cref="T:System.Single" /> valores para determinar o valor mínimo do.</param>
        <summary>Retorna o valor mínimo em uma sequência de anulável <see cref="T:System.Single" /> valores.</summary>
        <returns>Um valor do tipo <c>Nullable&lt;único&gt; </c> em c# ou <c>Nullable (de único)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Se a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Int32%7D%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#63](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#63)]
 [!code-vb[System.Linq.Enumerable#63](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#63)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%28System.Collections.Generic.IEnumerable%7BSystem.Double%7D%29> para determinar o valor mínimo em uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#60](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#60)]
 [!code-vb[System.Linq.Enumerable#60](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <summary>Retorna o valor mínimo em uma sequência genérica.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TSource` implementa <xref:System.IComparable%601>, esse método usa a implementação para comparar valores. Caso contrário, se tipo `TSource` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Se `TSource` é um tipo de referência e a sequência de origem está vazia ou contém somente os valores que são `null`, essa função retorna `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar o valor mínimo em uma sequência de <xref:System.IComparable%601> objetos.  
  
 [!code-csharp[System.Linq.Enumerable#67](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#67)]
 [!code-vb[System.Linq.Enumerable#67](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#67)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Decimal%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Decimal>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Double>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Int32>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int64%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Int64>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Decimal" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Decimal&gt; </c> em c# ou <c>Nullable (de Decimal)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Decimal%7D%7D%29> método usa o <xref:System.Decimal> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Decimal>` em c# ou `Nullable(Of Decimal)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Double" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;duplo&gt; </c> em c# ou <c>Nullable (de duplo)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Double%7D%7D%29> método usa o <xref:System.Double> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Double>` em c# ou `Nullable(Of Double)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int32" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int32&gt; </c> em c# ou <c>Nullable (de Int32)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int32%7D%7D%29> método usa o <xref:System.Int32> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de origem em um tipo numérico, especificamente `Nullable<Int32>` em c# ou `Nullable(Of Int32)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Int64" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;Int64&gt; </c> em c# ou <c>Nullable (de Int64)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Int64%7D%7D%29> método usa o <xref:System.Int64> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Int64>` em c# ou `Nullable(Of Int64)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> mínimo que permite valor nulo.</summary>
        <returns>O valor do tipo <c>Nullable&lt;único&gt; </c> em c# ou <c>Nullable (de único)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que corresponde ao valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Nullable%7BSystem.Single%7D%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Single>` em c# ou `Nullable(Of Single)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Min&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência e retorna o valor <see cref="T:System.Single" /> mínimo.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> método usa o <xref:System.Single> implementação de <xref:System.IComparable%601> para comparar valores.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Single>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="source" /> não contém elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Min&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static TResult Min&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TResult Min&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Min``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <c>seletor</c>.</typeparam>
        <param name="source">Uma sequência de valores para determinação do valor mínimo.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Invoca uma função de transformação em cada elemento de uma sequência genérica e retorna o menor valor resultante.</summary>
        <returns>O valor mínimo na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se tipo `TResult` implementa <xref:System.IComparable%601>, esse método usa a implementação para comparar valores. Caso contrário, se tipo `TResult` implementa <xref:System.IComparable>, que a implementação é usada para comparar valores.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Min()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Min%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Min%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%7D%29> para determinar o valor mínimo em uma sequência de valores projetadas.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#68](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#68)]
 [!code-vb[System.Linq.Enumerable#68](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OfType&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; OfType&lt;TResult&gt; (this System.Collections.IEnumerable source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; OfType&lt;TResult&gt;(class System.Collections.IEnumerable source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.IEnumerable" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo no qual filtrar os elementos da sequência.</typeparam>
        <param name="source">O <see cref="T:System.Collections.IEnumerable" /> cujos elementos serão filtrados.</param>
        <summary>Filtra os elementos de um <see cref="T:System.Collections.IEnumerable" /> com base em um tipo especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada de tipo <paramref name="TResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.OfType%60%601%28System.Collections.IEnumerable%29> método retorna apenas os elementos no `source` que pode ser convertido no tipo `TResult`. Em vez disso, receberão uma exceção se um elemento não pode ser convertido no tipo `TResult`, use <xref:System.Linq.Enumerable.Cast%60%601%28System.Collections.IEnumerable%29>.  
  
 Esse método é um de alguns métodos de operador de consulta padrão que podem ser aplicados a uma coleção que tem um tipo sem parâmetros, como um <xref:System.Collections.ArrayList>. Isso ocorre porque <xref:System.Linq.Enumerable.OfType%2A> estende o tipo <xref:System.Collections.IEnumerable>. <xref:System.Linq.Enumerable.OfType%2A>não pode ser aplicado somente a coleções com base em com os parâmetros <xref:System.Collections.Generic.IEnumerable%601> tipo, mas coleções com base no sem parâmetros <xref:System.Collections.IEnumerable> digite também.  
  
 Aplicando <xref:System.Linq.Enumerable.OfType%2A> para uma coleção que implementa <xref:System.Collections.IEnumerable>, você ganha a capacidade de consultar a coleção usando os operadores de consulta padrão. Por exemplo, especificar um argumento de tipo de <xref:System.Object> para <xref:System.Linq.Enumerable.OfType%2A> retorna um objeto do tipo `IEnumerable<Object>` em c# ou `IEnumerable(Of Object)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)], para que os operadores de consulta padrão podem ser aplicados.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.OfType%2A> para filtrar os elementos de um <xref:System.Collections.IEnumerable>.  
  
 [!code-csharp[System.Linq.Enumerable#69](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#69)]
 [!code-vb[System.Linq.Enumerable#69](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <summary>Classifica os elementos de uma sequência em ordem crescente de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno deste método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique critérios adicionais de classificação para classificar uma sequência. `ThenBy`e `ThenByDescending` também retornar um <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Este método compara chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 Na sintaxe de expressão de consulta, um `orderby` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Order By` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.OrderBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.OrderBy%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> para classificar os elementos de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#70](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#70)]
 [!code-vb[System.Linq.Enumerable#70](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#70)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderBy&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderBy&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Classifica os elementos de uma sequência em ordem crescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno deste método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique critérios adicionais de classificação para classificar uma sequência. `ThenBy`e `ThenByDescending` também retornar um <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar as chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <summary>Classifica os elementos de uma sequência em ordem decrescente de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 Para obter um exemplo desse método, consulte <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29>.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno deste método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique critérios adicionais de classificação para classificar uma sequência. `ThenBy`e `ThenByDescending` também retornar um <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Este método compara chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 Na sintaxe de expressão de consulta, um `orderby descending` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Order By Descending` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.OrderByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="OrderByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; OrderByDescending&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; OrderByDescending&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.OrderByDescending``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Uma sequência de valores a serem ordenados.</param>
        <param name="keySelector">Uma função para extrair uma chave de um elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Classifica os elementos de uma sequência em ordem decrescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 Dois métodos são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que é o tipo de retorno deste método. Esses dois métodos, ou seja, `ThenBy` e `ThenByDescending`, permitem que você especifique critérios adicionais de classificação para classificar uma sequência. `ThenBy`e `ThenByDescending` também retornar um <xref:System.Linq.IOrderedEnumerable%601>, que significa que qualquer número de chamadas consecutivas para `ThenBy` ou `ThenByDescending` podem ser feitas.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar as chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.OrderByDescending%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> para classificar os elementos de uma sequência em ordem decrescente por meio de uma função de transformação e um comparador personalizado.  
  
 [!code-csharp[System.Linq.Enumerable#71](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#71)]
 [!code-vb[System.Linq.Enumerable#71](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#71)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Prepend&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Prepend&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, TSource element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Prepend&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, !!TSource element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="element" Type="TSource" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <paramref name="source" />.</typeparam>
        <param name="source">Uma sequência de valores.</param>
        <param name="element">O valor a ser precedido a <paramref name="source" />.</param>
        <summary>Adiciona um valor ao início da sequência.</summary>
        <returns>Uma nova sequência que começa com <paramref name="element" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>        
      </Docs>
    </Member>
    <Member MemberName="Range">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;int&gt; Range (int start, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;int32&gt; Range(int32 start, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Range(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">O valor do primeiro inteiro na sequência.</param>
        <param name="count">O número de inteiros sequenciais a serem gerados.</param>
        <summary>Gera uma sequência de números integrais dentro de um intervalo especificado.</summary>
        <returns>Um <c>IEnumerable&lt;Int32&gt; </c> em c# ou <c>IEnumerable (Of Int32)</c> em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] que contém um intervalo de números inteiros sequenciais.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Range%2A> para gerar uma sequência de valores.  
  
 [!code-csharp[System.Linq.Enumerable#72](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#72)]
 [!code-vb[System.Linq.Enumerable#72](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#72)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que 0.  
  
 -ou-  
  
 <paramref name="start" /> + <paramref name="count" />-1 é maior do que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Repeat&lt;TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Repeat&lt;TResult&gt; (TResult element, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Repeat&lt;TResult&gt;(!!TResult element, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Repeat``1(``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="element" Type="TResult" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TResult">O tipo do valor a ser repetido na sequência de resultado.</typeparam>
        <param name="element">O valor a ser repetido.</param>
        <param name="count">O número de vezes para repetir o valor na sequência gerada.</param>
        <summary>Gera uma sequência que contém um valor repetido.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém um valor repetido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Repeat%2A> para gerar uma sequência de um valor repetida.  
  
 [!code-csharp[System.Linq.Enumerable#73](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#73)]
 [!code-vb[System.Linq.Enumerable#73](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#73)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Reverse&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Reverse&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Reverse``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores a ser revertida.</param>
        <summary>Inverte a ordem dos elementos em uma sequência.</summary>
        <returns>Uma sequência cujos elementos correspondem aos elementos da sequência de entrada em ordem inversa.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Ao contrário de <xref:System.Linq.Enumerable.OrderBy%2A>, esse método de classificação não considera os valores reais em si mesmos para determinar a ordem. Em vez disso, ele retorna apenas os elementos na ordem inversa da qual eles são produzidos pela origem subjacente.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Reverse%2A> para inverter a ordem dos elementos de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#74](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#74)]
 [!code-vb[System.Linq.Enumerable#74](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#74)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <c>seletor</c>.</typeparam>
        <param name="source">Uma sequência de valores na qual uma função de transformação será invocada.</param>
        <param name="selector">Uma função de transformação para aplicar a cada elemento de origem; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Projeta cada elemento de uma sequência em um novo formulário, incorporando o índice do elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado da invocação da função de transformação em cada elemento de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O primeiro argumento para `selector` representa o elemento para processar. O segundo argumento `selector` representa o índice de base zero do elemento na sequência de origem. Isso pode ser útil se os elementos estão em uma ordem conhecida e fazer algo com um elemento em um índice específico, por exemplo. Ele também pode ser útil se você quiser recuperar o índice de um ou mais elementos.  
  
 Esse método de projeção requer que a função de transformação, `selector`, para produzir um valor para cada valor na sequência de origem, `source`. Se `selector` retorna um valor que é uma coleção, é até o consumidor para atravessar as subsequências manualmente. Em tal situação, talvez seja melhor para sua consulta retornar uma única sequência agrupada de valores. Para fazer isso, use o <xref:System.Linq.Enumerable.SelectMany%2A> método em vez de <xref:System.Linq.Enumerable.Select%2A>. Embora `SelectMany` funciona da mesma forma que `Select`, ele é diferente em que a função de transformação retorna uma coleção que é expandida, em seguida, por `SelectMany` antes de ser retornado.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2C%60%601%7D%29> projeto em uma sequência de valores e usar o índice de cada elemento.  
  
 [!code-csharp[System.Linq.Enumerable#76](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#76)]
 [!code-vb[System.Linq.Enumerable#76](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#76)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Select&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TResult&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Select&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TResult&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TResult">O tipo do valor retornado por <c>seletor</c>.</typeparam>
        <param name="source">Uma sequência de valores na qual uma função de transformação será invocada.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Projeta cada elemento de uma sequência em um novo formulário.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado da invocação da função de transformação em cada elemento de <paramref name="source" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Esse método de projeção requer que a função de transformação, `selector`, para produzir um valor para cada valor na sequência de origem, `source`. Se `selector` retorna um valor que é uma coleção, é até o consumidor para atravessar as subsequências manualmente. Em tal situação, talvez seja melhor para sua consulta retornar uma única sequência agrupada de valores. Para fazer isso, use o <xref:System.Linq.Enumerable.SelectMany%2A> método em vez de <xref:System.Linq.Enumerable.Select%2A>. Embora `SelectMany` funciona da mesma forma que `Select`, ele é diferente em que a função de transformação retorna uma coleção que é expandida, em seguida, por `SelectMany` antes de ser retornado.  
  
 Na sintaxe de expressão de consulta, um `select` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Select` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Select%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Select%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> ao projeto em uma sequência de valores.  
  
 [!code-csharp[System.Linq.Enumerable#75](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#75)]
 [!code-vb[System.Linq.Enumerable#75](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#75)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência retornado por <c>seletor</c>.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" /> e nivela as sequências resultantes em uma sequência.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são resultado da invocação da função de transformação de um para muitos em cada elemento da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> método enumera a sequência de entrada, usa uma função de transformação para mapear cada elemento para uma <xref:System.Collections.Generic.IEnumerable%601>e, em seguida, enumera e gera os elementos de cada tais <xref:System.Collections.Generic.IEnumerable%601> objeto. Ou seja, para cada elemento de `source`, `selector` é chamado e uma sequência de valores é retornada. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>em seguida, mescla esta coleção bidimensional de coleções em um unidimensional <xref:System.Collections.Generic.IEnumerable%601> e o retorna. Por exemplo, se uma consulta usa <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para obter os pedidos (do tipo `Order`) para cada cliente em um banco de dados, o resultado é do tipo `IEnumerable<Order>` em c# ou `IEnumerable(Of Order)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Se, em vez disso, a consulta usa <xref:System.Linq.Enumerable.Select%2A> para obter os pedidos, a coleção de coleções de pedidos não é combinada e o resultado é do tipo `IEnumerable<List<Order>>` em c# ou `IEnumerable(Of List(Of Order))` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Na sintaxe de expressão de consulta, cada `from` cláusula ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `From` cláusula ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) após inicial converte para uma invocação de <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para executar uma projeção de um-para-muitos em uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#77](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#77)]
 [!code-vb[System.Linq.Enumerable#77](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#77)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TResult&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência retornado por <c>seletor</c>.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="selector">Uma função de transformação para aplicar a cada elemento de origem; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" /> e nivela as sequências resultantes em uma sequência. O índice de cada elemento de origem é usado no formulário projetado desse elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado da invocação da função de transformação um-para-muitos em cada elemento de uma sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> método enumera a sequência de entrada, usa uma função de transformação para mapear cada elemento para uma <xref:System.Collections.Generic.IEnumerable%601>e, em seguida, enumera e gera os elementos de cada tais <xref:System.Collections.Generic.IEnumerable%601> objeto. Ou seja, para cada elemento de `source`, `selector` é chamado e uma sequência de valores é retornada. <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29>em seguida, mescla esta coleção bidimensional de coleções em um unidimensional <xref:System.Collections.Generic.IEnumerable%601> e o retorna. Por exemplo, se uma consulta usa <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para obter os pedidos (do tipo `Order`) para cada cliente em um banco de dados, o resultado é do tipo `IEnumerable<Order>` em c# ou `IEnumerable(Of Order)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]. Se, em vez disso, a consulta usa <xref:System.Linq.Enumerable.Select%2A> para obter os pedidos, a coleção de coleções de pedidos não é combinada e o resultado é do tipo `IEnumerable<List<Order>>` em c# ou `IEnumerable(Of List(Of Order))` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O primeiro argumento para `selector` representa o elemento para processar. O segundo argumento `selector` representa o índice de base zero do elemento na sequência de origem. Isso pode ser útil se os elementos estão em uma ordem conhecida e fazer algo com um elemento em um índice específico, por exemplo. Ele também pode ser útil se você quiser recuperar o índice de um ou mais elementos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> para realizar uma projeção de um-para-muitos em uma matriz e usará o índice de cada elemento externo.  
  
 [!code-csharp[System.Linq.Enumerable#78](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#78)]
 [!code-vb[System.Linq.Enumerable#78](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#78)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TCollection">O tipo dos elementos intermediários coletados pelo <c>collectionSelector</c>.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência resultante.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="collectionSelector">Uma função de transformação a ser aplicada a cada elemento da sequência de entrada.</param>
        <param name="resultSelector">Uma função de transformação a ser aplicada a cada elemento da sequência intermediária.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" />, mescla as sequências resultantes em uma sequência e chama uma função de seletor de resultado em cada elemento contido nele.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado de chamar a função de transformação de um para muitos <paramref name="collectionSelector" /> em cada elemento de <paramref name="source" /> e, em seguida, mapear cada um desses elementos de sequência e seu elemento de origem correspondente para um elemento de resultado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> método é útil quando você precisa manter os elementos de `source` no escopo para a lógica de consulta que ocorre após a chamada a <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Consulte a seção de exemplo para obter um exemplo de código. Se há uma relação bidirecional entre objetos do tipo `TSource` e objetos do tipo `TCollection`, ou seja, se um objeto do tipo `TCollection` fornece uma propriedade para recuperar o `TSource` objeto que gerou a ele, você não precisa essa sobrecarga de <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Em vez disso, você pode usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> e navegue de volta para o `TSource` objeto por meio de `TCollection` objeto.  
  
 Na sintaxe de expressão de consulta, cada `from` cláusula ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `From` cláusula ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) após inicial converte para uma invocação de <xref:System.Linq.Enumerable.SelectMany%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> para realizar uma projeção de um-para-muitos em uma matriz e usar uma função de seletor de resultado para manter cada elemento correspondente da sequência de origem no escopo para a chamada final `Select`.  
  
 [!code-csharp[System.Linq.Enumerable#124](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#124)]
 [!code-vb[System.Linq.Enumerable#124](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#124)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectMany&lt;TSource,TCollection,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; SelectMany&lt;TSource,TCollection,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt; collectionSelector, Func&lt;TSource,TCollection,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; SelectMany&lt;TSource, TCollection, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, class System.Collections.Generic.IEnumerable`1&lt;!!TCollection&gt;&gt; collectionSelector, class System.Func`3&lt;!!TSource, !!TCollection, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SelectMany``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TCollection" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="collectionSelector" Type="System.Func&lt;TSource,System.Int32,System.Collections.Generic.IEnumerable&lt;TCollection&gt;&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TSource,TCollection,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TCollection">O tipo dos elementos intermediários coletados pelo <c>collectionSelector</c>.</typeparam>
        <typeparam name="TResult">O tipo dos elementos da sequência resultante.</typeparam>
        <param name="source">Uma sequência de valores a serem projetados.</param>
        <param name="collectionSelector">Uma função de transformação para aplicar a cada elemento de origem; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <param name="resultSelector">Uma função de transformação a ser aplicada a cada elemento da sequência intermediária.</param>
        <summary>Projeta cada elemento de uma sequência em um <see cref="T:System.Collections.Generic.IEnumerable`1" />, mescla as sequências resultantes em uma sequência e chama uma função de seletor de resultado em cada elemento contido nele. O índice de cada elemento de origem é usado no formulário projetado intermediário do elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos são o resultado de chamar a função de transformação de um para muitos <paramref name="collectionSelector" /> em cada elemento de <paramref name="source" /> e, em seguida, mapear cada um desses elementos de sequência e seu elemento de origem correspondente para um elemento de resultado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29> método é útil quando você precisa manter os elementos de `source` no escopo para a lógica de consulta que ocorre após a chamada a <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Consulte a seção de exemplo para obter um exemplo de código. Se há uma relação bidirecional entre objetos do tipo `TSource` e objetos do tipo `TCollection`, ou seja, se um objeto do tipo `TCollection` fornece uma propriedade para recuperar o `TSource` objeto que gerou a ele, você não precisa essa sobrecarga de <xref:System.Linq.Enumerable.SelectMany%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%2CSystem.Func%7B%60%600%2C%60%601%2C%60%602%7D%29>. Em vez disso, você pode usar <xref:System.Linq.Enumerable.SelectMany%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Collections.Generic.IEnumerable%7B%60%601%7D%7D%29> e navegue de volta para o `TSource` objeto por meio de `TCollection` objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="collectionSelector" /> ou <paramref name="resultSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com <c>segundo</c>.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com a primeira sequência.</param>
        <summary>Determina se duas sequências são iguais comparando os elementos usando o comparador de igualdade padrão para o tipo.</summary>
        <returns>
          <see langword="true" /> se as duas sequências de origem forem de mesmo comprimento e seus elementos correspondentes forem iguais de acordo com o comparador de igualdade padrão para seu tipo; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método enumera as sequências de duas fonte em paralelo e compara os elementos correspondentes usando o comparador de igualdade padrão para `TSource`, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>. O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar os valores dos tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar essa interface e fornecer sua própria <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
   
  
## Examples  
 Os exemplos de código a seguir demonstram como usar <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para determinar se duas sequências são iguais. Os dois primeiros exemplos, o método determina se as sequências comparadas contêm referências para os mesmos objetos. Nos exemplos a terceira e quarto, o método compara os dados reais dos objetos dentro de sequências.  
  
 Neste exemplo, as sequências são iguais.  
  
 [!code-csharp[System.Linq.Enumerable#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#32)]
 [!code-vb[System.Linq.Enumerable#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#32)]  
  
 O exemplo de código a seguir compara duas sequências que não são iguais. Observe que as sequências contêm dados idênticos, mas como os objetos que eles contêm têm referências diferentes, as sequências não são consideradas iguais.  
  
 [!code-csharp[System.Linq.Enumerable#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#33)]
 [!code-vb[System.Linq.Enumerable#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#33)]  
  
 Se você deseja comparar os dados reais dos objetos em sequências em vez de apenas comparar suas referências, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em sua classe. O exemplo de código a seguir mostra como implementar essa interface em uma classe auxiliar e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois que você implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#8)]
 [!code-vb[CSLINQEncapsulatedComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SequenceEqual&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static bool SequenceEqual&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SequenceEqual&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SequenceEqual``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com <c>segundo</c>.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para comparar com a primeira sequência.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> a ser usado para comparar elementos.</param>
        <summary>Determina se duas sequências são iguais, comparando seus elementos usando um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
        <returns>
          <see langword="true" /> se as duas sequências de origem tiverem o mesmo tamanho e seus elementos correspondentes forem comparados como iguais de acordo com o <paramref name="comparer" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método enumera as sequências de duas fonte em paralelo e compara os elementos correspondentes usando especificado <xref:System.Collections.Generic.IEqualityComparer%601>. Se c`omparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar os elementos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar essa comparação, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.SequenceEqual%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#8](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#8)]
 [!code-vb[CSLINQCustomComparer#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o único elemento será retornado.</param>
        <summary>Retornará o único elemento de uma sequência e lançará uma exceção se não houver exatamente um elemento na sequência.</summary>
        <returns>O único elemento de uma sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método lançará uma exceção se a sequência de entrada está vazia. Em vez disso, retornar `null` quando a sequência de entrada estiver vazia, use <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para selecionar o único elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#79](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#79)]
 [!code-vb[System.Linq.Enumerable#79](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#79)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> lança uma exceção quando a sequência não contém exatamente um elemento.  
  
 [!code-csharp[System.Linq.Enumerable#80](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#80)]
 [!code-vb[System.Linq.Enumerable#80](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#80)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A sequência de entrada contém mais de um elemento.  
  
 -ou-  
  
 A sequência de entrada está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="Single&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource Single&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource Single&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Single``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual retornar um único elemento.</param>
        <param name="predicate">Uma função para testar um elemento em relação a uma condição.</param>
        <summary>Retorna o único elemento de uma sequência que satisfaz uma condição especificada e gera uma exceção se houver mais de um tal elemento.</summary>
        <returns>O único elemento da sequência de entrada que atende a uma condição.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método lançará uma exceção se a sequência de entrada não contém nenhum elemento correspondente. Em vez disso, retornar `null` quando nenhum elemento correspondente foi encontrado, use <xref:System.Linq.Enumerable.SingleOrDefault%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para selecionar o único elemento de uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#81](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#81)]
 [!code-vb[System.Linq.Enumerable#81](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#81)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> lança uma exceção quando a sequência não contém exatamente um elemento que atendem à condição.  
  
 [!code-csharp[System.Linq.Enumerable#82](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#82)]
 [!code-vb[System.Linq.Enumerable#82](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#82)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Nenhum elemento satisfaz a condição na <paramref name="predicate" />.  
  
 -ou-  
  
 Mais de um elemento satisfaz a condição na <paramref name="predicate" />.  
  
 -ou-  
  
 Uma sequência de origem está vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual o único elemento será retornado.</param>
        <summary>Retorna o único elemento de uma sequência ou um valor padrão se a sequência é vazia; esse método gera uma exceção se há mais de um elemento na sequência.</summary>
        <returns>O único elemento da sequência de entrada, ou <see langword="default" />(<paramref name="TSource" />), se a sequência não contiver elementos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
 O <xref:System.Linq.Enumerable.SingleOrDefault%2A> método não fornece uma maneira de especificar um valor padrão. Se você quiser especificar um valor padrão diferente de `default(TSource)`, use o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método conforme descrito na seção de exemplo.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para selecionar o único elemento de uma matriz.  
  
 [!code-csharp[System.Linq.Enumerable#83](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#83)]
 [!code-vb[System.Linq.Enumerable#83](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#83)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> retorna um valor padrão quando a sequência não contém exatamente um elemento.  
  
 [!code-csharp[System.Linq.Enumerable#84](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#84)]
 [!code-vb[System.Linq.Enumerable#84](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#84)]  
  
 Às vezes, o valor de `default(TSource)` não é o valor padrão que você deseja usar se a coleção não contém elementos. Em vez de verificar o resultado para o valor padrão indesejado e, em seguida, alterá-la, se necessário, você pode usar o <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> método para especificar o valor padrão que você deseja usar se a coleção está vazia. Em seguida, chame <xref:System.Linq.Enumerable.Single%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter o elemento. O exemplo de código a seguir usa ambas as técnicas para obter um valor padrão de 1, se um conjunto de números de página está vazio. Porque o valor padrão para um número inteiro é 0, que não é um número de página válido normalmente, o valor padrão deve ser especificado como 1 em vez disso. A primeira variável de resultado é verificada para o valor padrão indesejado após a conclusão da consulta em execução. A segunda variável de resultado é obtida usando <xref:System.Linq.Enumerable.DefaultIfEmpty%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2C%60%600%29> para especificar um valor padrão de 1.  
  
 [!code-csharp[System.Linq.Enumerable#128](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#128)]
 [!code-vb[System.Linq.Enumerable#128](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#128)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">A sequência de entrada contém mais de um elemento.</exception>
      </Docs>
    </Member>
    <Member MemberName="SingleOrDefault&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource SingleOrDefault&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource SingleOrDefault&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SingleOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual retornar um único elemento.</param>
        <param name="predicate">Uma função para testar um elemento em relação a uma condição.</param>
        <summary>Retorna o único elemento de uma sequência que satisfaz uma condição especificada ou um valor padrão se esse elemento não existir. Esse método lança uma exceção se mais de um elemento satisfizer a condição.</summary>
        <returns>O único elemento da sequência de entrada que atende à condição ou <see langword="default" />(<paramref name="TSource" />) se esse elemento não for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor padrão para referência e tipos anuláveis é `null`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para selecionar o único elemento de uma matriz que satisfazem uma condição.  
  
 [!code-csharp[System.Linq.Enumerable#85](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#85)]
 [!code-vb[System.Linq.Enumerable#85](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#85)]  
  
 O exemplo de código a seguir demonstra que <xref:System.Linq.Enumerable.SingleOrDefault%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> retorna um valor padrão quando a sequência não contém exatamente um elemento que atendem à condição.  
  
 [!code-csharp[System.Linq.Enumerable#86](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#86)]
 [!code-vb[System.Linq.Enumerable#86](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#86)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Skip&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Skip&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Skip``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual os elementos serão retornados.</param>
        <param name="count">O número de elementos a serem ignorados antes de retornar os elementos restantes.</param>
        <summary>Ignora um número especificado de elementos em uma sequência e retorna os elementos restantes.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos que ocorrem após o índice especificado na sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Se `source` contém menos de `count` elementos, vazio <xref:System.Collections.Generic.IEnumerable%601> é retornado. Se `count` é menor ou igual a zero, todos os elementos de `source` são gerou.  
  
 O <xref:System.Linq.Enumerable.Take%2A> e <xref:System.Linq.Enumerable.Skip%2A> métodos são complementa funcional. Dada uma sequência `coll` inteiro e `n`, concatenando os resultados de `coll.Take(n)` e `coll.Skip(n)` gera a mesma sequência `coll`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Skip` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Skip%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Skip%2A> para ignorar um número especificado de elementos em uma matriz classificada e retorna os elementos restantes.  
  
 [!code-csharp[System.Linq.Enumerable#87](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#87)]
 [!code-vb[System.Linq.Enumerable#87](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#87)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual os elementos serão retornados.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Ignora elementos em uma sequência, contanto que uma condição especificada seja verdadeira e retorne os elementos restantes.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos da sequência de entrada, começando no primeiro elemento da série linear que não passa no teste especificado por <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Este método testa cada elemento de `source` usando `predicate` e ignora o elemento se o resultado for `true`. Depois que a função de predicado retorna `false` para um elemento, esse elemento e os elementos restantes no `source` são gerou e não houver nenhuma mais invocações de `predicate`.  
  
 Se `predicate` retorna `true` para todos os elementos na sequência, vazio <xref:System.Collections.Generic.IEnumerable%601> é retornado.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` gera a mesma sequência `coll`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Skip While` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para ignorar os elementos de uma matriz como uma condição for verdadeira.  
  
 [!code-csharp[System.Linq.Enumerable#88](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#88)]
 [!code-vb[System.Linq.Enumerable#88](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#88)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; SkipWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; SkipWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> do qual os elementos serão retornados.</param>
        <param name="predicate">Uma função para testar cada elemento de origem em relação a uma condição; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Ignora elementos em uma sequência, contanto que uma condição especificada seja verdadeira e retorne os elementos restantes. O índice do elemento é usado na lógica da função de predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos da sequência de entrada, começando no primeiro elemento da série linear que não passa no teste especificado por <paramref name="predicate" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> método testa cada elemento de `source` usando `predicate` e ignora o elemento se o resultado for `true`. Depois que a função de predicado retorna `false` para um elemento, esse elemento e os elementos restantes no `source` são gerou e não houver nenhuma mais invocações de `predicate`.  
  
 Se `predicate` retorna `true` para todos os elementos na sequência, vazio <xref:System.Collections.Generic.IEnumerable%601> é retornado.  
  
 O primeiro argumento de `predicate` representa o elemento para teste. O segundo argumento representa o índice de base zero do elemento no `source`.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` gera a mesma sequência `coll`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Skip While` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.SkipWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.SkipWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> para ignorar os elementos de uma matriz como uma condição que depende do índice do elemento é true.  
  
 [!code-csharp[System.Linq.Enumerable#89](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#89)]
 [!code-vb[System.Linq.Enumerable#89](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#89)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static decimal Sum (this System.Collections.Generic.IEnumerable&lt;decimal&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Decimal&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Decimal&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Decimal" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Decimal%7D%29> método retornará zero se `source` não contém elementos.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static double Sum (this System.Collections.Generic.IEnumerable&lt;double&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum(class System.Collections.Generic.IEnumerable`1&lt;float64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Double&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Double" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static int Sum (this System.Collections.Generic.IEnumerable&lt;int&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum(class System.Collections.Generic.IEnumerable`1&lt;int32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int32&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Int32" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static long Sum (this System.Collections.Generic.IEnumerable&lt;long&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum(class System.Collections.Generic.IEnumerable`1&lt;int64&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Int64&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Int64" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;decimal&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Decimal&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Decimal" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;double&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Double&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Double" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;int&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int32&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Int32" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;long&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;int64&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Int64&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Int64" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_elementtype](~/includes/sqo-diff-overload-example-elementtype-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum (this System.Collections.Generic.IEnumerable&lt;Nullable&lt;float&gt;&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Nullable`1&lt;float32&gt;&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Nullable&lt;System.Single&gt;&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos para cálculo da soma.</param>
        <summary>Computa a soma de uma sequência de valores <see cref="T:System.Single" /> que permitem valores nulos.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Nullable%7BSystem.Single%7D%7D%29> para somar os valores de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#121](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#121)]
 [!code-vb[System.Linq.Enumerable#121](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#121)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum">
      <MemberSignature Language="C#" Value="public static float Sum (this System.Collections.Generic.IEnumerable&lt;float&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum(class System.Collections.Generic.IEnumerable`1&lt;float32&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum(System.Collections.Generic.IEnumerable{System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;System.Single&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <param name="source">Uma sequência de valores <see cref="T:System.Single" /> para cálculo da soma.</param>
        <summary>Calcula a soma de uma sequência de valores <see cref="T:System.Single" />.</summary>
        <returns>A soma dos valores na sequência.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%28System.Collections.Generic.IEnumerable%7BSystem.Single%7D%29> para somar os valores de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#120](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#120)]
 [!code-vb[System.Linq.Enumerable#120](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#120)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static decimal Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,decimal&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Decimal&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Decimal})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Decimal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Decimal" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Decimal>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static double Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,double&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Double})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Double&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Double" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Double>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static int Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int32&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int32" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Int32>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static long Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,long&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, int64&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int64})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int64" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Int64>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;decimal&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;decimal&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;valuetype System.Decimal&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;valuetype System.Decimal&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Decimal}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Decimal&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Decimal&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Decimal" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluídos valores que são `null`.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Decimal>` em c# ou `Nullable(Of Decimal)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;double&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;double&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Double}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Double&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Double" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Double>` em c# ou `Nullable(Of Double)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;int&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;int&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int32}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int32&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int32" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Int32>` em c# ou `Nullable(Of Int32)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;long&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;long&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;int64&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;int64&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Int64}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int64&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Int64&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Int64" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Int64>` em c# ou `Nullable(Of Int64)` em[!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">A soma é maior que <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static Nullable&lt;float&gt; Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,Nullable&lt;float&gt;&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Nullable`1&lt;float32&gt; Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, valuetype System.Nullable`1&lt;float32&gt;&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{System.Single}})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Single&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Nullable&lt;System.Single&gt;&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Single" /> anuláveis obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método retorna zero se `source` não contém elementos.  
  
 O resultado não incluir valores que são `null`.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente `Nullable<Single>` em c# ou `Nullable(Of Single)` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sum&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static float Sum&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,float&gt; selector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sum&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, float32&gt; selector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Sum``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Single})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="selector" Type="System.Func&lt;TSource,System.Single&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência de valores usados para calcular uma soma.</param>
        <param name="selector">Uma função de transformação a ser aplicada a cada elemento.</param>
        <summary>Calcula a soma da sequência de valores <see cref="T:System.Single" /> obtidos pela invocação de uma função de transformação em cada elemento da sequência de entrada.</summary>
        <returns>A soma dos valores projetados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Single%7D%29> método retornará zero se `source` não contém elementos.  
  
 Você pode aplicar esse método para uma sequência de valores arbitrários, se você fornecer uma função `selector`, que projeta os membros de `source` em um tipo numérico, especificamente <xref:System.Single>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Aggregate Into Sum()` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Sum%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Sum%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Double%7D%29> para somar os valores projetados de uma sequência.  
  
 [!INCLUDE[sqo_diff_overload_example_func](~/includes/sqo-diff-overload-example-func-md.md)]  
  
 [!code-csharp[System.Linq.Enumerable#98](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#98)]
 [!code-vb[System.Linq.Enumerable#98](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#98)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="selector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Take&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Take&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Take&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Take``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">A sequência da qual os elementos serão retornados.</param>
        <param name="count">O número de elementos a serem retornados.</param>
        <summary>Retorna um número especificado de elementos contíguos do início de uma sequência.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém o número especificado de elementos do início da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 <xref:System.Linq.Enumerable.Take%2A>Enumera `source` e gera elementos até `count` elementos produziram ou `source` não contém mais elementos. Se `count` excede o número de elementos em `source`, todos os elementos de `source` são retornados.  
  
 Se `count` é menor ou igual a zero, `source` não é enumerado e um vazio <xref:System.Collections.Generic.IEnumerable%601> é retornado.  
  
 O <xref:System.Linq.Enumerable.Take%2A> e <xref:System.Linq.Enumerable.Skip%2A> métodos são complementa funcional. Dada uma sequência `coll` inteiro e `n`, concatenando os resultados de `coll.Take(n)` e `coll.Skip(n)` gera a mesma sequência `coll`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Take` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Take%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Take%2A> para retornar elementos desde o início de uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#99](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#99)]
 [!code-vb[System.Linq.Enumerable#99](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#99)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeLast&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeLast&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeLast&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Uma sequência a qual retornar os elementos.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Retorna os elementos de uma sequência contanto que uma condição especificada seja verdadeira.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que ocorrem antes do elemento no qual o teste não é mais aprovado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> método testa cada elemento de `source` usando `predicate` e gera o elemento se o resultado for `true`. Enumeração interrompe quando a função de predicado retorna `false` para um elemento ou quando `source` não contém mais elementos.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` gera a mesma sequência `coll`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Take While` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para retornar elementos desde o início de uma sequência como uma condição for verdadeira.  
  
 [!code-csharp[System.Linq.Enumerable#100](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#100)]
 [!code-vb[System.Linq.Enumerable#100](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#100)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TakeWhile&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; TakeWhile&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; TakeWhile&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">A sequência da qual os elementos serão retornados.</param>
        <param name="predicate">Uma função para testar cada elemento de origem em relação a uma condição; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Retorna os elementos de uma sequência contanto que uma condição especificada seja verdadeira. O índice do elemento é usado na lógica da função de predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que ocorrem antes do elemento no qual o teste não é mais aprovado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> método testa cada elemento de `source` usando `predicate` e gera o elemento se o resultado for `true`. Enumeração interrompe quando a função de predicado retorna `false` para um elemento ou quando `source` não contém mais elementos.  
  
 O primeiro argumento de `predicate` representa o elemento para teste. O segundo argumento representa o índice de base zero do elemento no `source`.  
  
 O <xref:System.Linq.Enumerable.TakeWhile%2A> e <xref:System.Linq.Enumerable.SkipWhile%2A> métodos são complementa funcional. Dada uma sequência `coll` e uma função pura `p`, concatenando os resultados de `coll.TakeWhile(p)` e `coll.SkipWhile(p)` gera a mesma sequência `coll`.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Take While` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.TakeWhile%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.TakeWhile%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> para retornar elementos desde o início de uma sequência como uma condição que usa o índice do elemento é true.  
  
 [!code-csharp[System.Linq.Enumerable#101](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#101)]
 [!code-vb[System.Linq.Enumerable#101](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#101)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem crescente de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação com a aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Este método compara chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 Na sintaxe de expressão de consulta, um `orderby [first criterion], [second criterion]` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Order By [first criterion], [second criterion]` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.ThenBy%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ThenBy%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> para executar uma ordenação secundária dos elementos em uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#102](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#102)]
 [!code-vb[System.Linq.Enumerable#102](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#102)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenBy&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenBy&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenBy&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenBy``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem crescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação com a aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar as chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem decrescente, de acordo com uma chave.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação com a aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Esse método de classificação compara chaves usando o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A>.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
 Em [!INCLUDE[csprcs](~/includes/csprcs-md.md)] sintaxe de expressão de consulta um `orderby [first criterion], [second criterion] descending` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 Em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)] sintaxe de expressão de consulta um `Order By [first criterion], [second criterion] Descending` cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.ThenByDescending%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ThenByDescending&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.IOrderedEnumerable&lt;TSource&gt; ThenByDescending&lt;TSource,TKey&gt; (this System.Linq.IOrderedEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; ThenByDescending&lt;TSource, TKey&gt;(class System.Linq.IOrderedEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ThenByDescending``2(System.Linq.IOrderedEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.IOrderedEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Linq.IOrderedEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> que contém elementos a ser classificados.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IComparer`1" /> para comparar chaves.</param>
        <summary>Executa uma ordenação posterior dos elementos em uma sequência em ordem decrescente usando um comparador especificado.</summary>
        <returns>Um <see cref="T:System.Linq.IOrderedEnumerable`1" /> cujos elementos são classificados em ordem decrescente de acordo com uma chave.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Para solicitar uma sequência, os valores dos elementos de si mesmos, especifique a função identity (`x => x` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `Function(x) x` na [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) para `keySelector`.  
  
 <xref:System.Linq.Enumerable.ThenBy%2A>e <xref:System.Linq.Enumerable.ThenByDescending%2A> são definidos para estender o tipo <xref:System.Linq.IOrderedEnumerable%601>, que também é o tipo de retorno dos métodos a seguir. Esse design permite que você especificar vários critérios de classificação com a aplicação de qualquer número de <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A> métodos.  
  
> [!NOTE]
>  Porque <xref:System.Linq.IOrderedEnumerable%601> herda de <xref:System.Collections.Generic.IEnumerable%601>, você pode chamar <xref:System.Linq.Enumerable.OrderBy%2A> ou <xref:System.Linq.Enumerable.OrderByDescending%2A> nos resultados de uma chamada para <xref:System.Linq.Enumerable.OrderBy%2A>, <xref:System.Linq.Enumerable.OrderByDescending%2A>, <xref:System.Linq.Enumerable.ThenBy%2A> ou <xref:System.Linq.Enumerable.ThenByDescending%2A>. Isso apresenta um novo primário ordenação que ignora a ordem estabelecida anteriormente.  
  
 Se `comparer` é `null`, o comparador padrão <xref:System.Collections.Generic.Comparer%601.Default%2A> é usado para comparar as chaves.  
  
 Esse método executa uma classificação estável; ou seja, se as chaves de dois elementos são iguais, a ordem dos elementos é preservada. Em contraste, uma classificação instável não preserva a ordem dos elementos que têm a mesma chave.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ThenByDescending%60%602%28System.Linq.IOrderedEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IComparer%7B%60%601%7D%29> para executar uma ordenação secundária dos elementos em uma sequência em ordem decrescente, usando um comparador personalizado.  
  
 [!code-csharp[System.Linq.Enumerable#103](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#103)]
 [!code-vb[System.Linq.Enumerable#103](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#103)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static TSource[] ToArray&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TSource[] ToArray&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToArray``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TSource[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> para criar uma matriz.</param>
        <summary>Cria uma matriz de um <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Uma matriz que contém os elementos da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToArray%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método força a avaliação imediata de consulta e retorna uma matriz que contém os resultados da consulta. Você pode acrescentar esse método à sua consulta para obter uma cópia armazenada em cache os resultados da consulta.  
  
 <xref:System.Linq.Enumerable.ToList%2A>tem um comportamento semelhante mas retorna um <xref:System.Collections.Generic.List%601> em vez de uma matriz.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToArray%2A> para forçar a avaliação imediata de consulta e retornar uma matriz de resultados.  
  
 [!code-csharp[System.Linq.Enumerable#104](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#104)]
 [!code-vb[System.Linq.Enumerable#104](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#104)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> método usa o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> para comparar as chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToDictionary%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> para criar um <xref:System.Collections.Generic.Dictionary%602> usando um seletor de chave.  
  
 [!code-csharp[System.Linq.Enumerable#105](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#105)]
 [!code-vb[System.Linq.Enumerable#105](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#105)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TSource&gt; ToDictionary&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TSource&gt; ToDictionary&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo das chaves retornado por <c>keySelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada e um comparador de chaves.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` é `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <c>elementSelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com as funções especificadas de seletor de chave e seletor de elemento.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToDictionary%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método usa o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> para comparar as chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToDictionary&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.Dictionary&lt;TKey,TElement&gt; ToDictionary&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.Dictionary`2&lt;!!TKey, !!TElement&gt; ToDictionary&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.Dictionary&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <c>elementSelector</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.Dictionary`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.Dictionary`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de acordo com uma função de seletor de chave, um comparador e uma função de seletor de elemento especificados.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.Dictionary`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` é `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="keySelector" /> gera uma chave que é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="keySelector" /> gera chaves duplicatas para dois elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToHashSet&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.HashSet&lt;TSource&gt; ToHashSet&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.HashSet`1&lt;!!TSource&gt; ToHashSet&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToHashSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">To be added.</typeparam>
        <param name="source">To be added.</param>
        <param name="comparer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToList&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.List&lt;TSource&gt; ToList&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.List`1&lt;!!TSource&gt; ToList&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToList``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.List&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Collections.Generic.List`1" /> será criado.</param>
        <summary>Cria um <see cref="T:System.Collections.Generic.List`1" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.List`1" /> que contém elementos da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToList%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método força a avaliação imediata de consulta e retorna um <xref:System.Collections.Generic.List%601> que contém os resultados da consulta. Você pode acrescentar esse método à sua consulta para obter uma cópia armazenada em cache os resultados da consulta.  
  
 <xref:System.Linq.Enumerable.ToArray%2A>tem um comportamento semelhante mas retorna uma matriz em vez de um <xref:System.Collections.Generic.List%601>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToList%2A> para forçar a avaliação imediata de consulta e retornar um <xref:System.Collections.Generic.List%601> que contém os resultados da consulta.  
  
 [!code-csharp[System.Linq.Enumerable#106](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#106)]
 [!code-vb[System.Linq.Enumerable#106](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#106)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> difere de um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TSource&gt; ToLookup&lt;TSource,TKey&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TSource&gt; ToLookup&lt;TSource, TKey&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com uma função de seletor de chave especificada e um comparador de chaves.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém chaves e valores.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%602%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> é diferente para um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 Se `comparer` é `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="keySelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <c>elementSelector</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" />, de acordo com as funções especificadas de seletor de chave e seletor de elemento.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> difere de um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 O comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%29> para criar um <xref:System.Linq.Lookup%602> usando uma função de seletor de chave e uma função de seletor de elemento.  
  
 [!code-csharp[System.Linq.Enumerable#107](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#107)]
 [!code-vb[System.Linq.Enumerable#107](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#107)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToLookup&lt;TSource,TKey,TElement&gt;">
      <MemberSignature Language="C#" Value="public static System.Linq.ILookup&lt;TKey,TElement&gt; ToLookup&lt;TSource,TKey,TElement&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,TKey&gt; keySelector, Func&lt;TSource,TElement&gt; elementSelector, System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Linq.ILookup`2&lt;!!TKey, !!TElement&gt; ToLookup&lt;TSource, TKey, TElement&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, !!TKey&gt; keySelector, class System.Func`2&lt;!!TSource, !!TElement&gt; elementSelector, class System.Collections.Generic.IEqualityComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.ToLookup``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.ILookup&lt;TKey,TElement&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TElement" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="keySelector" Type="System.Func&lt;TSource,TKey&gt;" />
        <Parameter Name="elementSelector" Type="System.Func&lt;TSource,TElement&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <typeparam name="TKey">O tipo de chave retornada pelo <c>keySelector</c>.</typeparam>
        <typeparam name="TElement">O tipo do valor retornado por <c>elementSelector</c>.</typeparam>
        <param name="source">O <see cref="T:System.Collections.Generic.IEnumerable`1" /> por meio do qual um <see cref="T:System.Linq.Lookup`2" /> será criado.</param>
        <param name="keySelector">Uma função para extrair uma chave de cada elemento.</param>
        <param name="elementSelector">Uma função de transformação para produzir um valor de elemento de resultado de cada elemento.</param>
        <param name="comparer">Um <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar chaves.</param>
        <summary>Cria um <see cref="T:System.Linq.Lookup`2" /> de um <see cref="T:System.Collections.Generic.IEnumerable`1" /> de acordo com uma função de seletor de chave, um comparador e uma função de seletor de elemento especificados.</summary>
        <returns>Um <see cref="T:System.Linq.Lookup`2" /> que contém valores do tipo <paramref name="TElement" /> selecionados da sequência de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Linq.Enumerable.ToLookup%60%603%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2C%60%601%7D%2CSystem.Func%7B%60%600%2C%60%602%7D%2CSystem.Collections.Generic.IEqualityComparer%7B%60%601%7D%29> método retorna um <xref:System.Linq.Lookup%602>, um dicionário de um-para-muitos que mapeia chaves para coleções de valores. Um <xref:System.Linq.Lookup%602> difere de um <xref:System.Collections.Generic.Dictionary%602>, que executa um mapeamento de chaves para valores únicos.  
  
 Se `comparer` é `null`, o comparador de igualdade padrão <xref:System.Collections.Generic.EqualityComparer%601.Default%2A> é usado para comparar as chaves.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" />, <paramref name="keySelector" /> ou <paramref name="elementSelector" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o primeiro conjunto da união.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o segundo conjunto da união.</param>
        <summary>Produz a união de conjunto de duas sequências usando o comparador de igualdade padrão.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos de ambas as sequências de entrada, excluindo as duplicatas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Este método exclui duplicatas do conjunto de retorno. Este é um comportamento diferente para o <xref:System.Linq.Enumerable.Concat%2A> método, que retorna todos os elementos nas sequências de entrada, incluindo duplicatas.  
  
 O comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar os valores dos tipos que implementam o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica. Para comparar um tipo de dados personalizado, você precisa implementar essa interface e fornecer sua própria <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos para o tipo.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Union%2A> enumera `first` e `second` nessa ordem e produz cada elemento que já não gerou.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> para obter a união de duas sequências de inteiros.  
  
 [!code-csharp[System.Linq.Enumerable#109](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#109)]
 [!code-vb[System.Linq.Enumerable#109](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#109)]  
  
 Se você deseja comparar sequências de objetos de um tipo de dados personalizado, você precisa implementar o <xref:System.Collections.Generic.IEqualityComparer%601> interface genérica em um helperclass. O exemplo de código a seguir mostra como implementar essa interface em um tipo de dados personalizadas e fornecer <xref:System.Object.GetHashCode%2A> e <xref:System.Object.Equals%2A> métodos.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#9](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#9)]  
  
 Depois que você implementar essa interface, você pode usar sequências de `ProductA` objetos no <xref:System.Linq.Enumerable.Union%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQEncapsulatedComparer#10](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#10)]  
[!code-csharp[CSLINQEncapsulatedComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/CS/EncapsulatedComparer.cs#4)]
[!code-vb[CSLINQEncapsulatedComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQEncapsulatedComparer/VB/EncapsulatedComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Union&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Union&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; first, System.Collections.Generic.IEnumerable&lt;TSource&gt; second, System.Collections.Generic.IEqualityComparer&lt;TSource&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Union&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; second, class System.Collections.Generic.IEqualityComparer`1&lt;!!TSource&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos das sequências de entrada.</typeparam>
        <param name="first">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o primeiro conjunto da união.</param>
        <param name="second">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> cujos elementos distintos formam o segundo conjunto da união.</param>
        <param name="comparer">O <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para comparar valores.</param>
        <summary>Produz a união de conjunto de duas sequências usando o <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> especificado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém os elementos de ambas as sequências de entrada, excluindo as duplicatas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Se c`omparer` é `null`, o comparador de igualdade padrão, <xref:System.Collections.Generic.EqualityComparer%601.Default%2A>, é usado para comparar valores.  
  
 Quando o objeto retornado por esse método é enumerado, <xref:System.Linq.Enumerable.Union%2A> enumera `first` e `second` nessa ordem e produz cada elemento que já não gerou.  
  
 O <xref:System.Linq.Enumerable.Concat%2A> método difere de <xref:System.Linq.Enumerable.Union%2A> método porque o <xref:System.Linq.Enumerable.Concat%2A> método retorna todos os elementos nas sequências de entrada, incluindo duplicatas, enquanto <xref:System.Linq.Enumerable.Union%2A> retorna apenas valores exclusivos.  
  
   
  
## Examples  
 O exemplo a seguir mostra como implementar um comparador de igualdade que pode ser usado no <xref:System.Linq.Enumerable.Union%2A> método.  
  
 [!code-csharp[CSLINQCustomComparer#1](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#1)]
 [!code-vb[CSLINQCustomComparer#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#1)]  
  
 Depois de implementar essa comparação, você pode usar sequências de `Product` objetos no <xref:System.Linq.Enumerable.Union%2A> método, conforme mostrado no exemplo a seguir.  
  
 [!code-csharp[CSLINQCustomComparer#2](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#2)]
 [!code-vb[CSLINQCustomComparer#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#2)]  
[!code-csharp[CSLINQCustomComparer#4](~/samples/snippets/csharp/VS_Snippets_VBCSharp/CsLINQCustomComparer/CS/CustomComparer.cs#4)]
[!code-vb[CSLINQCustomComparer#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/CsLINQCustomComparer/VB/CustomComparer.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`2&lt;!!TSource, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> a ser filtrado.</param>
        <param name="predicate">Uma função para testar cada elemento em relação a uma condição.</param>
        <summary>Filtra uma sequência de valores com base em um predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que atendem à condição.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 Na sintaxe de expressão de consulta, um `where` ([!INCLUDE[csprcs](~/includes/csprcs-md.md)]) ou `Where` ([!INCLUDE[vbprvb](~/includes/vbprvb-md.md)]) cláusula se traduz em uma chamada de <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29>.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Boolean%7D%29> para filtrar uma sequência.  
  
 [!code-csharp[System.Linq.Enumerable#110](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#110)]
 [!code-vb[System.Linq.Enumerable#110](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#110)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Where&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TSource&gt; Where&lt;TSource&gt; (this System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TSource,int,bool&gt; predicate);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; Where&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`3&lt;!!TSource, int32, bool&gt; predicate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TSource&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" RefType="this" />
        <Parameter Name="predicate" Type="System.Func&lt;TSource,System.Int32,System.Boolean&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource">O tipo dos elementos de <c>fonte</c>.</typeparam>
        <param name="source">Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> a ser filtrado.</param>
        <param name="predicate">Uma função para testar cada elemento de origem em relação a uma condição; o segundo parâmetro da função representa o índice do elemento de origem.</param>
        <summary>Filtra uma sequência de valores com base em um predicado. O índice de cada elemento é usado na lógica da função de predicado.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos da sequência de entrada que atendem à condição.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O primeiro argumento de `predicate` representa o elemento para teste. O segundo argumento representa o índice de base zero do elemento no `source`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar <xref:System.Linq.Enumerable.Where%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Func%7B%60%600%2CSystem.Int32%2CSystem.Boolean%7D%29> para filtrar uma sequência com base em um predicado que envolve o índice de cada elemento.  
  
 [!code-csharp[System.Linq.Enumerable#111](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#111)]
 [!code-vb[System.Linq.Enumerable#111](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#111)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="source" /> ou <paramref name="predicate" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zip&lt;TFirst,TSecond,TResult&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;TResult&gt; Zip&lt;TFirst,TSecond,TResult&gt; (this System.Collections.Generic.IEnumerable&lt;TFirst&gt; first, System.Collections.Generic.IEnumerable&lt;TSecond&gt; second, Func&lt;TFirst,TSecond,TResult&gt; resultSelector);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEnumerable`1&lt;!!TResult&gt; Zip&lt;TFirst, TSecond, TResult&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TFirst&gt; first, class System.Collections.Generic.IEnumerable`1&lt;!!TSecond&gt; second, class System.Func`3&lt;!!TFirst, !!TSecond, !!TResult&gt; resultSelector) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Enumerable.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;TResult&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TFirst" />
        <TypeParameter Name="TSecond" />
        <TypeParameter Name="TResult" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="first" Type="System.Collections.Generic.IEnumerable&lt;TFirst&gt;" RefType="this" />
        <Parameter Name="second" Type="System.Collections.Generic.IEnumerable&lt;TSecond&gt;" />
        <Parameter Name="resultSelector" Type="System.Func&lt;TFirst,TSecond,TResult&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TFirst">O tipo de elementos na primeira sequência de entrada.</typeparam>
        <typeparam name="TSecond">O tipo de elementos na segunda sequência de entrada.</typeparam>
        <typeparam name="TResult">O tipo de elementos na sequência de resultado.</typeparam>
        <param name="first">A primeira sequência a ser mesclada.</param>
        <param name="second">A segunda sequência a ser mesclada.</param>
        <param name="resultSelector">Uma função que especifica como mesclar os elementos das duas sequências.</param>
        <summary>Aplica uma função especificada para os elementos correspondentes de duas sequências, produzindo uma sequência dos resultados.</summary>
        <returns>Um <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contém elementos mesclados de duas sequências de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é implementado usando a execução adiada. O imediata valor de retorno é um objeto que armazena todas as informações necessárias para executar a ação. A consulta representada por esse método não é executada até que o objeto é enumerado ou chamando seu `GetEnumerator` método diretamente ou usando `foreach` na [!INCLUDE[csprcs](~/includes/csprcs-md.md)] ou `For Each` em [!INCLUDE[vbprvb](~/includes/vbprvb-md.md)].  
  
 O método mescla cada elemento da primeira sequência com um elemento que tem o mesmo índice na segunda sequência. Se as sequências não têm o mesmo número de elementos, o método mescla sequências até atingir o final de um deles. Por exemplo, se uma sequência tem três elementos e o outro um tem quatro, a sequência de resultados terá somente três elementos.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como usar o <xref:System.Linq.Enumerable.Zip%2A> método para mesclar duas sequências.  
  
 [!code-csharp[System.Linq.Enumerable#200](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Linq.Enumerable/CS/enumerable.cs#200)]
 [!code-vb[System.Linq.Enumerable#200](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Linq.Enumerable/VB/Enumerable.vb#200)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="first" /> ou <paramref name="second" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
