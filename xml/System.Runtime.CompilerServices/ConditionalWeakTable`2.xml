<Type Name="ConditionalWeakTable&lt;TKey,TValue&gt;" FullName="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;">
  <TypeSignature Language="C#" Value="public sealed class ConditionalWeakTable&lt;TKey,TValue&gt; where TKey : class where TValue : class" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ConditionalWeakTable`2&lt;class TKey, class TValue&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="TKey">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TValue">
      <Constraints>
        <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
  </Interfaces>
  <Docs>
    <typeparam name="TKey">O tipo de referência ao qual o campo está anexado.</typeparam>
    <typeparam name="TValue">O tipo do campo. Este deve ser um tipo de referência.</typeparam>
    <summary>Permite que os compiladores anexem dinamicamente os campos de objeto para objetos gerenciados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe permite que os compiladores anexem propriedades arbitrárias para objetos gerenciados em tempo de execução. Um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto é um dicionário que associa um objeto gerenciado, que é representado por uma chave para sua propriedade anexada, que é representada por um valor. Chaves do objeto são as instâncias individuais do `TKey` classe à qual a propriedade está anexada e seus valores são os valores de propriedade que são atribuídos a objetos correspondentes.  
  
 As chaves devem ser exclusivas; em outras palavras, a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe oferece suporte a um valor anexado por objeto gerenciado. Duas chaves são iguais se transmiti-los para o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método retornará `true`.  
  
> [!NOTE]
>  Você não pode controlar as comparações de igualdade, substituindo <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> para definir explicitamente o código hash para uma chave. O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe não usa o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método para calcular os códigos de hash e, portanto, não chamar <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> substituições.  
  
 Embora o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe contém uma coleção de pares chave/valor, ele é mais considerado como uma tabela em vez de um objeto de dicionário. O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe difere de um dicionário de várias maneiras:  
  
-   Ele não mantém as chaves. Ou seja, uma chave não é mantida ativa apenas porque ele é um membro da coleção.  
  
-   Ele não inclui todos os métodos (como `GetEnumerator` ou `Contains`) que normalmente tem um dicionário.  
  
-   Ele não implementa o <xref:System.Collections.Generic.IDictionary%602> interface.  
  
 O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe difere de outros objetos de coleção em seu gerenciamento da vida útil do objeto de chaves armazenadas na coleção. Normalmente, quando um objeto é armazenado em uma coleção, seu tempo de vida dura até ser removido (e existem referências adicionais para o objeto) ou até que o objeto de coleção em si é destruído. No entanto, a <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> classe, adicionando um par chave/valor para a tabela não garante que a chave será mantido, mesmo que possa ser acessado diretamente de um valor armazenado na tabela (por exemplo, se a tabela contiver uma chave, A, com um valor V1 e com um valor de P2 que contém uma referência a um uma segunda chave, B). Em vez disso, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> automaticamente remove a entrada de chave/valor como não há outras referências a uma chave existem fora da tabela. O exemplo fornece uma ilustração.  
  
   
  
## Examples  
 O exemplo a seguir ilustra que uma chave armazenada no <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela não persiste após as referências a ele fora da tabela são destruídas. O exemplo define duas classes: `ManagedClass`, que representa a chave na tabela, e `ClassData`, que representa o valor da chave. O exemplo cria três objetos de cada tipo. Ele também cria um <xref:System.WeakReference> objeto que representa o segundo `ManagedClass`e, em seguida, destrói o segundo `ManagedClass` instância. A tentativa de recuperar o segundo `ManagedClass` de objeto do <xref:System.WeakReference.Target%2A> propriedade indica que nenhuma referência ao objeto permanecem.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/cs/example1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.class/vb/example1.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Instâncias de <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" /> classe é thread-safe. Eles não exigem chamadores fazer qualquer bloqueio adicionais.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ConditionalWeakTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.%23ctor%2A> construtor instancia vazio <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela; ou seja, a tabela não contém nenhum pares chave/valor. Você pode adicionar pares chave/valor chamando o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A>, ou <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método.  
  
 Todas as chaves em um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto deve ser exclusivo. As chaves não forem exclusivas se eles se referem ao mesmo objeto (ou seja, se transmiti-los como argumentos para o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Add(`0,`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">A chave a ser adicionada. <c>chave</c> representa o objeto ao qual a propriedade está anexada.</param>
        <param name="value">Valor da propriedade da chave.</param>
        <summary>Adiciona uma chave para a tabela.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todas as chaves em um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> objeto deve ser exclusivo. As chaves não forem exclusivas se eles se referem ao mesmo objeto (ou seja, se transmiti-los como argumentos para o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método `true`).  
  
 Se a chave é coletado como lixo durante a operação de adição, o par chave/valor existente será removido e o par chave/valor novo é adicionado sem uma exceção sendo lançada.  
  
   
  
## Examples  
 O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância. O exemplo, em seguida, chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> método para adicionar um `MainClass` objeto e seu anexado `MainInfo` o objeto para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela. O exemplo também ilustra chamadas para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para adicionar pares chave/valor para a tabela e o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar o valor de uma chave existente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="key" /> já existe.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddOrUpdate">
      <MemberSignature Language="C#" Value="public void AddOrUpdate (TKey key, TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOrUpdate(!TKey key, !TValue value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.AddOrUpdate(`0,`1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue" />
      </Parameters>
      <Docs>
        <param name="key">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ConditionalWeakTable`2 ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Finalize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que os recursos são liberados e outras operações de limpeza são executadas quando o coletor de lixo recupera o objeto <see cref="T:System.Runtime.CompilerServices.ConditionalWeakTable`2" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O coletor de lixo chama <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Finalize%2A> quando o objeto atual está pronto para ser finalizado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOrCreateValue">
      <MemberSignature Language="C#" Value="public TValue GetOrCreateValue (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetOrCreateValue(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetOrCreateValue(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">A chave para pesquisar. <c>chave</c> representa o objeto ao qual a propriedade está anexada.</param>
        <summary>Atomicamente procura uma chave especificada na tabela e retorna o valor correspondente. Se a chave não existir na tabela, o método chama o construtor padrão da classe que representa o valor da tabela para criar um valor que está associado à chave especificada.</summary>
        <returns>O valor que corresponde à <paramref name="key" />, se <paramref name="key" /> já existe na tabela; Caso contrário, um novo valor criado pelo construtor da classe definida por padrão o <paramref name="TValue" /> parâmetro de tipo genérico.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `key` não existe na tabela, o método adiciona o conteúdo, juntamente com o objeto que é instanciado chamando o construtor padrão da classe definida pelo `TValue` parâmetro de tipo genérico. Se o `TValue` classe não possui construtor padrão, um <xref:System.MissingMethodException> é gerada.  
  
 Este é o método recomendado para recuperar um valor existente ou adicionando um novo valor para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela se a classe de valor da tabela define um construtor padrão. Se ele não define um construtor padrão, em vez disso, você pode chamar o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método, que se baseia em um método de retorno de chamada fornecido para instanciar o objeto que representa o valor da tabela  
  
 Para recuperar o valor de uma chave existente sem adicionar o par chave/valor se a chave não for encontrada na tabela, chame o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância. O exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método para adicionar um `MainClass` objeto e seu anexado `MainInfo` o objeto para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela. O exemplo também ilustra chamadas para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para adicionar pares chave/valor para a tabela e o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar o valor de uma chave existente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.MissingMemberException" />, em vez disso.  
  
</para>
          </block>  
  
 A classe que representa o valor da tabela não define um construtor padrão.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public TValue GetValue (TKey key, System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;.CreateValueCallback createValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !TValue GetValue(!TKey key, class System.Runtime.CompilerServices.ConditionalWeakTable`2/CreateValueCallback&lt;!TKey, !TValue&gt; createValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.GetValue(`0,System.Runtime.CompilerServices.ConditionalWeakTable`2.CreateValueCallback{`0,`1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TValue</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="createValueCallback" Type="System.Runtime.CompilerServices.ConditionalWeakTable&lt;TKey,TValue&gt;+CreateValueCallback" />
      </Parameters>
      <Docs>
        <param name="key">A chave para pesquisar. <c>chave</c> representa o objeto ao qual a propriedade está anexada.</param>
        <param name="createValueCallback">Um delegado para um método que pode criar um valor para o determinado <c>chave</c>. Ele tem um único parâmetro do tipo <c>TKey</c>e retorna um valor do tipo <c>TValue</c>.</param>
        <summary>Atomicamente procura uma chave especificada na tabela e retorna o valor correspondente. Se a chave não existir na tabela, o método invoca um método de retorno de chamada para criar um valor que está associado à chave especificada.</summary>
        <returns>O valor anexado ao <paramref name="key" />, se <paramref name="key" /> já existe na tabela; Caso contrário, o novo valor retornado pelo <paramref name="createValueCallback" /> delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `key` não existe na tabela, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> invoca o método que é definido pelo `createValueCallback` parâmetro e passa a chave. Um novo valor é associado à chave da tabela e retornado como resultado.  
  
 Use esse método somente quando a classe que representa o valor da tabela não define um construtor padrão. Se ela define um construtor padrão, use o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> método em vez disso. Para recuperar o valor de uma chave existente sem adicionar o par chave/valor se a chave não for encontrada na tabela, chame o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método.  
  
 Se vários threads tentarem criar a mesma chave, `createValueCallback` pode ser chamado várias vezes com a mesma chave. Somente uma dessas chamadas terá êxito e o valor retornado será adicionado à tabela. Qual thread tiver êxito na criação do valor é indeterminado. Essa regra permite a tabela para invocar `createValueCallback` fora o bloqueio de tabela interna para evitar deadlocks.  
  
   
  
## Examples  
 O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância. Também define um static (`Shared` no Visual Basic) `CreateAttachedValue` método que pode ser atribuído ao <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.CreateValueCallback> delegar e passados para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método. O exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> método para adicionar um `MainClass` objeto e seu anexado `MainInfo` o objeto para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela. O exemplo também ilustra chamadas para o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A> e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A> métodos para adicionar pares chave/valor para a tabela e o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para recuperar o valor de uma chave existente.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> ou <paramref name="createValueCallback" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (TKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Remove(!TKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.Remove(`0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
      </Parameters>
      <Docs>
        <param name="key">A chave a ser removido.</param>
        <summary>Remove uma chave e o valor da tabela.</summary>
        <returns>
          <see langword="true" />Se a chave for encontrada e removida; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a chave é coletado como lixo durante esta operação, o método gera uma exceção e o valor retornado é indefinido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt; IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;!TKey, !TValue&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;TKey,TValue&gt;&gt;#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;TKey,TValue&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.System#Collections#IEnumerable#GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (TKey key, out TValue value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!TKey key, [out] !TValue&amp; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.ConditionalWeakTable`2.TryGetValue(`0,`1@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="TKey" />
        <Parameter Name="value" Type="TValue&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="key">A chave que representa um objeto com uma propriedade anexada.</param>
        <param name="value">Quando este método retorna, contém o valor da propriedade anexada. Se <c>chave</c> não for encontrado, <c>valor</c> contém o valor padrão.</param>
        <summary>Obtém o valor da chave especificada.</summary>
        <returns>
          <see langword="true" />Se <paramref name="key" /> for encontrado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a chave é coletado como lixo durante esta operação, o método pode retornar `false` e defina `value` para o padrão de valor (como se a chave não estava presente).  
  
   
  
## Examples  
 O exemplo a seguir define uma `MainClass` classe e um `MainInfo` classe, que fornece informações sobre o `MainClass` instância. O exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.Add%2A>, <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetOrCreateValue%2A>, e <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.GetValue%2A> métodos para adicionar pares de chave/valor para um <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602> tabela. Em cada caso, o exemplo chama o <xref:System.Runtime.CompilerServices.ConditionalWeakTable%602.TryGetValue%2A> método para confirmar que o par chave/valor foi adicionado à tabela.  
  
 [!code-csharp[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/cs/getvalue1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.ConditionalWeakTable.GetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.conditionalweaktable.getvalue/vb/getvalue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="key" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
  </Members>
</Type>
