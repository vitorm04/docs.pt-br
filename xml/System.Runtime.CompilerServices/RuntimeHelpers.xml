<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um conjunto de propriedades que dão suporte a compiladores e métodos estáticos. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como definir confiável identificadores usando o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método. Para definir com segurança um identificador para um identificador pré-existente especificado, você deve garantir que a alocação do identificador nativo e a gravação subsequente desse identificador em um <xref:System.Runtime.InteropServices.SafeHandle> objeto é atômico. Qualquer falha entre essas operações (por exemplo, uma exceção de falta de memória ou anulação de thread) resulta no identificador nativo vazem.  Você pode usar o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método para certificar-se de que o identificador não vazou.  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Garante que o espaço de pilha restante é grande o suficiente para executar a função média do .NET Framework.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A>Fornece informações sobre uma pilha artificialmente limitada que preserva espaço suficiente para uma exceção a ser gerado e a ação de recuperação a ser executada. O limite de pilha artificial é escolhido pelo common language runtime para garantir que há espaço suficiente permaneça gerar uma exceção com segurança.  
  
 Esse método é útil em situações em que o estouro de pilha pode ocorrer como resultado de recursão ilimitada. Ele é destinado ao uso em cenários de serviços do compilador, embora também possa ser usado com segurança em outros cenários de desenvolvimento.  
  
 Se o espaço de pilha suficiente, a exceção não é gerada e a maioria dos tipos do .NET Framework e membros ainda podem ser chamados.  
  
> [!NOTE]
>  Esse método não faz parte do suporte de região (CER) de execução restrita e não deve ser confundido com o <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException">O espaço de pilha disponível é insuficiente para executar a função média do .NET Framework.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" />
        <Parameter Name="o2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o1">O primeiro objeto a ser comparado.</param>
        <param name="o2">O segundo objeto a ser comparado.</param>
        <summary>Determina se as instâncias <see cref="T:System.Object" /> especificadas são consideradas iguais.</summary>
        <returns>
          <see langword="true" />Se o <paramref name="o1" /> parâmetro está na mesma instância que o <paramref name="o2" /> parâmetro, ou se ambas forem <see langword="null" />, ou se <c>o1. Equals(O2)</c> retorna <see langword="true" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado por compiladores.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como comparar dois objetos usando o <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> método.  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" />
        <Parameter Name="userData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="code">Um delegado para o código a experimentar.</param>
        <param name="backoutCode">Um delegado para o código a executar se uma exceção ocorrer.</param>
        <param name="userData">Os dados a serem passados para <c>código</c> e <c>backoutCode</c>.</param>
        <summary>Executa o código usando um <see cref="T:System.Delegate" /> enquanto usa outro <see cref="T:System.Delegate" /> para executar código adicional no caso de uma exceção.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado por compiladores.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Um objeto para recuperar o código hash.</param>
        <summary>Serve como uma função de hash para um determinado objeto e é adequado para uso em algoritmos e estruturas de dados que usam códigos de hash, como uma tabela de hash.</summary>
        <returns>Um código hash para o objeto identificado pelo parâmetro <paramref name="o" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> método sempre chama o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método não virtualmente, mesmo se o tipo de objeto tiver substituído o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método. Portanto, o uso <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> pode diferir da chamada `GetHashCode` diretamente no objeto com o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> método.  
  
> [!WARNING]
>  Embora o <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> método retorna códigos de hash idênticos para referências de objeto idênticos, você não deve usar esse método para testar a identidade do objeto, pois esse código de hash não identifica exclusivamente uma referência de objeto. Para testar para identificar de objeto (ou seja, para testar que dois objetos de referência o mesmo objeto na memória), chame o <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> método. Ou você deve usar <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> para testar se duas cadeias de caracteres representam referências de objeto igual, porque a cadeia de caracteres é definidos como internos. Para testar a cadeia de caracteres como internos, chame o <xref:System.String.IsInterned%2A?displayProperty=nameWithType> método.  
  
 O <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> métodos diferem da seguinte maneira:  
  
-   <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>Retorna um código de hash com base na definição do objeto de igualdade. Por exemplo, duas cadeias de caracteres com conteúdo idêntico retornará o mesmo valor para <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
-   <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>Retorna um código de hash que indica a identidade do objeto. Ou seja, dois de cadeia de caracteres variáveis cujos conteúdos são idênticos e que representam uma cadeia de caracteres que é definidos como internos (consulte o [cadeia de caracteres como internos](#interning) seção) ou códigos de hash que representam uma única cadeia de caracteres na memória de retorno idênticos.  
  
> [!IMPORTANT]
>  Observe que <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> sempre retorna códigos de hash idênticos para referências de objeto igual. No entanto, o inverso é verdadeiro não: códigos hash igual não indicam referências de objeto igual. Um valor de código hash específico não é exclusivo para um determinado objeto de referência; referências de objeto diferentes podem gerar códigos hash idênticos.  
  
 Esse método é usado por compiladores.  
  
<a name="interning"></a>   
## <a name="string-interning"></a>Centralização da cadeia de caracteres  
 O common language runtime (CLR) mantém um pool interno de cadeias de caracteres e armazena literais no pool. Se duas cadeias de caracteres (por exemplo, `str1` e `str2`) são formadas de uma cadeia de caracteres idêntica literal, o CLR definirá `str1` e `str2` para apontar para o mesmo local no heap gerenciado para conservar memória. Chamando <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> na cadeia de caracteres dois objetos produzirá o mesmo código de hash, ao contrário do segundo item com marcador na seção anterior.  
  
 O CLR adiciona apenas literais para o pool. Resultados das operações de cadeia de caracteres, como concatenação não são adicionados ao pool, a menos que o compilador resolve a concatenação de cadeia de caracteres como uma única cadeia de caracteres literal. Portanto, se `str2` foi criado como resultado de uma operação de concatenação e `str2` é idêntico ao `str1`usando <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> na cadeia de caracteres dois objetos não produzirá o mesmo código de hash.  
  
 Se você deseja adicionar uma cadeia de caracteres concatenada ao pool explicitamente, use o <xref:System.String.Intern%2A?displayProperty=nameWithType> método.  
  
 Você também pode usar o <xref:System.String.IsInterned%2A?displayProperty=nameWithType> método para verificar se uma cadeia de caracteres tem uma referência interno.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a diferença entre o <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> e <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> métodos. A saída do exemplo ilustra o seguinte:  
  
-   Ambos os conjuntos de códigos de hash para o primeiro conjunto de cadeias de caracteres passada para o `ShowHashCodes` método forem diferentes, pois as cadeias de caracteres são completamente diferentes.  
  
-   <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>gera o mesmo código hash para o segundo conjunto de cadeias de caracteres passada para o `ShowHashCodes` método, porque as cadeias de caracteres são iguais. No entanto, o <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> método não. A primeira cadeia de caracteres é definida usando uma literal de cadeia de caracteres e portanto é definidos como internos. Embora o valor da segunda cadeia de caracteres é o mesmo, ele não é definidos como internos, porque ele é retornado por uma chamada para o <xref:System.String.Format%2A?displayProperty=nameWithType> método.  
  
-   No caso de cadeia de caracteres terceira, os códigos hash produzido por <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> para ambas as cadeias de caracteres são idênticas, como são os códigos de hash produzidos pelo <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>. Isso é porque o compilador foi tratado o valor atribuído a duas cadeias de caracteres como uma única cadeia de caracteres literal e, portanto, as variáveis de cadeia de caracteres se referem à mesma cadeia de caracteres definidos como interno.  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O tipo de valor a ser demarcado.</param>
        <summary>Demarca como um tipo de valor.</summary>
        <returns>Uma cópia demarcada do <paramref name="obj" /> se for uma classe de valor; caso contrário, o próprio <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um tipo de valor de conversão boxing cria um objeto e executa uma cópia superficial dos campos do tipo de valor especificado para o novo objeto.  
  
 Esse método permite que uma classe de valor a ser manipulada como um objeto enquanto mantém o comportamento de alias de uma classe de valor.  
  
 O valor de retorno depende se a classe de valor é mutável ou imutável:  
  
-   Se o valor que está sendo atribuído é uma classe de valor mutável, o método retorna uma cópia superficial da classe, porque as classes de valor tem semântica de cópia.  
  
-   Se o valor que está sendo atribuído é uma classe de valor imutável, o método retorna o objeto em si, em vez de uma cópia da classe.  
  
 Compiladores de idiomas dinamicamente com tipo podem usar esse método para certificar-se de que tipos de valor boxed funcionam do mesmo modo para tipos de valor não Demarcado. Ou seja, tipos de valor boxed obtenham clonados quando você passá-los ao redor, e eles sempre são transmitidos por valor. O compilador pode chamar <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> para atribuir um tipo de valor a um objeto ou para passar um tipo de valor como um parâmetro de um objeto de tipo.  
  
 Esse método é usado por compiladores.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como caixa de uma classe de valor usando o <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> método.  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array">A matriz a ser inicializada.</param>
        <param name="fldHandle">Um identificador de campo que especifica o local dos dados usados para inicializar a matriz.</param>
        <summary>Oferece uma maneira rápida de inicializar uma matriz de dados armazenados em um módulo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado por compiladores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o deslocamento, em bytes, para os dados na cadeia de caracteres especificada.</summary>
        <value>O deslocamento de byte, do início do objeto <see cref="T:System.String" /> para o primeiro caractere na cadeia de caracteres.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compiladores usam essa propriedade para operações de ponteiro inseguro, mas eficiente, os caracteres em uma cadeia de caracteres gerenciada. Compiladores devem fixar movimentação pelo coletor de lixo antes de usar a cadeia de caracteres. Observe que as cadeias de caracteres de tempo de execução de linguagem comuns são imutáveis; Isto é, seu conteúdo pode ser lido mas não alterado.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Designa um corpo de código como uma região de execução restrita (CER).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compiladores de usam esse método para marcar `catch`, `finally`, e `fault` blocos como regiões de execução restrita (CERs). Código que está marcado como uma região restrita só deve chamar outro código com contratos de confiabilidade forte. Ele não deve alocar ou fazer chamadas virtuais para métodos não preparadas ou não confiáveis, a menos que ele está preparado para lidar com falhas.  
  
 Observe que não intermediário opcodes de idioma, exceto `NOP`, são permitidos entre uma chamada para o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método e o `try` bloco. Para obter mais informações sobre as CERs, consulte as classes de <xref:System.Runtime.ConstrainedExecution> namespace.  
  
 CERs são marcadas com o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método não funcionar perfeitamente quando um <xref:System.StackOverflowException> é gerado a partir de `try` bloco. Para obter mais informações, consulte o método <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.  
  
 O <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> chamadas de método de <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir confiável identificadores usando o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método. Para definir com segurança um identificador para um identificador pré-existente especificado, você deve garantir que a alocação do identificador nativo e a gravação subsequente desse identificador em um <xref:System.Runtime.InteropServices.SafeHandle> objeto é atômico. Qualquer falha entre essas operações (por exemplo, uma exceção de falta de memória ou anulação de thread) resulta no identificador nativo vazem. Você pode usar o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> método para certificar-se de que o identificador não vazou.  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Designa um corpo de código como uma região de execução restrita (CER) sem executar qualquer probing.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compiladores não devem chamar este método diretamente. Em vez disso, defina uma CER chamando o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">O delegado de evento para preparar.</param>
        <summary>Fornece uma maneira de aplicativos preparar dinamicamente <see cref="T:System.AppDomain" /> delegados de eventos.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain>evento delega como <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, e <xref:System.AppDomain.UnhandledException> não está preparado automaticamente na inicialização. Você pode usar os seguintes métodos para prepará-los:  
  
-   O método de atributo usando o <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> atributo.  
  
-   O método de atributo usando o <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atributo.  
  
-   Chamar o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> método preparar dinamicamente o delegado.  
  
 Para obter mais informações, consulte o artigo [manter seu código em execução com os recursos de confiabilidade do .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) no MSDN Magazine.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">O tipo de delegado para preparar.</param>
        <summary>Indica que o delegado especificado deve estar preparado para inclusão em uma região de execução restrita (CER).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compiladores de usam esse método para preparar o método de invocação do delegado e preparar o destino dessa invocação (e o gráfico de chamada estaticamente determinável do representante) como uma região de execução restrita (CER).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="method">Um identificador para o método a ser preparado.</param>
        <summary>Prepara um método para inclusão em uma CER (região de execução restrita).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Compiladores usam o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> método para lidar com chamadas virtuais que são feitas dentro de uma região de execução restrita (CER). Em tempo de compilação JIT, o common language runtime geralmente não ter informações suficientes sobre o destino de uma chamada virtual. Portanto, o tempo de execução não inicialmente preparar o segmento do gráfico de chamada. Se o código que está usando a CER tem conhecimento suficiente determinar o destino em qualquer ponto no tempo antes do CER é efetivamente inserida, ele pode chamar <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> para realizar a preparação do tempo de execução mesmo normalmente é feita para a raiz de uma CER o método especificado como um argumento.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" />
      </Parameters>
      <Docs>
        <param name="method">Um identificador para o método a ser preparado.</param>
        <param name="instantiation">A instanciação a ser passada para o método.</param>
        <summary>Prepara um método para inclusão em uma CER (região de execução restrita) com a instanciação especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode fornecer suporte a genéricos compiladores usando o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> método. O common language runtime não é possível preparar as regiões de execução restrita (CERs) com raiz em um método que tem parâmetros de tipo genérico (um parâmetro de tipo na classe que contém o método ou um em que o próprio método) quando os parâmetros de tipo são instanciados como tipos de referência.  
  
 Você pode usar essa sobrecarga para passar uma instanciação específica (como uma matriz de tipos), especificando os parâmetros de tipo de classe primeiro (se houver), seguido pelos parâmetros de tipo de método (se houver). O tempo de execução prepara essa instanciação do método. (Isso é necessário apenas se a instâncias que você usar contém pelo menos um parâmetro de tipo de referência.) Assim, você pode usar um estilo de CER `try` cláusula em um método genérico (ou um método não genérico em uma classe genérica) e ele funcionam de forma confiável com instanciações de <xref:System.Int32> ou outros tipos de valor. Para criar uma instância de referência de tipos, como <xref:System.String>, você deve usar uma explícita <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> método no CER raiz método primeiro.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Testes para uma determinada quantidade de espaço de pilha para garantir que um estouro de pilha não pode ocorrer dentro de um bloco subsequente de código (supondo que o seu código usa apenas uma quantidade finita e moderada de espaço de pilha). É recomendável que você use uma região de execução restrita (CER) em vez desse método.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado pela infraestrutura de região (CER) de execução restrita quando em execução em hosts que são resistentes a estouro de pilha, como Microsoft SQL Server e Microsoft Exchange Server. Este método atualmente sondas de 48 KB de espaço de pilha em x86 plataforma, mas o valor exato pode ser alterado ao longo do tempo e pode variar em outras plataformas.  
  
 Esse método também é usado por compiladores.  
  
 Em vez de usar o <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> método, você deve usar uma CER padrão. Ou seja, se você estiver planejando usar uma quantidade moderada de espaço de pilha, chame o <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> método imediatamente antes de sua `try` / `finally` ou `try` / `catch` bloco. Se você estiver chamando um método recursivo ou planeja usar muito espaço de pilha, você deve usar o <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type">Um identificador de tipo que especifica o método de construtor de classe a ser executado.</param>
        <summary>Executa um método de construtor da classe especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado por compiladores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException">O inicializador de classe lança uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" />
      </Parameters>
      <Docs>
        <param name="module">Um identificador que especifica o método de construtor do módulo para executar.</param>
        <summary>Executa um método de construtor do módulo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é usado por compiladores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException">O construtor do módulo gera uma exceção.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
