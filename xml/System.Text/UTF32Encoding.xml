<Type Name="UTF32Encoding" FullName="System.Text.UTF32Encoding">
  <TypeSignature Language="C#" Value="public sealed class UTF32Encoding : System.Text.Encoding" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit UTF32Encoding extends System.Text.Encoding" />
  <TypeSignature Language="DocId" Value="T:System.Text.UTF32Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Text.Encoding</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa uma codificação de caracteres Unicode UTF-32.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificação é o processo de transformar um conjunto de caracteres Unicode em uma sequência de bytes. Decodificação de é o processo de transformar uma sequência de bytes codificados em um conjunto de caracteres Unicode.  
  
 O [padrão Unicode](http://go.microsoft.com/fwlink/?linkid=37123) atribui um ponto de código (um número) para cada caractere em todos os scripts com suporte. Um formato de transformação Unicode (UTF) é uma forma de codificar esse ponto de código. O [padrão Unicode](http://go.microsoft.com/fwlink/?linkid=37123) usa UTFs os seguintes:  
  
-   UTF-8, que representa cada ponto de código como uma sequência de um a quatro bytes.  
  
-   UTF-16, que representa cada ponto de código como uma sequência de inteiros de 16 bits de um ou dois.  
  
-   UTF-32, o que representa cada ponto de código como um inteiro de 32 bits.  
  
 Para obter mais informações sobre os UTFs e outras codificações com suporte <xref:System.Text>, consulte.  
  
 O <xref:System.Text.UTF32Encoding> classe representa uma codificação UTF-32. O codificador pode usar a ordem de byte big endian (byte mais significativo primeiro) ou a ordem de bytes endian pouca (byte menos significativo primeiro). Por exemplo, a letra maiuscula latina um (ponto de código U + 0041) é serializado como segue (em hexadecimal):  
  
-   Ordem de byte big endian: 00 00 00 41  
  
-   Ordem de bytes endian pouco: 41 00 00 00  
  
 É geralmente mais eficiente para armazenar caracteres Unicode usando a ordem de byte nativo. Por exemplo, é melhor usar a ordem de bytes endian pouco em plataformas endian pequeno, como computadores Intel. <xref:System.Text.UTF32Encoding>corresponde a páginas de código Windows 12000 (ordem de byte endian pouco) e 12001 (ordem de byte big endian). Você pode determinar o "endian" de uma arquitetura específica chamando o <xref:System.BitConverter.IsLittleEndian?displayProperty=nameWithType> método.  
  
 Opcionalmente, o <xref:System.Text.UTF32Encoding> objeto fornece uma marca de ordem de byte (BOM), que é uma matriz de bytes que pode ter como prefixo para a sequência de bytes resultante do processo de codificação. Se o preâmbulo contiver uma marca de ordem de byte (BOM), ele ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF de uma matriz de bytes.  
  
 Se o <xref:System.Text.UTF32Encoding> instância está configurada para fornecer um BOM, você poderá recuperá-lo ao chamar o <xref:System.Text.UTF32Encoding.GetPreamble%2A> método; caso contrário, o método retorna uma matriz vazia. Observe que, mesmo se um <xref:System.Text.UTF32Encoding> objeto é configurado para dar suporte a BOM, você deve incluir a BOM no início do fluxo de bytes codificados como apropriado; os métodos de codificação do <xref:System.Text.UTF32Encoding> classe não faça isso automaticamente.  
  
 Para habilitar a detecção de erro e tornar a instância da classe mais seguro, você deve criar uma instância de um <xref:System.Text.UTF32Encoding> objeto chamando o <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtor e a configuração de seu `throwOnInvalidBytes` argumento `true`. Com a detecção de erro, um método que detecta uma sequência inválida de caracteres ou bytes lança um <xref:System.ArgumentException> exceção. Sem detecção de erro, nenhuma exceção é lançada e a sequência inválida geralmente é ignorada.  
  
 Você pode instanciar uma <xref:System.Text.UTF32Encoding> objeto de várias maneiras, dependendo se você deseja-lo para fornecer uma marca de ordem de byte (BOM), se desejar que a codificação big-endian ou little endian e se você deseja habilitar a detecção de erro. A seguinte tabela lista o <xref:System.Text.UTF32Encoding> construtores e <xref:System.Text.Encoding> propriedades que retornam uma <xref:System.Text.UnicodeEncoding> objeto.  
  
|Membro|Endianness|BOM|Detecção de erro|  
|------------|----------------|---------|---------------------|  
|<xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType>|Little endian|Sim|Nenhum (fallback de substituição)|  
|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=nameWithType>|Little endian|Sim|Nenhum (fallback de substituição)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurável|Configurável|Nenhum (fallback de substituição)|  
|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>|Configurável|Configurável|Configurável|  
  
 O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.UTF32Encoding.GetBytes%2A> método executa a codificação real.  
  
 Da mesma forma, o <xref:System.Text.UTF32Encoding.GetCharCount%2A> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.UTF32Encoding.GetChars%2A> e <xref:System.Text.UTF32Encoding.GetString%2A> os métodos executam a decodificação real.  
  
 Para um codificador ou decodificador é capaz de salvar informações de estado quando a codificação ou decodificação de dados que abrange vários blocos (como cadeia de caracteres de 1 milhão de caracteres codificada em segmentos de caractere de 100.000), use o <xref:System.Text.UTF32Encoding.GetEncoder%2A> e <xref:System.Text.UTF32Encoding.GetDecoder%2A> propriedades, respectivamente.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o comportamento de <xref:System.Text.UTF32Encoding> objetos com e sem detecção de erro habilitada. Ele cria uma matriz de bytes cujos últimos quatro bytes representam um par substituto inválido; o substituto alto U + D8FF é seguido por um U + 01FF, que está fora do intervalo de substitutos baixos (0xDC00 a 0xDFFF). Sem detecção de erro, o decodificador UTF32 usa fallback de substituição para substituir o par substituto inválido com o CARACTERE de substituição (U + FFFD).  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 O exemplo a seguir codifica uma cadeia de caracteres Unicode em uma matriz de bytes usando um <xref:System.Text.UTF32Encoding> objeto. A matriz de bytes, em seguida, é decodificada em uma cadeia de caracteres para demonstrar que não há nenhuma perda de dados.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  
  
 O exemplo a seguir usa a mesma cadeia de caracteres que o anterior, exceto que ele grava os bytes codificados em um arquivo e prefixos de fluxo de bytes com uma marca de ordem de byte (BOM). Ele lê o arquivo de duas maneiras diferentes: como um arquivo de texto usando um <xref:System.IO.StreamReader> objeto; e como um arquivo binário. Como se esperaria em nenhum caso é BOM incluído na cadeia de caracteres leitura recentemente.  
  
 [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.UTF32Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria uma instância que usa a ordem de bytes endian pouco, fornece uma marca de ordem de byte Unicode e não gerará uma exceção quando uma codificação inválido é detectada.  
  
> [!NOTE]
>  Por motivos de segurança, você deve ativar a detecção de erro chamando o <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtor e a configuração de seu `throwOnInvalidCharacters` argumento `true`.  
  
   
  
## Examples  
 O seguinte exemplo recupera e exibe a ordem de byte marcar para diferentes <xref:System.Text.UTF32Encoding> instâncias.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> para usar a ordem de byte big endian (byte mais significativo primeiro) ou <see langword="false" /> para usar a ordem de byte little endian (byte menos significativo primeiro).</param>
        <param name="byteOrderMark">
          <see langword="true" />para especificar que uma marca de ordem de byte Unicode é fornecida; Caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.UTF32Encoding" />. Parâmetros de especificam se deseja usar a ordem de byte big endian e se o <see cref="M:System.Text.UTF32Encoding.GetPreamble" /> método retorna uma marca de ordem de byte Unicode Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria uma instância que não lança uma exceção quando uma codificação inválido é detectada.  
  
> [!NOTE]
>  Por motivos de segurança, você deve ativar a detecção de erro chamando o <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtor e a configuração de seu `throwOnInvalidCharacters` argumento `true`.  
  
   
  
## Examples  
 O seguinte exemplo recupera e exibe a ordem de byte marcar para diferentes <xref:System.Text.UTF32Encoding> instâncias.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="bigEndian" Type="System.Boolean" />
        <Parameter Name="byteOrderMark" Type="System.Boolean" />
        <Parameter Name="throwOnInvalidCharacters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="bigEndian">
          <see langword="true" /> para usar a ordem de byte big endian (byte mais significativo primeiro) ou <see langword="false" /> para usar a ordem de byte little endian (byte menos significativo primeiro).</param>
        <param name="byteOrderMark">
          <see langword="true" />para especificar que uma marca de ordem de byte Unicode é fornecida; Caso contrário, <see langword="false" />.</param>
        <param name="throwOnInvalidCharacters">
          <see langword="true" />para especificar que uma exceção deve ser gerada quando uma codificação inválido é detectada; Caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.UTF32Encoding" />. Parâmetros especificam se deve usar a ordem de byte big endian, se deseja fornecer uma marca de ordem de byte Unicode e se lançar uma exceção quando uma codificação inválido é detectada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `throwOnInvalidCharacters` é `true`, um método que detecta uma sequência de bytes inválido gera <xref:System.ArgumentException?displayProperty=nameWithType>. Caso contrário, o método não lança uma exceção, e a sequência inválida é ignorada.  
  
> [!NOTE]
>  Por motivos de segurança, você deve ativar a detecção de erro chamando o <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> construtor e a configuração de seu `throwOnInvalidCharacters` argumento `true`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o comportamento de <xref:System.Text.UTF32Encoding>, com detecção de erro habilitada e sem.  
  
 [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O <see cref="T:System.Object" /> para comparar com o objeto atual.</param>
        <summary>Determina se o especificado <see cref="T:System.Object" /> é igual à atual <see cref="T:System.Text.UTF32Encoding" /> objeto.</summary>
        <returns>
          <see langword="true" />Se <paramref name="value" /> é uma instância de <see cref="T:System.Text.UTF32Encoding" /> e é igual ao objeto atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dois <xref:System.Text.UTF32Encoding> objetos são considerados iguais se todas as seguintes condições forem verdadeiras:  
  
-   Os dois objetos usam a mesma ordem de byte.  
  
-   Os dois objetos fornecem a marca de ordem de byte, ou ambos não.  
  
-   Os dois objetos usam o mesmo codificador de fallback.  
  
-   Os dois objetos usam o mesmo decodificador de fallback.  
  
   
  
## Examples  
 O exemplo a seguir cria <xref:System.Text.UTF32Encoding> objetos usando valores de parâmetros diferentes e, em seguida, verifica-las para fins de igualdade.  
  
 [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">O <see cref="T:System.String" /> que contém o conjunto de caracteres a ser codificado.</param>
        <summary>Calcula o número de bytes produzidos codificando todos os caracteres no <see cref="T:System.String" /> especificado.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo. Inserindo o preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <xref:System.Text.UTF32Encoding.GetByteCount%2A> método.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> e <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> métodos para calcular o número real e máximo de bytes necessários para codificar uma cadeia de caracteres. Ele também exibe o número real de bytes necessários para armazenar um fluxo de bytes com uma marca de ordem de byte.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="s" /> contém uma sequência de caracteres inválida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Um ponteiro para o primeiro caractere a ser codificado.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Calcula o número de bytes produzidos por codificação de um conjunto de caracteres a partir do ponteiro de caractere especificado.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar uma <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo. Inserindo um preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <xref:System.Text.UTF32Encoding.GetByteCount%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public override int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="index">O índice do primeiro caractere a codificação.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Calcula o número de bytes produzidos codificando um conjunto de caracteres da matriz de caracteres especificada.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo. Inserindo um preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor e o número de bytes no preâmbulo não é refletido no valor retornado pelo <xref:System.Text.UTF32Encoding.GetByteCount%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir preenche uma matriz com um latino letras maiusculas e minúsculas e chama o <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar o número de bytes necessários para codificar caracteres latinos em minúsculas. Em seguida, exibe essas informações junto com o número total de bytes necessários se for adicionada uma marca de ordem de byte. Ele compara esse número com o valor retornado pelo <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica o número máximo de bytes necessários para codificar caracteres latinos em minúsculas. O exemplo a seguir preenche uma matriz com uma combinação de caracteres grego e cirílico e chama o <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para determinar o número de bytes necessários para codificar os caracteres cirílicos. Em seguida, exibe essas informações junto com o número total de bytes necessários se for adicionada uma marca de ordem de byte. Ele compara esse número com o valor retornado pelo <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> método, que indica o número máximo de bytes necessários para codificar os caracteres cirílicos.  
  
 [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]
 [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="chars" />.  
  
 -ou-  
  
 Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Um ponteiro para o primeiro caractere a ser codificado.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">Um ponteiro para o local no qual começar a escrever a sequência resultante de bytes.</param>
        <param name="byteCount">O número máximo de bytes a serem gravados.</param>
        <summary>Codifica um conjunto de caracteres a partir do ponteiro de caractere especificado em uma sequência de bytes armazenados iniciando o ponteiro de bytes especificado.</summary>
        <returns>O número real de bytes gravados no local indicado pelo parâmetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais. Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo usa o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.UTF32Encoding.GetDecoder%2A> método ou o <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
> [!NOTE]
>  Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo. Inserindo um preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor. O <xref:System.Text.UTF32Encoding.GetBytes%2A> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ou <paramref name="byteCount" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.  
  
 -ou-  
  
 <paramref name="byteCount" /> é menor que o número de bytes resultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="charIndex">O índice do primeiro caractere a codificação.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">A matriz de bytes para conter a sequência resultante de bytes.</param>
        <param name="byteIndex">O índice no qual será iniciada a gravação da sequência de bytes resultante.</param>
        <summary>Codifica um conjunto de caracteres da matriz de caractere especificado para a matriz de bytes especificado.</summary>
        <returns>O número real de bytes gravados no <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais. Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo usa o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.UTF32Encoding.GetDecoder%2A> método ou o <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
> [!NOTE]
>  Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo. Inserindo um preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor. O <xref:System.Text.UTF32Encoding.GetBytes%2A> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, em seguida, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.  
  
 -ou-  
  
 <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="chars" /> contém uma sequência de caracteres inválida.  
  
 -ou-  
  
 O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">O <see cref="T:System.String" /> que contém o conjunto de caracteres a ser codificado.</param>
        <param name="charIndex">O índice do primeiro caractere a codificação.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">A matriz de bytes para conter a sequência resultante de bytes.</param>
        <param name="byteIndex">O índice no qual será iniciada a gravação da sequência de bytes resultante.</param>
        <summary>Codifica um conjunto de caracteres do <see cref="T:System.String" /> especificado para a matriz de bytes especificada.</summary>
        <returns>O número real de bytes gravados no <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais. Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo usa o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.UTF32Encoding.GetDecoder%2A> método ou o <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
> [!NOTE]
>  Para garantir que os bytes codificados são decodificar corretamente quando eles são salvos como um arquivo ou como um fluxo, poderá colocar um fluxo de bytes codificados com um preâmbulo. Inserindo um preâmbulo no início de um fluxo de bytes (como no início de uma série de bytes a serem gravados em um arquivo) é responsabilidade do desenvolvedor. O <xref:System.Text.UTF32Encoding.GetBytes%2A> método não preceda um preâmbulo para o início de uma sequência de bytes codificados.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres e codifica a cadeia de caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.  
  
 -ou-  
  
 <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="s" /> contém uma sequência de caracteres inválida.  
  
 -ou-  
  
 O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro do primeiro byte a ser decodificado.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes começando no ponteiro de bytes especificado.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.UTF32Encoding.GetCharCount%2A>calcula o tamanho da matriz exatos necessário para o <xref:System.Text.UTF32Encoding.GetChars%2A> método para armazenar os caracteres resultantes. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.UTF32Encoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public override int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte para decodificar.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes da matriz de bytes especificada.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.UTF32Encoding.GetCharCount%2A> método calcula o tamanho da matriz exatos necessário para o <xref:System.Text.UTF32Encoding.GetChars%2A> método para armazenar os caracteres resultantes. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.UTF32Encoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.  
  
 -ou-  
  
 Número excessivo de caracteres. O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro do primeiro byte a ser decodificado.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <param name="chars">Um ponteiro para o local no qual começar a escrever resultante conjunto de caracteres.</param>
        <param name="charCount">O número máximo de caracteres a serem gravados.</param>
        <summary>Decodifica uma sequência de bytes a partir do ponteiro de bytes especificada em um conjunto de caracteres que são armazenados iniciando o ponteiro de caractere especificado.</summary>
        <returns>O número real de caracteres gravados no local indicado pelo <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetChars%2A> para armazenar os caracteres resultantes, chame o <xref:System.Text.UTF32Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.UTF32Encoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método. Você pode removê-lo ao chamar o <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais. Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo usa o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.UTF32Encoding.GetDecoder%2A> método ou o <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ou <paramref name="charCount" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.  
  
 -ou-  
  
 <paramref name="charCount" />é menor que o número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="byteIndex">O índice do primeiro byte para decodificar.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <param name="chars">A matriz de caracteres para conter o conjunto de caracteres resultante.</param>
        <param name="charIndex">O índice no qual será iniciada a gravação do conjunto de caracteres resultante.</param>
        <summary>Decodifica uma sequência de bytes da matriz de bytes especificada na matriz de caracteres especificada.</summary>
        <returns>O número real de caracteres gravados em <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetChars%2A> para armazenar os caracteres resultantes, chame o <xref:System.Text.UTF32Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.UTF32Encoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método. Você pode removê-lo ao chamar o <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais. Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo usa o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.UTF32Encoding.GetDecoder%2A> método ou o <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="byteindex" /> e <paramref name="byteCount" /> não denotam um intervalo válido em <paramref name="bytes" />.  
  
 -ou-  
  
 <paramref name="charIndex" /> não é um índice válido em <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.  
  
 -ou-  
  
 <paramref name="chars" /> não tem capacidade suficiente do <paramref name="charIndex" /> até o final da matriz para acomodar os caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public override System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetDecoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um decodificador que converte uma sequência codificada em UTF-32 de bytes em uma sequência de caracteres Unicode.</summary>
        <returns>Um <see cref="T:System.Text.Decoder" /> que converte uma sequência codificada em UTF-32 de bytes em uma sequência de caracteres Unicode.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método converte blocos sequenciais de bytes em blocos sequenciais de caracteres, de maneira semelhante para o <xref:System.Text.UTF32Encoding.GetChars%2A> método. No entanto, um <xref:System.Text.Decoder> mantém informações de estado entre as chamadas para corretamente pode decodificar sequências de bytes que abrangem os blocos. O <xref:System.Text.Decoder> também preserva bytes à direita do final de blocos de dados e usa os bytes à direita na próxima operação de decodificação. Portanto, <xref:System.Text.UTF32Encoding.GetDecoder%2A> e <xref:System.Text.UTF32Encoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.  
  
 Se detecção de erros está habilitada, ou seja, o `throwOnInvalidCharacters` parâmetro do construtor foi definido como `true`, detecção de erros também está habilitada no <xref:System.Text.Decoder> retornado por esse método. Se a detecção de erros está habilitada e uma sequência inválida for encontrada, o estado do decodificador é indefinido e processamento deve parar.  
  
   
  
## Examples  
 O exemplo a seguir usa um codificador e um decodificador para codificar uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodificar os bytes para uma matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public override System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetEncoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um codificador que converte uma sequência de caracteres Unicode em uma sequência codificada em UTF-32 de bytes.</summary>
        <returns>Um <see cref="T:System.Text.Encoder" /> que converte uma sequência de caracteres Unicode em uma sequência codificada em UTF-32 de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método converte blocos sequenciais de caracteres em blocos sequenciais de bytes, de maneira semelhante para o <xref:System.Text.UTF32Encoding.GetBytes%2A> método. No entanto, um <xref:System.Text.Encoder> mantém informações de estado entre as chamadas para que ele pode codificar corretamente sequências de caracteres que abrangem os blocos. O <xref:System.Text.Encoder> também preserva à direita caracteres do final de blocos de dados e usa os caracteres à direita na próxima operação de codificação. Por exemplo, um bloco de dados pode terminar com um alto-substitutos sem correspondência e o baixa-substituto correspondente pode estar no próximo bloco de dados. Portanto, <xref:System.Text.UTF32Encoding.GetDecoder%2A> e <xref:System.Text.UTF32Encoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.  
  
 Se detecção de erros está habilitada, ou seja, o `throwOnInvalidCharacters` parâmetro do construtor foi definido como `true`, detecção de erros também está habilitada no <xref:System.Text.Encoder> retornado por esse método. Se a detecção de erros está habilitada e uma sequência inválida for encontrada, o estado do codificador é indefinido e processamento deve parar.  
  
   
  
## Examples  
 O exemplo a seguir usa um codificador e um decodificador para codificar uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodificar os bytes para uma matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para a instância atual.</summary>
        <returns>O código hash para a atual <see cref="T:System.Text.UTF32Encoding" /> objeto.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public override int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <summary>Calcula o número máximo de bytes que produziu o número especificado de caracteres de codificação.</summary>
        <returns>O número máximo de bytes que produziu o número especificado de caracteres de codificação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.UTF32Encoding.GetByteCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>é um número pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.EncoderFallback>. Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> pode retornar valores grandes.  
  
 Na maioria dos casos, esse método retorna números razoáveis para cadeias de caracteres pequenas. Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável for excedido. Você também poderá usar uma abordagem diferente e usar <xref:System.Text.UTF32Encoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>não tem relação com <xref:System.Text.UTF32Encoding.GetChars%2A>. Se você precisar de uma função semelhante para usar com <xref:System.Text.UTF32Encoding.GetChars%2A>, use <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  
  
> [!NOTE]
>  `GetMaxByteCount(N)`não é necessariamente o mesmo valor como `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres e codifica a cadeia de caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> é menor que zero.  
  
 -ou-  
  
 O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public override int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <summary>Calcula o número máximo de caracteres produzido decodificando o número de bytes especificado.</summary>
        <returns>O número máximo de caracteres produzido decodificando o número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.UTF32Encoding.GetChars%2A> para armazenar os caracteres resultantes, você deve chamar o <xref:System.Text.UTF32Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, você deve chamar o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.UTF32Encoding.GetCharCount%2A> método aloca geralmente menos memória, enquanto o <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>é um número pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.DecoderFallback>. Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> pode retornar valores grandes.  
  
 Na maioria dos casos, esse método retorna números razoáveis para cadeias de caracteres pequenas. Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável for excedido. Você também poderá usar uma abordagem diferente e usar <xref:System.Text.UTF32Encoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A>.  
  
 <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>não tem relação com <xref:System.Text.UTF32Encoding.GetBytes%2A>. Se você precisar de uma função semelhante para usar com <xref:System.Text.UTF32Encoding.GetBytes%2A>, use <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  
  
> [!NOTE]
>  `GetMaxCharCount(N)`não é necessariamente o mesmo valor como `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> é menor que zero.  
  
 -ou-  
  
 O número de bytes resultante é maior que o número máximo que pode ser retornado como um inteiro.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public override byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetPreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma marca de ordem de byte Unicode codificada no formato UTF-32, se o <see cref="T:System.Text.UTF32Encoding" /> objeto é configurado para fornecer uma.</summary>
        <returns>Uma matriz de bytes que contém a marca de ordem de byte Unicode se o objeto <see cref="T:System.Text.UTF32Encoding" /> é configurado para fornecer uma. Caso contrário, esse método retorna uma matriz de bytes de tamanho zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.UTF32Encoding> objeto pode fornecer um preâmbulo, que é uma matriz de bytes que pode ter como prefixo para a sequência de bytes resultante do processo de codificação. Iniciar uma sequência de bytes codificados com uma marca de ordem de byte (pontos de código U + 0000 U + FEFF) ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF. A marca de ordem de byte Unicode (BOM) é serializada da seguinte maneira (em hexadecimal):  
  
-   Ordem de byte big endian: 00 00 FE FF  
  
-   Ordem de bytes endian pouco: FF FE 00 00  
  
 Você pode instanciar uma <xref:System.Text.UTF32Encoding> do objeto cuja <xref:System.Text.UTF32Encoding.GetPreamble%2A> método retorna um BOM válido das seguintes maneiras:  
  
-   Recuperando o <xref:System.Text.UTF32Encoding> objeto retornado pelo <xref:System.Text.Encoding.UTF32%2A?displayProperty=nameWithType> propriedade.  
  
-   Chamando o sem parâmetros <xref:System.Text.UTF32Encoding.%23ctor> construtor para instanciar um <xref:System.Text.UTF32Encoding> objeto.  
  
-   Fornecendo `true` como o valor da `byteOrderMark` argumento para o <xref:System.Text.UTF32Encoding.%23ctor%2A> e <xref:System.Text.UTF32Encoding.%23ctor%2A> construtores.  
  
 É recomendável que você use BOM, pois ele fornece quase determinada identificação de uma codificação para arquivos que foram perdidos referência para o <xref:System.Text.UTF32Encoding> objeto, por exemplo, sem marcas ou marcada incorretamente os dados da web ou arquivos de texto aleatório armazenados quando uma empresa não tinha preocupações internacionais ou outros dados. Geralmente, os problemas do usuário podem ser evitados se dados são marcados de forma consistente e corretamente.  
  
 Para os padrões que fornecem um tipo de codificação, um BOM é um pouco redundante. No entanto, ele pode ser usado para ajudar a um servidor de enviar o cabeçalho de codificação correto. Como alternativa, ele pode ser usado como um fallback caso a codificação caso contrário, será perdida.  
  
 Há algumas desvantagens de usar um BOM. Por exemplo, saber como limitar os campos de banco de dados que usam um BOM pode ser difícil. Concatenação de arquivos pode ser um problema também, por exemplo, quando os arquivos são mesclados de tal forma que um caractere desnecessário pode terminar no meio de dados. Apesar de algumas desvantagens, no entanto, o uso de um BOM é altamente recomendável.  
  
 Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte o Unicode Standard no [home page do Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Para garantir que os bytes codificados são decodificar corretamente, você deve prefixar bytes codificados com um preâmbulo. Observe que o <xref:System.Text.UTF32Encoding.GetBytes%2A> método não preceda um BOM para uma sequência de bytes codificados; fornecer um BOM no início de um fluxo de bytes apropriado é responsabilidade do desenvolvedor.  
  
   
  
## Examples  
 O seguinte código exemplo recupera e exibe a ordem de byte marcar para diferentes <xref:System.Text.UTF32Encoding> instâncias.  
  
 [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  
  
 O exemplo a seguir cria dois <xref:System.Text.UTF32Encoding> objetos, a primeira delas não fornece um BOM e o segundo, que não. Depois, ele chama o <xref:System.Text.UTF32Encoding.GetPreamble%2A> método gravar BOM para um arquivo antes de gravar uma cadeia de caracteres codificado em UTF-32. Como mostra a saída do exemplo, o arquivo que salva os bytes do codificador do segundo tem quatro bytes mais que o primeiro.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  
  
 Você também pode comparar os arquivos usando o `fc` comando em uma janela de console, ou você pode inspecionar os arquivos em um editor de texto que inclui um modo de exibição hexadecimal. Observe que, quando o arquivo é aberto em um editor que dá suporte a UTF-32, BOM não será exibida.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public override string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte para decodificar.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Decodifica um intervalo de bytes de uma matriz de bytes em uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que contém os resultados de decodificação de sequência especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Detecção de erro, uma sequência inválida faz com que esse método lançar um <xref:System.ArgumentException>. Sem detecção de erro inválidas sequências são ignoradas e nenhuma exceção é lançada.  
  
 Se o intervalo de bytes a ser decodificado inclui a marca de ordem de byte (BOM) e a matriz de bytes foi retornada por um método de um tipo com reconhecimento de não-BOM, o caractere de U + FFFE está incluído na matriz de caracteres retornada por este método. Você pode removê-lo ao chamar o <xref:System.String.TrimStart%2A?displayProperty=nameWithType> método.  
  
 Dados a serem convertidos, como a leitura de um fluxo de dados podem estar disponíveis somente em blocos sequenciais. Nesse caso, ou se a quantidade de dados é tão grande que precisa ser divididos em blocos menores, o aplicativo deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.UTF32Encoding.GetDecoder%2A> método ou o <xref:System.Text.UTF32Encoding.GetEncoder%2A> método, respectivamente.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em duas matrizes de matrizes de bytes, em ordem little endian e outro na ordem big-endian. Ele decodifica, em seguida, os bytes de volta para uma cadeia de caracteres.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]
 [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  
  
 O exemplo a seguir inicializa uma matriz chamando o <xref:System.Text.UTF32Encoding.GetByteCount%2A> método para determinar exatamente quantos bytes são necessários para uma cadeia de caracteres codificada e, em seguida, adicionar o tamanho da marca de ordem de byte (BOM). O exemplo, em seguida, chama o <xref:System.Text.UTF32Encoding.GetPreamble%2A> método para armazenar o BOM para a matriz antes de chamar o <xref:System.Text.UTF32Encoding.GetBytes%2A> método para armazenar os bytes codificados para a matriz. O exemplo, em seguida, chama o <xref:System.Text.UTF32Encoding.GetString%2A> método decodificar a cadeia de caracteres.  
  
 [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]
 [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  
  
 Observe que nesse caso a cadeia de caracteres decodificada é diferente de cadeia de caracteres original, desde que ela começa com uma marca de ordem de byte de 32 bits U + FFFE U + 0000. Isso significa que compara duas cadeias de caracteres como diferente e que, se a cadeia de caracteres é a saída, a BOM será exibida como o caractere de substituição "?".  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">A detecção de erros está habilitada e <paramref name="bytes" /> contém uma sequência de bytes inválida.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
