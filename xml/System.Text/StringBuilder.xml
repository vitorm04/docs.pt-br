<Type Name="StringBuilder" FullName="System.Text.StringBuilder">
  <TypeSignature Language="C#" Value="public sealed class StringBuilder : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit StringBuilder extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Text.StringBuilder" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma cadeia de caracteres mutável. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/text/stringbuilder.cs#adf60ee46ebd299f). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Essa classe representa um objeto de tipo de cadeia de caracteres cujo valor é uma sequência de caracteres de mutável.  
  
 Nesta seção:  
  
-   [Os tipos de cadeia de caracteres e StringBuilder](#StringAndSB)  
  
-   [Como funciona o StringBuilder](#HowWorks)  
  
-   [Alocação de memória](#Memory)  
  
-   [Criando um objeto StringBuilder](#Instantiating)  
  
-   [Chamando métodos de StringBuilder](#Calling)  
  
-   [Executando operações de StringBuilder](#Operations)  
  
    -   [Iteração caracteres StringBuilder](#Iterating)  
  
    -   [Adicionar texto a um objeto StringBuilder](#Adding)  
  
    -   [Excluindo o texto de um objeto StringBuilder](#Deleting)  
  
    -   [Modificando o texto em um objeto StringBuilder](#Modifying)  
  
-   [Pesquisando o texto em um objeto StringBuilder](#Searching)  
  
-   [Converter o objeto StringBuilder em uma cadeia de caracteres](#Converting)  
  
<a name="StringAndSB"></a>   
## <a name="the-string-and-stringbuilder-types"></a>Os tipos String e StringBuilder  
 Embora <xref:System.Text.StringBuilder> e <xref:System.String> ambos representam sequências de caracteres, eles são implementados de maneira. <xref:System.String>é um tipo imutável. Ou seja, cada operação que é exibida modificar um <xref:System.String> objeto realmente cria uma nova cadeia de caracteres.  
  
 Por exemplo, a chamada para o <xref:System.String.Concat%2A?displayProperty=nameWithType> método o exemplo c# a seguir é exibida alterar o valor de uma variável de cadeia de caracteres chamada `value`. Na verdade, o <xref:System.String.Concat%2A> método retorna um `value` objeto que tem um valor diferente e um endereço do `value` objeto passado para o método. Observe que o exemplo deve ser compilado usando o `/unsafe` opção de compilador.  
  
 [!code-csharp[System.Text.StringBuilder.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/immutability2.cs#1)]  
  
 Para rotinas que executam manipulação de cadeia de caracteres amplo (como aplicativos que modificar várias vezes em um loop em uma cadeia de caracteres), a modificação de uma cadeia de caracteres repetidamente pode exato uma penalidade de desempenho significativa. A alternativa é usar <xref:System.Text.StringBuilder>, que é uma classe de cadeia de caracteres mutável. Mutabilidade significa que, quando uma instância da classe tiver sido criada, ele pode ser modificado por acrescentando, remover, substituir ou inserir caracteres. Um <xref:System.Text.StringBuilder> objeto mantém um buffer para acomodar expansões à cadeia de caracteres. Novos dados são anexados ao buffer se espaço está disponível. Caso contrário, um novo buffer maior é alocado, dados do buffer original são copiados para o novo buffer e os novos dados, em seguida, são acrescentados ao buffer de novo.  
  
> [!IMPORTANT]
>  Embora o <xref:System.Text.StringBuilder> classe geralmente oferece desempenho melhor do que o <xref:System.String> classe, você não poderá automaticamente substituir <xref:System.String> com <xref:System.Text.StringBuilder> sempre que você deseja manipular cadeias de caracteres. Desempenho depende do tamanho da cadeia de caracteres, a quantidade de memória a ser alocada para a nova cadeia de caracteres, o sistema no qual seu aplicativo está em execução e o tipo de operação. Você deve estar preparado para testar seu aplicativo para determinar se <xref:System.Text.StringBuilder> realmente oferece uma melhoria significativa de desempenho.  
  
 Considere o uso de <xref:System.String> classe sob estas condições:  
  
-   Quando o número de alterações que seu aplicativo fará uma cadeia de caracteres é pequeno. Nesses casos, <xref:System.Text.StringBuilder> pode oferta insignificante ou nenhuma melhoria de desempenho sobre <xref:System.String>.  
  
-   Quando você está executando um número fixo de operações de concatenação, particularmente com literais de cadeia de caracteres. Nesse caso, o compilador pode combinar as operações de concatenação em uma única operação.  
  
-   Quando você tem que executar operações de pesquisa extensos enquanto você estiver criando sua cadeia de caracteres. O <xref:System.Text.StringBuilder> não classe tem métodos de pesquisa, como `IndexOf` ou `StartsWith`. Você precisa converter o <xref:System.Text.StringBuilder> o objeto para um <xref:System.String> para essas operações e isso podem invalidar o benefício de usar <xref:System.Text.StringBuilder>. Para obter mais informações, consulte o [pesquisando o texto em um objeto StringBuilder](#Searching) seção.  
  
 Considere o uso de <xref:System.Text.StringBuilder> classe sob estas condições:  
  
-   Quando você espera que seu aplicativo para tornar um número desconhecido de alterações para uma cadeia de caracteres em tempo de design (por exemplo, quando você estiver usando um loop de concatenar um número aleatório de cadeias de caracteres que contém a entrada do usuário).  
  
-   Quando você espera que seu aplicativo para tornar um número significativo de alterações para uma cadeia de caracteres.  
  
<a name="HowWorks"></a>   
## <a name="how-stringbuilder-works"></a>Como StringBuilder funciona  
 O <xref:System.Text.StringBuilder.Length%2A?displayProperty=nameWithType> propriedade indica o número de caracteres a <xref:System.Text.StringBuilder> atualmente contém um objeto. Se você adicionar caracteres para o <xref:System.Text.StringBuilder> do objeto, seu tamanho aumenta até que ele é igual ao tamanho do <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propriedade, que define o número de caracteres que contém o objeto. Se o número de caracteres adicionados faz com que o comprimento do <xref:System.Text.StringBuilder> objeto exceda sua capacidade atual, a nova memória é alocada, o valor da <xref:System.Text.StringBuilder.Capacity%2A> propriedade é duplicada, novos caracteres serão adicionados ao <xref:System.Text.StringBuilder> objeto e sua <xref:System.Text.StringBuilder.Length%2A> propriedade é ajustada. Memória adicional para o <xref:System.Text.StringBuilder> objeto esteja alocado dinamicamente até atingir o valor definido pelo <xref:System.Text.StringBuilder.MaxCapacity%2A?displayProperty=nameWithType> propriedade. Quando a capacidade máxima é atingida, nenhuma memória adicional pode ser alocada para o <xref:System.Text.StringBuilder> objeto e tentando caracteres de adicionar ou expandi-lo, além de sua capacidade máxima gera um <xref:System.ArgumentOutOfRangeException> ou um <xref:System.OutOfMemoryException> exceção.  
  
 O exemplo a seguir ilustra como uma <xref:System.Text.StringBuilder> objeto aloca memória novo e aumenta sua capacidade dinamicamente à medida que se expande a cadeia de caracteres atribuída ao objeto. O código cria um <xref:System.Text.StringBuilder> objeto chamando seu construtor (sem parâmetros) padrão. A capacidade padrão desse objeto é 16 caracteres e sua capacidade máxima é de mais de 2 bilhões de caracteres. Acrescentando a cadeia de caracteres "Esta é uma frase". resulta em uma nova alocação de memória porque o comprimento de cadeia de caracteres (19 caracteres) excede a capacidade padrão da <xref:System.Text.StringBuilder> objeto. A capacidade do objeto de dobra a 32 caracteres, nova cadeia de caracteres é adicionada e o comprimento do objeto agora é igual a 19 caracteres. O código então adiciona a cadeia de caracteres "Esta é uma frase adicional." como o valor da <xref:System.Text.StringBuilder> objeto 11 vezes. Sempre que a operação de acréscimo faz com que o comprimento do <xref:System.Text.StringBuilder> objeto exceda sua capacidade, sua capacidade existente é duplicado e o <xref:System.Text.StringBuilder.Append%2A> operação for bem-sucedida.  
  
 [!code-csharp[System.Text.StringBuilder.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/default1.cs#3)]
 [!code-vb[System.Text.StringBuilder.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/default1.vb#3)]  
  
<a name="Memory"></a>   
## <a name="memory-allocation"></a>Alocação de memória  
 A capacidade padrão de um <xref:System.Text.StringBuilder> objeto é 16 caracteres e sua capacidade máxima de padrão é <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Esses valores padrão são usados se você chamar o <xref:System.Text.StringBuilder.%23ctor> e <xref:System.Text.StringBuilder.%23ctor%28System.String%29> construtores.  
  
 Você pode definir explicitamente a capacidade inicial de um <xref:System.Text.StringBuilder> objeto das seguintes maneiras:  
  
-   Ao chamar qualquer uma da <xref:System.Text.StringBuilder> construtores que inclui um `capacity` quando você cria o objeto de parâmetro.  
  
-   Atribuindo explicitamente um novo valor para o <xref:System.Text.StringBuilder.Capacity%2A?displayProperty=nameWithType> propriedade para expandir um existente <xref:System.Text.StringBuilder> objeto. Observe que a propriedade gera uma exceção se a nova capacidade é menor do que o existente capacidade ou maior que o <xref:System.Text.StringBuilder> capacidade máxima do objeto.  
  
-   Chamando o <xref:System.Text.StringBuilder.EnsureCapacity%2A?displayProperty=nameWithType> método com a nova capacidade. A nova capacidade não deve ser maior que o <xref:System.Text.StringBuilder> capacidade máxima do objeto. No entanto, ao contrário de uma atribuição para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade <xref:System.Text.StringBuilder.EnsureCapacity%2A> não lançará uma exceção se a nova capacidade de desejado é menor que a capacidade existente; nesse caso, a chamada do método não tem nenhum efeito.  
  
 Se o comprimento da cadeia de caracteres atribuída ao <xref:System.Text.StringBuilder> objeto na chamada de construtor excede a capacidade padrão ou a capacidade especificada, o <xref:System.Text.StringBuilder.Capacity%2A> está definida como o comprimento da cadeia de caracteres especificada com o `value` parâmetro.  
  
 Você pode definir explicitamente a capacidade máxima de um <xref:System.Text.StringBuilder> objeto chamando o <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> construtor. Você não pode alterar a capacidade máxima, atribuindo um novo valor para o <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade, porque ele é somente leitura.  
  
 Como a seção anterior mostra, sempre que a capacidade existente é inadequada, mais memória é alocada e a capacidade de um <xref:System.Text.StringBuilder> objeto duplas até o valor definido pelo <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade.  
  
 Em geral, a capacidade padrão e a capacidade máxima são adequadas para a maioria dos aplicativos. Você pode considerar configurar esses valores nas seguintes condições:  
  
-   Se o tamanho final do <xref:System.Text.StringBuilder> objeto é provavelmente aumentará excessivamente grandes, geralmente além de vários megabytes. Nesse caso, pode haver algum benefício de desempenho da definição inicial <xref:System.Text.StringBuilder.Capacity%2A> propriedade para um valor muito alto para eliminar a necessidade de muitos realocações de memória.  
  
-   Se seu aplicativo estiver em execução em um sistema com memória limitada. Nesse caso, você talvez queira considerar a configuração de <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade a ser menos de <xref:System.Int32.MaxValue?displayProperty=nameWithType> se seu aplicativo está tratando grandes cadeias de caracteres que podem fazer com que ele execute em um ambiente de limite de memória.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-a-stringbuilder-object"></a>Criando uma instância de um objeto StringBuilder  
 Você instancia um <xref:System.Text.StringBuilder> objeto chamando um dos seus construtores de classe sobrecarregados seis, que são listados na tabela a seguir. Três dos construtores instanciar uma <xref:System.Text.StringBuilder> objeto cujo valor é uma cadeia de caracteres vazia, mas definir seu <xref:System.Text.StringBuilder.Capacity%2A> e <xref:System.Text.StringBuilder.MaxCapacity%2A> valores de maneira diferente. Os construtores de três restantes definem um <xref:System.Text.StringBuilder> objeto que tem um valor de cadeia de caracteres específica e a capacidade. Dois dos três construtores usam a capacidade máxima de padrão de <xref:System.Int32.MaxValue?displayProperty=nameWithType>, enquanto o terceiro permite que você defina a capacidade máxima.  
  
|Construtor|Valor da cadeia de caracteres|Capacidade|Capacidade máxima|  
|-----------------|------------------|--------------|----------------------|  
|<xref:System.Text.StringBuilder.%23ctor>|<xref:System.String.Empty?displayProperty=nameWithType>|16|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definido pelo `capacity` parâmetro|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29>|<xref:System.String.Empty?displayProperty=nameWithType>|Definido pelo `capacity` parâmetro|Definido pelo `maxCapacity` parâmetro|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%29>|Definido pelo `value` parâmetro|16 ou `value`. <xref:System.String.Length%2A>, o que for maior|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%29>|Definido pelo `value` parâmetro|Definido pelo `capacity` parâmetro ou `value`. <xref:System.String.Length%2A>, o que for maior.|<xref:System.Int32.MaxValue?displayProperty=nameWithType>|  
|<xref:System.Text.StringBuilder.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29>|Definido pelo `value`. <xref:System.String.Substring%2A>(`startIndex`, `length`)|Definido pelo `capacity` parâmetro ou `value`. <xref:System.String.Length%2A>, o que for maior.|Definido pelo `maxCapacity` parâmetro|  
  
 O exemplo a seguir usa três essas sobrecargas de construtor para instanciar <xref:System.Text.StringBuilder> objetos.  
  
 [!code-csharp[System.Text.StringBuilder.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/instantiate1.cs#6)]
 [!code-vb[System.Text.StringBuilder.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/instantiate1.vb#6)]  
  
<a name="Calling"></a>   
## <a name="calling-stringbuilder-methods"></a>Chamando métodos StringBuilder  
 A maioria dos métodos modificar a cadeia de caracteres em um <xref:System.Text.StringBuilder> instância retornar uma referência à mesma instância. Isso permite que você chame <xref:System.Text.StringBuilder> métodos de duas maneiras:  
  
-   Você pode fazer chamadas de método individuais e ignorar o valor de retorno, como o exemplo a seguir.  
  
     [!code-csharp[System.Text.StringBuilder.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call1.cs#4)]
     [!code-vb[System.Text.StringBuilder.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call1.vb#4)]  
  
-   Você pode fazer uma série de chamadas de método em uma única instrução. Isso pode ser conveniente se você quiser escrever uma única instrução que encadeia operações sucessivas. O exemplo a seguir consolida três chamadas de método do exemplo anterior em uma única linha de código.  
  
     [!code-csharp[System.Text.StringBuilder.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/call2.cs#5)]
     [!code-vb[System.Text.StringBuilder.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/call2.vb#5)]  
  
<a name="Operations"></a>   
## <a name="performing-stringbuilder-operations"></a>Executando operações StringBuilder  
 Você pode usar os métodos do <xref:System.Text.StringBuilder> classe para iterar, adicionar, excluir ou modificar os caracteres em uma <xref:System.Text.StringBuilder> objeto.  
  
<a name="Iterating"></a>   
### <a name="iterating-stringbuilder-characters"></a>Iterando caracteres StringBuilder  
 Você pode acessar os caracteres em uma <xref:System.Text.StringBuilder> objeto usando o <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriedade. No c#, <xref:System.Text.StringBuilder.Chars%2A> é um indexador; no Visual Basic, é a propriedade padrão da <xref:System.Text.StringBuilder> classe. Isso permite que você definir ou recuperar caracteres individuais usando seu índice somente, sem referenciar explicitamente os <xref:System.Text.StringBuilder.Chars%2A> propriedade. Caracteres de um <xref:System.Text.StringBuilder> objeto começam no índice 0 (zero) e continuar indexar <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 O exemplo a seguir ilustra o <xref:System.Text.StringBuilder.Chars%2A> propriedade. Ele adiciona dez números aleatórios para um <xref:System.Text.StringBuilder> de objeto e, em seguida, itera cada caractere. Se a categoria Unicode do caractere é <xref:System.Globalization.UnicodeCategory?displayProperty=nameWithType>, ele diminui o número 1 (ou altera o número 9 se seu valor é 0). O exemplo exibe o conteúdo do <xref:System.Text.StringBuilder> objeto ambos antes e depois que os valores de caracteres individuais foram alterados.  
  
 [!code-csharp[System.Text.StringBuilder.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/chars1.cs#7)]
 [!code-vb[System.Text.StringBuilder.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/chars1.vb#7)]  
  
<a name="Adding"></a>   
### <a name="adding-text-to-a-stringbuilder-object"></a>Adicionando texto a um objeto StringBuilder  
 O <xref:System.Text.StringBuilder> classe inclui os seguintes métodos para expandir o conteúdo de um <xref:System.Text.StringBuilder> objeto:  
  
-   O <xref:System.Text.StringBuilder.Append%2A> método acrescenta uma cadeia de caracteres, uma subcadeia de caracteres, uma matriz de caracteres, uma parte de uma matriz de caracteres, um único caractere repetido várias vezes, ou a representação de cadeia de caracteres de dados primitivos de tipo para um <xref:System.Text.StringBuilder> objeto.  
  
-   O <xref:System.Text.StringBuilder.AppendLine%2A> método anexa um terminador de linha ou uma cadeia de caracteres junto com um terminador de linha para um <xref:System.Text.StringBuilder> objeto.  
  
-   O <xref:System.Text.StringBuilder.AppendFormat%2A> método anexa um para um <xref:System.Text.StringBuilder> objeto. As representações de cadeia de caracteres de objetos incluídos na cadeia de caracteres de resultado podem refletir as convenções de formatação da cultura atual do sistema ou de uma cultura específica.  
  
-   O <xref:System.Text.StringBuilder.Insert%2A> método insere uma cadeia de caracteres, uma subcadeia de caracteres, várias repetições de uma cadeia de caracteres, uma matriz de caracteres, uma parte de uma matriz de caracteres, ou a representação de cadeia de caracteres de dados primitivos de tipo em uma posição especificada o <xref:System.Text.StringBuilder> objeto. A posição é definida por um índice com base em zero.  
  
 O exemplo a seguir usa o <xref:System.Text.StringBuilder.Append%2A>, <xref:System.Text.StringBuilder.AppendLine%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>, e <xref:System.Text.StringBuilder.Insert%2A> métodos para expandir o texto de um <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/expand1.cs#9)]
 [!code-vb[System.Text.StringBuilder.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/expand1.vb#9)]  
  
<a name="Deleting"></a>   
### <a name="deleting-text-from-a-stringbuilder-object"></a>Excluindo texto de um objeto StringBuilder  
 O <xref:System.Text.StringBuilder> classe inclui métodos que podem reduzir o tamanho do atual <xref:System.Text.StringBuilder> instância. O <xref:System.Text.StringBuilder.Clear%2A> método Remove todos os caracteres e define o <xref:System.Text.StringBuilder.Length%2A> propriedade como zero. O <xref:System.Text.StringBuilder.Remove%2A> método exclui um número especificado de caracteres começando na posição de um índice específico. Além disso, você pode remover caracteres do final de um <xref:System.Text.StringBuilder> objeto definindo seu <xref:System.Text.StringBuilder.Length%2A> propriedade para um valor menor que o comprimento da instância atual.  
  
 O exemplo a seguir remove a parte do texto de um <xref:System.Text.StringBuilder> objeto exibe sua capacidade resultante, capacidade máxima e valores de propriedade de comprimento e, em seguida, chama o <xref:System.Text.StringBuilder.Clear%2A> método para remover todos os caracteres da <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/delete1.cs#10)]
 [!code-vb[System.Text.StringBuilder.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/delete1.vb#10)]  
  
<a name="Modifying"></a>   
### <a name="modifying-the-text-in-a-stringbuilder-object"></a>Alterando o texto em um objeto StringBuilder  
 O <xref:System.Text.StringBuilder.Replace%2A?displayProperty=nameWithType> método substitui todas as ocorrências de um caractere ou uma cadeia de caracteres em todo o <xref:System.Text.StringBuilder> objeto ou em um intervalo de caracteres em particular. O exemplo a seguir usa o <xref:System.Text.StringBuilder.Replace%2A> método para substituir todos os pontos de exclamação (!) com pontos de interrogação (?) de <xref:System.Text.StringBuilder> objeto.  
  
 [!code-csharp[System.Text.StringBuilder.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/replace1.cs#11)]
 [!code-vb[System.Text.StringBuilder.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/replace1.vb#11)]  
  
<a name="Searching"></a>   
## <a name="searching-the-text-in-a-stringbuilder-object"></a>Pesquisando o texto em um objeto StringBuilder  
 O <xref:System.Text.StringBuilder> classe inclui métodos semelhantes a <xref:System.String.Contains%2A?displayProperty=nameWithType>, <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, e <xref:System.String.StartsWith%2A?displayProperty=nameWithType> métodos fornecidos pelo <xref:System.String> classe, que permitem que você pesquise o objeto para um determinado caractere ou uma subcadeia de caracteres. Determinar a presença ou a partir de posição do caractere de uma subcadeia de caracteres requer que você pesquisa um <xref:System.String> valor usando um método de pesquisa de cadeia de caracteres ou um método de expressão regular. Há quatro maneiras de implementar essas pesquisas, como mostra a tabela a seguir.  
  
|Técnica|Profissionais|Contras|  
|---------------|----------|----------|  
|Valores de cadeia de caracteres de pesquisa antes de adicioná-los para o <xref:System.Text.StringBuilder> objeto.|Útil para determinar se existe uma subcadeia de caracteres.|Não pode ser usado quando a posição do índice de uma subcadeia de caracteres é importante.|  
|Chamar <xref:System.Text.StringBuilder.ToString%2A> e pesquisar retornado <xref:System.String> objeto.|Fácil de usar se você atribuir todo o texto para um <xref:System.Text.StringBuilder> do objeto e, em seguida, comece a modificá-lo.|Ineficiente chamar repetidamente <xref:System.Text.StringBuilder.ToString%2A> se é necessário fazer modificações antes de todo o texto é adicionado para o <xref:System.Text.StringBuilder> objeto.<br /><br /> Você deve lembrar de trabalho do final do <xref:System.Text.StringBuilder> texto do objeto, se você estiver fazendo alterações.|  
|Use o <xref:System.Text.StringBuilder.Chars%2A> propriedade para um intervalo de caracteres de pesquisa em sequência.|Útil se você estiver preocupado com caracteres individuais ou uma subcadeia de caracteres pequena.|Complicadas se o número de caracteres a procurar é grande ou se a lógica de pesquisa é complexa.|  
|Converter o <xref:System.Text.StringBuilder> o objeto para um <xref:System.String> objeto e, em seguida, executar modificações no <xref:System.String> objeto.|Útil se o número de modificações é pequeno.|Nega o benefício de desempenho de <xref:System.Text.StringBuilder> classe se o número de modificações for grande.|  
  
 Vamos examinar essas técnicas mais detalhadamente.  
  
-   Se o objetivo da pesquisa é determinar se uma determinada subcadeia de caracteres existe (ou seja, se não estiver interessado na posição da subcadeia de caracteres), você pode pesquisar cadeias de caracteres antes de armazená-los no <xref:System.Text.StringBuilder> objeto. O exemplo a seguir fornece uma possível implementação. Define uma `StringBuilderFinder` classe cujo recebe uma referência a um <xref:System.Text.StringBuilder> objeto e a subcadeia de caracteres para localizar na cadeia de caracteres. Nesse caso, o exemplo tenta determinar se temperaturas gravadas no Fahrenheit ou Celsius e adiciona o texto introdutório apropriado para o início do <xref:System.Text.StringBuilder> objeto. Um gerador de número aleatório é usado para selecionar uma matriz que contém dados em ° c ou ° f.  
  
     [!code-csharp[System.Text.StringBuilder.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern1.cs#12)]
     [!code-vb[System.Text.StringBuilder.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern1.vb#12)]  
  
-   Chamar o <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para converter o <xref:System.Text.StringBuilder> o objeto para um <xref:System.String> objeto. Você pode pesquisar a cadeia de caracteres usando métodos como <xref:System.String.LastIndexOf%2A?displayProperty=nameWithType> ou <xref:System.String.StartsWith%2A?displayProperty=nameWithType>, ou você pode usar expressões regulares e <xref:System.Text.RegularExpressions.Regex> classe para procurar padrões. Porque ambos <xref:System.Text.StringBuilder> e <xref:System.String> objetos usam para armazenar as posições de índice de caracteres, subcadeias de caracteres, caracteres de codificação UTF-16 e correspondências de expressões regulares são os mesmos em ambos os objetos. Isso permite que você use <xref:System.Text.StringBuilder> métodos para fazer alterações na mesma posição na qual esse texto é encontrado no <xref:System.String> objeto.  
  
    > [!NOTE]
    >  Se você adotar essa abordagem, você deve trabalhar do final do <xref:System.Text.StringBuilder> objeto para o início para que você não precisa converter repetidamente o <xref:System.Text.StringBuilder> objeto como uma cadeia de caracteres.  
  
     O exemplo a seguir ilustra esta abordagem. Ele armazena quatro ocorrências de cada letra do alfabeto inglês em um <xref:System.Text.StringBuilder> objeto. Em seguida, converte o texto para um <xref:System.String> de objeto e usa uma expressão regular para identificar a posição inicial de cada sequência de quatro caracteres. Finalmente, adiciona um sublinhado antes de cada sequência de quatro caracteres, exceto a primeira sequência e converte o primeiro caractere da sequência de em letras maiusculas.  
  
     [!code-csharp[System.Text.StringBuilder.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern2.cs#13)]
     [!code-vb[System.Text.StringBuilder.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern2.vb#13)]  
  
-   Use o <xref:System.Text.StringBuilder.Chars%2A?displayProperty=nameWithType> propriedade sequencialmente pesquisar um intervalo de caracteres em um <xref:System.Text.StringBuilder> objeto. Essa abordagem pode não ser prática se o número de caracteres a ser pesquisada for grande ou a lógica de pesquisa é particularmente complexa.  
  
     O exemplo a seguir é idêntico em funcionalidade ao exemplo anterior, mas difere na implementação. Ele usa o <xref:System.Text.StringBuilder.Chars%2A> propriedade para detectar quando um valor de caractere é alterado, insere um caractere de sublinhado na posição e converte o primeiro caractere na nova sequência em maiusculas.  
  
     [!code-csharp[System.Text.StringBuilder.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern3.cs#14)]
     [!code-vb[System.Text.StringBuilder.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern3.vb#14)]  
  
-   Armazenar todo o texto não modificado no <xref:System.Text.StringBuilder> de objeto, chame o <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método para converter o <xref:System.Text.StringBuilder> do objeto para um <xref:System.String> objeto e, em seguida, faça as modificações no <xref:System.String> objeto. Você pode usar essa abordagem se você tiver apenas algumas modificações; Caso contrário, o custo de trabalhar com cadeias de caracteres imutáveis pode anular os benefícios de desempenho do uso de um <xref:System.Text.StringBuilder> objeto.  
  
     O exemplo a seguir é idêntico em funcionalidade para os dois exemplos anteriores, mas difere na implementação. Ele cria um <xref:System.Text.StringBuilder> de objeto, converte-o para um <xref:System.String> de objeto e, em seguida, usa uma expressão regular para executar todas as modificações restantes na cadeia de caracteres. O <xref:System.Text.RegularExpressions.Regex.Replace%28System.String%2CSystem.String%2CSystem.Text.RegularExpressions.MatchEvaluator%29?displayProperty=nameWithType> método usa uma expressão lambda para executar a substituição de cada correspondência.  
  
     [!code-csharp[System.Text.StringBuilder.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.class/cs/pattern4.cs#15)]
     [!code-vb[System.Text.StringBuilder.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.class/vb/pattern4.vb#15)]  
  
<a name="Converting"></a>   
## <a name="converting-the-stringbuilder-object-to-a-string"></a>Convertendo o objeto StringBuilder em uma cadeia de caracteres  
 Você deve converter o <xref:System.Text.StringBuilder> o objeto para um <xref:System.String> objeto antes que você pode passar a cadeia de caracteres representada pelo <xref:System.Text.StringBuilder> objeto para um método que tem um <xref:System.String> parâmetro ou exibi-lo na interface do usuário. Realizar essa conversão ao chamar o <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método. Para obter uma ilustração, consulte o exemplo anterior, que chama o <xref:System.Text.StringBuilder.ToString%2A> método para converter um <xref:System.Text.StringBuilder> para uma cadeia de caracteres do objeto para que ele pode ser passado para um método de expressão regular.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar muitos dos métodos definidos pela <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#1)]
 [!code-csharp[StringBuilder#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#1)]
 [!code-vb[StringBuilder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de cadeia de caracteres desta instância é definido como <xref:System.String.Empty?displayProperty=nameWithType>, e a capacidade é definida como a capacidade específica da implementação padrão.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor sem parâmetros.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#1)]
 [!code-csharp[System.Text.StringBuilder.Constructors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#1)]
 [!code-vb[System.Text.StringBuilder.Constructors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">O tamanho inicial sugerido desta instância.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> usando a capacidade especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede esse `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 O valor de cadeia de caracteres desta instância é definido como <xref:System.String.Empty?displayProperty=nameWithType>. Se `capacity` for zero, a capacidade específica da implementação padrão é usada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com uma capacidade especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#3)]
 [!code-csharp[System.Text.StringBuilder.Constructors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#3)]
 [!code-vb[System.Text.StringBuilder.Constructors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres usada para inicializar o valor da instância. Se <c>valor</c> é <see langword="null" />, o novo <see cref="T:System.Text.StringBuilder" /> conterá a cadeia de caracteres vazia (ou seja, ele contém <see cref="F:System.String.Empty" />).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> usando a cadeia de caracteres especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `value` for `null`, o novo <xref:System.Text.StringBuilder> conterá a cadeia de caracteres vazia (ou seja, ele conterá <xref:System.String.Empty>).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com a cadeia de caracteres especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#4)]
 [!code-csharp[System.Text.StringBuilder.Constructors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#4)]
 [!code-vb[System.Text.StringBuilder.Constructors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (int capacity, int maxCapacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, int32 maxCapacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="maxCapacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">O tamanho inicial sugerido de <see cref="T:System.Text.StringBuilder" />.</param>
        <param name="maxCapacity">O número máximo de caracteres que pode conter a cadeia de caracteres atual.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> que começa com uma capacidade especificada e pode crescer até um máximo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede esse `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 Se `capacity` for zero, a capacidade específica da implementação padrão é usada.  
  
 O `maxCapacity` propriedade define o número máximo de caracteres que pode conter a instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede esse `maxCapacity` valor, o <xref:System.Text.StringBuilder> objeto não alocar mais memória, mas em vez disso gera uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com uma capacidade especificada e a capacidade máxima.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#5)]
 [!code-csharp[System.Text.StringBuilder.Constructors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#5)]
 [!code-vb[System.Text.StringBuilder.Constructors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxCapacity" /> é menor que 1, <paramref name="capacity" /> é menor que zero ou <paramref name="capacity" /> é maior que <paramref name="maxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres usada para inicializar o valor da instância. Se <c>valor</c> é <see langword="null" />, o novo <see cref="T:System.Text.StringBuilder" /> conterá a cadeia de caracteres vazia (ou seja, ele contém <see cref="F:System.String.Empty" />).</param>
        <param name="capacity">O tamanho inicial sugerido de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> usando a cadeia de caracteres e a capacidade especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede esse `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 Se `capacity` for zero, a capacidade específica da implementação padrão é usada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com uma cadeia de caracteres inicial e uma capacidade especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#7)]
 [!code-csharp[System.Text.StringBuilder.Constructors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#7)]
 [!code-vb[System.Text.StringBuilder.Constructors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StringBuilder (string value, int startIndex, int length, int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string value, int32 startIndex, int32 length, int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.#ctor(System.String,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres que contém a subcadeia de caracteres usada para inicializar o valor dessa instância. Se <c>valor</c> é <see langword="null" />, o novo <see cref="T:System.Text.StringBuilder" /> conterá a cadeia de caracteres vazia (ou seja, ele contém <see cref="F:System.String.Empty" />).</param>
        <param name="startIndex">A posição dentro <c>valor</c> onde a subcadeia de caracteres começa.</param>
        <param name="length">O número de caracteres na subcadeia de caracteres.</param>
        <param name="capacity">O tamanho inicial sugerido de <see cref="T:System.Text.StringBuilder" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.StringBuilder" /> da capacidade e da subcadeia de caracteres especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `capacity` parâmetro define o número máximo de caracteres que podem ser armazenados na memória alocada pela instância atual. Seu valor é atribuído para o <xref:System.Text.StringBuilder.Capacity%2A> propriedade. Se o número de caracteres a ser armazenado na instância atual excede esse `capacity` valor, o <xref:System.Text.StringBuilder> objeto aloca memória adicional para armazená-los.  
  
 Se `capacity` for zero, a capacidade específica da implementação padrão é usada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como chamar o <xref:System.Text.StringBuilder.%23ctor%2A> construtor com a cadeia de caracteres especificada.  
  
 [!code-cpp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CPP/constructors.cpp#6)]
 [!code-csharp[System.Text.StringBuilder.Constructors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/CS/constructors.cs#6)]
 [!code-vb[System.Text.StringBuilder.Constructors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Constructors/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> além de <paramref name="length" /> não é uma posição no <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">O valor booliano a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um valor booliano especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Boolean%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Boolean%29> chamadas de método de <xref:System.Boolean.ToString?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value`. A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro sem sinal de 8 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Byte%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#3)]
 [!code-vb[System.Text.StringBuilder.Append#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#3)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Byte%29> chamadas de método de <xref:System.Byte.ToString%28System.IFormatProvider%29> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">A unidade de código codificado em UTF-16 a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um objeto <see cref="T:System.Char" /> especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Char%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#4)]
 [!code-vb[System.Text.StringBuilder.Append#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#4)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">A matriz de caracteres a ser acrescentada.</param>
        <summary>Acrescenta a representação de cadeia de caracteres dos caracteres Unicode em uma matriz especificada a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método anexa todos os caracteres na matriz especificada para a instância atual na mesma ordem em que aparecem no `value`. Se `value` é `null`, nenhuma alteração é feita.  
  
 O <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#6)]
 [!code-vb[System.Text.StringBuilder.Append#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#6)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um número decimal especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Decimal%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#8)]
 [!code-vb[System.Text.StringBuilder.Append#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#8)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Decimal%29> chamadas de método de <xref:System.Decimal.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um número de ponto flutuante de precisão dupla especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Double%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#9)]
 [!code-vb[System.Text.StringBuilder.Append#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#9)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Double%29> chamadas de método de <xref:System.Double.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro com sinal de 16 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Int16%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#10)]
 [!code-vb[System.Text.StringBuilder.Append#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#10)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Int16%29> chamadas de método de <xref:System.Int16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro com sinal de 32 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Int32%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#11)]
 [!code-vb[System.Text.StringBuilder.Append#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#11)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Int32%29> chamadas de método de <xref:System.Int32.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Anexa a representação de cadeia de caracteres de um inteiro assinado de 64 bits especificado para essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Int64%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#12)]
 [!code-vb[System.Text.StringBuilder.Append#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#12)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Int64%29> chamadas de método de <xref:System.Int64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um objeto especificado à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Object%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir. Define uma `Dog` classe, cria um `Dog` objeto e faz três chamadas para o <xref:System.Text.StringBuilder.Append%2A> método para criar uma cadeia de caracteres que contém o cão nome e categoria.  
  
 [!code-csharp[System.Text.Stringbuilder.Append#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append4.cs#18)]
 [!code-vb[System.Text.Stringbuilder.Append#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append4.vb#18)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Object%29> chamadas de método de <xref:System.Object.ToString%2A?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value`. Se `value` é `null`, nenhuma alteração é feita para o <xref:System.Text.StringBuilder> objeto.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Anexa a representação de cadeia de caracteres de um inteiro assinado de 8 bits especificado para essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.SByte%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#13)]
 [!code-vb[System.Text.StringBuilder.Append#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#13)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.SByte%29> chamadas de método de <xref:System.SByte.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um número de ponto flutuante de precisão simples especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Single%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#14)]
 [!code-vb[System.Text.StringBuilder.Append#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#14)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.Single%29> chamadas de método de <xref:System.Single.ToString%2A?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser acrescentada.</param>
        <summary>Acrescenta uma cópia da cadeia de caracteres especificada a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.String%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#2)]
 [!code-vb[System.Text.StringBuilder.Append#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#2)]  
  
 Se `value` é `null`, nenhuma alteração é feita.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Anexa a representação de cadeia de caracteres de um inteiro não assinado de 16 bits especificado para essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.UInt16%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#15)]
 [!code-vb[System.Text.StringBuilder.Append#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#15)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.UInt16%29> chamadas de método de <xref:System.UInt16.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value`. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de um inteiro sem sinal de 32 bits especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.UInt32%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#16)]
 [!code-vb[System.Text.StringBuilder.Append#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#16)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.UInt32%29> chama o <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">O valor a ser acrescentado.</param>
        <summary>Anexa a representação de cadeia de caracteres de um inteiro não assinado de 64 bits especificado para essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.UInt64%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#17)]
 [!code-vb[System.Text.StringBuilder.Append#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#17)]  
  
 O <xref:System.Text.StringBuilder.Append%28System.UInt64%29> chamadas de método de <xref:System.UInt64.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> método para obter a representação de cadeia de caracteres de `value` para a cultura atual. Para controlar a formatação de `value`, chame o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char value, int repeatCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char value, int32 repeatCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="repeatCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O caractere a ser acrescentado.</param>
        <param name="repeatCount">O número de vezes para acrescentar <c>valor</c>.</param>
        <summary>Acrescenta um número de cópias especificado da representação de cadeia de caracteres de um caractere Unicode a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.Append%28System.Char%2CSystem.Int32%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#5)]
 [!code-vb[System.Text.StringBuilder.Append#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#5)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="repeatCount" /> é menor que zero.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char* value, int valueCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char* value, int32 valueCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="valueCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de caracteres.</param>
        <param name="valueCount">O número de caracteres na matriz.</param>
        <summary>Acrescenta uma matriz de caracteres Unicode começando em um endereço especificado a essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método anexa `valueCount` caracteres começando no endereço `value` para a instância atual.  
  
 O <xref:System.Text.StringBuilder.Append%28System.Char%2A%2CSystem.Int32%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> objeto.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="valueCount" /> é menor que zero.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <exception cref="T:System.NullReferenceException">
          O <paramref name="value" /> é um ponteiro nulo.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de caracteres.</param>
        <param name="startIndex">A posição inicial no <c>valor</c>.</param>
        <param name="charCount">O número de caracteres a serem acrescentados.</param>
        <summary>Acrescenta a representação de cadeia de caracteres de uma submatriz especificada de caracteres Unicode à essa instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método anexa o intervalo especificado de caracteres em `value` para a instância atual. Se `value` é `null` e `startIndex` e `count` forem zero, sem alterações.  
  
 O <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append2.cs#7)]
 [!code-vb[System.Text.StringBuilder.Append#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append2.vb#7)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />é <see langword="null" />, e <paramref name="startIndex" /> e <paramref name="charCount" /> não são zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> + <paramref name="charCount" />é maior que o comprimento de <paramref name="value" />.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Append">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Append (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Append(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Append(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres que contém a subcadeia de caracteres a ser acrescentada.</param>
        <param name="startIndex">A posição inicial da subcadeia de caracteres dentro de <c>valor</c>.</param>
        <param name="count">O número de caracteres em <c>valor</c> acrescentar.</param>
        <summary>Acrescenta uma cópia de uma subcadeia de caracteres especificada a esta instância.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método anexa o intervalo especificado de caracteres em `value` para a instância atual. Se `value` é `null` e `startIndex` e `count` forem zero, sem alterações.  
  
 O <xref:System.Text.StringBuilder.Append%28System.String%2CSystem.Int32%2CSystem.Int32%29> método modifica a instância desta classe; ele não retorna uma nova instância da classe. Por isso, você pode chamar um método ou propriedade de referência existente e não é necessário atribuir o valor de retorno para um <xref:System.Text.StringBuilder> do objeto, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.StringBuilder.Append#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/cs/append3.cs#19)]
 [!code-vb[System.Text.StringBuilder.Append#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.StringBuilder.Append/vb/append3.vb#19)]  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />é <see langword="null" />, e <paramref name="startIndex" /> e <paramref name="count" /> não são zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" />menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" />menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> + <paramref name="count" />é maior que o comprimento de <paramref name="value" />.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">Um objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um único argumento.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato em <paramref name="format" /> é substituído pela representação de cadeia de caracteres de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato. O índice dos itens de formato deve ser 0, que corresponde ao `arg0`, o único objeto na lista de parâmetros do método. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres de `arg0`.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro no *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`representa o objeto a ser formatado. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres de `arg0`. Se o item de formato inclui `formatString` e `arg0` implementa o <xref:System.IFormattable> interface, em seguida, `arg0.ToString(formatString, null)` define a formatação. Caso contrário, `arg0.ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por seu doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por seu doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior que ou igual a 1.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="args">Uma matriz de objetos a ser formatada.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um argumento correspondente em uma matriz de parâmetros.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato no <paramref name="format" /> é substituído pela representação de cadeia de caracteres do argumento de objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros do método. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro no *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `args`representa os objetos a serem formatados. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres do objeto correspondente no `args`. Se o item de formato inclui `formatString` e o objeto correspondente no `args` implementa o <xref:System.IFormattable> interface, em seguida, `args[index].ToString(formatString, provider)` define a formatação. Caso contrário, `args[index].ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por seu doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por seu doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um único argumento usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de `arg0` em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato. O índice de cada item de formato deve ser zero (0), pois esse método inclui uma lista de argumentos com um único argumento. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres de `arg0`.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Nesse caso, desde o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> método tem um único argumento na lista de argumentos, o valor de *índice* deve ser sempre 0. Se não, é um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> implementação que pode fornecer informações de formatação para os objetos em `args`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específica da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específica da cultura `arg0` se ele é um valor numérico.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específica da cultura `arg0` se ele é um valor de data e hora.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação para `arg0`. Normalmente, essa implementação também implementa o <xref:System.ICustomFormatter> interface.  
  
 Se o `provider` parâmetro é `null`, formatação informações são obtidas da cultura atual.  
  
 `arg0`representa o objeto a ser formatado. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres de `arg0`. Se o item de formato inclui `formatString` e `arg0` implementa o <xref:System.IFormattable> interface, em seguida, `arg0.ToString(formatString, provider)` define a formatação. Caso contrário, `arg0.ToString()` define a formatação.  
  
   
  
## Examples  
 A seguir inclui duas chamadas para o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%29> método. Ambos usam as convenções de formatação da cultura do inglês-Grã-Bretanha (en-GB). O primeiro insere a representação de cadeia de caracteres de uma <xref:System.Decimal> valor de moeda em uma cadeia de caracteres de resultado. O segundo insere um <xref:System.DateTime> valor em dois locais em um resultado de cadeia de caracteres, incluindo primeiro, somente curto Data da cadeia de caracteres e o segundo a cadeia de caracteres de curto período de tempo.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat1.cs#2)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior que ou igual a um (1).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="args">Uma matriz de objetos a ser formatada.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de um argumento correspondente em uma matriz de parâmetro usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres do argumento do objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros do método. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro no *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> implementação que pode fornecer informações de formatação para os objetos em `args`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específica da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específica da cultura para valores numéricos em `args`.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específica da cultura para valores de data e hora em `args`.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação para um ou mais dos objetos no `args`. Normalmente, essa implementação também implementa o <xref:System.ICustomFormatter> interface. O segundo exemplo na próxima seção ilustra uma <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> chamada de método com um personalizado <xref:System.IFormatProvider> implementação.  
  
 Se o `provider` parâmetro é `null`, informações do provedor de formato são obtidas da cultura atual.  
  
 `args`representa os objetos a serem formatados. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres do objeto correspondente no `args`. Se o item de formato inclui `formatString` e o objeto correspondente no `args` implementa o <xref:System.IFormattable> interface, em seguida, `args[index].ToString(formatString, provider)` define a formatação. Caso contrário, `args[index].ToString()` define a formatação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 O exemplo a seguir define um personalizado <xref:System.IFormatProvider> implementação denominada `CustomerFormatter` que formata um número com hifens de cliente de 10 dígitos após o quarto e o sétimo dígitos. Ele é passado para o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> método para criar uma cadeia de caracteres que inclui o número de customer formatado e o nome do cliente.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/customernumberformatter1.cs#1)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/customernumberformatter1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um dos dois argumentos.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato no <paramref name="format" /> é substituído pela representação de cadeia de caracteres do argumento de objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos `arg0` e `arg1`, os dois objetos na lista de parâmetros do método. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro no *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`e `arg1` representar os objetos a serem formatados. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres do `arg0` ou `arg1`. Se o item de formato inclui `formatString` e implementa o objeto correspondente a <xref:System.IFormattable> interface, em seguida, `arg` *x* `.ToString(formatString, provider)` define a formatação, onde *x* é o índice do argumento. Caso contrário, `arg` *x* `.ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por seu doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por seu doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior que ou igual a 2.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um de dois argumentos usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres do argumento do objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros do método. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro no *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> implementação que pode fornecer informações de formatação para `arg0` e `arg1`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específica da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específica da cultura `arg0` ou `arg1` se eles são valores numéricos.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específica da cultura `arg0` ou `arg1` se eles são valores de data e hora.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação para `arg0` e `arg1`. Normalmente, essa implementação também implementa o <xref:System.ICustomFormatter> interface.  
  
 Se o `provider` parâmetro é `null`, informações do provedor de formato são obtidas da cultura atual.  
  
 `arg0`e `arg1` representar os objetos a serem formatados. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres do objeto que tem o índice correspondente. Se o item de formato inclui `formatString` e implementa o argumento correspondente a <xref:System.IFormattable> interface e, em seguida, o argumento `ToString(formatString, provider)` método define a formatação. Caso contrário, o argumento `ToString()` método define a formatação.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%29> método para exibir dados de hora e temperatura armazenados em um genérico <xref:System.Collections.Generic.Dictionary%602> objeto. Observe que a cadeia de caracteres de formato tem três itens de formato, embora haja somente a objetos a serem formatados. Isso ocorre porque o objeto primeiro na lista (um valor de data e hora) é usado por dois itens de formato: O primeiro exibe de item de formato a hora e a segunda exibe a data.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat2.cs#3)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior que ou igual a 2 (duas).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um dos três argumentos.</summary>
        <returns>Uma referência a essa instância com <paramref name="format" /> acrescentado. Cada item de formato no <paramref name="format" /> é substituído pela representação de cadeia de caracteres do argumento de objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos `arg0` por meio de `arg2`, os objetos na lista de parâmetros do método. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro no *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 `arg0`, `arg1`, e `arg2` representar os objetos a serem formatados. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres do `arg0`, `arg1`, ou `arg2`, dependendo do índice do item de formato. Se o item de formato inclui `formatString` e o objeto correspondente no `args` implementa o <xref:System.IFormattable> interface, em seguida, `arg` *x* `.ToString(formatString, null)` define a formatação, onde *x* é o índice do argumento. Caso contrário, `arg` *x* `.ToString()` define a formatação.  
  
 Se a cadeia de caracteres atribuída a `format` é "Obrigado por seu doação de {0: # # #} latas de alimentos para nossa organização de caridade." e `arg0` é um inteiro com o valor 10, o valor de retorno será "Obrigado por seu doação 10 latas de alimentos para nossa organização de caridade".  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendFormat%2A> método.  
  
 [!code-cpp[stringbuilder.appendformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendformat/CPP/appfmt.cpp#1)]
 [!code-csharp[stringbuilder.appendformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendformat/CS/appfmt.cs#1)]
 [!code-vb[stringbuilder.appendformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendformat/VB/appfmt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior que ou igual a 3.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendFormat">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendFormat (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendFormat(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendFormat(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma cadeia de caracteres de formato composto.</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Acrescenta a cadeia de caracteres retornada pelo processamento de uma cadeia de caracteres de formato composto, que contém zero ou mais itens de formato, a essa instância. Cada item de formato é substituído pela representação de cadeia de caracteres de um de três argumentos usando um provedor de formato especificado.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo. Após a operação de acréscimo, essa instância conterá os dados que existiam antes da operação, tendo como sufixo uma cópia de <paramref name="format" />, na qual qualquer especificação de formato será substituída pela representação de cadeia de caracteres do argumento do objeto correspondente.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) do .NET Framework para converter o valor de um objeto em sua representação de texto e inserir essa representação atual <xref:System.Text.StringBuilder> objeto.  
  
 O `format` parâmetro consiste em zero ou mais execuções de texto misturado com zero ou mais espaços reservados indexados, chamados de itens de formato, que correspondem aos objetos na lista de parâmetros do método. O processo de formatação substitui cada item de formato com a representação de cadeia de caracteres do objeto correspondente.  
  
 A sintaxe de um item de formato é o seguinte:  
  
 {*índice*[,*comprimento*] [:*formatString*]}  
  
 Os elementos entre colchetes são opcionais. A tabela a seguir descreve cada elemento.  
  
|Elemento|Descrição|  
|-------------|-----------------|  
|*índice*|A posição de base zero na lista de parâmetros do objeto a ser formatado. Se o objeto especificado por *índice* é `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Se não houver nenhum parâmetro no *índice* posição, um <xref:System.FormatException> é gerada.|  
|,*comprimento*|O número mínimo de caracteres na representação de cadeia de caracteres do parâmetro. Em caso positivo, o parâmetro é alinhado à direita; Se for negativo, será alinhado à esquerda.|  
|:*formatString*|Uma cadeia de caracteres de formato personalizado ou padrão que é compatível com o parâmetro.|  
  
> [!NOTE]
>  Para as cadeias de caracteres de formato padrão e personalizados usadas com valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md). Para as cadeias de caracteres de formato padrão e personalizados usadas com valores numéricos, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md). Para as cadeias de caracteres de formato padrão usadas com enumerações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
 O `provider` parâmetro especifica um <xref:System.IFormatProvider> implementação que pode fornecer informações de formatação para `arg0` e `arg1`. `provider` pode ser um destes procedimentos:  
  
-   Um <xref:System.Globalization.CultureInfo> objeto que fornece informações de formatação específica da cultura.  
  
-   Um <xref:System.Globalization.NumberFormatInfo> objeto que fornece informações de formatação específica da cultura `arg0` ou `arg1` se eles são valores numéricos.  
  
-   Um <xref:System.Globalization.DateTimeFormatInfo> objeto que fornece informações de formatação específica da cultura `arg0`, `arg1`, ou `arg2` se eles são valores de data e hora.  
  
-   Um personalizado <xref:System.IFormatProvider> implementação que fornece informações de formatação para `arg0`, `arg1`, e `arg2`. Normalmente, essa implementação também implementa o <xref:System.ICustomFormatter> interface.  
  
 Se o `provider` parâmetro é `null`, informações do provedor de formato são obtidas da cultura atual.  
  
 `arg0`, `arg1`, e `arg2` representar os objetos a serem formatados. Cada item de formato em `format` é substituída com a representação de cadeia de caracteres do objeto que tem o índice correspondente. Se o item de formato inclui `formatString` e implementa o argumento correspondente a <xref:System.IFormattable> interface e, em seguida, o argumento `ToString(formatString, provider)` método define a formatação. Caso contrário, o argumento `ToString()` método define a formatação.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Text.StringBuilder.AppendFormat%28System.IFormatProvider%2CSystem.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para ilustrar o resultado de um valor booleano `And` operação com valores inteiros. Observe que a cadeia de caracteres de formato inclui seis itens de formato, mas o método tiver apenas três itens na lista de argumento, porque cada item é formatado de duas maneiras diferentes.  
  
 [!code-csharp[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/cs/appendformat3.cs#4)]
 [!code-vb[System.Text.StringBuilder.AppendFormat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.appendformat/vb/appendformat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> é inválido.  
  
 -ou-  
  
 O índice de um item de formato é menor que 0 (zero) ou maior que ou igual a 3 (três).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O tamanho da cadeia de caracteres expandida excederá <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (char separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(char separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.Char,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.Object[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin (string separator, params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin(string separator, string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendJoin&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendJoin&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendJoin&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendJoin``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Acrescenta o terminador de linha padrão ao final do atual objeto <see cref="T:System.Text.StringBuilder" />.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O terminador de linha padrão é o valor atual de <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriedade.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.AppendLine%2A> método.  
  
 [!code-cpp[stringbuilder.appendline#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.appendline/CPP/al.cpp#1)]
 [!code-csharp[stringbuilder.appendline#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.appendline/CS/al.cs#1)]
 [!code-vb[stringbuilder.appendline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.appendline/VB/al.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AppendLine">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder AppendLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder AppendLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.AppendLine(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser acrescentada.</param>
        <summary>Acrescenta uma cópia da cadeia de caracteres especificada seguida pelo terminador de linha padrão para o fim do objeto <see cref="T:System.Text.StringBuilder" /> atual.</summary>
        <returns>Uma referência a essa instância após a conclusão da operação de acréscimo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O terminador de linha padrão é o valor atual de <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> propriedade.  
  
 A capacidade desta instância é ajustada conforme necessário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <see cref="T:System.Text.StringBuilder" /> objeto chamando o <see cref="M:System.Text.StringBuilder.#ctor(System.Int32,System.Int32)" /> construtor, o comprimento e a capacidade do <see cref="T:System.Text.StringBuilder" /> instância pode crescer além do valor de seu <see cref="P:System.Text.StringBuilder.MaxCapacity" /> propriedade. Isso pode ocorrer especialmente quando você chama o <see cref="M:System.Text.StringBuilder.Append(System.String)" /> e <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object)" /> métodos acrescentar cadeias pequenas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Capacity">
      <MemberSignature Language="C#" Value="public int Capacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Capacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Capacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o número máximo de caracteres que podem ser contidos na memória alocada pela instância atual.</summary>
        <value>O número máximo de caracteres que podem ser contidos na memória alocada pela instância atual. Seu valor pode variar de <see cref="P:System.Text.StringBuilder.Length" /> para <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Capacity%2A>não afeta o valor de cadeia de caracteres da instância atual. <xref:System.Text.StringBuilder.Capacity%2A>pode ser diminuído desde que ele não é menor que <xref:System.Text.StringBuilder.Length%2A>.  
  
 O <xref:System.Text.StringBuilder> aloque mais espaço quando necessário e aumenta dinamicamente <xref:System.Text.StringBuilder.Capacity%2A> adequadamente. Por motivos de desempenho, um <xref:System.Text.StringBuilder> pode alocar mais memória do que o necessário. A quantidade de memória alocada é específico da implementação.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Capacity%2A> propriedade.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor que o comprimento atual desta instância.  
  
 -ou-  
  
 O valor especificado para uma operação de definição é maior que a capacidade máxima.</exception>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Chars(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição do caractere.</param>
        <summary>Obtém ou define o caractere na posição de caractere especificada nessa instância.</summary>
        <value>O caractere Unicode na posição <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `index` parâmetro é a posição de um caractere dentro de <xref:System.Text.StringBuilder>. O primeiro caractere na cadeia de caracteres está no índice 0. O comprimento de uma cadeia de caracteres é o número de caracteres que ele contém. O último caractere acessível de uma <xref:System.Text.StringBuilder> instância está no índice <xref:System.Text.StringBuilder.Length%2A> - 1.  
  
 <xref:System.Text.StringBuilder.Chars%2A>é a propriedade padrão do <xref:System.Text.StringBuilder> classe. Em c#, é um indexador. Isso significa que os caracteres individuais podem ser recuperados do <xref:System.Text.StringBuilder.Chars%2A> propriedade conforme mostrado no exemplo a seguir, que conta o número de alfabético, espaço em branco e os caracteres de pontuação em uma cadeia de caracteres.  
  
 [!code-csharp[System.Text.StringBuilder.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.chars/cs/chars1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.chars/vb/chars1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora dos limites dessa instância ao definir um caractere.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> está fora dos limites dessa instância ao obter um caractere.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os caracteres da instância <see cref="T:System.Text.StringBuilder" /> atual.</summary>
        <returns>Um objeto cujo <see cref="P:System.Text.StringBuilder.Length" /> é 0 (zero).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.StringBuilder.Clear%2A>é um método prático que é equivalente à configuração de <xref:System.Text.StringBuilder.Length%2A> propriedade da instância atual como 0 (zero).  
  
 Chamando o <xref:System.Text.StringBuilder.Clear%2A> método não modifica a instância atual <xref:System.Text.StringBuilder.Capacity%2A> ou <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Text.StringBuilder> objeto com uma cadeia de caracteres, chamadas de <xref:System.Text.StringBuilder.Clear%2A> método e, em seguida, anexa uma nova cadeia de caracteres.  
  
 [!code-csharp[System.Text.StringBuilder.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.stringbuilder.clear/cs/clear1.cs#1)]
 [!code-vb[System.Text.StringBuilder.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.stringbuilder.clear/vb/clear1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">A posição inicial nessa instância de onde os caracteres serão copiados. O índice é baseado em zero.</param>
        <param name="destination">A matriz na qual os caracteres serão copiados.</param>
        <param name="destinationIndex">A posição inicial no <c>destino</c> onde os caracteres serão copiados. O índice é baseado em zero.</param>
        <param name="count">O número de caracteres a serem copiados.</param>
        <summary>Copia os caracteres de um segmento especificado desta instância para um segmento especificado de uma matriz <see cref="T:System.Char" /> de destino.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.StringBuilder.CopyTo%2A> método se destina a ser usado em situações raras, quando você precisa copiar com eficiência as seções de um <xref:System.Text.StringBuilder> objeto em uma matriz. A matriz deve ser um tamanho fixo, pré-alocados, reutilizável e possivelmente globalmente acessível.  
  
 Por exemplo, seu aplicativo pode preencher uma <xref:System.Text.StringBuilder> com um grande número de caracteres do objeto, em seguida, use o <xref:System.Text.StringBuilder.CopyTo%2A> método para copiar partes pequenas, sucessivas do <xref:System.Text.StringBuilder> objeto em uma matriz em que as partes são processadas. Quando todos os dados de <xref:System.Text.StringBuilder> objeto for processado, o tamanho do <xref:System.Text.StringBuilder> objeto é definido como zero e o ciclo é repetido.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.CopyTo%2A> método.  
  
 [!code-cpp[stringbuilder.copyto2#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.copyto2/CPP/ct2.cpp#1)]
 [!code-csharp[stringbuilder.copyto2#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.copyto2/CS/ct2.cs#1)]
 [!code-vb[stringbuilder.copyto2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.copyto2/VB/ct2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, ou <paramref name="count" />, é menor que zero.  
  
 -ou-  
  
 <paramref name="sourceIndex" /> é maior que o tamanho desta instância.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="sourceIndex" /> + <paramref name="count" />é maior que o comprimento dessa instância.  
  
 -ou-  
  
 <paramref name="destinationIndex" /> + <paramref name="count" />é maior que o comprimento de <paramref name="destination" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.EnsureCapacity(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">A capacidade mínima para garantia.</param>
        <summary>Garante que a capacidade desta instância do <see cref="T:System.Text.StringBuilder" /> tenha pelo menos o valor especificado.</summary>
        <returns>A nova capacidade desta instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a capacidade atual for menor do que o `capacity` parâmetro, a memória para esta instância seja realocada para manter pelo menos `capacity` número de caracteres; caso contrário, o uso de memória não é alterado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.EnsureCapacity%2A> método.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="capacity" /> é menor que zero.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Text.StringBuilder sb);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Text.StringBuilder sb) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Equals(System.Text.StringBuilder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sb" Type="System.Text.StringBuilder" />
      </Parameters>
      <Docs>
        <param name="sb">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
        <summary>Retorna um valor que indica se essa instância é igual a um objeto especificado.</summary>
        <returns>
          <see langword="true" /> se essa instância e <paramref name="sb" /> tem a cadeia de caracteres igual, <see cref="P:System.Text.StringBuilder.Capacity" /> e <see cref="P:System.Text.StringBuilder.MaxCapacity" /> valores; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O código a seguir usa o <xref:System.Text.StringBuilder.Equals%2A> método para verificar se dois <xref:System.Text.StringBuilder> objetos são iguais. O método é chamado repetidamente depois pequenas alterações são feitas em cada objeto e os resultados são exibidos no console.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um valor booliano nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro não assinado de 8 bits especificado para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Byte.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um caractere Unicode especificado nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Char.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">A matriz de caracteres a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de uma matriz de caracteres Unicode especificada nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
 Se `value` é `null`, o <xref:System.Text.StringBuilder> não é alterado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Decimal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um número decimal para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Double)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um número de ponto flutuante de precisão dupla para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro assinado de 16 bits especificado para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int16.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro assinado de 32 bits especificado para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int32.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro assinado de 64 bits para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Int64.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O objeto a ser inserido, ou <see langword="null" />.</param>
        <summary>Insere a representação de cadeia de caracteres de um objeto para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Object.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
 Se `value` é `null`, o valor desta instância é alterado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro assinado de 8 bits especificado para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.SByte.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Single)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um número de ponto flutuante de precisão simples para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">A cadeia de caracteres a ser inserida.</param>
        <summary>Insere uma cadeia de caracteres nesta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade é ajustada conforme necessário.  
  
 Esta instância do <xref:System.Text.StringBuilder> não será alterado se `value` é `null`, ou `value` não é `null` , mas seu tamanho é zero.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />é menor que zero ou maior que o comprimento atual desta instância.  
  
 -ou-  
  
 O tamanho atual deste objeto <see cref="T:System.Text.StringBuilder" /> mais o tamanho de <paramref name="value" /> ultrapassa <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro não assinado de 16 bits para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt16.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro não assinado de 32 bits para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt32.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">O valor a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de um inteiro não assinado de 64 bits para esta instância na posição do caractere especificado.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.UInt64.ToString%2A?displayProperty=nameWithType>é usado para obter uma representação de cadeia de caracteres de `value`. Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <exception cref="T:System.OutOfMemoryException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
        <block subset="none" type="usage">
          <para>No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)] e versões anteriores, chamadas para esse método lançou uma <see cref="T:System.ArgumentOutOfRangeException" /> se inserindo <paramref name="value" /> causaria a comprimento total do objeto exceda <see cref="P:System.Text.StringBuilder.MaxCapacity" />. Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o método gera uma <see cref="T:System.OutOfMemoryException" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, string value, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, string value, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.String,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">A cadeia de caracteres a ser inserida.</param>
        <param name="count">O número de vezes para inserir <c>valor</c>.</param>
        <summary>Insere uma ou mais cópias de uma cadeia de caracteres especificada nesta instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância após a conclusão da inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
 Isso <xref:System.Text.StringBuilder> objeto não será alterado se `value` é `null`, `value` não é `null` , mas seu comprimento for zero, ou `count` é zero.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />é menor que zero ou maior que o comprimento atual desta instância.  
  
 -ou-  
  
 <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.OutOfMemoryException">O tamanho atual deste objeto <see cref="T:System.Text.StringBuilder" /> mais o tamanho de <paramref name="value" /> vezes <paramref name="count" /> excede <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Insert (int index, char[] value, int startIndex, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Insert(int32 index, char[] value, int32 startIndex, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Insert(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">A posição nessa instância em que a inserção é iniciada.</param>
        <param name="value">Uma matriz de caracteres.</param>
        <param name="startIndex">O índice inicial em <c>valor</c>.</param>
        <param name="charCount">O número de caracteres a ser inserido.</param>
        <summary>Insere a representação de cadeia de caracteres de uma submatriz de caracteres Unicode especificada nessa instância na posição do caractere especificada.</summary>
        <returns>Uma referência a essa instância após a operação de inserção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres existentes são deslocados para liberar espaço para o novo texto. A capacidade desta instância é ajustada conforme necessário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Insert%2A> método.  
  
 [!code-cpp[stringbuilder.insert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.insert/CPP/insert.cpp#1)]
 [!code-csharp[stringbuilder.insert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.insert/CS/insert.cs#1)]
 [!code-vb[stringbuilder.insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.insert/VB/insert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" />é <see langword="null" />, e <paramref name="startIndex" /> e <paramref name="charCount" /> não são zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />, <paramref name="startIndex" />, ou <paramref name="charCount" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> é maior que o tamanho desta instância.  
  
 -ou-  
  
 <paramref name="startIndex" /> além de <paramref name="charCount" /> não é uma posição no <paramref name="value" />.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho do objeto atual <see cref="T:System.Text.StringBuilder" />.</summary>
        <value>O tamanho dessa instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comprimento de uma <xref:System.Text.StringBuilder> objeto é definido por seu número de <xref:System.Char> objetos.  
  
 Como o <xref:System.String.Length%2A?displayProperty=nameWithType> propriedade, o <xref:System.Text.StringBuilder.Length%2A> propriedade indica o comprimento do objeto de cadeia de caracteres atual. Ao contrário de <xref:System.String.Length%2A?displayProperty=nameWithType> propriedade, que é somente leitura, o <xref:System.Text.StringBuilder.Length%2A> propriedade permite que você modifique o comprimento da cadeia de caracteres armazenado no <xref:System.Text.StringBuilder> objeto.  
  
 Se o comprimento especificado é menor que o comprimento atual <xref:System.Text.StringBuilder> objeto será truncado para o comprimento especificado. Se o comprimento especificado é maior que o tamanho atual, o final do valor de cadeia de caracteres do atual <xref:System.Text.StringBuilder> objeto será preenchido com o caractere Unicode nulo (U + 0000).  
  
 Se o comprimento especificado é maior que a capacidade atual, <xref:System.Text.StringBuilder.Capacity%2A> aumenta para que seja maior ou igual ao comprimento especificado.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Length%2A> propriedade.  
  
 [!code-cpp[stringbuilder.ensurecapacity#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CPP/cap.cpp#1)]
 [!code-csharp[stringbuilder.ensurecapacity#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.ensurecapacity/CS/cap.cs#1)]
 [!code-vb[stringbuilder.ensurecapacity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.ensurecapacity/VB/cap.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O valor especificado para uma operação de definição é menor que zero ou maior que <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCapacity">
      <MemberSignature Language="C#" Value="public int MaxCapacity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxCapacity" />
      <MemberSignature Language="DocId" Value="P:System.Text.StringBuilder.MaxCapacity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a capacidade máxima desta instância.</summary>
        <value>O número máximo de caracteres que esta instância pode conter.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A capacidade máxima para esta implementação é <xref:System.Int32?displayProperty=nameWithType>. No entanto, esse valor é específico da implementação e pode ser diferente em implementações de outros ou posteriores. Você pode definir explicitamente a capacidade máxima de um <xref:System.Text.StringBuilder> objeto chamando o <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> construtor.  
  
 No[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], quando você cria uma instância de <xref:System.Text.StringBuilder> objeto chamando o <xref:System.Text.StringBuilder.%23ctor%28System.Int32%2CSystem.Int32%29> construtor, o comprimento e a capacidade do <xref:System.Text.StringBuilder> instância pode crescer além do valor de seu <xref:System.Text.StringBuilder.MaxCapacity%2A> propriedade. Isso pode ocorrer especialmente quando você chama o <xref:System.Text.StringBuilder.Append%2A> e <xref:System.Text.StringBuilder.AppendFormat%2A> métodos acrescentar cadeias pequenas.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Remove (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Remove(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Remove(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <param name="length">O número de caracteres a serem removidos.</param>
        <summary>Remove o intervalo especificado de caracteres dessa instância.</summary>
        <returns>Uma referência a essa instância após a operação de imposto embutido tiver sido concluída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método atual remove o intervalo especificado de caracteres da instância atual. Os caracteres em (`startIndex` + `length`) são movidos para `startIndex`, e o valor de cadeia de caracteres da instância atual é reduzido em `length`. A capacidade da instância atual não é afetada.  
  
> [!NOTE]
>  O <xref:System.Text.StringBuilder.Remove%2A> método modifica o valor atual <xref:System.Text.StringBuilder> instância e retorna essa instância. Não crie e retornam um novo <xref:System.Text.StringBuilder> objeto.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Remove%2A> método.  
  
 [!code-cpp[stringbuilder.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.remove/CPP/remove.cpp#1)]
 [!code-csharp[stringbuilder.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.remove/CS/remove.cs#1)]
 [!code-vb[stringbuilder.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.remove/VB/remove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero, ou <paramref name="startIndex" />  +  <paramref name="length" /> é maior que o comprimento dessa instância.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">O caractere a ser substituído.</param>
        <param name="newChar">O caractere que substitui <c>oldChar</c>.</param>
        <summary>Substitui todas as ocorrências de um caractere especificado nesta instância por outro caractere especificado.</summary>
        <returns>Uma referência a essa instância com <paramref name="oldChar" /> substituído por <paramref name="newChar" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldChar` na instância atual. O tamanho do atual <xref:System.Text.StringBuilder> instância não é alterada após a substituição.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">A cadeia de caracteres a ser substituída.</param>
        <param name="newValue">A cadeia de caracteres que substitui <c>oldValue</c>, ou <see langword="null" />.</param>
        <summary>Substitui todas as ocorrências de uma cadeia de caracteres especificada nesta instância por outra cadeia de caracteres especificada.</summary>
        <returns>Uma referência a essa instância com todas as instâncias de <paramref name="oldValue" /> substituídas por <paramref name="newValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldValue` na instância atual. Se `newValue` é `null` ou <xref:System.String?displayProperty=nameWithType>, todas as ocorrências de `oldValue` são removidos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="oldValue" /> é zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (char oldChar, char newChar, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(char oldChar, char newChar, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.Char,System.Char,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldChar">O caractere a ser substituído.</param>
        <param name="newChar">O caractere que substitui <c>oldChar</c>.</param>
        <param name="startIndex">A posição nessa instância em que a subcadeia é iniciada.</param>
        <param name="count">O tamanho da subcadeia.</param>
        <summary>Substitui, dentro de uma subcadeia dessa instância, todas as ocorrências um caractere especificado por outro caractere especificado.</summary>
        <returns>Uma referência a essa instância com <paramref name="oldChar" /> substituído por <paramref name="newChar" /> no intervalo de <paramref name="startIndex" /> para <paramref name="startIndex" />  +  <paramref name="count" /> -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldChar` na instância atual. O tamanho do atual <xref:System.Text.StringBuilder> objeto não é alterado após a substituição.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> + <paramref name="count" />é maior que o comprimento do valor desta instância.  
  
 -ou-  
  
 <paramref name="startIndex" /> ou <paramref name="count" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public System.Text.StringBuilder Replace (string oldValue, string newValue, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Text.StringBuilder Replace(string oldValue, string newValue, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.Replace(System.String,System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="oldValue">A cadeia de caracteres a ser substituída.</param>
        <param name="newValue">A cadeia de caracteres que substitui <c>oldValue</c>, ou <see langword="null" />.</param>
        <param name="startIndex">A posição nessa instância em que a subcadeia é iniciada.</param>
        <param name="count">O tamanho da subcadeia.</param>
        <summary>Substitui, dentro de uma subcadeia dessa instância, todas as ocorrências de uma cadeia de caracteres especificada por outra cadeia de caracteres especificada.</summary>
        <returns>Uma referência a essa instância com todas as instâncias de <paramref name="oldValue" /> substituído por <paramref name="newValue" /> no intervalo de <paramref name="startIndex" /> para <paramref name="startIndex" />  +  <paramref name="count" /> - 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação ordinal, diferencia maiusculas de minúsculas para identificar ocorrências de `oldValue` na subcadeia de caracteres especificada. Se `newValue` é `null` ou <xref:System.String?displayProperty=nameWithType>, todas as ocorrências de `oldValue` são removidos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.StringBuilder.Replace%2A> método.  
  
 [!code-cpp[stringbuilder.replace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringbuilder.replace/CPP/replace.cpp#1)]
 [!code-csharp[stringbuilder.replace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringbuilder.replace/CS/replace.cs#1)]
 [!code-vb[stringbuilder.replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringbuilder.replace/VB/replace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="oldValue" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O comprimento de <paramref name="oldValue" /> é zero.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" />Além de <paramref name="count" /> indica uma posição de caractere não dentro desta instância.  
  
 -ou-  
  
 Aumentar o valor dessa instância excederia <see cref="P:System.Text.StringBuilder.MaxCapacity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">O objeto a ser preenchido com informações de serialização.</param>
        <param name="context">O local para armazenar e recuperar dados serializado. Reservado para uso futuro.</param>
        <summary>Preenche uma <see cref="T:System.Runtime.Serialization.SerializationInfo" /> objeto com os dados necessários para desserializar atual <see cref="T:System.Text.StringBuilder" /> objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `context` parâmetro é reservado para uso futuro e não participam nesta operação.  
  
 Para obter mais informações, consulte o método <xref:System.Runtime.Serialization.SerializationInfo.AddValue%28System.String%2CSystem.Object%2CSystem.Type%29?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="info" /> é <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor dessa instância em um <see cref="T:System.String" />.</summary>
        <returns>Uma cadeia de caracteres cujo valor é o mesmo que essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar o <xref:System.Text.StringBuilder.ToString%2A> método para converter o <xref:System.Text.StringBuilder> o objeto para um <xref:System.String> objeto antes que você pode passar a cadeia de caracteres representada pelo <xref:System.Text.StringBuilder> objeto para um método que tem um <xref:System.String> parâmetro ou exibi-lo na interface do usuário.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a chamar o <xref:System.Text.StringBuilder.ToString%2A> método. Este exemplo é parte de um exemplo maior fornecido para a <xref:System.Text.StringBuilder> classe.  
  
 [!code-cpp[StringBuilder#5](~/samples/snippets/cpp/VS_Snippets_CLR/StringBuilder/cpp/StringBuilder.cpp#5)]
 [!code-csharp[StringBuilder#5](~/samples/snippets/csharp/VS_Snippets_CLR/StringBuilder/CS/StringBuilder.cs#5)]
 [!code-vb[StringBuilder#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringBuilder/VB/StringBuilder.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.StringBuilder.ToString(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição inicial da subcadeia de caracteres nessa instância.</param>
        <param name="length">O tamanho da subcadeia.</param>
        <summary>Converte o valor de uma subcadeia de caracteres dessa instância em um <see cref="T:System.String" />.</summary>
        <returns>Uma cadeia de caracteres cujo valor é igual a subcadeia de caracteres especificada nesta instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar o <xref:System.Text.StringBuilder.ToString%2A> método para converter o <xref:System.Text.StringBuilder> o objeto para um <xref:System.String> objeto antes que você pode passar a cadeia de caracteres representada pelo <xref:System.Text.StringBuilder> objeto para um método que tem um <xref:System.String> parâmetro ou exibi-lo na interface do usuário.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
 -ou-  
  
 A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o tamanho da instância atual.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
