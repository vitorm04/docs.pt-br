<Type Name="EncoderFallbackBuffer" FullName="System.Text.EncoderFallbackBuffer">
  <TypeSignature Language="C#" Value="public abstract class EncoderFallbackBuffer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit EncoderFallbackBuffer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Text.EncoderFallbackBuffer" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece um buffer que permite que um manipulador de fallback retorne uma cadeia de caracteres alternativa para um codificador quando ele não é capaz de codificar um caractere de entrada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma codificação define um mapeamento entre um caractere Unicode e uma sequência codificada de bytes. Uma operação de codificação, que converte um caractere de entrada em uma sequência de bytes de saída, falha se nenhum mapeamento for definido para um caractere específico.  
  
 O .NET Framework fornece um mecanismo, chamado fallback, se uma conversão não pode ser executada de tratamento de falha. Todos os manipuladores de fallback do codificador devem implementar o seguinte:  
  
-   Um codificador de fallback, que é representado por uma classe derivada do <xref:System.Text.EncoderFallback> classe.  
  
-   Um buffer de fallback do codificador, que é representado por um tipo derivado de <xref:System.Text.EncoderFallbackBuffer> classe que pode retornar uma cadeia de caracteres para a operação de conversão.  
  
 Sequências podem usar três estratégias para lidar com falhas de conversão:  
  
-   Mapeamento de melhor ajuste. O buffer de fallback do codificador pode retornar uma cadeia de caracteres que representa uma aproximação para o caractere de entrada. O .NET Framework não fornece um melhor ajuste de público <xref:System.Text.EncoderFallbackBuffer> implementação.  
  
-   Substituição. O buffer de fallback do codificador pode retornar uma cadeia de caracteres, como um ponto de interrogação ("?"), que indica que um caractere não pode ser codificado. No .NET Framework, o <xref:System.Text.EncoderReplacementFallback> e <xref:System.Text.EncoderReplacementFallbackBuffer> classes fornecem uma implementação de buffer de fallback de substituição pública. O construtor do <xref:System.Text.EncoderReplacementFallback> classe permite que você defina a cadeia de caracteres de substituição.  
  
-   Exceção. O <xref:System.Text.EncoderFallbackBuffer> implementação lança uma exceção, que indica que um caractere não pode ser codificado e encerra a operação de codificação. Nesse caso, o manipulador de fallback deve fornecer um <xref:System.Text.EncoderFallbackBuffer> implementação, embora ele não retorna uma cadeia de caracteres para o codificador. No .NET Framework, o <xref:System.Text.EncoderExceptionFallback> e <xref:System.Text.EncoderExceptionFallbackBuffer> classes fornecem uma implementação de fallback de exceção pública que lança um <xref:System.Text.EncoderFallbackException> quando um caractere não pode ser codificado.  
  
 O buffer em um <xref:System.Text.EncoderFallbackBuffer> implementação representa a cadeia de caracteres inteira a ser retornado para o codificador em resposta a um codificador de fallback. Em geral, implementações também incluem informações de estado, como o índice do próximo caractere para retornar para o codificador e o número de caracteres restantes a serem retornadas. Porque <xref:System.Text.EncoderFallbackBuffer> é uma classe abstrata, ele requer que as classes derivadas para implementar os seguintes membros no mínimo:  
  
-   Sobrecarregados <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> método, que é chamado pelo codificador quando ele não é possível codificar um caractere. O codificador passa dois tipos de informações para a implementação do buffer de fallback: o caractere ou par substituto que não pode ser codificado e o índice do caractere de entrada. Em um manipulador de exceção de fallback do codificador, a exceção é lançada nesse método. Caso contrário, o método retornará `true` se ele fornece um fallback, ou `false` se não existir.  
  
-   O <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> método, que é chamado repetidamente pelo codificador se o <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> método retornará `true`. Em chamadas sucessivas, o manipulador deve retornar cada caractere em seu buffer. Quando ele tiver retornado todos os caracteres, ele deverá retornar U + 0000. Um manipulador de exceção sempre retorna a U + 0000.  
  
-   O <xref:System.Text.EncoderFallbackBuffer.MovePrevious%2A> método, que tenta mover o ponteiro para a posição anterior no buffer e indica se a migração foi bem-sucedida. Sempre retorna um manipulador de exceção `false`.  
  
-   O <xref:System.Text.EncoderFallbackBuffer.Remaining%2A> propriedade, que indica o número de caracteres restantes a serem retornadas para o codificador. Um manipulador de exceção de fallback sempre retorna zero.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EncoderFallbackBuffer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.EncoderFallbackBuffer" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public abstract bool Fallback (char charUnknown, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Fallback(char charUnknown, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknown" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknown">Um caractere de entrada.</param>
        <param name="index">A posição de índice do caractere no buffer de entrada.</param>
        <summary>Quando substituído em uma classe derivada, prepara o buffer de fallback para lidar com o caractere de entrada especificado.</summary>
        <returns>
          <see langword="true" />Se o buffer de fallback pode processar <paramref name="charUnknown" />; <see langword="false" /> se o buffer de fallback ignora <paramref name="charUnknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> e <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> chamada de métodos <xref:System.Text.DecoderFallbackBuffer.Fallback%28System.Byte%5B%5D%2CSystem.Int32%29> se encontram um caractere de entrada desconhecido que não pode ser codificado. Um valor de retorno `true` indica que o buffer de fallback pode processar o caractere de entrada, o que faz com que o método de chamada chamar o <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> método para obter cada caractere do buffer de fallback. Porque ele não processar caracteres individuais, o <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> método em um manipulador de exceção fallback lança uma exceção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Fallback">
      <MemberSignature Language="C#" Value="public abstract bool Fallback (char charUnknownHigh, char charUnknownLow, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Fallback(char charUnknownHigh, char charUnknownLow, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Fallback(System.Char,System.Char,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charUnknownHigh" Type="System.Char" />
        <Parameter Name="charUnknownLow" Type="System.Char" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charUnknownHigh">O substituto alto do par de entrada.</param>
        <param name="charUnknownLow">O substituto baixo do par de entrada.</param>
        <param name="index">A posição de índice do par substituto no buffer de entrada.</param>
        <summary>Quando substituído em uma classe derivada, prepara o buffer de fallback para lidar com o par substituto especificado.</summary>
        <returns>
          <see langword="true" />Se o buffer de fallback pode processar <paramref name="charUnknownHigh" /> e <paramref name="charUnknownLow" />; <see langword="false" /> se o buffer de fallback ignora o par substituto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> e <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> chamada de métodos <xref:System.Text.EncoderFallbackBuffer.Fallback%28System.Char%2CSystem.Char%2CSystem.Int32%29> se encontram um par substituto em sua entrada. Um valor de retorno `true` indica que o buffer de fallback pode processar o par substituto, o que faz com que o método de chamada chamar o <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> método para obter cada caractere do buffer de fallback.  Porque ele não processar caracteres individuais, o <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> método em um manipulador de exceção fallback lança uma exceção.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextChar">
      <MemberSignature Language="C#" Value="public abstract char GetNextChar ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char GetNextChar() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.GetNextChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, recupera o próximo caractere no buffer de fallback.</summary>
        <returns>O próximo caractere no buffer de fallback.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma operação de codificação chama o <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> método se a operação de encontrar um caractere desconhecido ou o par substituto na entrada. Por exemplo, no caso de um caso de fallback, substituição do <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> método retorna `true`, existe uma cadeia de substituição que podem ser codificados em vez da entrada desconhecida. As chamadas de operação de codificação de <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> método repetidamente e obtém o caractere de uma cadeia de caracteres substitutos por vez. Quando todos os caracteres no buffer de fallback foram retornados para o codificador de <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> método deve retornar a U + 0000.  
  
 Para um manipulador de fallback de exceção, o <xref:System.Text.EncoderFallbackBuffer.GetNextChar%2A> método deve retornar a U + 0000.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MovePrevious">
      <MemberSignature Language="C#" Value="public abstract bool MovePrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MovePrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.MovePrevious" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, faz com que a próxima chamada para o <see cref="M:System.Text.EncoderFallbackBuffer.GetNextChar" /> método para acessar a posição do caractere de buffer de dados que é anterior a atual posição do caractere.</summary>
        <returns>
          <see langword="true" />Se o <see cref="M:System.Text.EncoderFallbackBuffer.MovePrevious" /> operação foi bem-sucedida; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um manipulador de exceção fallback deve retornar `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remaining">
      <MemberSignature Language="C#" Value="public abstract int Remaining { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Remaining" />
      <MemberSignature Language="DocId" Value="P:System.Text.EncoderFallbackBuffer.Remaining" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o número de caracteres no atual <see cref="T:System.Text.EncoderFallbackBuffer" /> objeto permanecer para serem processados.</summary>
        <value>O número de caracteres no buffer de fallback atual que ainda não foi processada.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.EncoderFallbackBuffer.Fallback%2A> método `true` se <xref:System.Text.EncoderFallbackBuffer.Remaining%2A> é um valor diferente de zero.  
  
 Para um manipulador de fallback de exceção, o <xref:System.Text.DecoderFallbackBuffer.Remaining%2A> método deve retornar zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public virtual void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.EncoderFallbackBuffer.Reset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa todas as informações de estado e de dados pertencentes a esse buffer de fallback.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Depois de chamar o <see cref="M:System.Text.EncoderFallbackBuffer.Reset" /> método, o <see cref="P:System.Text.EncoderFallbackBuffer.Remaining" /> propriedade deve retornar 0, o <see cref="M:System.Text.EncoderFallbackBuffer.GetNextChar" /> método deve retornar a U + 0000 e o <see cref="M:System.Text.EncoderFallbackBuffer.MovePrevious" /> método deve retornar <see langword="false" />.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>
