<Type Name="Encoding" FullName="System.Text.Encoding">
  <TypeSignature Language="C#" Value="public abstract class Encoding : ICloneable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Encoding extends System.Object implements class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Text.Encoding" />
  <AssemblyInfo>
    <AssemblyName>System.Text.Encoding</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa uma codificação de caracteres.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/text/encoding.cs#3b6090c501893c25). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 Codificação é o processo de transformar um conjunto de caracteres Unicode em uma sequência de bytes. Por outro lado, a decodificação é o processo de transformar uma sequência de bytes codificados em um conjunto de caracteres Unicode. Para obter informações sobre os formatos do Unicode transformação (UTFs) e outras codificações com suporte <xref:System.Text.Encoding>, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 Observe que <xref:System.Text.Encoding> foi projetado para operar em caracteres Unicode em vez de dados arbitrários de binários, como matrizes de bytes. Se você deve codificar os dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O .NET Framework fornece as seguintes implementações de <xref:System.Text.Encoding> classe para oferecer suporte a outras codificações e codificações de Unicode atuais:  
  
-   <xref:System.Text.ASCIIEncoding>codifica caracteres Unicode como único caracteres ASCII de 7 bits. Esta codificação só dá suporte a valores de caractere entre U + 0000 e U + 007F. Página de código 20127. Também está disponível por meio de <xref:System.Text.Encoding.ASCII%2A> propriedade.  
  
-   <xref:System.Text.UTF7Encoding>codifica caracteres Unicode usando a codificação UTF-7. Essa codificação dá suporte a todos os valores de caractere Unicode. Página de código 65000. Também está disponível por meio de <xref:System.Text.Encoding.UTF7%2A> propriedade.  
  
-   <xref:System.Text.UTF8Encoding>codifica caracteres Unicode usando a codificação UTF-8. Essa codificação dá suporte a todos os valores de caractere Unicode. Página de código 65001. Também está disponível por meio de <xref:System.Text.Encoding.UTF8%2A> propriedade.  
  
-   <xref:System.Text.UnicodeEncoding>codifica caracteres Unicode usando a codificação UTF-16. Há suporte para ambas as ordens little endian e big bytes endian. Também está disponível por meio de <xref:System.Text.Encoding.Unicode%2A> propriedade e o <xref:System.Text.Encoding.BigEndianUnicode%2A> propriedade.  
  
-   <xref:System.Text.UTF32Encoding>codifica caracteres Unicode usando a codificação UTF-32. Little endian (página de código 12000) tanto byte big endian (página de código 12001) ordens têm suporte. Também está disponível por meio de <xref:System.Text.Encoding.UTF32%2A> propriedade.  
  
 O <xref:System.Text.Encoding> classe é usado principalmente para converter entre codificações diferentes e Unicode. Geralmente, uma das classes derivadas de Unicode é a opção correta para seu aplicativo.  
  
 Use o <xref:System.Text.Encoding.GetEncoding%2A> método para obter outras codificações e chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma lista de todas as codificações.  
  
 A tabela a seguir lista as codificações com suporte do .NET Framework. Lista número de página de código do cada codificação e os valores da codificação <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> e <xref:System.Text.EncodingInfo.DisplayName%2A?displayProperty=nameWithType> propriedades. Um asterisco na última coluna indica que a página de código nativo é suportada pelo .NET Framework, independentemente da plataforma subjacente. Observe que o código de páginas cujo <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> propriedade corresponde a um padrão internacional não são necessariamente compatíveis por completo com esse padrão.  
  
|Página de código|Nome|Nome para exibição|Suporte do .NET framework|  
|---------------|----------|------------------|----------------------------|  
|37|IBM037|IBM EBCDIC (EUA-Canadá)||  
|437|IBM437|Estados Unidos de OEM||  
|500|IBM500|IBM EBCDIC (internacional)||  
|708|ASMO-708|Árabe (ASMO 708)||  
|720|720 DOS|Árabe (DOS)||  
|737|ibm737|Grego (DOS)||  
|775|ibm775|Báltico (DOS)||  
|850|ibm850|Europeu Ocidental (DOS)||  
|852|ibm852|Europeu central (DOS)||  
|855|IBM855|Cirílico OEM||  
|857|ibm857|Turco (DOS)||  
|858|IBM00858|OEM latino multilíngue I||  
|860|IBM860|Português (DOS)||  
|861|ibm861|Islandês (DOS)||  
|862|862 DOS|Hebraico (DOS)||  
|863|IBM863|Francês canadense (DOS)||  
|864|IBM864|Árabe (864)||  
|865|IBM865|Nórdico (DOS)||  
|866|cp866|Cirílico (DOS)||  
|869|ibm869|Grego moderno (DOS)||  
|870|IBM870|IBM EBCDIC (latino multilíngue-2)||  
|874|Windows 874|Tailandês (Windows)||  
|875|cp875|IBM EBCDIC (Grego moderno)||  
|932|shift_jis|Japonês (JIS-Shift)||  
|936|GB2312|Chinês simplificado (GB2312)|✓|  
|949|1987 ks_c_5601|Coreano||  
|950|Big5|Chinês tradicional (Big5)||  
|1026|IBM1026|IBM EBCDIC (Turco Latino-5)||  
|1047|IBM01047|IBM Latin-1||  
|1140|IBM01140|IBM EBCDIC (EUA-Canadá-Euro)||  
|1141|IBM01141|IBM EBCDIC (Alemanha-Euro)||  
|1142|IBM01142|IBM EBCDIC (Dinamarca-Noruega-Euro)||  
|1143|IBM01143|IBM EBCDIC (Finlândia-Suécia-Euro)||  
|1144|IBM01144|IBM EBCDIC (Itália-Euro)||  
|1145|IBM01145|IBM EBCDIC (Espanha-Euro)||  
|1146|IBM01146|IBM EBCDIC (Euro do Reino Unido)||  
|1147|IBM01147|IBM EBCDIC (França-Euro)||  
|1148|IBM01148|IBM EBCDIC (International-Euro)||  
|1149|IBM01149|IBM EBCDIC (Islandês-Euro)||  
|1200|UTF-16|Unicode|✓|  
|1201|unicodeFFFE|Unicode (Big endian)|✓|  
|1250|Windows-1250|Europeu central (Windows)||  
|1251|Windows-1251|Cirílico (Windows)||  
|1252|Windows-1252|Europeu Ocidental (Windows)|✓|  
|1253|Windows 1253|Grego (Windows)||  
|1254|Windows-1254|Turco (Windows)||  
|1255|Windows 1255|Hebraico (Windows)||  
|1256|Windows 1256|Árabe (Windows)||  
|1257|1257 do Windows|Báltico (Windows)||  
|1258|Windows-1258|Vietnamita (Windows)||  
|1361|Johab|Coreano (Johab)||  
|10000|Macintosh|Europeu Ocidental (Mac)||  
|10001|x-mac-japonês|Japonês (Mac)||  
|10002|x-mac-chinesetrad|Chinês tradicional (Mac)||  
|10003|x-mac-coreano|Coreano (Mac)|✓|  
|10004|x-mac-árabe|Árabe (Mac)||  
|10005|x-mac-hebraico|Hebraico (Mac)||  
|10006|x-mac-grego|Grego (Mac)||  
|10007|x-mac-cirílico|Cirílico (Mac)||  
|10008|x-mac-chinesesimp|Chinês simplificado (Mac)|✓|  
|10010|Romeno-mac-x|Romeno (Mac)||  
|10017|Ucraniano-mac-x|Ucraniano (Mac)||  
|10021|x-mac-tailandês|Tailandês (Mac)||  
|10029|x-mac-ce|Europeu central (Mac)||  
|10079|x-mac-Islandês|Islandês (Mac)||  
|10081|x-mac-turco|Turco (Mac)||  
|10082|x-mac-croata|Croata (Mac)||  
|12000|UTF-32|Unicode (UTF-32)|✓|  
|12001|UTF-32BE|Unicode (UTF-32 Big endian)|✓|  
|20000|Chinês-x-CNS|Chinês tradicional (CNS)||  
|20001|x-cp20001|TCA Taiwan||  
|20002|Chinês-x-Eten|Chinês tradicional (Eten)||  
|20003|x-cp20003|Taiwan IBM5550||  
|20004|x-cp20004|Teletexto Taiwan||  
|20005|x-cp20005|Wang Taiwan||  
|20105|IA5 x|Europeu Ocidental (IA5)||  
|20106|x-IA5-alemão|Alemão (IA5)||  
|20107|x-IA5-sueco|Sueco (IA5)||  
|20108|x-IA5-Norueguês|Norueguês (IA5)||  
|20127|US-ascii|US-ASCII|✓|  
|20261|x-cp20261|T.61||  
|20269|x-cp20269|ISO 6937||  
|20273|IBM273|IBM EBCDIC (Alemanha)||  
|20277|IBM277|IBM EBCDIC (Dinamarca-Noruega)||  
|20278|IBM278|IBM EBCDIC (Finlândia-Suécia)||  
|20280|IBM280|IBM EBCDIC (Itália)||  
|20284|IBM284|IBM EBCDIC (Espanha)||  
|20285|IBM285|IBM EBCDIC (REINO UNIDO)||  
|20290|IBM290|IBM EBCDIC (japonês katakana)||  
|20297|IBM297|IBM EBCDIC (França)||  
|20420|IBM420|IBM EBCDIC (árabe)||  
|20423|IBM423|IBM EBCDIC (grego)||  
|20424|IBM424|IBM EBCDIC (hebraico)||  
|20833|x-EBCDIC-KoreanExtended|IBM EBCDIC (coreano estendido)||  
|20838|IBM-tailandês|IBM EBCDIC (tailandês)||  
|20866|KOI8-r|Cirílico (KOI8-R)||  
|20871|IBM871|IBM EBCDIC (Islandês)||  
|20880|IBM880|IBM EBCDIC (Russo Cirílico)||  
|20905|IBM905|IBM EBCDIC (turco)||  
|20924|IBM00924|IBM Latin-1||  
|20932|EUC-JP|Japonês (JIS 0208-1990 e 0212-1990)||  
|20936|x-cp20936|Chinês simplificado (GB2312-80)|✓|  
|20949|x-cp20949|Coreano Wansung|✓|  
|21025|cp1025|IBM EBCDIC (Sérvio cirílico-búlgaro)||  
|21866|KOI8-u|Cirílico (KOI8-U)||  
|28591|ISO 8859-1|Europeu Ocidental (ISO)|✓|  
|28592|ISO 8859-2|Europeu central (ISO)||  
|28593|ISO 8859-3|3 latinos (ISO)||  
|28594|ISO 8859-4|Báltico (ISO)||  
|28595|ISO 8859-5|Cirílico (ISO)||  
|28596|ISO-8859-6|Árabe (ISO)||  
|28597|ISO-8859-7|Grego (ISO)||  
|28598|ISO-8859-8|Hebraico (ISO-Visual)|✓|  
|28599|ISO-8859-9|Turco (ISO)||  
|28603|ISO-8859-13|Estoniano (ISO)||  
|28605|ISO 8859-15|Latino 9 (ISO)||  
|29001|x-Europa|Europa||  
|38598|ISO 8859-8 i|Hebraico (ISO-lógico)|✓|  
|50220|ISO-2022-jp|Japonês (JIS)|✓|  
|50221|csISO2022JP|Japonês (JIS-Permitir 1 byte Kana)|✓|  
|50222|ISO-2022-jp|Japonês (JIS-Permitir 1 byte Kana - portanto / SI)|✓|  
|50225|ISO-2022-kr|Coreano (ISO)|✓|  
|50227|x-cp50227|Chinês simplificado (ISO-2022)|✓|  
|51932|euc-jp|Japonês (EUC)|✓|  
|51936|EUC-CN|Chinês simplificado (EUC)|✓|  
|51949|EUC-kr|Coreano (EUC)|✓|  
|52936|Hz-gb-2312|Chinês simplificado (HZ)|✓|  
|54936|GB18030|Chinês simplificado (GB18030)|✓|  
|57002|x-iscii-de|ISCII Devanagari|✓|  
|57003|x iscii ser|Bengali ISCII|✓|  
|57004|x-iscii-ta|ISCII Tâmil|✓|  
|57005|x-iscii-te|Télugo ISCII|✓|  
|57006|iscii x como|Assamês ISCII|✓|  
|57007|x-iscii ou|Oriá ISCII|✓|  
|57008|x-iscii-ka|Kannada ISCII|✓|  
|57009|x-iscii-ma|ISCII Malaio|✓|  
|57010|x-iscii-gu|Gujarati ISCII|✓|  
|57011|x-iscii-pa|Punjabi ISCII|✓|  
|65000|UTF-7|Unicode (UTF-7)|✓|  
|65001|UTF-8|Unicode (UTF-8)|✓|  
  
 A exemplo a seguir chama o <xref:System.Text.Encoding.GetEncoding%28System.Int32%29> e <xref:System.Text.Encoding.GetEncoding%28System.String%29> a codificação de página de código de métodos para obter o grego (Windows). Ele compara o <xref:System.Text.Encoding> objetos retornados por chamadas de método para mostrar que forem iguais e, em seguida, o maps exibe o ponto de código Unicode e o valor de página de código correspondente para cada caractere do alfabeto grego.  
  
 [!code-csharp[System.Text.Encoding#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding/cs/getencoding1.cs#1)]
 [!code-vb[System.Text.Encoding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding/vb/getencoding1.vb#1)]  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O UTF-16 e os codificadores UTF-32 podem usar a ordem de byte big endian (byte mais significativo primeiro) ou a ordem de bytes endian pouca (byte menos significativo primeiro). Por exemplo, a letra maiuscula latina um (U + 0041) é serializado como segue (em hexadecimal):  
  
-   Ordem de byte big endian da UTF-16: 00 41  
  
-   Ordem de byte endian UTF-16 little: 41 00  
  
-   Ordem de byte big endian da UTF-32: 00 00 00 41  
  
-   Ordem de byte endian pouco UTF-32: 41 00 00 00  
  
 É geralmente mais eficiente para armazenar caracteres Unicode usando a ordem de byte nativo. Por exemplo, é melhor usar a ordem de bytes endian pouco em plataformas endian pequeno, como computadores Intel.  
  
 O <xref:System.Text.Encoding.GetPreamble%2A> método recupera uma matriz de bytes que inclui a marca de ordem de byte (BOM). Se a matriz de bytes é o prefixo para um fluxo codificado, isso ajuda o decodificador para identificar o formato de codificação usado.  
  
 Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte o Unicode Standard no [home page do Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
 Observe que as classes de codificação permitem erros:  
  
-   Alterar modo silencioso para um "?" caracteres.  
  
-   Use um caractere de "melhor ajuste".  
  
-   Altere para um comportamento específico do aplicativo através do uso de <xref:System.Text.EncoderFallback> e <xref:System.Text.DecoderFallback> classes com o caractere de substituição de U + FFFD Unicode.  
  
 Você deve lançar uma exceção em qualquer erro de fluxo de dados. Um aplicativo usa um sinalizador de "throwonerror" quando aplicável ou usa o <xref:System.Text.EncoderExceptionFallback> e <xref:System.Text.DecoderExceptionFallback> classes. Fallback se ajuste melhor geralmente não é recomendável porque pode causar perda de dados ou confusão e é mais lenta que a substituição de caracteres simples. Para codificações ANSI, o melhor ajuste é o comportamento padrão.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.  
  
> [!NOTE]
>  A matriz do byte [] é o único tipo neste exemplo que contém os dados codificados. Os tipos de .NET Char e cadeia de caracteres são Unicode, portanto, o <xref:System.Text.Encoding.GetChars%2A> chamada decodifica os dados em Unicode.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes derivadas substituir este construtor.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codePage">O identificador de página de código da codificação preferencial.  
  
 -ou-  
  
 0, para usar a codificação padrão.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.Encoding" /> que corresponde à página de código especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Classes derivadas substituir este construtor.  
  
 Criar chamadas para o construtor de classe derivada uma <xref:System.Text.Encoding> objeto que usa o retorno de melhor ajuste para codificação e decodificação de operações. Tanto o <xref:System.Text.Encoding.DecoderFallback%2A> e <xref:System.Text.Encoding.EncoderFallback%2A> propriedades são somente leitura e não pode ser modificadas. Para controlar a estratégia de fallback para uma classe derivada de <xref:System.Text.Encoding>, chame o <xref:System.Text.Encoding.%23ctor%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> construtor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Encoding (int codePage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(int32 codePage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.#ctor(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="codePage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codePage">O identificador de página de código da codificação.</param>
        <param name="encoderFallback">Um objeto que fornece um procedimento de tratamento de erros quando um caractere não pode ser codificado com a codificação atual.</param>
        <param name="decoderFallback">Um objeto que fornece um procedimento de tratamento de erros quando uma sequência de bytes não pode ser decodificada com a codificação atual.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Text.Encoding" /> que corresponde à página de código especificada com as estratégias de fallback de codificador e decodificador especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é `protected`; derivada classes substituem-la.  
  
 Você pode chamar esse construtor de uma classe derivada para controlar o fallback de codificação e decodificação estratégias. O <xref:System.Text.Encoding> construtores de classe criam objetos de codificação somente leitura que não permitem o codificador ou decodificador de fallback a ser definido depois que o objeto é criado.  
  
 Se qualquer um dos `encoderFallback` ou `decoderFallback` for vazio, fallback melhor ajuste é usado como a estratégia de fallback correspondente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codePage" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="ASCII">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding ASCII { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding ASCII" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.ASCII" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o conjunto de caracteres ASCII (7 bits).</summary>
        <value>Uma codificação para o conjunto de caracteres ASCII (7 bits).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caracteres ASCII são limitados para os mais baixo 128 caracteres Unicode U + 0000 a U + 007F.  
  
 Ao selecionar a codificação ASCII para seu aplicativo, considere o seguinte:  
  
-   A codificação ASCII normalmente é adequada para protocolos que exijam ASCII.  
  
-   Se você exigir codificação de 8 bits (que às vezes incorretamente é conhecido como "ASCII"), a codificação UTF-8 é recomendada durante o ASCII de codificação. Para os caracteres 0-7F, os resultados são idênticos, mas o uso de UTF-8 evita perda de dados, permitindo que a representação de todos os caracteres Unicode representável. Observe que a codificação ASCII tem um 8 bits ambiguidade que pode permitir que o uso mal-intencionado, mas a codificação UTF-8 remove a ambiguidade de 8 bits.  
  
-   Antes do .NET Framework versão 2.0, o .NET Framework permitidos falsificação ignorando os 8 bits. Começando com o .NET Framework 2.0, pontos de código não-ASCII retornam durante a decodificação.  
  
 O <xref:System.Text.ASCIIEncoding> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> método para instanciar um <xref:System.Text.ASCIIEncoding> objeto cujo fallback é uma <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.ASCII#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.ascii/cs/encoding.ascii2.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.ascii/vb/encoding.ascii2.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra o efeito da codificação de caracteres que estão fora do intervalo ASCII de ASCII.  
  
 [!code-cpp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CPP/ascii.cpp#1)]
 [!code-csharp[System.Text.Encoding.ASCII Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/CS/ascii.cs#1)]
 [!code-vb[System.Text.Encoding.ASCII Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.ASCII Example/VB/ascii.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BigEndianUnicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding BigEndianUnicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding BigEndianUnicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BigEndianUnicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-16 que usa a ordem de byte big endian.</summary>
        <value>Um objeto de codificação para o formato UTF-16 que usa a ordem de byte big endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.UnicodeEncoding> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar um big endian <xref:System.Text.UnicodeEncoding> objeto cujo fallback é uma <xref:System.Text.EncoderFallbackException> ou <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode1.cs#2)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode1.vb#2)]  
  
 Retornado <xref:System.Text.UnicodeEncoding> objeto tem <xref:System.Text.Encoding.BodyName%2A>, <xref:System.Text.Encoding.HeaderName%2A>, e <xref:System.Text.Encoding.WebName%2A> propriedades, que geram o nome "unicodeFFFE". Embora a marca de ordem de byte big endian UTF-16 é FEFF hexadecimal, o nome "unicodeFFFE" foi escolhido porque a marca de ordem de byte é exibido como FFFE hexadecimal little endian em computadores com Windows.  
  
   
  
## Examples  
 O exemplo a seguir lê um arquivo de texto com uma codificação UTF-16 usando a ordem de byte big endian.  
  
 [!code-cpp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CPP/bigendianunicode.cpp#1)]
 [!code-csharp[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/CS/bigendianunicode.cs#1)]
 [!code-vb[System.Text.Encoding.BigEndianUnicode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.BigEndianUnicode/VB/bigendianunicode.vb#1)]  
  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BodyName">
      <MemberSignature Language="C#" Value="public virtual string BodyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BodyName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.BodyName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um nome para a codificação atual que pode ser usado com marcas de corpo do agente de email.</summary>
        <value>Um nome para o <see cref="T:System.Text.Encoding" /> atual que pode ser usado com marcas de corpo do agente de email.  
  
 -ou-  
  
 Uma cadeia de caracteres vazia ("") se o <see cref="T:System.Text.Encoding" /> atual não puder ser usado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar de uma codificação para um nome de corpo, você deve chamar <xref:System.Text.Encoding.GetEncoding%2A> com o <xref:System.Text.Encoding.BodyName%2A> propriedade. Geralmente, o método recupera uma codificação diferente da codificação de teste fornecido na chamada. Em geral somente aplicativos de email é necessário recuperar esses uma codificação; a maioria dos outros aplicativos que precisam para descrever uma codificação deve usar seus <xref:System.Text.Encoding.WebName%2A>.  
  
 Em alguns casos, o valor de <xref:System.Text.Encoding.BodyName%2A> propriedade corresponde ao padrão internacional que define a codificação. Isso não significa que a implementação está em conformidade por completo com esse padrão.  
  
   
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se compara em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, cria uma cópia superficial do atual <see cref="T:System.Text.Encoding" /> objeto.</summary>
        <returns>Uma cópia do atual <see cref="T:System.Text.Encoding" /> objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O clone é gravável mesmo que o original <xref:System.Text.Encoding> objeto é somente leitura. Portanto, as propriedades do clone podem ser modificadas.  
  
 Uma cópia superficial de um objeto é uma cópia do objeto somente. Se o objeto contiver referências a outros objetos, a cópia superficial não cria cópias dos objetos referenciados. Ela se refere aos objetos originais em vez disso. Em contraste, uma cópia em profundidade de um objeto cria uma cópia do objeto e uma cópia de tudo direta ou indiretamente referenciado por esse objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodePage">
      <MemberSignature Language="C#" Value="public virtual int CodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.CodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o identificador de página de código do <see cref="T:System.Text.Encoding" /> atual.</summary>
        <value>O identificador de página de código do <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se compara em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">O formato de codificação de <c>bytes</c>.</param>
        <param name="dstEncoding">O formato de codificação de destino.</param>
        <param name="bytes">Os bytes a serem convertidos.</param>
        <summary>Converte uma matriz de bytes inteira de uma codificação para outra.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Byte" /> que contém os resultados da conversão <paramref name="bytes" /> de <paramref name="srcEncoding" /> para <paramref name="dstEncoding" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres Unicode codificados em uma cadeia de caracteres codificados ASCII. Porque o objeto de codificação ASCII retornado pelo <xref:System.Text.Encoding.ASCII%2A> propriedade usa fallback de substituição e o caractere de Pi não faz parte do conjunto de caracteres ASCII, o caractere de Pi é substituído com um ponto de interrogação, como a saída mostra o exemplo.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="dstEncoding" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Convert">
      <MemberSignature Language="C#" Value="public static byte[] Convert (System.Text.Encoding srcEncoding, System.Text.Encoding dstEncoding, byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8[] Convert(class System.Text.Encoding srcEncoding, class System.Text.Encoding dstEncoding, unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="srcEncoding" Type="System.Text.Encoding" />
        <Parameter Name="dstEncoding" Type="System.Text.Encoding" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="srcEncoding">A codificação da matriz de origem, <c>bytes</c>.</param>
        <param name="dstEncoding">A codificação da matriz de saída.</param>
        <param name="bytes">A matriz de bytes a ser convertida.</param>
        <param name="index">O índice do primeiro elemento da <c>bytes</c> para converter.</param>
        <param name="count">O número de bytes a serem convertidos.</param>
        <summary>Converte um intervalo de bytes em uma matriz de bytes de uma codificação para outra.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Byte" /> que contém o resultado da conversão de um intervalo de bytes em <paramref name="bytes" /> de <paramref name="srcEncoding" /> para <paramref name="dstEncoding" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="srcEncoding" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="dstEncoding" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> e <paramref name="count" /> não especificam um intervalo válido na matriz de bytes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 **srcEncoding.** <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 **dstEncoding.** <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DecoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.DecoderFallback DecoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.DecoderFallback DecoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.DecoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.DecoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Text.DecoderFallback" /> para o objeto <see cref="T:System.Text.Encoding" /> atual.</summary>
        <value>O objeto de fallback do decodificador para o objeto <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.DecoderFallback> objeto representa um manipulador de erro que é invocado quando não é possível decodificar uma sequência de bytes codificados em um caractere. Há suporte para qualquer um dos seguintes tipos de manipulador:  
  
-   Um melhor ajuste manipulador de fallback, que substitui os bytes que não podem ser decodificadas com algum caractere substituto adequado.  
  
-   Um manipulador de fallback de substituição, que substitui os bytes que não podem ser decodificadas com alguns caracteres de substituição arbitrário. O .NET Framework inclui um manipulador de fallback de substituição, <xref:System.Text.DecoderFallback>, que por padrão substitui bytes não podem ser decodificadas com um ponto de interrogação ("?") caracteres.  
  
-   Um manipulador de fallback de exceção, que gera uma exceção quando não não possível decodificar bytes. O .NET Framework inclui um manipulador de fallback de exceção, <xref:System.Text.DecoderExceptionFallback>, que gera um <xref:System.Text.DecoderFallbackException> quando bytes não podem ser decodificados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor em uma operação de definição é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não é possível atribuir um valor em uma operação de conjunto porque o objeto <see cref="T:System.Text.Encoding" /> atual é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Default" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a codificação padrão para esta implementação do .NET.</summary>
        <value>A codificação padrão para essa implementação do .NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Computadores diferentes podem usar diferentes codificações como o padrão, e a codificação padrão pode ser alterados em um único computador. Se você usar o <xref:System.Text.Encoding.Default%2A> codificação para codificar e decodificar dados transmitidos entre computadores ou recuperados em momentos diferentes no mesmo computador, ele pode converter dados incorretamente. Além disso, a codificação retornado pelo <xref:System.Text.Encoding.Default%2A> propriedade usa fallback melhor ajuste para mapear caracteres sem suporte para caracteres suportados pela página de código. Por esses motivos, não é recomendável usar a codificação padrão. Para garantir que os bytes codificados são decodificar corretamente, você deve usar uma codificação Unicode, como <xref:System.Text.UTF8Encoding> ou <xref:System.Text.UnicodeEncoding>. Você também pode usar um protocolo de alto nível para garantir que o mesmo formato é usado para codificar e decodificar.  

### <a name="the-default-property-in-the-net-framework"></a>A propriedade padrão do .NET Framework

No .NET Framework da área de trabalho do Windows, o <xref:System.Text.Encoding.Default%2A> propriedade sempre obtém a página de código ativo do sistema e cria um <xref:System.Text.Encoding> objeto correspondente a ele. A página de código ativa pode ser uma página de código ANSI, que inclui um conjunto junto com os caracteres adicionais que variam por página de código de caracteres ASCII. Como todos os <xref:System.Text.Encoding.Default%2A> codificações com base nas páginas de código ANSI perda de dados, considere usar o <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> codificação em vez disso. UTF-8 é geralmente idêntico no U + 00 ao intervalo de U + 7F, mas pode codificar caracteres fora do intervalo ASCII sem perda.

## <a name="the-default-property-on-net-core"></a>A propriedade padrão no .NET Core

No núcleo do .NET, o <xref:System.Text.Encoding.Default%2A> propriedade sempre retorna o <xref:System.Text.UTF8Encoding>. UTF-8 tem suporte em todos os sistemas operacionais (Windows, Linux e Max OS X) sobre quais aplicativos .NET Core executar.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EncoderFallback">
      <MemberSignature Language="C#" Value="public System.Text.EncoderFallback EncoderFallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.EncoderFallback EncoderFallback" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncoderFallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.EncoderFallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Text.EncoderFallback" /> para o objeto <see cref="T:System.Text.Encoding" /> atual.</summary>
        <value>O objeto de fallback do codificador para o objeto <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.EncoderFallback> objeto representa um manipulador de erro que é invocado quando um caractere não pode ser convertido em uma sequência de bytes codificados. Há suporte para qualquer um dos seguintes tipos de manipulador:  
  
-   Um melhor ajuste manipulador de fallback, que substitui os caracteres que não podem ser codificados com algum caractere substituto adequado.  
  
-   Um manipulador de fallback de substituição, que substitui os caracteres que não podem ser codificados com alguns caracteres de substituição arbitrário. O .NET Framework inclui um manipulador de fallback de substituição, <xref:System.Text.EncoderFallback>, que por padrão substitui caracteres que não podem ser codificados com um ponto de interrogação ("?") caracteres.  
  
-   Um manipulador de fallback de exceção, que gera uma exceção quando caracteres não podem ser codificados. O .NET Framework inclui um manipulador de fallback de exceção, <xref:System.Text.EncoderExceptionFallback>, que gera um <xref:System.Text.EncoderFallbackException> quando caracteres não podem ser decodificados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor em uma operação de definição é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Não é possível atribuir um valor em uma operação de conjunto porque o objeto <see cref="T:System.Text.Encoding" /> atual é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="EncodingName">
      <MemberSignature Language="C#" Value="public virtual string EncodingName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EncodingName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.EncodingName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém a descrição legível por humanos da codificação atual.</summary>
        <value>A descrição legível por humanos do <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.EncodingName%2A> propriedade destina-se a exibição. Para localizar um nome que pode ser passado para o <xref:System.Text.Encoding.GetEncoding%2A> método, use o <xref:System.Text.Encoding.WebName%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se compara em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O <see cref="T:System.Object" /> para comparar com a instância atual.</param>
        <summary>Determina se o especificado <see cref="T:System.Object" /> é igual à instância atual.</summary>
        <returns>
          <see langword="true" />Se <paramref name="value" /> é uma instância de <see cref="T:System.Text.Encoding" /> e é igual à instância atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Duas instâncias do <xref:System.Text.Encoding> são considerados iguais se eles correspondem à mesma página de código e seus `EncoderFallback` e `DecoderFallback` objetos são iguais. Em particular, páginas de código derivada todos têm uma página de código de 0 e suas sequências são normalmente `null` (`Nothing` no Visual Basic .NET). Assim, eles são todos considerados iguais um ao outro. Uma consequência é que quando <xref:System.Text.Encoding.Equals%2A> é usado para popular uma tabela de hash, todas as derivadas codificações de comparação igual e entram no mesmo slot de tabela de hash.  
  
   
  
## Examples  
 O exemplo a seguir obtém duas instâncias da mesma codificação (uma por página de código) e outra pelo nome e verifica sua igualdade.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém os caracteres a serem codificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de todos os caracteres na matriz de caracteres especificada.</summary>
        <returns>O número de bytes produzidos por codificação de todos os caracteres na matriz de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, chame o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar as versões de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, você deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos pela codificação de caracteres na cadeia de caracteres especificada.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, chame o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo lida com entradas de cadeia de caracteres, a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> é recomendado.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public virtual int GetByteCount (char* chars, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char* chars, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Um ponteiro para o primeiro caractere a ser codificado.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos por codificação de um conjunto de caracteres a partir do ponteiro de caractere especificado.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetBytes%2A> requer para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%28System.Char%2A%2CSystem.Int32%29> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações para usar estes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%2A> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetByteCount (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetByteCount(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="index">O índice do primeiro caractere a codificação.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de bytes produzidos por codificação de um conjunto de caracteres da matriz de caractere especificado.</summary>
        <returns>O número de bytes produzidos por codificação de caracteres especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, chame o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado.  
  
-   Se seu aplicativo lida com entradas de cadeia de caracteres, a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> é recomendado.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém os caracteres a serem codificados.</param>
        <summary>Quando substituído em uma classe derivada, codifica todos os caracteres na matriz de caracteres especificada em uma sequência de bytes.</summary>
        <returns>Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding>não será possível manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve chamar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A> método.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres que contém os caracteres a serem codificados.</param>
        <summary>Quando substituído em uma classe derivada, codifica todos os caracteres na cadeia de caracteres especificada em uma sequência de bytes.</summary>
        <returns>Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding>não será possível manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual byte[] GetBytes (char[] chars, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetBytes(char[] chars, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="index">O índice do primeiro caractere a codificação.</param>
        <param name="count">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres na matriz de caracteres especificada em uma sequência de bytes.</summary>
        <returns>Uma matriz de bytes que contém os resultados de codificação do conjunto de caracteres especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding>não será possível manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="chars" />.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public byte[] GetBytes (string s, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetBytes(string s, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="index">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char* chars, int32 charCount, unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">Um ponteiro para o primeiro caractere a ser codificado.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">Um ponteiro para o local no qual começar a escrever a sequência resultante de bytes.</param>
        <param name="byteCount">O número máximo de bytes a serem gravados.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres começando no ponteiro de caractere especificado em uma sequência de bytes armazenados do ponteiro de bytes especificado.</summary>
        <returns>O número real de bytes gravados no local indicado pelo parâmetro <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetBytes%2A> requer para armazenar os bytes resultantes, chame o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> objeto fornecido pelo <xref:System.Text.Encoding.GetDecoder%2A> ou <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding>não será possível manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> ou <paramref name="byteCount" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="byteCount" /> é menor que o número de bytes resultante.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public abstract int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(char[] chars, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="chars">A matriz de caracteres que contém o conjunto de caracteres a serem codificados.</param>
        <param name="charIndex">O índice do primeiro caractere a codificação.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">A matriz de bytes para conter a sequência resultante de bytes.</param>
        <param name="byteIndex">O índice no qual será iniciada a gravação da sequência de bytes resultante.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres da matriz de caracteres especificada em uma matriz de bytes especificada.</summary>
        <returns>O número real de bytes gravados no <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding>não será possível manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar três caracteres de uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CPP/getbytes_chararric.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/CS/getbytes_chararric.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArrIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArrIC/VB/getbytes_chararric.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="chars" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.  
  
 -ou-  
  
 <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBytes">
      <MemberSignature Language="C#" Value="public virtual int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetBytes(string s, int32 charIndex, int32 charCount, unsigned int8[] bytes, int32 byteIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="charIndex" Type="System.Int32" />
        <Parameter Name="charCount" Type="System.Int32" />
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="s">A cadeia de caracteres que contém o conjunto de caracteres a ser codificado.</param>
        <param name="charIndex">O índice do primeiro caractere a codificação.</param>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <param name="bytes">A matriz de bytes para conter a sequência resultante de bytes.</param>
        <param name="byteIndex">O índice no qual será iniciada a gravação da sequência de bytes resultante.</param>
        <summary>Quando substituído em uma classe derivada, codifica um conjunto de caracteres da cadeia de caracteres especificada em uma matriz de bytes especificada.</summary>
        <returns>O número real de bytes gravados no <paramref name="bytes" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve chamar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, chame o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 O <xref:System.Text.Encoding.GetByteCount%2A> método determina o número de bytes resulta em codificação de um conjunto de caracteres Unicode e o <xref:System.Text.Encoding.GetBytes%2A> método executa a codificação real. O <xref:System.Text.Encoding.GetBytes%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método, que trata de várias conversões em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetByteCount%2A> e <xref:System.Text.Encoding.GetBytes%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo precisará codificar muitos caracteres de entrada para uma página de código e processar os caracteres usando várias chamadas. Nesse caso, você provavelmente precisa manter o estado entre as chamadas, levando em conta o estado que é mantido pelo <xref:System.Text.Encoder> do objeto que está sendo usado. (Por exemplo, uma sequência de caracteres que contém pares substitutos pode terminar com um substituto alto. O <xref:System.Text.Encoder> lembrará que substituto alto para que ela pode ser combinada com um substituto baixo no início de uma chamada a seguir. <xref:System.Text.Encoding>não será possível manter o estado, portanto, o caractere será enviado para o <xref:System.Text.EncoderFallback>.)  
  
-   Se seu aplicativo manipula entradas de cadeia de caracteres, você deve usar a versão de cadeia de caracteres do <xref:System.Text.Encoding.GetBytes%2A>.  
  
-   A versão de buffer de caractere Unicode de <xref:System.Text.Encoding.GetBytes%28System.Char%2A%2CSystem.Int32%2CSystem.Byte%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas usando o <xref:System.Text.Encoder> objeto ou inserindo buffers existentes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o <xref:System.Text.Encoding.GetBytes%2A> versão que ofereça suporte a matrizes de bytes é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetByteCount%2A>. O método de conversão converte o máximo possível de dados e lança uma exceção se o buffer de saída é muito pequeno. Para codificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma cadeia de caracteres ou um intervalo na cadeia de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/CS/getbytes_string.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_String/VB/getbytes_string.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charIndex" />, <paramref name="charCount" /> ou <paramref name="byteIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="charIndex" /> e <paramref name="charCount" /> não denotam um intervalo válido em <paramref name="chars" />.  
  
 -ou-  
  
 <paramref name="byteIndex" /> não é um índice válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.ArgumentException">
          O <paramref name="bytes" /> não tem capacidade suficiente do <paramref name="byteIndex" /> ao final da matriz para acomodar os bytes resultantes.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de caracteres produzida pela decodificação de todos os bytes na matriz de bytes especificado.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> para armazenar os caracteres resultantes, você deve usar o <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método. Para calcular o tamanho máximo de matriz, você deve usar o <xref:System.Text.Encoding.GetMaxCharCount%28System.Int32%29> método. O <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetCharCount%28System.Byte%5B%5D%29> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%29> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que trata de várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre as chamadas.  
  
-   Se seu aplicativo manipula saídas de cadeia de caracteres, você deve usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <xref:System.String> tipo é preferível.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a buffers de caracteres de saída é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public virtual int GetCharCount (byte* bytes, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8* bytes, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro do primeiro byte a ser decodificado.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de caracteres produzido pelo decodificar uma sequência de bytes a partir do ponteiro de bytes especificado.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetChars%2A> requer para armazenar os caracteres resultantes, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que trata de várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre as chamadas.  
  
-   Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <xref:System.String> tipo é preferível.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a buffers de caracteres de saída é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="count" /> é menor que zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetCharCount (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetCharCount(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte para decodificar.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número de caracteres produzidos pela decodificação de uma sequência de bytes da matriz de bytes especificada.</summary>
        <returns>O número de caracteres produzido pela decodificação da sequência de bytes especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetChars%2A> para armazenar os caracteres resultantes, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A> método espera conversões discretas, em comparação com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que trata de várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre as chamadas.  
  
-   Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <xref:System.String> tipo é preferível.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a buffers de caracteres de saída é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <summary>Quando substituído em uma classe derivada, decodifica todos os bytes na matriz de bytes especificada em um conjunto de caracteres.</summary>
        <returns>Uma matriz de caracteres que contém os resultados de decodificação de sequência especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Obtém os caracteres de uma sequência de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretos, enquanto <xref:System.Text.Decoder> destina-se a várias passagens em um único fluxo de entrada.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que trata de várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um <xref:System.Text.Encoding.GetChars%2A> chamar e continuar no início do próximo <xref:System.Text.Encoding.GetChars%2A> chamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>chamará o fallback para as sequências incompletas, mas <xref:System.Text.Decoder> lembrará as sequências para a próxima chamada.)  
  
-   Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <xref:System.String> tipo é preferível.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a buffers de caracteres de saída é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual char[] GetChars (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance char[] GetChars(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte para decodificar.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada em um conjunto de caracteres.</summary>
        <returns>Uma matriz de caracteres que contém os resultados de decodificação de sequência especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Obtém os caracteres de uma sequência de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretos, enquanto <xref:System.Text.Decoder> destina-se a várias passagens em um único fluxo de entrada.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que trata de várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um <xref:System.Text.Encoding.GetChars%2A> chamar e continuar no início do próximo <xref:System.Text.Encoding.GetChars%2A> chamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>chamará o fallback para as sequências incompletas, mas <xref:System.Text.Decoder> lembrará as sequências para a próxima chamada.)  
  
-   Se seu aplicativo manipula saídas de cadeia de caracteres, é recomendável usar o <xref:System.Text.Encoding.GetString%2A> método. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <xref:System.String> tipo é preferível.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a buffers de caracteres de saída é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public virtual int GetChars (byte* bytes, int byteCount, char* chars, int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8* bytes, int32 byteCount, char* chars, int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char*" />
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro do primeiro byte a ser decodificado.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <param name="chars">Um ponteiro para o local no qual começar a escrever resultante conjunto de caracteres.</param>
        <param name="charCount">O número máximo de caracteres a serem gravados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes a partir do ponteiro de bytes especificada em um conjunto de caracteres que são armazenados iniciando o ponteiro de caractere especificado.</summary>
        <returns>O número real de caracteres gravados no local indicado pelo <paramref name="chars" /> parâmetro.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular a matriz exata tamanho que <xref:System.Text.Encoding.GetChars%2A> requer para armazenar os caracteres resultantes, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>Obtém os caracteres de uma sequência de bytes de entrada. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretos, enquanto <xref:System.Text.Decoder> destina-se a várias passagens em um único fluxo de entrada.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> objeto fornecido pelo <xref:System.Text.Encoding.GetDecoder%2A> ou <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que trata de várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um <xref:System.Text.Encoding.GetChars%2A> chamar e continuar no início do próximo <xref:System.Text.Encoding.GetChars%2A> chamar. <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType>chamará o fallback para as sequências incompletas, mas <xref:System.Text.Decoder> lembrará as sequências para a próxima chamada.)  
  
-   Se seu aplicativo lida com saídas de cadeia de caracteres, o <xref:System.Text.Encoding.GetString%2A> método é recomendado. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <xref:System.String> tipo é preferível.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a buffers de caracteres de saída é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> ou <paramref name="charCount" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="charCount" />é menor que o número de caracteres resultante.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetChars">
      <MemberSignature Language="C#" Value="public abstract int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetChars(unsigned int8[] bytes, int32 byteIndex, int32 byteCount, char[] chars, int32 charIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="byteIndex" Type="System.Int32" />
        <Parameter Name="byteCount" Type="System.Int32" />
        <Parameter Name="chars" Type="System.Char[]" />
        <Parameter Name="charIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="byteIndex">O índice do primeiro byte para decodificar.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <param name="chars">A matriz de caracteres para conter o conjunto de caracteres resultante.</param>
        <param name="charIndex">O índice no qual será iniciada a gravação do conjunto de caracteres resultante.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada na matriz de caracteres especificada.</summary>
        <returns>O número real de caracteres gravados em <paramref name="chars" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetChars%2A> para armazenar os caracteres resultantes, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > obtém caracteres de uma sequência de bytes de entrada. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > é diferente de <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> porque <xref:System.Text.Encoding> espera conversões discretos, enquanto <xref:System.Text.Decoder> foi projetado para várias passagens em um único fluxo de entrada.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 **Observação** esse método foi projetado para operar em caracteres Unicode, não em dados binários arbitrários, como matrizes de bytes. Se você precisa codificar dados binários arbitrários em texto, você deve usar um protocolo como uuencode, que é implementado pelos métodos como <xref:System.Convert.ToBase64CharArray%2A?displayProperty=nameWithType>.  
  
 O <xref:System.Text.Encoding.GetCharCount%2A> método determina quantos caracteres resultar em decodificar uma sequência de bytes e o <xref:System.Text.Encoding.GetChars%2A> método executa a decodificação real. O <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> método espera conversões discretas, em comparação com o <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método, que trata de várias passagens em um único fluxo de entrada.  
  
 Várias versões do <xref:System.Text.Encoding.GetCharCount%2A> e <xref:System.Text.Encoding.GetChars%2A> têm suporte. A seguir está algumas considerações de programação para uso dos seguintes métodos:  
  
-   Seu aplicativo talvez seja necessário decodificar vários bytes de entrada de uma página de código e processar os bytes usando várias chamadas. Nesse caso, você provavelmente precisará manter o estado entre as chamadas, como sequências de bytes podem ser interrompidas durante processamento em lotes. (Por exemplo, a parte de uma sequência de shift ISO-2022 pode terminar um [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > chamar e continuar no início do próximo [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A > chamar. [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType > chamará o fallback para as sequências incompletas, mas <xref:System.Text.Decoder> lembrará as sequências para a próxima chamada.)  
  
-   Se seu aplicativo lida com saídas de cadeia de caracteres, o <xref:System.Text.Encoding.GetString%2A> método é recomendado. Como esse método deve verificar o comprimento da cadeia de caracteres e alocar um buffer, é um pouco mais lenta, mas resultante <xref:System.String> tipo é preferível.  
  
-   A versão de byte do <xref:System.Text.Encoding.GetChars%28System.Byte%2A%2CSystem.Int32%2CSystem.Char%2A%2CSystem.Int32%29> permite que algumas técnicas rápidas, especialmente com várias chamadas para buffers grandes. Tenha em mente, no entanto, que esta versão do método, às vezes, é seguro, como ponteiros são necessários.  
  
-   Se seu aplicativo deve converter uma grande quantidade de dados, ele deve reutilizar o buffer de saída. Nesse caso, o [\], Int32, Int32, Char\<xref:System.Text.Encoding.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29 > versão que dá suporte a buffers de caracteres de saída é a melhor opção.  
  
-   Considere o uso de <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método em vez de <xref:System.Text.Encoding.GetCharCount%2A>. O método de conversão converte o máximo possível de dados e gera uma exceção se o buffer de saída é muito pequeno. Para decodificação contínua de um fluxo, esse método é geralmente a melhor opção.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres de uma codificação para outra.  
  
 [!code-cpp[System.Text.Encoding.Convert Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CPP/convert.cpp#1)]
 [!code-csharp[System.Text.Encoding.Convert Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/CS/convert.cs#1)]
 [!code-vb[System.Text.Encoding.Convert Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Convert Example/VB/convert.vb#1)]  
  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica um intervalo de bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CPP/getcharsic.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/CS/getcharsic.cs#1)]
 [!code-vb[System.Text.Encoding.GetCharsIC#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetCharsIC/VB/getcharsic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="chars" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteIndex" />, <paramref name="byteCount" /> ou <paramref name="charIndex" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="byteindex" /> e <paramref name="byteCount" /> não denotam um intervalo válido em <paramref name="bytes" />.  
  
 -ou-  
  
 <paramref name="charIndex" /> não é um índice válido em <paramref name="chars" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="chars" /> não tem capacidade suficiente do <paramref name="charIndex" /> até o final da matriz para acomodar os caracteres resultantes.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetDecoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Decoder GetDecoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Decoder GetDecoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetDecoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Decoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um decodificador que converte uma sequência de bytes codificada em uma sequência de caracteres.</summary>
        <returns>Um <see cref="T:System.Text.Decoder" /> que converte uma sequência de bytes codificada em uma sequência de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Decoder.GetChars%2A?displayProperty=nameWithType> método converte blocos sequenciais de bytes em blocos sequenciais de caracteres, de maneira semelhante para o <xref:System.Text.Encoding.GetChars%2A> método dessa classe. No entanto, um <xref:System.Text.Decoder> mantém informações de estado entre as chamadas para ele decodifica corretamente sequências de bytes que abrangem os blocos. O <xref:System.Text.Decoder> também preserva bytes à direita do final de blocos de dados e usa os bytes à direita na próxima operação de decodificação. Portanto, <xref:System.Text.Encoding.GetDecoder%2A> e <xref:System.Text.Encoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>A implementação padrão retorna um <see cref="T:System.Text.Decoder" /> que chama o <see cref="M:System.Text.Encoding.GetCharCount(System.Byte[])" /> e <see cref="M:System.Text.Encoding.GetChars(System.Byte[])" /> métodos do atual <see cref="T:System.Text.Encoding" />. Você deve substituir este método para retornar um <see cref="T:System.Text.Decoder" /> que mantém seu estado entre as chamadas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetEncoder">
      <MemberSignature Language="C#" Value="public virtual System.Text.Encoder GetEncoder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Text.Encoder GetEncoder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoder</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um codificador que converte uma sequência de caracteres Unicode em uma sequência codificada de bytes.</summary>
        <returns>Um <see cref="T:System.Text.Encoder" /> que converte uma sequência de caracteres Unicode em uma sequência codificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoder.GetBytes%2A?displayProperty=nameWithType> método converte blocos sequenciais de caracteres em blocos sequenciais de bytes, de maneira semelhante para o <xref:System.Text.Encoding.GetBytes%2A> método dessa classe. No entanto, um <xref:System.Text.Encoder> mantém informações de estado entre as chamadas para ele codifica corretamente sequências de caracteres que abrangem os blocos. O <xref:System.Text.Encoder> também preserva à direita caracteres do final de blocos de dados e usa os caracteres à direita na próxima operação de codificação. Por exemplo, um bloco de dados pode terminar com um substituto alto sem correspondência e o correspondência substituto baixo seria o próximo bloco de dados. Portanto, <xref:System.Text.Encoding.GetDecoder%2A> e <xref:System.Text.Encoding.GetEncoder%2A> são úteis para transmissão de rede e operações de arquivo, porque essas operações geralmente lidam com blocos de dados em vez de um fluxo de dados completo.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>A implementação padrão retorna um <see cref="T:System.Text.Encoder" /> que chama o <see cref="M:System.Text.Encoding.GetByteCount(System.Char[])" /> e <see cref="M:System.Text.Encoding.GetBytes(System.Char[])" /> métodos do atual <see cref="T:System.Text.Encoding" />. Você deve substituir este método para retornar um <see cref="T:System.Text.Encoder" /> que mantém seu estado entre as chamadas.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="codepage">O identificador de página de código da codificação preferencial. Os valores possíveis são listados na coluna da tabela que aparece na página de código a <see cref="T:System.Text.Encoding" /> tópico sobre a classe.  
  
 -ou-  
  
 0 (zero), para usar a codificação padrão.</param>
        <summary>Retorna a codificação associada ao identificador de página de código especificado.</summary>
        <returns>A codificação é associada à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O manipulador de fallback depende do tipo de codificação de `codepage`. Se `codepage` for configurado com um caractere de byte duplo ou página de código (DBCS) de codificação, um manipulador de fallback de melhor ajuste é usado. Caso contrário, um manipulador de fallback de substituição será usado. Esses manipuladores de retorno não podem ser apropriados para seu aplicativo. Para especificar o manipulador de fallback usado pela codificação especificada pelo `codepage`, você pode chamar o <xref:System.Text.Encoding.GetEncoding%28System.Int32%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> sobrecarga.  
  
 O <xref:System.Text.Encoding.GetEncoding%2A> método depende da plataforma subjacente para dar suporte a maioria das páginas de código. No entanto, o .NET Framework suporta nativamente algumas codificações. Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico sobre a classe. Como alternativa, você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma matriz de <xref:System.Text.EncodingInfo> objetos que contém informações sobre todas as codificações.  
  
 Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <xref:System.Text.EncodingProvider> objeto. Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado.  

Você também pode fornecer um valor de 0 para o `codepage` argumento. Seu comportamento preciso depende se qualquer codificações foram disponibilizadas Registrando um <xref:System.Text.EncodingProvider> objeto:

- Se um ou mais provedores de codificação for registrados, ele retorna a codificação do último provedor registrado que escolheu para retornar uma codificação quando a <xref:System.Text.Encoding.GetEncoding%2A> método é passado um `codepage` argumento de 0.     

- No .NET Framework, se nenhuma codificação provedor tiver sido registrado, se o <xref:System.Text.CodePagesEncodingProvider> é o provedor de codificação registrado, ou se nenhum provedor de codificação registrado manipula um `codepage` valor de 0, ele retorna a página de código ativo do sistema operacional. Para determinar a página de código ativo em sistemas Windows, chame o Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) função do .NET Framework da área de trabalho do Windows.

- No núcleo do .NET, se nenhum provedor de codificação tiver sido registrado ou se nenhum provedor de codificação registrado manipula um `codepage` valor de 0, ele retorna o <xref:System.Text.UTF8Encoding>.
  
> [!NOTE]
>  Um código sem suporte páginas causa uma <xref:System.ArgumentException> seja gerada, enquanto outros causam um <xref:System.NotSupportedException>. Portanto, seu código deve capturar todas as exceções indicadas na seção de exceções.  
  
> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em computadores diferentes e podem ser alterados em um único computador, levando a corrupção de dados. Por esse motivo, se a página de código ativo é uma página de código ANSI, codificar e decodificar dados usando a página de código padrão retornado por `Encoding.GetEncoding(0)` não é recomendado. Para obter os resultados mais consistentes, você deve usar uma codificação Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, a <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você habilitar a detecção de erro.  

   
  
## Examples  
 O exemplo a seguir obtém duas instâncias da mesma codificação (uma página de código) e outra pelo nome e verifica sua igualdade.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" />é menor que zero ou maior que 65535.</exception>
        <exception cref="T:System.ArgumentException">
          Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
        <exception cref="T:System.NotSupportedException">
          Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O identificador da página de código da codificação preferencial. Qualquer valor retornado pelo <see cref="P:System.Text.Encoding.WebName" /> propriedade é válida. Os valores possíveis são listados na coluna Nome da tabela que aparece no <see cref="T:System.Text.Encoding" /> tópico sobre a classe.</param>
        <summary>Retorna a codificação associada ao nome da página de código especificada.</summary>
        <returns>A codificação associado à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O manipulador de fallback depende do tipo de codificação de `name`. Se `name` for configurado com um caractere de byte duplo ou página de código (DBCS) de codificação, um manipulador de fallback de melhor ajuste é usado. Caso contrário, um manipulador de fallback de substituição será usado. Esses manipuladores de retorno não podem ser apropriados para seu aplicativo. Para especificar o manipulador de fallback usado pela codificação especificada pelo `name`, você pode chamar o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29> sobrecarga.  
  
 O <xref:System.Text.Encoding.GetEncoding%2A> método depende da plataforma subjacente para dar suporte a maioria das páginas de código. No entanto, o .NET Framework suporta nativamente algumas codificações. Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico sobre a classe. Como alternativa, você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método para obter uma matriz de <xref:System.Text.EncodingInfo> objetos que contém informações sobre todas as codificações. 
  
 Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <xref:System.Text.EncodingProvider> objeto. Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado.  
   
> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em computadores diferentes, ou podem ser alteradas para um único computador, levando a corrupção de dados. Para obter os resultados mais consistentes, você deve usar Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico.  
 
  
 <xref:System.Text.Encoding.GetEncoding%2A>Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, a <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você habilitar a detecção de erro.  
  
## Examples  
 O exemplo a seguir obtém duas instâncias da mesma codificação (uma página de código) e outra pelo nome e verifica sua igualdade.  
  
 [!code-cpp[System.Text.Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CPP/equals.cpp#1)]
 [!code-csharp[System.Text.Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Equals/CS/equals.cs#1)]
 [!code-vb[System.Text.Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />não é um nome de página de código válido.  
  
 -ou-  
  
 A página de código indicada por <paramref name="name" /> não tem suporte da plataforma subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (int codepage, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(int32 codepage, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="codepage" Type="System.Int32" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="codepage">O identificador de página de código da codificação preferencial. Os valores possíveis são listados na coluna da tabela que aparece na página de código a <see cref="T:System.Text.Encoding" /> tópico sobre a classe.  
  
 -ou-  
  
 0 (zero), para usar a codificação padrão.</param>
        <param name="encoderFallback">Um objeto que fornece um procedimento de tratamento de erros quando um caractere não pode ser codificado com a codificação atual.</param>
        <param name="decoderFallback">Um objeto que fornece um procedimento de tratamento de erros quando uma sequência de bytes não pode ser decodificada com a codificação atual.</param>
        <summary>Retorna a codificação associada ao identificador de página de código especificado. Os parâmetros especificam um manipulador de erro para caracteres que não podem ser codificados e sequências de bytes que não podem ser decodificadas.</summary>
        <returns>A codificação é associada à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Algumas páginas de código não há suporte para fazer com que a exceção <xref:System.ArgumentException> seja gerada, enquanto outros causam <xref:System.NotSupportedException>. Portanto, seu código deve capturar todas as exceções indicadas na seção de exceções.  
  
 O <xref:System.Text.Encoding.GetEncoding%2A> método depende da plataforma subjacente para dar suporte a maioria das páginas de código. No entanto, o .NET Framework suporta nativamente algumas codificações. Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico sobre a classe. Você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método no .NET Framework completo na área de trabalho do Windows para obter uma lista de todas as codificações.   
  
 Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <xref:System.Text.EncodingProvider> objeto.  Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado.  

Você também pode fornecer um valor de 0 para o `codepage` argumento. Seu comportamento preciso depende se qualquer codificações foram disponibilizadas Registrando um <xref:System.Text.EncodingProvider> objeto:

- Se um ou mais provedores de codificação for registrados, ele retorna a codificação do último provedor registrado que escolheu para retornar uma codificação quando a <xref:System.Text.Encoding.GetEncoding%2A> método é passado um `codepage` argumento de 0.     

- No .NET Framework, se nenhuma codificação provedor tiver sido registrado, se o <xref:System.Text.CodePagesEncodingProvider> é o provedor de codificação registrado, ou se nenhum provedor de codificação registrado manipula um `codepage` valor de 0, ele retorna a página de código ativo.

- No núcleo do .NET, se nenhum provedor de codificação tiver sido registrado ou se nenhum provedor de codificação registrado manipula um `codepage` valor de 0, ele retorna o <xref:System.Text.UTF8Encoding> codificação.

> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em computadores diferentes e podem ser alterados em um único computador, levando a corrupção de dados. Por esse motivo, se a página de código ativo é uma página de código ANSI, codificar e decodificar dados usando a página de código padrão retornado por `Encoding.GetEncoding(0)` não é recomendado. Para obter os resultados mais consistentes, você deve usar Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico. 
  
 Para obter a codificação associado à página de código ativo, ou você pode fornecer um valor de 0 para o `codepage` argumento ou, se seu código está em execução no .NET Framework completo na área de trabalho do Windows, recuperar o valor da <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType> propriedade. Para determinar a página de código ativa atual, chame o Windows [GetACP](http://msdn.microsoft.com/library/windows/desktop/dd318070.aspx) função do .NET Framework da área de trabalho do Windows.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, a <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você habilitar a detecção de erro.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="codepage" />é menor que zero ou maior que 65535.</exception>
        <exception cref="T:System.ArgumentException">
          Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
        <exception cref="T:System.NotSupportedException">
          Não há suporte para <paramref name="codepage" /> na plataforma subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding GetEncoding (string name, System.Text.EncoderFallback encoderFallback, System.Text.DecoderFallback decoderFallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.Encoding GetEncoding(string name, class System.Text.EncoderFallback encoderFallback, class System.Text.DecoderFallback decoderFallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="encoderFallback" Type="System.Text.EncoderFallback" />
        <Parameter Name="decoderFallback" Type="System.Text.DecoderFallback" />
      </Parameters>
      <Docs>
        <param name="name">O identificador da página de código da codificação preferencial. Qualquer valor retornado pelo <see cref="P:System.Text.Encoding.WebName" /> propriedade é válida. Os valores possíveis são listados na coluna Nome da tabela que aparece no <see cref="T:System.Text.Encoding" /> tópico sobre a classe.</param>
        <param name="encoderFallback">Um objeto que fornece um procedimento de tratamento de erros quando um caractere não pode ser codificado com a codificação atual.</param>
        <param name="decoderFallback">Um objeto que fornece um procedimento de tratamento de erros quando uma sequência de bytes não pode ser decodificada com a codificação atual.</param>
        <summary>Retorna a codificação associada ao nome da página de código especificada. Os parâmetros especificam um manipulador de erro para caracteres que não podem ser codificados e sequências de bytes que não podem ser decodificadas.</summary>
        <returns>A codificação é associada à página de código especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.GetEncoding%2A> método depende da plataforma subjacente para dar suporte a maioria das páginas de código. No entanto, o .NET Framework suporta nativamente algumas codificações.  
  
 Além de codificações intrinsecamente têm suporte em uma versão de plataforma específica do .NET Framework, o <xref:System.Text.Encoding.GetEncoding%2A> método retorna qualquer codificações adicionais que são disponibilizadas Registrando um <xref:System.Text.EncodingProvider> objeto. Se a mesma codificação tiver sido registrada por vários <xref:System.Text.EncodingProvider> objetos, esse método retorna o último deles registrado. 
  
> [!NOTE]
>  As páginas de código ANSI podem ser diferentes em computadores diferentes e podem ser alterados em um único computador, levando a corrupção de dados. Para obter os resultados mais consistentes, você deve usar uma codificação Unicode, como UTF-8 (página de código 65001) ou UTF-16, em vez de uma página de código específico.  
  
 Para obter uma lista de páginas de código, consulte o <xref:System.Text.Encoding> tópico sobre a classe. Você pode chamar o <xref:System.Text.Encoding.GetEncodings%2A> método no .NET Framework completo na área de trabalho do Windows para obter uma lista de todas as codificações.  
  
 <xref:System.Text.Encoding.GetEncoding%2A>Retorna uma instância armazenada em cache com as configurações padrão. Você deve usar os construtores de classes derivadas para obter uma instância com configurações diferentes. Por exemplo, a <xref:System.Text.UTF32Encoding> classe fornece um construtor que permite que você habilitar a detecção de erro.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Text.Encoding.GetEncoding%28System.String%2CSystem.Text.EncoderFallback%2CSystem.Text.DecoderFallback%29?displayProperty=nameWithType> método.  
  
 [!code-cpp[sys.txt.fallbackEncRpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cpp/fallEncRpl.cpp#1)]
 [!code-csharp[sys.txt.fallbackEncRpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/sys.txt.fallbackEncRpl/cs/fallEncRpl.cs#1)]
 [!code-vb[sys.txt.fallbackEncRpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/sys.txt.fallbackEncRpl/vb/fallEncRpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="name" />não é um nome de página de código válido.  
  
 -ou-  
  
 A página de código indicada por <paramref name="name" /> não tem suporte da plataforma subjacente.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEncodings">
      <MemberSignature Language="C#" Value="public static System.Text.EncodingInfo[] GetEncodings ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Text.EncodingInfo[] GetEncodings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetEncodings" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.EncodingInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma matriz que contém todas as codificações.</summary>
        <returns>Uma matriz que contém todas as codificações.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna uma lista de codificações com suporte, diferenciadas exclusivamente pela página de código. Para uma tabela que lista as codificações com suporte, consulte o <xref:System.Text.Encoding> tópico sobre a classe.  
  
> [!NOTE]
>  A lista de codificações com suporte retornadas pelo <xref:System.Text.Encoding.GetEncodings%2A> método não inclui qualquer codificações adicionais disponibilizadas por qualquer <xref:System.Text.EncodingProvider> implementações que foram registradas por chamadas para o <xref:System.Text.Encoding.RegisterProvider%2A> método.  
  
 Codificações 50220 e 50222 são ambos associado com o nome "iso-2022-jp", mas eles não são idênticos. Codificação 50220 converte caracteres Katakana de meia largura para caracteres Katakana de largura total, enquanto codificação 50222 usa uma sequência de shift-em/shift-out para codificar caracteres Katakana de meia largura. É o nome de exibição para codificação 50222 "japonês (JIS-Permitir 1 byte Kana - portanto / SI)" para diferenciá-lo da codificação 50220, que tem a exibição nome "japonês (JIS)".  
  
 Se você solicitar a codificação nome "iso-2022-jp", retorna o .NET Framework que codificação 50220. No entanto, a codificação é apropriado para seu aplicativo depende o tratamento preferencial dos caracteres Katakana de meia largura.  
  
 Para obter uma codificação específica, você deve usar o <xref:System.Text.Encoding.GetEncoding%2A> método.  
  
 <xref:System.Text.Encoding.GetEncodings%2A>às vezes, é usado para apresentar ao usuário uma lista de codificações em um arquivo **Salvar como** caixa de diálogo. No entanto, várias codificações de não Unicode são incompleta e traduzir o número de caracteres para "?", ou tem um comportamento um pouco diferente em diferentes plataformas. Considere o uso de UTF-8 ou UTF-16 como padrão.  
  
   
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para a instância atual.</summary>
        <returns>O código hash da instância atual.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMaxByteCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxByteCount (int charCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxByteCount(int32 charCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxByteCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="charCount">O número de caracteres a ser codificado.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número máximo de bytes produzidos pela codificação do número especificado de caracteres.</summary>
        <returns>O número máximo de bytes que produziu o número especificado de caracteres de codificação.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `charCount` parâmetro, na verdade, especifica o número de <xref:System.Char> objetos que representam os caracteres Unicode para codificar, como o .NET Framework usa internamente UTF-16 para representar caracteres Unicode. Consequentemente, a maioria dos caracteres Unicode pode ser representado por um <xref:System.Char> objeto, mas um caractere Unicode representado por um par substituto, por exemplo, são necessárias duas <xref:System.Char> objetos.  
  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetBytes%2A> para armazenar os bytes resultantes, você deve usar o <xref:System.Text.Encoding.GetByteCount%2A> método. Para calcular o tamanho máximo de matriz, use o <xref:System.Text.Encoding.GetMaxByteCount%2A> método. O <xref:System.Text.Encoding.GetByteCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxByteCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.Encoding.GetMaxByteCount%2A>recupera um número pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.EncoderFallback>. Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <xref:System.Text.Encoding.GetMaxByteCount%2A> recupera valores grandes, especialmente nos casos em que o pior caso de codificação envolve alternar os modos para cada caractere. Por exemplo, isso pode acontecer de ISO-2022-JP. Para obter mais informações, consulte a postagem do blog "[novidades com Encoding.GetMaxByteCount() e Encoding.GetMaxCharCount()?](http://go.microsoft.com/fwlink/?LinkId=153702)" (http://blogs.msdn.com/shawnste/archive/2005/03/02/383903.aspx).  
  
 Na maioria dos casos, esse método recupera valores razoáveis para pequenas cadeias de caracteres. Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura erros em casos raros, quando um buffer mais razoável é muito pequeno. Você também poderá considerar uma abordagem diferente usando <xref:System.Text.Encoding.GetByteCount%2A> ou <xref:System.Text.Encoder.Convert%2A?displayProperty=nameWithType>.  
  
 Ao usar <xref:System.Text.Encoding.GetMaxByteCount%2A>, você deve alocar o buffer de saída com base no tamanho máximo do buffer de entrada. Se o buffer de saída é restrito em tamanho, você pode usar o <xref:System.Text.Encoding.Convert%2A> método.  
  
 Observe que <xref:System.Text.Encoding.GetMaxByteCount%2A> considera possíveis substitutos restantes de uma operação de decodificador anterior. Por causa do decodificador, passando um valor de 1 para o método recupera 2 para uma codificação de byte único, como ASCII. Você deve usar o <xref:System.Text.ASCIIEncoding.IsSingleByte%2A> propriedade se essas informações são necessárias.  
  
> [!NOTE]
>  `GetMaxByteCount(N)`não é necessariamente o mesmo valor como `N* GetMaxByteCount(1)`.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="charCount" /> é menor que zero.</exception>
        <exception cref="T:System.Text.EncoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.EncoderFallback" /> é definido como <see cref="T:System.Text.EncoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Todos os <see cref="T:System.Text.Encoding" /> implementações devem garantir que nenhuma exceção de estouro de buffer ocorre se buffers são dimensionados de acordo com os resultados dos cálculos desse método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetMaxCharCount">
      <MemberSignature Language="C#" Value="public abstract int GetMaxCharCount (int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetMaxCharCount(int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetMaxCharCount(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, calcula o número máximo de caracteres produzido decodificando o número de bytes especificado.</summary>
        <returns>O número máximo de caracteres produzido decodificando o número de bytes especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para calcular o tamanho de matriz exato necessário por <xref:System.Text.Encoding.GetChars%2A> para armazenar os caracteres resultantes, você deve usar o <xref:System.Text.Encoding.GetCharCount%2A> método. Para calcular o tamanho máximo de matriz, use o <xref:System.Text.Encoding.GetMaxCharCount%2A> método. O <xref:System.Text.Encoding.GetCharCount%2A> método geralmente permite a alocação de memória inferior, enquanto o <xref:System.Text.Encoding.GetMaxCharCount%2A> método geralmente é executado mais rapidamente.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>recupera um número pior caso, incluindo o pior caso para selecionado no momento <xref:System.Text.DecoderFallback>. Se um fallback for escolhido com uma cadeia de caracteres possivelmente grande, <xref:System.Text.Encoding.GetMaxCharCount%2A> recupera valores grandes.  
  
 Na maioria dos casos, esse método recupera números razoáveis para cadeias de caracteres pequenas. Para grandes cadeias de caracteres, você terá que escolher entre usar buffers grandes e captura de erros no caso raro em que um buffer mais razoável é muito pequeno. Você também poderá considerar uma abordagem diferente usando <xref:System.Text.Encoding.GetCharCount%2A> ou <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType>.  
  
 <xref:System.Text.Encoding.GetMaxCharCount%2A>não tem nenhuma relação com <xref:System.Text.Encoding.GetBytes%2A>. Se você precisar de uma função semelhante para usar com <xref:System.Text.Encoding.GetBytes%2A>, você deve usar <xref:System.Text.Encoding.GetMaxByteCount%2A>.  
  
 Ao usar <xref:System.Text.Encoding.GetMaxCharCount%2A>, você deve alocar o buffer de saída com base no tamanho máximo do buffer de entrada. Se o buffer de saída é restrito em tamanho, você pode usar o <xref:System.Text.Decoder.Convert%2A?displayProperty=nameWithType> método.  
  
 Observe que <xref:System.Text.Encoding.GetMaxCharCount%2A> considera o pior caso para bytes restantes de uma operação anterior do codificador. Para a maioria das páginas de código, passando um valor de 0 a esse método recupera valores maiores que ou iguais a 1.  
  
> [!NOTE]
>  `GetMaxCharCount(N)`não é necessariamente o mesmo valor como `N* GetMaxCharCount(1)`.  
  
   
  
## Examples  
 O exemplo a seguir codifica uma cadeia de caracteres em uma matriz de bytes e, em seguida, decodifica os bytes em uma matriz de caracteres.  
  
 [!code-cpp[System.Text.Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CPP/getchars.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/CS/getchars.cs#1)]
 [!code-vb[System.Text.Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetChars/VB/getchars.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> é menor que zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
        <block subset="none" type="overrides">
          <para>Todos os <see cref="T:System.Text.Encoding" /> implementações devem garantir que nenhuma exceção de estouro de buffer ocorre se buffers são dimensionados de acordo com os resultados dos cálculos desse método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetPreamble">
      <MemberSignature Language="C#" Value="public virtual byte[] GetPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] GetPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetPreamble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, retorna uma sequência de bytes que especifica a codificação usada.</summary>
        <returns>Uma matriz de bytes que contém uma sequência de bytes que especifica a codificação usada.  
  
 -ou-  
  
 Uma matriz de bytes de tamanho zero, se um preâmbulo não for necessário.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Opcionalmente, o <xref:System.Text.Encoding> objeto fornece um preâmbulo que é uma matriz de bytes que pode ter como prefixo para a sequência de bytes resultante do processo de codificação. Se o preâmbulo contiver uma marca de ordem de byte (em Unicode, o ponto de código de U + FEFF), ele ajuda o decodificador de determinar a ordem de bytes e o formato de transformação ou UTF.  
  
 A marca de ordem de byte Unicode (BOM) é serializada da seguinte maneira (em hexadecimal):  
  
-   UTF-8: EF BB BF  
  
-   Ordem de byte do UTF-16 big endian: FF FE  
  
-   Ordem de byte endian UTF-16 little: FF FE  
  
-   Ordem de byte big endian da UTF-32: 00 00 FE FF  
  
-   Ordem de byte endian pouco UTF-32: FF FE 00 00  
  
 Você deve usar o BOM, porque fornece quase determinada identificação de uma codificação para arquivos que foram perdidos referência para o <xref:System.Text.Encoding> objeto, por exemplo, sem marcas ou marcada incorretamente os dados da web ou arquivos de texto aleatório armazenados quando uma empresa não tinha preocupações internacionais ou outros dados. Problemas de usuário geralmente podem ser evitados se dados são consistentemente e corretamente marcados, preferencialmente em UTF-8 ou UTF-16.  
  
 Para os padrões que fornecem um tipo de codificação, um BOM é um pouco redundante. No entanto, ele pode ser usado para ajudar a um servidor de enviar o cabeçalho de codificação correto. Como alternativa, ele pode ser usado como um fallback caso a codificação caso contrário, será perdida.  
  
 Há algumas desvantagens de usar um BOM. Por exemplo, saber como limitar os campos de banco de dados que usam um BOM pode ser difícil. Concatenação de arquivos pode ser um problema também, por exemplo, quando os arquivos são mesclados de tal forma que um caractere desnecessário pode terminar no meio de dados. Apesar de algumas desvantagens, no entanto, o uso de um BOM é altamente recomendável.  
  
 Para obter mais informações sobre a ordem de byte e a marca de ordem de byte, consulte o Unicode Standard no [home page do Unicode](http://go.microsoft.com/fwlink/?LinkId=37123).  
  
> [!CAUTION]
>  Para garantir que os bytes codificados são decodificar corretamente, você deve prefixar bytes codificados com um preâmbulo. No entanto, a maioria das codificações não fornecem um preâmbulo. Para garantir que os bytes codificados são decodificar corretamente, você deve usar uma codificação Unicode, ou seja, <xref:System.Text.UTF8Encoding>, <xref:System.Text.UnicodeEncoding>, ou <xref:System.Text.UTF32Encoding>, com um preâmbulo.  
  
   
  
## Examples  
 O exemplo a seguir determina a ordem de byte da codificação com base no preâmbulo.  
  
 [!code-cpp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CPP/preamble.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/CS/preamble.cs#1)]
 [!code-vb[System.Text.Encoding.GetPreamble Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetPreamble Example/VB/preamble.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <summary>Quando substituído em uma classe derivada, decodifica todos os bytes na matriz de bytes especificada em uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que contém os resultados de decodificação de sequência especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> objeto retornado pelo <xref:System.Text.Encoding.GetDecoder%2A> método de uma classe derivada.  
  
 Consulte a seção comentários a <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tópico de referência para uma discussão sobre técnicas e as considerações de decodificação.  
  
 Observe que o comportamento preciso do <xref:System.Text.Encoding.GetString%2A> método para um determinado <xref:System.Text.Encoding> implementação depende da estratégia de fallback definida para que <xref:System.Text.Encoding> objeto. Para obter mais informações, consulte a seção "Escolhendo uma estratégia de Fallback" o [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) tópico.  
  
   
  
## Examples  
 O exemplo a seguir lê uma cadeia de caracteres codificada em UTF-8 de um arquivo binário, representado por um <xref:System.IO.FileStream> objeto. Para arquivos que são menores que 2.048 bytes, ele lê o conteúdo do arquivo inteiro em uma matriz de bytes e chama o <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%29> método para executar a decodificação. Para arquivos maiores, ele lê 2.048 bytes por vez em uma matriz de bytes, chamadas de <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar o número de caracteres estão contidos na matriz e, em seguida, chama o <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para executar a decodificação.  
  
 [!code-csharp[System.Text.Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring1.cs#2)]
 [!code-vb[System.Text.Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring1.vb#2)]  
  
 O exemplo usa o seguinte texto, que deve ser salvo em um arquivo codificado UTF-8 denominado Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A matriz de bytes contém pontos de código Unicode inválidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public string GetString (byte* bytes, int byteCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetString(unsigned int8* bytes, int32 byteCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte*,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte*" />
        <Parameter Name="byteCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">Um ponteiro para uma matriz de bytes.</param>
        <param name="byteCount">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica um número especificado de bytes, começando em um endereço especificado em uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que contém os resultados de decodificação de sequência especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.GetString%2A> método foi projetado para otimizar o desempenho quando você tem um ponteiro nativo para uma matriz de bytes. Em vez de criar uma matriz de bytes gerenciado e, em seguida, codificá-lo, em vez disso, você pode chamar esse método sem a necessidade de criar os objetos intermediários.  
  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> objeto retornado pelo <xref:System.Text.Encoding.GetDecoder%2A> método de uma classe derivada.  
  
 Consulte a seção comentários a <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tópico de referência para uma discussão sobre técnicas e as considerações de decodificação.  
  
 Observe que o comportamento preciso do <xref:System.Text.Encoding.GetString%2A> método para um determinado <xref:System.Text.Encoding> implementação depende da estratégia de fallback definida para que <xref:System.Text.Encoding> objeto. Para obter mais informações, consulte a seção "Escolhendo uma estratégia de Fallback" o [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) tópico.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          O <paramref name="bytes" /> é um ponteiro nulo.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="byteCount" /> é menor que zero.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter uma explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetString">
      <MemberSignature Language="C#" Value="public virtual string GetString (byte[] bytes, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetString(unsigned int8[] bytes, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.GetString(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytes" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bytes">A matriz de bytes que contém a sequência de bytes a ser decodificada.</param>
        <param name="index">O índice do primeiro byte para decodificar.</param>
        <param name="count">O número de bytes a serem decodificados.</param>
        <summary>Quando substituído em uma classe derivada, decodifica uma sequência de bytes da matriz de bytes especificada em uma cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres que contém os resultados de decodificação de sequência especificada de bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dados a serem convertidos estão disponíveis somente em blocos sequenciais (como ler a partir de um fluxo de dados) ou se a quantidade de dados é tão grande que ele precisa ser divididos em blocos menores, você deve usar o <xref:System.Text.Decoder> ou <xref:System.Text.Encoder> fornecidos pelo <xref:System.Text.Encoding.GetDecoder%2A> método ou o <xref:System.Text.Encoding.GetEncoder%2A> método, respectivamente, de uma classe derivada.  
  
 Consulte a seção comentários a <xref:System.Text.Encoding.GetChars%2A?displayProperty=nameWithType> tópico de referência para uma discussão sobre técnicas e as considerações de decodificação.  
  
   
  
## Examples  
 O exemplo a seguir lê uma cadeia de caracteres codificada em UTF-8 de um arquivo binário que é representado por um <xref:System.IO.FileStream> objeto. Para arquivos que são menores que 2.048 bytes, ele lê o conteúdo do arquivo inteiro em uma matriz de bytes e chama o <xref:System.Text.Encoding.GetString%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> método para executar a decodificação. Para arquivos maiores, ele lê 2.048 bytes por vez em uma matriz de bytes, chamadas de <xref:System.Text.Decoder.GetCharCount%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para determinar o número de caracteres estão contidos na matriz e, em seguida, chama o <xref:System.Text.Decoder.GetChars%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Char%5B%5D%2CSystem.Int32%29?displayProperty=nameWithType> método para executar a decodificação.  
  
 [!code-csharp[System.Text.Encoding.GetString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetString/CS/getstring2.cs#3)]
 [!code-vb[System.Text.Encoding.GetString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetString/VB/getstring2.vb#3)]  
  
 O exemplo usa o seguinte texto, que deve ser salvo em um arquivo codificado UTF-8 denominado Utf8Example.txt.  
  
```  
  
This is a UTF-8-encoded file that contains primarily Latin text, although it   
does list the first twelve letters of the Russian (Cyrillic) alphabet:  
  
А б в г д е ё ж з и й к  
  
The goal is to save this file, then open and decode it as a binary stream.  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A matriz de bytes contém pontos de código Unicode inválidos.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="bytes" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> ou <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="count" /> não denotam um intervalo válido em <paramref name="bytes" />.</exception>
        <exception cref="T:System.Text.DecoderFallbackException">Ocorreu um fallback (consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md) para obter explicação completa)  
  
 -e-  
  
 <see cref="P:System.Text.Encoding.DecoderFallback" /> é definido como <see cref="T:System.Text.DecoderExceptionFallback" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeaderName">
      <MemberSignature Language="C#" Value="public virtual string HeaderName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string HeaderName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.HeaderName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um nome para a codificação atual que pode ser usado com marcas de cabeçalho do agente de email.</summary>
        <value>Um nome para o <see cref="T:System.Text.Encoding" /> atual a ser usado com marcas de cabeçalho do agente de email.  
  
 -ou-  
  
 Uma cadeia de caracteres vazia ("") se o <see cref="T:System.Text.Encoding" /> atual não puder ser usado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você precisar de uma codificação para um nome de cabeçalho, você deve chamar o <xref:System.Text.Encoding.GetEncoding%2A> método com o <xref:System.Text.Encoding.HeaderName%2A> propriedade. Geralmente, o método recupera uma codificação diferente da codificação de teste fornecido na chamada. Geralmente somente aplicativos de email necessário recuperar esses uma codificação.  
  
 Em alguns casos, o valor de <xref:System.Text.Encoding.BodyName%2A> propriedade corresponde ao padrão internacional que define a codificação. Isso não significa que a implementação está em conformidade por completo com esse padrão.  
  
 Observe que <xref:System.Text.Encoding.WebName%2A> retorna o nome a ser usado para descrever uma codificação. O <xref:System.Text.Encoding.HeaderName%2A> propriedade define uma codificação diferente que pode funcionar melhor para um aplicativo de email, por exemplo. No entanto, o uso da propriedade para definir a codificação não é recomendado.  
  
   
  
## Examples  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se compara em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public bool IsAlwaysNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsAlwaysNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um valor que indica se a codificação atual sempre é normalizada, usando o formulário de normalização padrão.</summary>
        <returns>
          <see langword="true" />Se o atual <see cref="T:System.Text.Encoding" /> sempre é normalizado; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formulário de normalização padrão é <xref:System.Text.NormalizationForm.FormC>, que usa a decomposição canônica completo, seguida pela substituição de sequências com suas composições primárias, se possível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAlwaysNormalized">
      <MemberSignature Language="C#" Value="public virtual bool IsAlwaysNormalized (System.Text.NormalizationForm form);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAlwaysNormalized(valuetype System.Text.NormalizationForm form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="form">Um dos valores de <see cref="T:System.Text.NormalizationForm" />.</param>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual sempre é normalizada, usando o formulário de normalização especificado.</summary>
        <returns>
          <see langword="true" />Se o atual <see cref="T:System.Text.Encoding" /> objeto sempre é normalizado usando especificado <see cref="T:System.Text.NormalizationForm" /> valor; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O formulário de normalização padrão é <xref:System.Text.NormalizationForm.FormC>, que usa a decomposição canônica completo, seguida pela substituição de sequências com suas composições primárias, se possível.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBrowserDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador para exibir o conteúdo.</summary>
        <value>
          <see langword="true" />Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes do navegador para exibir o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBrowserSave">
      <MemberSignature Language="C#" Value="public virtual bool IsBrowserSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBrowserSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsBrowserSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes do navegador para salvar o conteúdo.</summary>
        <value>
          <see langword="true" />Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes do navegador para salvar o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsDisplay">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsDisplay { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsDisplay" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsDisplay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes de email e notícias para exibir o conteúdo.</summary>
        <value>
          <see langword="true" />Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes de email e notícias para exibir o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMailNewsSave">
      <MemberSignature Language="C#" Value="public virtual bool IsMailNewsSave { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMailNewsSave" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsMailNewsSave" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual pode ser usada por clientes de email e notícias para salvar o conteúdo.</summary>
        <value>
          <see langword="true" />Se o atual <see cref="T:System.Text.Encoding" /> pode ser usado por clientes de email e notícias para salvar o conteúdo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual é somente leitura.</summary>
        <value>
          <see langword="true" />Se o atual <see cref="T:System.Text.Encoding" /> é somente leitura; caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSingleByte">
      <MemberSignature Language="C#" Value="public virtual bool IsSingleByte { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSingleByte" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.IsSingleByte" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se a codificação atual usa pontos de código de byte único.</summary>
        <value>
          <see langword="true" /> se o <see cref="T:System.Text.Encoding" /> atual usa pontos de código de byte único; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para um único byte de codificação, por exemplo, <xref:System.Text.ASCIIEncoding>, essa propriedade recupera `true`.  
  
> [!CAUTION]
>  Você deve ter cuidado ao que o aplicativo faz com o valor de <xref:System.Text.Encoding.IsSingleByte%2A>. Uma suposição de como uma codificação continuará ainda pode estar incorreta. Por exemplo, Windows-1252 tem um valor de `true` para <xref:System.Text.Encoding.IsSingleByte%2A?displayProperty=nameWithType>, mas Encoding.GetMaxByteCount(1) retorna 2. Isso ocorre porque o método considera possíveis substitutos restantes de uma operação de decodificador anterior.  
  
   
  
## Examples  
 O exemplo a seguir verifica os valores das propriedades de cada codificação Boolean.  
  
 [!code-cpp[System.Text.Encoding.IsProps#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CPP/isprops.cpp#1)]
 [!code-csharp[System.Text.Encoding.IsProps#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/CS/isprops.cs#1)]
 [!code-vb[System.Text.Encoding.IsProps#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.IsProps/VB/isprops.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterProvider">
      <MemberSignature Language="C#" Value="public static void RegisterProvider (System.Text.EncodingProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterProvider(class System.Text.EncodingProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.Text.EncodingProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Uma subclasse de <see cref="T:System.Text.EncodingProvider" /> que fornece acesso a codificações de caracteres adicionais.</param>
        <summary>Registra um provedor de codificação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.RegisterProvider%2A> método permite que você registre uma classe derivada de <xref:System.Text.EncodingProvider> que torna as codificações disponíveis em uma plataforma que não suporte-los. Depois que o provedor de codificação é registrado, as codificações que ele suporta podem ser recuperadas chamando qualquer <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> de sobrecarga. Se houver vários provedores de codificação, o <xref:System.Text.Encoding.GetEncoding%2A?displayProperty=nameWithType> método tenta recuperar uma codificação especificada de cada provedor começando com o mais recentemente registrados.

Registrar um provedor de codificação usando o <xref:System.Text.Encoding.RegisterProvider%2A> método também modifica o comportamento do [Encoding.GetEncoding(Int32)](<xref:System.Text.Encoding.GetEncoding(System.Int32)>) e [EncodingProvider.GetEncoding (Int32, EncoderFallback, DecoderFallback )](xref:System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)) métodos quando passou um argumento de `0`:

- Se o provedor registrado é o <xref:System.Text.CodePagesEncodingProvider>, o método retorna a codificação que corresponde à página de código ativo do sistema quando em execução no sistema operacional Windows.

- Um provedor de codificação personalizado pode escolher qual codificação para retornar quando um desses <xref:System.Text.Encoding.GetEncoding%2A> sobrecargas do método é passado um argumento de `0`. O provedor também pode optar por não retornar uma codificação tendo o <xref:System.Text.EncodingProvider.GetEncoding%2A?displayProperty=nameWithType> retorno do método `null`. 
  
 [!INCLUDE[net_v46](~/includes/net-v46-md.md)]inclui um provedor de codificação, <xref:System.Text.CodePagesEncodingProvider>, que torna as codificações disponíveis que estão presentes no .NET Framework completo, mas não estão disponíveis em [!INCLUDE[net_v46](~/includes/net-v46-md.md)]. Por padrão, [!INCLUDE[net_v46](~/includes/net-v46-md.md)] só dá suporte a Unicode codificações, ASCII e a página de código 28591.  
  
 Se o mesmo provedor de codificação é usado em várias chamadas para o <xref:System.Text.Encoding.RegisterProvider%2A> método, somente a primeira chamada do método registra o provedor. As chamadas subsequentes serão ignoradas.  
  
 Se o <xref:System.Text.Encoding.RegisterProvider%2A> método é chamado para registrar vários provedores que lidam com a mesma codificação, o último provedor registrado é usado para todos os codificação e decodificação de operações. Nenhum provedor registrado anteriormente é ignorados.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="provider" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unicode">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding Unicode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding Unicode" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.Unicode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-16 usando a ordem de byte little endian.</summary>
        <value>Uma codificação para o formato UTF-16 usando a ordem de byte little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter informações sobre as codificações com suporte do .NET Framework e uma discussão sobre qual codificação Unicode para usar, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 O <xref:System.Text.UnicodeEncoding> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.UnicodeEncoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar um pouco endian <xref:System.Text.UnicodeEncoding> objeto cujo fallback é uma <xref:System.Text.EncoderFallbackException> ou <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.Unicode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.unicode/cs/unicode1.cs#2)]
 [!code-vb[System.Text.Encoding.Unicode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.unicode/vb/unicode1.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UTF32">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF32 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF32" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF32" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-32 usando a ordem de byte little endian.</summary>
        <value>Um objeto de codificação para o formato UTF-32 usando a ordem de byte little endian.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.UTF32Encoding> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo. Ele usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar o CARACTERE de substituição Unicode (U + FFFE). Em vez disso, você pode chamar o <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar um <xref:System.Text.UTF32Encoding> objeto cujo fallback é uma <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Text.Encoding.UTF32#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf32/cs/encoding.utf32.1.cs#1)]
 [!code-vb[System.Text.Encoding.UTF32#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf32/vb/encoding.utf32.1.vb#1)]  
  
 Para obter uma discussão de ordem de byte endian pouco, consulte o <xref:System.Text.Encoding> tópico sobre a classe.  
  
 Para obter informações sobre as codificações com suporte do .NET Framework e uma discussão sobre qual codificação Unicode para usar, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UTF7">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF7 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF7" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF7" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-7.</summary>
        <value>Uma codificação para o formato UTF-7.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codificação UTF-7 é usado principalmente em ambientes que historicamente tem sido restrito a 7 bits, como NNTP e alguns aplicativos de email. Devido a problemas com eficiência e segurança, você não deve usar codificação UTF7 em ambientes de 8 bits em codificação UTF-8 pode ser usado em vez disso.  
  
   
  
## Examples  
 O exemplo a seguir determina o número de bytes necessários para codificar uma matriz de caracteres, codifica os caracteres e exibe os bytes resultantes.  
  
 [!code-cpp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]
 [!code-csharp[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]
 [!code-vb[System.Text.Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.GetBytes_CharArr/VB/getbytes_chararr.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UTF8">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding UTF8 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding UTF8" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.UTF8" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma codificação para o formato UTF-8.</summary>
        <value>Uma codificação para o formato UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade retorna um <xref:System.Text.UTF8Encoding> objeto que codifica caracteres de Unicode (codificação UTF-16) em uma sequência de um a quatro bytes por caractere, e que decodifica uma matriz de bytes codificados em UTF-8 para Unicode (codificação UTF-16) caracteres. Para obter informações sobre as codificações de caracteres com suporte do .NET Framework e uma discussão sobre qual codificação Unicode para usar, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).  
  
 O <xref:System.Text.UTF8Encoding> objeto que é retornado por essa propriedade não pode ter o comportamento apropriado para seu aplicativo.  
  
-   Ele retorna um <xref:System.Text.UTF8Encoding> objeto que fornece uma marca de ordem de byte Unicode (BOM). Para criar uma instância de uma codificação UTF8 que não fornece um BOM, chamar qualquer sobrecarga do <xref:System.Text.UTF8Encoding.%23ctor%2A> construtor.  
  
-   Ele retorna um <xref:System.Text.UTF8Encoding> objeto que usa o fallback de substituição para substituir cada cadeia de caracteres que não é possível codificar e cada byte que não é possível decodificar um ponto de interrogação ("?") caracteres. Em vez disso, você pode chamar o <xref:System.Text.UTF8Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> construtor para instanciar um <xref:System.Text.UTF8Encoding> objeto cujo fallback é uma <xref:System.Text.EncoderFallbackException> ou um <xref:System.Text.DecoderFallbackException>, como mostra o exemplo a seguir.  
  
     [!code-csharp[System.Text.Encoding.UTF8#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/encoding.utf8.1.cs#1)]
     [!code-vb[System.Text.Encoding.UTF8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/encoding.utf8.1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz que consiste dos seguintes caracteres:  
  
-   LETRA MINÚSCULA LATINA Z (U + 007A)  
  
-   MINÚSCULA LATINA UM (U + 0061)  
  
-   COMBINANDO CURTO (U + 0306)  
  
-   LETRA LATINA MINÚSCULA AE COM ACENTO AGUDO (U + 01FD)  
  
-   LETRA GREGA MINÚSCULA BETA (U + 03B2)  
  
-   Um par substituto (U + D800 U + DD54) que forma GREGA ACROPHONIC ATTIC um MILHAR STATERS (U + 10154).  
  
 Exibe as unidades de código UTF-16 de cada caractere e determina o número de bytes exigido por um codificador de UTF-8 para codificar a matriz de caracteres. Em seguida, ele codifica os caracteres e exibe os bytes resultantes codificado em UTF-8.  
  
 [!code-csharp[System.Text.Encoding.UTF8#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.encoding.utf8/cs/example1.cs#2)]
 [!code-vb[System.Text.Encoding.UTF8#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.encoding.utf8/vb/example1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WebName">
      <MemberSignature Language="C#" Value="public virtual string WebName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string WebName" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WebName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Text.Encoding</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o nome registrado na IANA (Internet Assigned Numbers Authority) da codificação atual.</summary>
        <value>O nome IANA do <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Text.Encoding.WebName%2A> propriedade é o mesmo que o <xref:System.Text.EncodingInfo.Name%2A> propriedade.  
  
 Observe que <xref:System.Text.Encoding.WebName%2A> retorna um nome registrado IANA para a codificação. Quando seu valor é o nome de um padrão, a implementação da codificação não pode estar em conformidade por completo para esse padrão. O <xref:System.Text.Encoding.HeaderName%2A> propriedade define uma codificação diferente que pode funcionar melhor para cabeçalhos de email. No entanto, a maioria dos aplicativos devem usar <xref:System.Text.Encoding.WebName%2A> em vez disso.  
  
 Para obter mais informações sobre o IANA, vá para [www.iana.org](http://www.iana.org/).  
  
 O <xref:System.Text.Encoding.WebName%2A?displayProperty=nameWithType> é igual a <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType> retornado por <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType>. Alguns dos nomes de web são duplicatas; Consulte os comentários para <xref:System.Text.Encoding.GetEncodings%2A?displayProperty=nameWithType> para obter mais informações.  
  
   
  
## Examples  
 O exemplo a seguir inclui o <xref:System.Text.Encoding.WebName%2A> em um cabeçalho HTML.  
  
 [!code-cpp[System.Text.Encoding.WebName#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CPP/webname.cpp#1)]
 [!code-csharp[System.Text.Encoding.WebName#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.WebName/CS/webname.cs#1)]
 [!code-vb[System.Text.Encoding.WebName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.WebName/VB/webname.vb#1)]  
  
 O exemplo a seguir recupera os nomes diferentes para cada codificação e exibe as codificações com um ou mais nomes diferentes dos <xref:System.Text.EncodingInfo.Name%2A?displayProperty=nameWithType>. Ele exibe <xref:System.Text.Encoding.EncodingName%2A> mas não se compara em relação a ela.  
  
 [!code-cpp[System.Text.Encoding.Names#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CPP/names.cpp#1)]
 [!code-csharp[System.Text.Encoding.Names#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.Names/CS/names.cs#1)]
 [!code-vb[System.Text.Encoding.Names#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.Names/VB/names.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowsCodePage">
      <MemberSignature Language="C#" Value="public virtual int WindowsCodePage { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WindowsCodePage" />
      <MemberSignature Language="DocId" Value="P:System.Text.Encoding.WindowsCodePage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém a página de código de sistema operacional Windows que mais bem corresponde à codificação atual.</summary>
        <value>A página de código de sistema operacional Windows que mais bem corresponde à <see cref="T:System.Text.Encoding" /> atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida para compatibilidade com o multilíngue do Windows (MLang) APIs, por exemplo, para determinar as famílias de fontes. Para globalização, usar uma das codificações Unicode é recomendado em vez disso. Também é recomendável usar <xref:System.Text.Encoding.WebName%2A> em vez de <xref:System.Text.Encoding.WindowsCodePage%2A> para identificar a página de código.  
  
   
  
## Examples  
 O exemplo a seguir determina a página de código do Windows que melhor corresponde a cada codificação.  
  
 [!code-cpp[System.Text.Encoding.CodePage#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CPP/codepage.cpp#1)]
 [!code-csharp[System.Text.Encoding.CodePage#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/CS/codepage.cs#1)]
 [!code-vb[System.Text.Encoding.CodePage#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.Encoding.CodePage/VB/codepage.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
