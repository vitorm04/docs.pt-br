<Type Name="XmlReader" FullName="System.Xml.XmlReader">
  <TypeSignature Language="C#" Value="public abstract class XmlReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XmlReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlReader" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("{debuggerDisplayProxy}")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um leitor que fornece acesso rápido não armazenado em cache e somente de encaminhamento aos dados XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Core/XmlReader.cs#086471e5cca0825f). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 <xref:System.Xml.XmlReader>fornece acesso somente de encaminhamento, somente leitura aos dados XML em adocument ou fluxo. Essa classe está de acordo com o W3C [Extensible Markup Language (XML) 1.0 (quarta edição)](http://www.w3.org/TR/2006/REC-xml-20060816/) e [Namespaces no XML 1.0 (terceira edição)](http://www.w3.org/TR/REC-xml-names/) recomendações.  
  
 <xref:System.Xml.XmlReader>métodos permitem percorrer dados XML e ler o conteúdo de um nó. As propriedades da classe refletem o valor do nó atual, que é onde o leitor está posicionado. O <xref:System.Xml.XmlReader.ReadState%2A> o valor da propriedade indica o estado atual do leitor de XML. Por exemplo, a propriedade é definida como <xref:System.Xml.ReadState.Initial> pelo <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> método e <xref:System.Xml.ReadState.Closed> pelo <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> método. <xref:System.Xml.XmlReader>também oferece verificações de conformidade de dados e validação em relação a um DTD ou esquema.  
  
 <xref:System.Xml.XmlReader>usa um modelo de pull para recuperar dados. Este modelo:  
  
-   Simplifica o gerenciamento de estado, um ajuste de procedimento natural, de cima para baixo.  
  
-   Oferece suporte a vários fluxos de entrada e das camadas.  
  
-   Permite que o cliente fornecer o analisador de um buffer no qual a cadeia de caracteres é gravada diretamente e evita a necessidade de uma cópia extra de cadeia de caracteres.  
  
-   Suporta processamento seletivo. O cliente pode ignorar itens e processar os que são de interesse para o aplicativo. Você também pode definir propriedades com antecedência para gerenciar como o fluxo XML é processado (por exemplo, a normalização).  
  
 Nesta seção:  
  
 [Criando um leitor de XML](#xmlreader_create)   
 [Validando dados XML](#xmlreader_validate)   
 [Conformidade de dados](#xmlreader_data)   
 [Navegar por nós](#xmlreader_nodes)   
 [Elementos XML de leitura](#xmlreader_elements)   
 [Atributos XML de leitura](#xmlreader_attributes)   
 [Conteúdo XML de leitura](#xmlreader_content)   
 [Conversão para tipos CLR](#xmlreader_clr)   
 [Programação assíncrona](#xmlreader_async)   
 [Considerações sobre segurança](#xmlreader_security)  
  
<a name="xmlreader_create"></a>   
## <a name="creating-an-xml-reader"></a>Criando um leitor de XML  
 Use o <xref:System.Xml.XmlReader.Create%2A> método para criar um <xref:System.Xml.XmlReader> instância.  
  
 Embora o .NET Framework fornece implementações concretas do <xref:System.Xml.XmlReader> classe, como o <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>e o <xref:System.Xml.XmlValidatingReader> classes, recomendamos que você use as classes especializadas apenas nestes cenários:  
  
-   Quando você deseja readan subárvore de DOM XML de um <xref:System.Xml.XmlNode> de objeto, use o <xref:System.Xml.XmlNodeReader> classe. (No entanto, essa classe não oferece suporte a validação DTD ou esquema.)  
  
-   Se você deve expandir entidades na solicitação, não deseja que seu texto conteúdo normalizado ou você não deseja atributos retornados padrão, use o <xref:System.Xml.XmlTextReader> classe.  
  
 Para especificar o conjunto de recursos que você deseja habilitar o leitor de XML, passe um <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> o objeto para o <xref:System.Xml.XmlReader.Create%2A> método. Você pode usar um único <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> de objeto para criar vários leitores com a mesma funcionalidade, ou modificar o <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> objeto para criar um novo leitor com um conjunto diferente de recursos. Também é fácil, você pode adicionar recursos a um leitor de existente.  
  
 Se você não usar um <xref:System.Xml.XmlReaderSettings?displayProperty=nameWithType> do objeto, as configurações padrão são usadas. Consulte o <xref:System.Xml.XmlReader.Create%2A> página de referência para obter detalhes.  
  
 <xref:System.Xml.XmlReader>gera um <xref:System.Xml.XmlException> erros de análise XML. Depois que uma exceção será lançada, o estado do leitor não é previsível. Por exemplo, o tipo de nó relatado pode ser diferente do tipo de nó real do nó atual. Use o <xref:System.Xml.XmlReader.ReadState%2A> propriedade para verificar se o leitor está em estado de erro.  
  
<a name="xmlreader_validate"></a>   
## <a name="validating-xml-data"></a>Validando dados XML  
 Para definir a estrutura de um documento XML e suas relações do elemento, tipos de dados e restrições de conteúdo, você pode usar uma definição de tipo de documento (DTD) ou esquema de linguagem XSD de definição de esquema XML. É considerado um documento XML bem formada caso ele atenda a todos os requisitos de sintáticos definidos pelo [recomendação do W3C XML 1.0](http://www.w3.org/TR/2006/REC-xml-20060816/). Ele é considerado válido se ele está bem-formado e também está em conformidade com as restrições definidas pelo DTD ou esquema. (Consulte o [W3C XML Schema Part 1: estruturas](http://www.w3.org/TR/xmlschema-1/) e [W3C XML Schema Part 2: tipos de dados](http://www.w3.org/TR/xmlschema-2/)recomendações.) Portanto, embora todos os documentos XML válidos sejam bem-formados, nem todos os documentos XML bem-formados são válidos.  
  
 Você pode validar os dados com base em um DTD, um esquema XSD embutido ou um esquema XSD é armazenado em um <xref:System.Xml.Schema.XmlSchemaSet> objeto (um cache); esses cenários são descritos no <xref:System.Xml.XmlReader.Create%2A> página de referência. <xref:System.Xml.XmlReader>não dá suporte a validação de esquema XML-Data Reduced (XDR).  
  
 Use as seguintes configurações no <xref:System.Xml.XmlReaderSettings> classe para especificar o tipo de validação, se houver, o <xref:System.Xml.XmlReader> oferece suporte a da instância.  
  
|Use este <xref:System.Xml.XmlReaderSettings> membro|Para especificar|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|----------------|  
|Propriedade <xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|Se deseja permitir o processamento do DTD. O padrão é não permitir o processamento de DTD.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.ValidationType%2A>|Se o leitor deve validar dados e o tipo de validação a ser executado (DTD ou esquema). A opção não é possível validação de dados.|  
|Evento <xref:System.Xml.XmlReaderSettings.ValidationEventHandler>|Um manipulador de eventos para receber informações sobre eventos de validação. Se um manipulador de eventos não for fornecido, <xref:System.Xml.XmlException> será apresentada no primeiro erro de validação.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|Opções de validação adicional por meio de <xref:System.Xml.Schema.XmlSchemaValidationFlags> os membros da enumeração:<br /><br /> -   `AllowXmlAttributes`-Permitir atributos XML (`xml:*`) em documentos de instância, mesmo quando eles não estão definidos no esquema. Os atributos são validados de acordo com o tipo de dados. Consulte o <xref:System.Xml.Schema.XmlSchemaValidationFlags> página de referência para a configuração para usar em cenários específicos. (Desabilitado por padrão).<br />-   `ProcessIdentityConstraints`-Restrições de identidade de processo (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, `xs:unique`) encontrados durante a validação. (Habilitado por padrão).<br />-   `ProcessSchemaLocation`– Processar esquemas especificados pelo `xsi:schemaLocation` ou `xsi:noNamespaceSchemaLocation` atributo. (Habilitado por padrão).<br />-   `ProcessInlineSchema`– Processe embutido esquemas XML durante a validação. (Desabilitado por padrão).<br />-   `ReportValidationWarnings`– Relatar eventos se ocorrer um aviso de validação. Um aviso é emitida normalmente quando não há nenhum DTD ou esquema XML para validar um elemento ou atributo específico contra. <xref:System.Xml.XmlReaderSettings.ValidationEventHandler> é usado para notificação. (Desabilitado por padrão).|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|O <xref:System.Xml.Schema.XmlSchemaSet> será usado para validação.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|O <xref:System.Xml.XmlResolver> para resolver e acessar recursos externos. Isso pode incluir entidades externas como DTD, esquemas e qualquer `xs:include` ou `xs:import` elementos contidos no esquema XML. Se você não especificar um <xref:System.Xml.XmlResolver>, o <xref:System.Xml.XmlReader> usa um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais de usuário.|  
  
<a name="xmlreader_data"></a>   
## <a name="data-conformance"></a>Conformidade de dados  
 Leitores XML que são criados pelo <xref:System.Xml.XmlReader.Create%2A> methodmeet os seguintes requisitos de conformidade por padrão:  
  
-   Novas linhas e o valor de atributo são normalizados de acordo com o W3C [recomendação XML 1.0](http://www.w3.org/TR/2006/REC-xml-20060816/).  
  
-   Todas as entidades são expandidas automaticamente.  
  
-   Os atributos padrão declarados na definição do tipo de documento sempre são adicionados, mesmo quando o leitor não valida.  
  
-   Declaração de prefixo XML mapeado para o URI de namespace XML correto é permitida.  
  
-   Os nomes de notação em uma única `NotationType` declaração do atributo e`NmTokens` em uma única `Enumeration` declarationare distinto do atributo.  
  
 Use essas <xref:System.Xml.XmlReaderSettings> propriedades para especificar o tipo de conformidade verifica que você deseja habilitar:  
  
|Use este <xref:System.Xml.XmlReaderSettings> propriedade|Para|Padrão|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------------|--------|-------------|  
|Propriedade <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|Habilitar ou desabilitar as verificações para o seguinte:<br /><br /> -Caracteres estão dentro do intervalo de caracteres XML válidos, conforme definido pelo [2.2 caracteres](http://www.w3.org/TR/2006/REC-xml-20060816/#charsets) seção da recomendação W3C XML 1.0.<br />-Todos os nomes XML são válidos, conforme definido pelo [2.3 comuns sintáticos constrói](http://www.w3.org/TR/2006/REC-xml-20060816/#NT-Name) seção da recomendação W3C XML 1.0.<br /><br /> Quando essa propriedade é definida como `true` (padrão), um <xref:System.Xml.XmlException> exceção é gerada se o arquivo XML contém caracteres inválidos ou nomes XML inválidos (por exemplo, um nome de elemento inicia com um número).|Caractere e verificação de nome está habilitado.<br /><br /> A definição de <xref:System.Xml.XmlReaderSettings.CheckCharacters%2A> como `false` desativa a verificação de caracteres em referências de entidade de caracteres. Se o leitor estiver processando os dados de texto, ele sempre verifica que nomes XML são válidos, independentemente dessa configuração. **Observação:** a recomendação XML 1.0 requer a conformidade do nível do documento quando houver um DTD. Portanto, se o leitor estiver configurado para dar suporte a <xref:System.Xml.ConformanceLevel?displayProperty=nameWithType>, mas os dados XML contém uma definição de tipo de documento (DTD), um <xref:System.Xml.XmlException> é gerada.|  
|Propriedade <xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|Escolha o nível de conformidade para impor:<br /><br /> -   <xref:System.Xml.ConformanceLevel.Document>. Está de acordo com as regras para um [documento bem formado do XML 1.0](http://www.w3.org/TR/2006/REC-xml-20060816/#sec-well-formed).<br />-   <xref:System.Xml.ConformanceLevel.Fragment>. Está de acordo com as regras para um fragmento de documento bem formado que podem ser consumidos como um [externo analisado entidade](http://www.w3.org/TR/2006/REC-xml-20060816/#wf-entities).<br />-   <xref:System.Xml.ConformanceLevel.Auto>. Está de acordo com o nível decidido pelo leitor.<br /><br /> Se os dados não estão em conformidade, um <xref:System.Xml.XmlException> exceção será lançada.|<xref:System.Xml.ConformanceLevel.Document>|  
  
<a name="xmlreader_nodes"></a>   
## <a name="navigating-through-nodes"></a>Navegar por nós  
 O nó atual é o nó XML no qual o leitor de XML é posicionado no momento. Todos os <xref:System.Xml.XmlReader> os métodos executam operações em relação a esse nó e todos os <xref:System.Xml.XmlReader> propriedades refletem o valor do nó atual.  
  
 Os métodos a seguir tornam mais fácil navegar por nós e analisar dados.  
  
|Use este <xref:System.Xml.XmlReaderSettings> método|Para|  
|-----------------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|<xref:System.Xml.XmlReader.Read%2A>|Ler o primeiro nó e Avançar por meio do nó de um fluxo por vez. Essas chamadas são normalmente executadas dentro uma `while` loop.<br /><br /> Use o <xref:System.Xml.XmlReader.NodeType%2A> propriedade para obter o tipo (por exemplo, atributo, comentário, elemento e assim por diante) do nó atual.|  
|<xref:System.Xml.XmlReader.Skip%2A>|Ignore os filhos do nó atual e mover para o próximo nó.|  
|<xref:System.Xml.XmlReader.MoveToContent%2A> e <xref:System.Xml.XmlReader.MoveToContentAsync%2A>|Ignorar nós de não-content e mover para o próximo nó de conteúdo ou até o fim do arquivo.<br /><br /> Nós de conteúdo não incluem <xref:System.Xml.XmlNodeType.ProcessingInstruction>, <xref:System.Xml.XmlNodeType.DocumentType>, <xref:System.Xml.XmlNodeType.Comment>, <xref:System.Xml.XmlNodeType.Whitespace>, e <xref:System.Xml.XmlNodeType.SignificantWhitespace>.<br /><br /> Conteúdo de nós incluem texto não seja espaço em branco, <xref:System.Xml.XmlNodeType.CDATA>, <xref:System.Xml.XmlNodeType.EntityReference> , e <xref:System.Xml.XmlNodeType.EndEntity>.|  
|<xref:System.Xml.XmlReader.ReadSubtree%2A>|Ler um elemento e todos os seus filhos e retornar uma nova <xref:System.Xml.XmlReader> instância definida como <xref:System.Xml.ReadState?displayProperty=nameWithType>.<br /><br /> Esse método é útil para criar limites de elementos XML; Por exemplo, se você deseja passar dados para outro componente para processamento e você quiser limitar a quantidade de dados pode acessar o componente.|  
  
 Consulte o <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> página de referência para obter um exemplo de navegar por meio de um nó de um de fluxo de texto por vez e exibir o tipo de cada nó.  
  
 As seções a seguir descrevem como você pode ler tipos específicos de dados, como elementos, atributos e dados de tipo.  
  
<a name="xmlreader_elements"></a>   
## <a name="reading-xml-elements"></a>Elementos XML de leitura  
 A tabela a seguir lista os métodos e propriedades que o <xref:System.Xml.XmlReader> classe fornece para processamento de elementos. Depois que <xref:System.Xml.XmlReader> é posicionada em um elemento, as propriedades de nó, como <xref:System.Xml.XmlReader.Name%2A>, refletem os valores do elemento. Além dos membros descritos a seguir, alguns dos métodos e das propriedades gerais da classe <xref:System.Xml.XmlReader> também podem ser usados para processar elementos. Por exemplo, é possível usar o método <xref:System.Xml.XmlReader.ReadInnerXml%2A> para ler o conteúdo de um elemento.  
  
> [!NOTE]
>  Consulte a seção 3.1 o [recomendação do W3C XML 1.0](http://www.w3.org/TR/2006/REC-xml-20060816/#sec-starttags) para definições de marcas de início, fim marcas e marcas de elemento vazio.  
  
|Use este <xref:System.Xml.XmlReader> membro|Para|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Método <xref:System.Xml.XmlReader.IsStartElement%2A>|Verifique se o nó atual é uma marca de início ou uma marca de elemento vazio.|  
|Método <xref:System.Xml.XmlReader.ReadStartElement%2A>|Verifique se o nó atual é um elemento e avança o leitor para o próximo nó (chamadas <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por <xref:System.Xml.XmlReader.Read%2A>).|  
|Método <xref:System.Xml.XmlReader.ReadEndElement%2A>|Verifique se o nó atual é uma marca de fim e avança o leitor para o próximo nó.|  
|Método <xref:System.Xml.XmlReader.ReadElementString%2A>|Ler um elemento somente texto.|  
|Método <xref:System.Xml.XmlReader.ReadToDescendant%2A>|Avança o leitor de XML para o próximo elemento descendente (filho) que tem o nome especificado.|  
|Método <xref:System.Xml.XmlReader.ReadToNextSibling%2A>|Avança o leitor de XML para o próximo elemento irmão que tem o nome especificado.|  
|Propriedade <xref:System.Xml.XmlReader.IsEmptyElement%2A>|Verifique se o elemento atual tem uma marca de elemento final. Por exemplo:<br /><br /> -   `<item num="123"/>`(<xref:System.Xml.XmlReader.IsEmptyElement%2A> is `true`.)<br />-   `<item num="123"> </item>`(<xref:System.Xml.XmlReader.IsEmptyElement%2A> é `false`, embora o conteúdo do elemento está vazio.)|  
  
 Para obter um exemplo de ler o conteúdo de texto dos elementos, consulte o <xref:System.Xml.XmlReader.ReadString%2A> método. O exemplo a seguir processa elementos usando um `while` loop.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
<a name="xmlreader_attributes"></a>   
## <a name="reading-xml-attributes"></a>Atributos XML de leitura  
 Atributos XML são mais comumente encontrados nos elementos, mas eles também têm permissão na declaração XML e nós de tipo de documento.  
  
 Quando posicionado em um nó de elemento, o <xref:System.Xml.XmlReader.MoveToAttribute%2A> método permite que você percorra a lista de atributos do elemento. Observe que após <xref:System.Xml.XmlReader.MoveToAttribute%2A> tiver sido chamado, as propriedades de nó como <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, e <xref:System.Xml.XmlReader.Prefix%2A> refletir as propriedades desse atributo, não as propriedades do elemento de atributo pertence.  
  
 O <xref:System.Xml.XmlReader> classe fornece os métodos e propriedades para ler e processar atributos em elementos.  
  
|Use este <xref:System.Xml.XmlReader> membro|Para|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propriedade <xref:System.Xml.XmlReader.HasAttributes%2A>|Verifique se o nó atual tem todos os atributos.|  
|Propriedade <xref:System.Xml.XmlReader.AttributeCount%2A>|Obtém o número de atributos no elemento atual.|  
|Método <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>|Mover para o primeiro atributo em um elemento.|  
|Método <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>|Mover para o próximo atributo em um elemento.|  
|Método <xref:System.Xml.XmlReader.MoveToAttribute%2A>|Mover para um atributo especificado.|  
|<xref:System.Xml.XmlReader.GetAttribute%2A>método ou <xref:System.Xml.XmlReader.Item%2A> propriedade|Obter o valor de um atributo especificado.|  
|Propriedade <xref:System.Xml.XmlReader.IsDefault%2A>|Verifique se o nó atual é um atributo que foi gerado a partir o valor padrão definido no DTD ou no esquema.|  
|Método <xref:System.Xml.XmlReader.MoveToElement%2A>|Mover para o elemento que possui o atributo atual. Use este método para retornar a um elemento depois de navegar por meio de seus atributos.|  
|Método <xref:System.Xml.XmlReader.ReadAttributeValue%2A>|Analisar o valor do atributo em um ou mais `Text`, `EntityReference`, ou `EndEntity` nós.|  
  
 Alguns dos métodos e propriedades gerais de <xref:System.Xml.XmlReader> também podem ser usados para processar atributos. Por exemplo, depois que <xref:System.Xml.XmlReader> é posicionado em um atributo, as propriedades <xref:System.Xml.XmlReader.Name%2A> e <xref:System.Xml.XmlReader.Value%2A> refletem os valores do atributo. Você também pode usar qualquer um dos métodos de conteúdo de `Read` para obter o valor do atributo.  
  
 Este exemplo usa o <xref:System.Xml.XmlReader.AttributeCount%2A> propriedade para navegar por todos os atributos em um elemento.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 Este exemplo usa o <xref:System.Xml.XmlReader.MoveToNextAttribute%2A> método em um `while` loop para navegar por meio dos atributos.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 **Atributos de leitura em nós de declaração XML**  
  
 Quando o leitor XML está posicionado em um nó de declaração XML, o <xref:System.Xml.XmlReader.Value%2A> propriedade retorna as informações de versão, autônoma e codificação como uma única cadeia de caracteres. <xref:System.Xml.XmlReader>objetos criados pelo <xref:System.Xml.XmlReader.Create%2A> método, o <xref:System.Xml.XmlTextReader> classe e o <xref:System.Xml.XmlValidatingReader> classe expõe a versão, autônoma e codificação itens como atributos.  
  
 **Atributos de leitura em nós de tipo de documento**  
  
 Quando o leitor XML está posicionado em um nó de tipo de documento, o <xref:System.Xml.XmlReader.GetAttribute%2A> método e <xref:System.Xml.XmlReader.Item%2A> propriedade pode ser usada para retornar os valores para os literais de sistema e público. Por exemplo, a chamada de `reader.GetAttribute("PUBLIC")` retorna o valor PUBLIC.  
  
 **Lendo os atributos em nós de instrução de processamento**  
  
 Quando o <xref:System.Xml.XmlReader> é posicionado em um nó de instrução de processamento, a propriedade <xref:System.Xml.XmlReader.Value%2A> retorna todo o conteúdo de texto. Os itens no nó de instrução de processamento não são tratados como atributos. Eles não poderão ser lidos com o <xref:System.Xml.XmlReader.GetAttribute%2A> ou <xref:System.Xml.XmlReader.MoveToAttribute%2A> método.  
  
<a name="xmlreader_content"></a>   
## <a name="reading-xml-content"></a>Conteúdo XML de leitura  
 A classe XMLReader inclui os seguintes membros que leem o conteúdo de um arquivo XML e retornam o conteúdo como valores de cadeia de caracteres. (Para retornar tipos CLR, consulte o [próxima seção](#xmlreader_clr).)  
  
|Use este <xref:System.Xml.XmlReader> membro|Para|  
|---------------------------------------------------------------------------------------------------------------------------------------------------|--------|  
|Propriedade <xref:System.Xml.XmlReader.Value%2A>|Obter o conteúdo de texto do nó atual. O valor retornado depende do tipo de nó; Consulte o <xref:System.Xml.XmlReader.Value%2A> página de referência para obter detalhes.|  
|Método <xref:System.Xml.XmlReader.ReadString%2A>|Obter o conteúdo de um nó de elemento ou texto como uma cadeia de caracteres. Esse método interrompe no processamento de instruções e comentários.<br /><br /> Para obter detalhes sobre como esse método manipula os tipos de nó específico, consulte o <xref:System.Xml.XmlReader.ReadString%2A> página de referência.|  
|Métodos <xref:System.Xml.XmlReader.ReadInnerXml%2A> e <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>|Obter todo o conteúdo do nó atual, inclusive a marcação, mas excluindo marcas de início e término. Por exemplo, para:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadInnerXml%2A>Retorna:<br /><br /> `this<child id="123"/>`|  
|Métodos <xref:System.Xml.XmlReader.ReadOuterXml%2A> e <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>|Obter todo o conteúdo do nó atual e seus filhos, inclusive as marcas de marcação e início/término. Por exemplo, para:<br /><br /> `<node>this<child id="123"/></node>`<br /><br /> <xref:System.Xml.XmlReader.ReadOuterXml%2A>Retorna:<br /><br /> `<node>this<child id="123"/></node>`|  
  
<a name="xmlreader_clr"></a>   
## <a name="converting-to-clr-types"></a>Conversão para tipos CLR  
 Você pode usar os membros de <xref:System.Xml.XmlReader> classe (listado na tabela a seguir) para ler dados XML e tipos de retorno valores como common language runtime (CLR) em vez de cadeias de caracteres. Esses membros permitem obter valores na representação que é mais apropriada para sua tarefa de codificação sem precisar analisar manualmente ou converter valores de cadeia de caracteres.  
  
-   O **ReadElementContentAs** métodos só podem ser chamados em tipos de nó de elemento. Esses métodos não podem ser usados em elementos que contêm os elementos filho ou o conteúdo misturado. Quando chamado, o objeto de <xref:System.Xml.XmlReader> ler a tag de início, lê o conteúdo do elemento, e então move após a marca do elemento de extremidade. Instruções de processamento e comentários são ignorados e as entidades são expandidas.  
  
-   O **ReadContentAs**métodos ler o conteúdo de texto na posição atual do leitor e se os dados XML não tem qualquer esquema ou os dados associadas a ela, de informações de tipo de converter o conteúdo de texto para o tipo de retorno solicitado. Texto, o espaço em branco, o espaço em branco significativo e seções CDATA são concatenados. Comentários e instruções de processamento são ignoradas e referências a entidades são resolvidas automaticamente.  
  
 O <xref:System.Xml.XmlReader> classe usa as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://www.w3.org/TR/xmlschema-2/)recomendação.  
  
|Use este <xref:System.Xml.XmlReader> método|Para retornar a este tipo CLR|  
|--------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------|  
|<xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsBoolean%2A>|<xref:System.Boolean>|  
|<xref:System.Xml.XmlReader.ReadContentAsDateTime%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A>|<xref:System.DateTime>|  
|<xref:System.Xml.XmlReader.ReadContentAsDouble%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsDouble%2A>|<xref:System.Double>|  
|<xref:System.Xml.XmlReader.ReadContentAsLong%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A>|<xref:System.Int64>|  
|<xref:System.Xml.XmlReader.ReadContentAsInt%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsInt%2A>|<xref:System.Int32>|  
|<xref:System.Xml.XmlReader.ReadContentAsString%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>|<xref:System.String>|  
|<xref:System.Xml.XmlReader.ReadContentAs%2A> e <xref:System.Xml.XmlReader.ReadElementContentAs%2A>|O tipo especificado com o `returnType` parâmetro|  
|<xref:System.Xml.XmlReader.ReadContentAsObject%2A> e <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>|O tipo mais apropriado, conforme especificado pelo <xref:System.Xml.XmlReader.ValueType%2A?displayProperty=nameWithType> propriedade. Consulte [suporte a tipo nas Classes System. XML](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) para informações de mapeamento.|  
  
 Se um elemento facilmente não pode ser convertido em um tipo CLR devido a seu formato, você pode usar um mapeamento de esquema para garantir uma conversão bem-sucedida. O exemplo a seguir usa um arquivo. xsd para converter o `hire-date` elemento para o `xs:date` tipo e, em seguida, usa o <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> método para retornar o elemento como um <xref:System.DateTime> objeto.  
  
 **Entrada (hireDate.xml):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#9](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xml#9)]  
  
 **Esquema (hireDate.xsd):**  
  
 [!code-xml[XmlReader.ReadElementContentAs#10](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/hireDate.xsd#10)]  
  
 **Código:**  
  
 [!code-csharp[XmlReader.ReadElementContentAs#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#13)]
 [!code-vb[XmlReader.ReadElementContentAs#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#13)]  
  
 **Saída:**  
  
```  
Six Month Review Date:  7/8/2003 12:00:00 AM  
```  
  
<a name="xmlreader_async"></a>   
## <a name="asynchronous-programming"></a>Programação assíncrona  
 A maioria do <xref:System.Xml.XmlReader> métodos têm assíncronas correspondentes que têm "Async" ao final de seus nomes de método. Por exemplo, o equivalente assíncrono de <xref:System.Xml.XmlReader.ReadContentAsObject%2A> é <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 Os métodos a seguir podem ser usados com chamadas de método assíncrono:  
  
-   <xref:System.Xml.XmlReader.GetAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToNextAttribute%2A>  
  
-   <xref:System.Xml.XmlReader.MoveToElement%2A>  
  
-   <xref:System.Xml.XmlReader.ReadAttributeValue%2A>  
  
-   <xref:System.Xml.XmlReader.ReadSubtree%2A>  
  
-   <xref:System.Xml.XmlReader.ResolveEntity%2A>  
  
 As seções a seguir descrevem o uso assíncrono para métodos que não têm contrapartes assíncronas.  
  
 **Método ReadStartElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#1)]
 [!code-vb[System.Xml.XmlReader.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#1)]  
  
 **Método ReadEndElement**  
  
 [!code-csharp[System.Xml.XmlReader.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#2)]
 [!code-vb[System.Xml.XmlReader.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#2)]  
  
 **Método ReadToNextSibling**  
  
 [!code-csharp[System.Xml.XmlReader.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#3)]
 [!code-vb[System.Xml.XmlReader.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#3)]  
  
 **Método ReadToFollowing**  
  
 [!code-csharp[System.Xml.XmlReader.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#4)]
 [!code-vb[System.Xml.XmlReader.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#4)]  
  
 **Método ReadToDescendant**  
  
 [!code-csharp[System.Xml.XmlReader.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#5)]
 [!code-vb[System.Xml.XmlReader.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#5)]  
  
<a name="xmlreader_security"></a>   
## <a name="security-considerations"></a>Considerações sobre segurança  
 Considere o seguinte ao trabalhar com o <xref:System.Xml.XmlReader> classe:  
  
-   Exceções geradas pelo <xref:System.Xml.XmlReader> pode divulgar informações de caminho que não podem ser transferidos para seu aplicativo. Seu aplicativo deve capturar exceções e processá-los corretamente.  
  
-   Não habilite o processamento de DTD se você estiver preocupado com a negação de problemas de serviço ou se você estiver lidando com fontes não confiáveis. Processamento do DTD é desabilitado por padrão para <xref:System.Xml.XmlReader> objetos criados pelo <xref:System.Xml.XmlReader.Create%2A> método.  
  
     Se você tiver o processamento de DTD ativado, você pode usar <xref:System.Xml.XmlSecureResolver> para restringir os recursos que <xref:System.Xml.XmlReader> pode acessar. Você também pode criar seu aplicativo para que o processamento de XML é a memória e tempo restrito. Por exemplo, você pode configurar os limites de tempo limite em seu aplicativo ASP.NET.  
  
-   Os dados XML podem incluir referências a recursos externos como um arquivo de esquema. Por padrão, os recursos externos são resolvidos usando um <xref:System.Xml.XmlUrlResolver> objeto sem credenciais de usuário. Você pode proteger este adicional seguindo um destes procedimentos:  
  
    -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
  
    -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> a `null`.  
  
-   O <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> e <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> sinalizadores de validação de um <xref:System.Xml.XmlReaderSettings> objeto não são definidas por padrão. Isso ajuda a proteger contra ataques <xref:System.Xml.XmlReader> baseados esquema- quando está processando dados de uma fonte não confiável. Quando esses sinalizadores são definidos, <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> do objeto de <xref:System.Xml.XmlReaderSettings> é usado para resolver os locais de esquema encontrados no documento de instância em <xref:System.Xml.XmlReader>. Se o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> está definida como `null`, locais de esquema não são resolvidos até mesmo se o <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema> e <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessSchemaLocation> validação sinalizadores são definidos.  
  
     Os esquemas adicionados durante a validação adicionar novos tipos e podem alterar o resultado de validação de documento que está sendo validada. Como resultado, os esquemas externos só devem ser resolvidos de fontes confiáveis.  
  
     É recomendável desabilitar a <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints> sinalizador ao validar documentos XML grandes não confiáveis em cenários de alta disponibilidade em um esquema que tem restrições de identidade em uma grande parte do documento. Esse sinalizador é habilitado por padrão.  
  
-   Os dados XML podem conter um grande número de declarações de atributos, namespace, elementos aninhados e assim por diante que exigem um montante considerável de tempo de processamento. Para limitar o tamanho da entrada que é enviado para o <xref:System.Xml.XmlReader>, você pode:  
  
    -   Limitar o tamanho do documento, definindo o <xref:System.Xml.XmlReaderSettings.MaxCharactersInDocument%2A> propriedade.  
  
    -   Limitar o número de caracteres que resultam de expandir entidades definindo o <xref:System.Xml.XmlReaderSettings.MaxCharactersFromEntities%2A> propriedade.  
  
    -   Criar um personalizado `IStream` implementação para o <xref:System.Xml.XmlReader>.  
  
-   O <xref:System.Xml.XmlReader.ReadValueChunk%2A> método pode ser usado para lidar com grandes fluxos de dados. Este método lê um pequeno número de caracteres de cada vez em vez de atribuir uma única cadeia de caracteres para o valor inteiro.  
  
-   Ao ler um documento XML com um grande número de prefixos, namespaces ou nomes exclusivos de locais, pode ocorrer um problema. Se você estiver usando uma classe que deriva de <xref:System.Xml.XmlReader>, e você chamar o <xref:System.Xml.XmlReader.LocalName%2A>, <xref:System.Xml.XmlReader.Prefix%2A>, ou <xref:System.Xml.XmlReader.NamespaceURI%2A> propriedade para cada item, a cadeia de caracteres retornada é adicionada a um <xref:System.Xml.NameTable>. A coleção mantida pelo <xref:System.Xml.NameTable> nunca diminui de tamanho, criando um vazamento de memória virtual dos identificadores de cadeia de caracteres. Uma redução para isso é derivar de <xref:System.Xml.NameTable> classe e impor uma cota de tamanho máximo. (Não é possível para evitar o uso de um <xref:System.Xml.NameTable>, ou alternar o <xref:System.Xml.NameTable> quando ele estiver cheio). Mitigação de outra é evitar o uso das propriedades mencionadas e em vez disso, use o <xref:System.Xml.XmlReader.MoveToAttribute%2A> método com o <xref:System.Xml.XmlReader.IsStartElement%2A> método sempre que possível; esses métodos não retornar cadeias de caracteres e, portanto, evitar o problema de sobrecarga do <xref:System.Xml.NameTable> coleção.  
  
-   os objetos de<xref:System.Xml.XmlReaderSettings> podem conter informações sigilosas como credenciais do usuário. Um componente não confiável pode usar o objeto de <xref:System.Xml.XmlReaderSettings> e suas credenciais de usuário para criar objetos de <xref:System.Xml.XmlReader> para ler dados. Tenha cuidado ao armazenar em cache <xref:System.Xml.XmlReaderSettings> objetos, ou ao passar o <xref:System.Xml.XmlReaderSettings> objeto de um componente para outro.  
  
-   Aceitar componentes de suporte, como <xref:System.Xml.NameTable>, <xref:System.Xml.XmlNamespaceManager>, e objetos de <xref:System.Xml.XmlResolver> , de uma fonte não confiável.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar a análise de APIto assíncrona XML.  
  
 [!code-csharp[System.Xml.XmlReader.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.xml.xmlreader.class/cs/program.cs#6)]
 [!code-vb[System.Xml.XmlReader.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.xml.xmlreader.class/vb/module1.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see langword="XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor é chamado pelos construtores de classe derivada para inicializar o estado nesse tipo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public abstract int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o número de atributos no nó atual.</summary>
        <value>O número de atributos no nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é relevante para `Element`, `DocumentType` e `XmlDeclaration` apenas nós. (Outros tipos de nó não tem atributos.)  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos do nó atual.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public abstract string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém a URI base do nó atual.</summary>
        <value>O URI de base do nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um documento XML em rede é composto de partes de dados agregados usando vários mecanismos de inclusão padrão do W3C e, portanto, contém nós que vêm de diferentes locais. Entidades DTD são um exemplo disto, mas isso não é limitado para DTDs. A base de URI informa onde veio esses nós. Se não houver nenhum URI de base para os nós que estão sendo retornados (por exemplo, eles foram analisados de uma cadeia de caracteres na memória), `String.Empty` será retornado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public virtual bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Xml.XmlReader" /> implementa o conteúdo binário de métodos de leitura.</summary>
        <value>
          <see langword="true" />Se os métodos de leitura de conteúdo binários são implementados; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conteúdo binário de leitura métodos incluem o <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, e <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A> métodos. Se essa propriedade retorna `false` um <xref:System.NotSupportedException> é retornado quando qualquer binário ler métodos é chamado.  
  
 Todas as implementações do Microsoft .NET Framework do <xref:System.Xml.XmlReader> classe retorno `true` para essa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Xml.XmlReader" /> implementa o <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> método.</summary>
        <value>
          <see langword="true" />Se o <see cref="T:System.Xml.XmlReader" /> implementa o <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> método; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Análise de texto <xref:System.Xml.XmlReader> objetos que foram criados a partir estático <xref:System.Xml.XmlReader.Create%2A> método sempre retornam `true`. Todas as outras implementações do Microsoft .NET Framework a <xref:System.Xml.XmlReader> classe, incluindo o <xref:System.Xml.XmlTextReader> classe, retorne `false`.  
  
 Se essa propriedade retorna `false` um <xref:System.NotSupportedException> é retornado quando o <xref:System.Xml.XmlReader.ReadValueChunk%2A> método é chamado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public virtual bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se este leitor pode analisar e resolver entidades.</summary>
        <value>
          <see langword="true" />Se o leitor pode analisar e resolver entidades; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade sempre retorna `false` para implementações de <xref:System.Xml.XmlReader> que não dão suporte a informações de DTD. Nesse caso, chamando <xref:System.Xml.XmlReader.ResolveEntity%2A> lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public virtual void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Close" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, altera o <see cref="P:System.Xml.XmlReader.ReadState" /> para <see cref="F:System.Xml.ReadState.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método também libera os recursos mantidos durante a leitura. Se <xref:System.Xml.XmlReader.Close%2A> já foi chamado, nenhuma ação é executada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A maioria do <xref:System.Xml.XmlReader.Create%2A> sobrecargas incluem um `settings` parâmetro que aceita uma <xref:System.Xml.XmlReaderSettings> objeto. Você pode usar esse objeto para:  
  
-   Especificar quais recursos você deseja oferecem suporte a <xref:System.Xml.XmlReader> objeto.  
  
-   Reutilizar o <xref:System.Xml.XmlReaderSettings> objeto para criar vários leitores. Você pode usar as mesmas configurações para criar vários leitores com a mesma funcionalidade. Ou, você pode modificar as configurações em um <xref:System.Xml.XmlReaderSettings> de instância e criar um novo leitor com um conjunto diferente de recursos.  
  
-   Adicione recursos a um leitor de XML existente. O método <xref:System.Xml.XmlReader.Create%2A> pode aceitar outro objeto <xref:System.Xml.XmlReader>. Subjacente <xref:System.Xml.XmlReader> objeto pode ser um leitor definida pelo usuário, um <xref:System.Xml.XmlTextReader> objeto ou outra <xref:System.Xml.XmlReader> instância que você deseja adicionar recursos adicionais.  
  
-   Tirar total proveito dos recursos, como verificação de conformidade melhor e conformidade para o [XML 1.0 (quarta edição)](http://www.w3.org/TR/2006/REC-xml-20060816/)recomendação que estão disponíveis apenas em <xref:System.Xml.XmlReader> objetos criados por estático <xref:System.Xml.XmlReader.Create%2A> método.  
  
> [!NOTE]
>  Embora o .NET Framework inclui implementações concretas do <xref:System.Xml.XmlReader> classe, como o <xref:System.Xml.XmlTextReader>, <xref:System.Xml.XmlNodeReader>e o <xref:System.Xml.XmlValidatingReader> classes, recomendamos que você crie <xref:System.Xml.XmlReader> instâncias usando o <xref:System.Xml.XmlReader.Create%2A> método.  
  
## <a name="default-settings"></a>Configurações padrão  
 Se você usar um <xref:System.Xml.XmlReader.Create%2A> sobrecarga que não aceita um <xref:System.Xml.XmlReaderSettings> do objeto, as seguintes configurações do leitor são usadas:  
  
|Configuração|Padrão|  
|-------------|-------------|  
|<xref:System.Xml.XmlReaderSettings.CheckCharacters%2A>|`true`|  
|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>|<xref:System.Xml.ConformanceLevel?displayProperty=nameWithType>|  
|<xref:System.Xml.XmlReaderSettings.IgnoreComments%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreProcessingInstructions%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.IgnoreWhitespace%2A>|`false`|  
|<xref:System.Xml.XmlReaderSettings.LineNumberOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.LinePositionOffset%2A>|0|  
|<xref:System.Xml.XmlReaderSettings.NameTable%2A>|`null`|  
|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A>|<xref:System.Xml.DtdProcessing.Prohibit>|  
|<xref:System.Xml.XmlReaderSettings.Schemas%2A>|Um objeto <xref:System.Xml.Schema.XmlSchemaSet> vazio|  
|<xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>|<xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessIdentityConstraints>habilitado|  
|<xref:System.Xml.XmlReaderSettings.ValidationType%2A>|<xref:System.Xml.ValidationType.None>|  
|<xref:System.Xml.XmlReaderSettings.XmlResolver%2A>|Um novo objeto <xref:System.Xml.XmlUrlResolver>.  Começando com o .NET Framework 4.5.2, essa configuração tem um valor padrão de `null`.|  
  
## <a name="settings-for-common-scenarios"></a>Configurações para cenários comuns  
 Aqui estão as <xref:System.Xml.XmlReaderSettings> propriedades deve ser definida para alguns dos cenários típicos de leitor XML.  
  
|Requisito|Definir|  
|-----------------|---------|  
|Dados devem ser um documento XML bem formado.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>to <xref:System.Xml.ConformanceLevel.Document>.|  
|Dados devem ser uma entidade analisada de XML bem formada.|<xref:System.Xml.XmlReaderSettings.ConformanceLevel%2A>to <xref:System.Xml.ConformanceLevel.Fragment>.|  
|Dados devem ser validados em relação a um DTD.|<xref:System.Xml.XmlReaderSettings.DtdProcessing%2A> a <xref:System.Xml.DtdProcessing.Parse><br /><xref:System.Xml.XmlReaderSettings.ValidationType%2A>to <xref:System.Xml.ValidationType.DTD>.|  
|Dados devem ser validados em relação a um esquema XML.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> a <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A>para o <xref:System.Xml.Schema.XmlSchemaSet> será usado para validação. Observe que <xref:System.Xml.XmlReader> não oferece suporte a validação de esquema XML-Data Reduced (XDR).|  
|Dados devem ser validados em relação a um esquema XML embutido.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> a <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.ValidationFlags%2A>to <xref:System.Xml.Schema.XmlSchemaValidationFlags.ProcessInlineSchema>.|  
|Suporte ao tipo.|<xref:System.Xml.XmlReaderSettings.ValidationType%2A> a <xref:System.Xml.ValidationType.Schema><br /><xref:System.Xml.XmlReaderSettings.Schemas%2A>para o <xref:System.Xml.Schema.XmlSchemaSet> para usar.|  
  
 <xref:System.Xml.XmlReader>não dá suporte a validação de esquema XML-Data Reduced (XDR).  
  
## <a name="asynchronous-programming"></a>Programação assíncrona  
 No modo síncrono, o <xref:System.Xml.XmlReader.Create%2A> método lê a primeira parte de dados do buffer do leitor de texto, arquivo ou fluxo. Isso pode gerar uma exceção se uma operação de e/s falhar. No modo assíncrono, a primeira operação de e/s ocorre com uma operação de leitura, portanto as exceções que podem surgir serão geradas quando ocorre a operação de leitura.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Por padrão, o <xref:System.Xml.XmlReader> usa um <xref:System.Xml.XmlUrlResolver> objeto sem credenciais de usuário para abrir os recursos. Isso significa que, por padrão, o leitor de XML pode acessar qualquer local que não requer credenciais. Use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriedade para controlar o acesso aos recursos:  
  
-   Definir <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> para um <xref:System.Xml.XmlSecureResolver> objeto para restringir os recursos que pode acessar o leitor de XML.  
  
 -ou-  
  
-   Definir <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> para `null` para impedir que o leitor de XML abrir todos os recursos externos.  
  
   
  
## Examples  
 Este exemplo cria um leitor de XML que retira um espaço em branco insignificante, retira comentários e executa a verificação de conformidade do nível de fragmento.  
  
 [!code-csharp[XmlReader.Create#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#11)]
 [!code-vb[XmlReader.Create#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#11)]  
  
 O exemplo a seguir usa um <xref:System.Xml.XmlUrlResolver> com as credenciais padrão para acessar um arquivo.  
  
 [!code-cpp[XmlReaderSettings.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#1)]
 [!code-csharp[XmlReaderSettings.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#1)]
 [!code-vb[XmlReaderSettings.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#1)]  
  
 [!code-cpp[XmlReaderSettings.cctor#2](~/samples/snippets/cpp/VS_Snippets_Data/XmlReaderSettings.cctor/CPP/XmlReaderSettings.cctor.cpp#2)]
 [!code-csharp[XmlReaderSettings.cctor#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderSettings.cctor/CS/factory_rdr_cctor2.cs#2)]
 [!code-vb[XmlReaderSettings.cctor#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderSettings.cctor/VB/factory_rdr_cctor2.vb#2)]  
  
 O código a seguir encapsula uma instância do leitor dentro de outro leitor.  
  
 [!code-csharp[XmlReader.Create#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#13)]
 [!code-vb[XmlReader.Create#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#13)]  
  
 Este exemplo encadeia leitores para adicionar validação de esquema DTD e XML.  
  
 [!code-csharp[XmlReader.Create#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#12)]
 [!code-vb[XmlReader.Create#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  
  
 O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo de busca de uma marca de ordem de byte ou outra entrada de codificação. Quando a codificação é determinada, a codificação é usada para continuar a ler o fluxo e processamento continuará ao analisar a entrada como um fluxo de caracteres (Unicode).</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando o fluxo especificado com as configurações padrão.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xml.XmlReaderSettings> objeto com as configurações padrão é usado para criar o leitor. Se você quiser especificar os recursos para dar suporte ao leitor de criado, use a sobrecarga que utiliza um <xref:System.Xml.XmlReaderSettings> de objeto como um de seus argumentos e passar uma <xref:System.Xml.XmlReaderSettings> objeto com as configurações corretas.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando a <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Xml.XmlReader> objeto lê de um <xref:System.IO.FileStream>.  
  
 [!code-csharp[XmlReader.Create#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#8)]
 [!code-vb[XmlReader.Create#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Xml.XmlReader" /> não tem permissões suficientes para acessar o local dos dados XML.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode para a codificação especificada na declaração XML não é usada pelo leitor de XML para decodificar o fluxo de dados.</param>
        <summary>Cria uma nova instância de <see cref="T:System.Xml.XmlReader" /> usando o leitor de texto especificado.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xml.XmlReaderSettings> objeto com as configurações padrão é usado para criar o leitor. Se você quiser especificar os recursos para dar suporte ao leitor de criado, use a sobrecarga que utiliza um <xref:System.Xml.XmlReaderSettings> de objeto como um de seus argumentos e passar uma <xref:System.Xml.XmlReaderSettings> objeto com as configurações corretas.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando a <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir usa a <xref:System.IO.StringReader> classe ler uma cadeia de caracteres XML.  
  
 [!code-csharp[XmlReader.Create#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#7)]
 [!code-vb[XmlReader.Create#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="inputUri">O URI para o arquivo que contém os dados XML. O <see cref="T:System.Xml.XmlUrlResolver" /> classe é usada para converter o caminho em uma representação de dados canônica.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> com o URI especificado.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Xml.XmlReaderSettings> objeto com as configurações padrão é usado para criar o leitor. Se você quiser especificar os recursos para dar suporte ao leitor de criado, use a sobrecarga que utiliza um <xref:System.Xml.XmlReaderSettings> de objeto como um de seus argumentos e passar uma <xref:System.Xml.XmlReaderSettings> objeto com as configurações corretas.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando a <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Xml.XmlReader> objeto que lê o arquivo de dados XML especificado pelo URI.  
  
 [!code-csharp[XmlReader.Create#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#6)]
 [!code-vb[XmlReader.Create#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="inputUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Xml.XmlReader" /> não tem permissões suficientes para acessar o local dos dados XML.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo identificado pelo URI não existe.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>  
  
 O formato de URI não está correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  
  
 O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo de busca de uma marca de ordem de byte ou outra entrada de codificação. Quando a codificação é determinada, a codificação é usada para continuar a ler o fluxo e processamento continuará ao analisar a entrada como um fluxo de caracteres (Unicode).</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância. Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> com as configurações e o fluxo especificado.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  -ou-  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode para a codificação especificada na declaração XML não é usada pelo leitor de XML para decodificar o fluxo de dados.</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" />. Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância do <see cref="T:System.Xml.XmlReader" /> usando as configurações e o leitor de texto especificados.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  -ou-  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="inputUri">O URI do arquivo que contém os dados XML. O <see cref="T:System.Xml.XmlResolver" /> do objeto no <see cref="T:System.Xml.XmlReaderSettings" /> objeto é usado para converter o caminho em uma representação de dados canônica. Se <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> é <see langword="null" />, um novo <see cref="T:System.Xml.XmlUrlResolver" /> objeto é usado.</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância. Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando o URI e as configurações especificados.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Isso significa que o <xref:System.Xml.XmlReader> pode acessar os locais que não requer autenticação. Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode restringir os recursos que o <xref:System.Xml.XmlReader> pode acessar, definindo o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriedade para um <xref:System.Xml.XmlSecureResolver> objeto.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Xml.XmlReader> objeto que oferece suporte à validação de DTD (definição) de tipo de documento.  
  
 [!code-csharp[XmlReader.Create#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#3)]
 [!code-vb[XmlReader.Create#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="inputUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível encontrar o arquivo especificado pelo URI.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>  
 No [.NET para aplicativos Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou [biblioteca de classes portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capturar a exceção de classe base, <see cref="T:System.FormatException" />, em vez disso.  
  
</para>
          </block>  
  
 O formato de URI não está correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.Xml.XmlReader reader, System.Xml.XmlReaderSettings settings);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.Xml.XmlReader reader, class System.Xml.XmlReaderSettings settings) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.Xml.XmlReader,System.Xml.XmlReaderSettings)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
      </Parameters>
      <Docs>
        <param name="reader">O objeto que você deseja usar como o leitor XML subjacente.</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância.  
  
 O nível de conformidade do <see cref="T:System.Xml.XmlReaderSettings" /> objeto seja deve corresponder o nível de conformidade do leitor subjacente ou deve ser definida como <see cref="F:System.Xml.ConformanceLevel.Auto" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as configurações e o leitor XML especificados.</summary>
        <returns>Um objeto encapsulado em torno do objeto <see cref="T:System.Xml.XmlReader" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método permite que você adicionar recursos adicionais para um subjacente <xref:System.Xml.XmlReader> objeto. Subjacente <xref:System.Xml.XmlReader> objeto pode ser outro <xref:System.Xml.XmlReader> objeto criado pelo <xref:System.Xml.XmlReader.Create%2A> método, ou uma <xref:System.Xml.XmlReader> objeto criado usando um dos concretos <xref:System.Xml.XmlReader> implementações.  
  
 Um padrão <xref:System.Xml.XmlUrlResolver> com nenhuma credencial é usada para acessar recursos externos, como um esquema.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, especifique um <xref:System.Xml.XmlResolver> com as credenciais necessárias usando a <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  -ou-  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria uma validação <xref:System.Xml.XmlReader> objeto que é encapsulado em torno de uma <xref:System.Xml.XmlNodeReader> objeto.  
  
 [!code-csharp[XmlReader.Create#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#5)]
 [!code-vb[XmlReader.Create#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="reader" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Se o objeto <see cref="T:System.Xml.XmlReaderSettings" /> especificar um nível de conformidade que não é consistente com o nível de conformidade do leitor subjacente.  
  
 -ou-  
  
 O <see cref="T:System.Xml.XmlReader" /> subjacente está em um estado <see cref="F:System.Xml.ReadState.Error" /> ou <see cref="F:System.Xml.ReadState.Closed" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  
  
 O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo de busca de uma marca de ordem de byte ou outra entrada de codificação. Quando a codificação é determinada, a codificação é usada para continuar a ler o fluxo e processamento continuará ao analisar a entrada como um fluxo de caracteres (Unicode).</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância. Este valor pode ser <see langword="null" />.</param>
        <param name="baseUri">O URI de base para a entidade ou o documento que está sendo lido. Este valor pode ser <see langword="null" />.  
  
 **Observação de segurança** a base de URI é usado para resolver o URI relativo do documento XML. Não use um URI base de uma fonte não confiável.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando o fluxo, o URI base e as configurações especificadas.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  -ou-  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.Stream input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.Stream input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.Stream,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">O fluxo que contém os dados XML.  
  
 O <see cref="T:System.Xml.XmlReader" /> examina os primeiros bytes do fluxo de busca de uma marca de ordem de byte ou outra entrada de codificação. Quando a codificação é determinada, a codificação é usada para continuar a ler o fluxo e processamento continuará ao analisar a entrada como um fluxo de caracteres (Unicode).</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância. Este valor pode ser <see langword="null" />.</param>
        <param name="inputContext">As informações de contexto necessárias para analisar o fragmento XML. As informações de contexto podem incluir o <see cref="T:System.Xml.XmlNameTable" /> atual, codificação, o escopo de namespace, use <c>XML: lang</c> e <c>XML: space</c> escopo, URI de base e definição de tipo de documento.  
  
 Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as informações de fluxo, configurações e contexto especificadas para análise.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  -ou-  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, string baseUri);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, string baseUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="baseUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode para a codificação especificada na declaração XML não é usada pelo <see cref="T:System.Xml.XmlReader" /> para decodificar o fluxo de dados.</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância. Este valor pode ser <see langword="null" />.</param>
        <param name="baseUri">O URI de base para a entidade ou o documento que está sendo lido. Este valor pode ser <see langword="null" />.  
  
 **Observação de segurança** a base de URI é usado para resolver o URI relativo do documento XML. Não use um URI base de uma fonte não confiável.</param>
        <summary>Cria um novo <see cref="T:System.Xml.XmlReader" /> instância usando o leitor de texto especificado, as configurações e o URI de base.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  -ou-  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (System.IO.TextReader input, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(class System.IO.TextReader input, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.IO.TextReader,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="input">O leitor de texto do qual os dados XML serão lidos. Um leitor de texto retorna um fluxo de caracteres de Unicode para a codificação especificada na declaração XML não é usada pelo leitor de XML para decodificar o fluxo de dados.</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância. Este valor pode ser <see langword="null" />.</param>
        <param name="inputContext">As informações de contexto necessárias para analisar o fragmento XML. As informações de contexto podem incluir o <see cref="T:System.Xml.XmlNameTable" /> atual, codificação, o escopo de namespace, use <c>XML: lang</c> e <c>XML: space</c> escopo, URI de base e definição de tipo de documento.  
  
 Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as informações de contexto, de configurações e do leitor de texto especificadas para análise.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode usar um dos seguintes métodos para controlar quais recursos o <xref:System.Xml.XmlReader> pode acessar:  
>   
>  -   Restringir os recursos que <xref:System.Xml.XmlReader> pode acessar definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a um objeto de <xref:System.Xml.XmlSecureResolver> .  
>   
>  -ou-  
>   
>  -   Não permita que <xref:System.Xml.XmlReader> abra os recursos externos definindo a propriedade de <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> a `null`.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Xml.XmlReader> objeto que lê um fragmento XML.  
  
 [!code-csharp[XmlReader.Create#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.Create/CS/XmlReader_Create.cs#1)]
 [!code-vb[XmlReader.Create#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.Create/VB/XmlReader_Create.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="input" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> e <see cref="P:System.Xml.XmlParserContext.NameTable" /> ambas as propriedades contêm valores. (Somente uma dessas propriedades <see langword="NameTable" /> podem ser definidas e usadas).</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Xml.XmlReader Create (string inputUri, System.Xml.XmlReaderSettings settings, System.Xml.XmlParserContext inputContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Xml.XmlReader Create(string inputUri, class System.Xml.XmlReaderSettings settings, class System.Xml.XmlParserContext inputContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Create(System.String,System.Xml.XmlReaderSettings,System.Xml.XmlParserContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inputUri" Type="System.String" />
        <Parameter Name="settings" Type="System.Xml.XmlReaderSettings" />
        <Parameter Name="inputContext" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="inputUri">O URI do arquivo que contém os dados XML. O <see cref="T:System.Xml.XmlResolver" /> do objeto no <see cref="T:System.Xml.XmlReaderSettings" /> objeto é usado para converter o caminho em uma representação de dados canônica. Se <see cref="P:System.Xml.XmlReaderSettings.XmlResolver" /> é <see langword="null" />, um novo <see cref="T:System.Xml.XmlUrlResolver" /> objeto é usado.</param>
        <param name="settings">As configurações para o novo <see cref="T:System.Xml.XmlReader" /> instância. Este valor pode ser <see langword="null" />.</param>
        <param name="inputContext">As informações de contexto necessárias para analisar o fragmento XML. As informações de contexto podem incluir o <see cref="T:System.Xml.XmlNameTable" /> atual, codificação, o escopo de namespace, use <c>XML: lang</c> e <c>XML: space</c> escopo, URI de base e definição de tipo de documento.  
  
 Este valor pode ser <see langword="null" />.</param>
        <summary>Cria uma nova instância <see cref="T:System.Xml.XmlReader" /> usando as informações de URI, de configurações e de contexto especificadas para análise.</summary>
        <returns>Um objeto usado para ler os dados XML no fluxo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão um <xref:System.Xml.XmlUrlResolver> sem credenciais é usado para acessar todos os recursos externos como uma definição de tipo de documento (DTD), entidades, esquemas e assim por diante.  
  
> [!IMPORTANT]
>  Começando com o .NET Framework 4.5.2, sem padrão <xref:System.Xml.XmlUrlResolver> é fornecido. Se sua solução tem como alvo o .NET Framework 4.5.2 ou versões posteriores, especifique um <xref:System.Xml.XmlResolver> usando o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade.  
  
 Isso significa que o <xref:System.Xml.XmlReader> pode acessar os locais que não requer autenticação. Se o recurso externo está localizado em um recurso de rede que requer autenticação, use o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A?displayProperty=nameWithType> propriedade para especificar um <xref:System.Xml.XmlResolver> com as credenciais necessárias.  
  
> [!IMPORTANT]
>  Você pode restringir os recursos que o <xref:System.Xml.XmlReader> pode acessar, definindo o <xref:System.Xml.XmlReaderSettings.XmlResolver%2A> propriedade para um <xref:System.Xml.XmlSecureResolver> objeto.  
  
 O criado <xref:System.Xml.XmlReader> objeto expande as referências de entidade e executa a normalização de XML de caracteres de nova linha.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <see langword="inputUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">O <see cref="T:System.Xml.XmlReader" /> não tem permissões suficientes para acessar o local dos dados XML.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="P:System.Xml.XmlReaderSettings.NameTable" /> e <see cref="P:System.Xml.XmlParserContext.NameTable" /> ambas as propriedades contêm valores. (Somente uma dessas propriedades <see langword="NameTable" /> podem ser definidas e usadas).</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não foi possível encontrar o arquivo especificado pelo URI.</exception>
        <exception cref="T:System.UriFormatException">O formato de URI não está correto.</exception>
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public abstract int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém a profundidade do nó atual no documento XML.</summary>
        <value>A profundidade do nó atual no documento XML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.Depth%2A> (no `XmlTextReader` classe) para um exemplo que usa essa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos usados pela instância atual da classe <see cref="T:System.Xml.XmlReader" />.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Dispose(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libera os recursos não gerenciados usados pelo <see cref="T:System.Xml.XmlReader" /> e opcionalmente libera os recursos gerenciados.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public abstract bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o leitor está posicionado no final do fluxo.</summary>
        <value>
          <see langword="true" />Se o leitor está posicionado no final do fluxo; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O índice do atributo. O índice é baseado em zero. (O primeiro atributo tem índice 0.)</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o índice especificado.</summary>
        <returns>O valor do atributo especificado. Esse método não move o leitor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir obtém o valor do atributo terceiro.  
  
 [!code-csharp[XmlReaderBasic#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#2)]
 [!code-vb[XmlReaderBasic#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="i" /> está fora do intervalo. Ele deve ser não-negativo e menor que o tamanho da coleção de atributos.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.Name" /> especificado.</summary>
        <returns>O valor do atributo especificado. Se o atributo não foi encontrado ou o valor é <see langword="String.Empty" />, <see langword="null" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não move o leitor.  
  
 Se o leitor estiver posicionado em um `DocumentType` nó, esse método pode ser usado para obter os literais PUBLIC e do sistema, por exemplo,`reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 O exemplo a seguir obtém o valor do atributo ISBN.  
  
 [!code-csharp[XmlReaderBasic#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#3)]
 [!code-vb[XmlReaderBasic#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public abstract string GetAttribute (string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetAttribute(string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetAttribute(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome local do atributo.</param>
        <param name="namespaceURI">O URI do namespace do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.LocalName" /> e o <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificados.</summary>
        <returns>O valor do atributo especificado. Se o atributo não foi encontrado ou o valor é <see langword="String.Empty" />, <see langword="null" /> será retornado. Esse método não move o leitor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O XML a seguir contém um atributo em um namespace específico:  
  
```  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Você pode pesquisar o `dt:type` de atributo usando um argumento (prefixo e o nome local) ou dois argumentos (nome local e URI de namespace):  
  
```  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 A pesquisa de `xmlns:dt` atributo, use um dos seguintes argumentos:  
  
```  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Você também pode obter essas informações usando o <xref:System.Xml.XmlReader.Prefix%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValueAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; GetValueAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; GetValueAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.GetValueAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o valor do nó atual de forma assíncrona.</summary>
        <returns>O valor do nó atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="HasAttributes">
      <MemberSignature Language="C#" Value="public virtual bool HasAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o nó atual tem atributos.</summary>
        <value>
          <see langword="true" />Se o nó atual possui atributos; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe todos os atributos do nó atual.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public virtual bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o nó atual pode ter um <see cref="P:System.Xml.XmlReader.Value" />.</summary>
        <value>
          <see langword="true" /> se o nó em que o leitor está posicionado no momento puder ter um <see langword="Value" />, caso contrário, <see langword="false" />. Se <see langword="false" />, o nó tem um valor de <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir lista os tipos de nós que têm um valor a ser retornado.  
  
|Tipo de nó|Valor|  
|---------------|-----------|  
|`Attribute`|O valor do atributo.|  
|`CDATA`|O conteúdo da seção CDATA.|  
|`Comment`|O conteúdo do comentário.|  
|`DocumentType`|O subconjunto interno.|  
|`ProcessingInstruction`|Todo o conteúdo, exceto o destino.|  
|`SignificantWhitespace`|O espaço em branco entre a marcação em um modelo de conteúdo misto.|  
|`Text`|O conteúdo do nó de texto.|  
|`Whitespace`|Espaço em branco entre a marcação.|  
|`XmlDeclaration`|O conteúdo da declaração.|  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.HasValue%2A> (no `XmlTextReader` classe) para obter um exemplo usando esse método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public virtual bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o nó atual é um atributo que foi gerado a partir o valor padrão definido no DTD ou no esquema.</summary>
        <value>
          <see langword="true" />Se o nó atual é um atributo cujo valor foi gerado a partir o valor padrão definido no DTD ou no esquema; <see langword="false" /> se o valor de atributo foi definido explicitamente.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `IsDefault`sempre retorna `false` para implementações de `XmlReader` que não dão suporte a informações de DTD ou esquema. Essa propriedade só se aplica a um nó de atributo.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos no elemento raiz.  
  
```  
using System;  
using System.IO;  
using System.Xml;  
  
public class Sample   
{  
  public static void Main(){  
  
    // Create the reader.  
    XmlReader reader = XmlReader.Create("book4.xml");  
  
    reader.MoveToContent();  
  
    // Display each of the attribute nodes, including default attributes.  
    while (reader.MoveToNextAttribute()){  
        if (reader.IsDefault)  
          Console.Write("(default attribute) ");  
        Console.WriteLine("{0} = {1}", reader.Name, reader.Value);    
    }             
  
    //Close the reader.  
    reader.Close();       
  
  }  
} // End class  
```  
  
 O exemplo usa os seguintes arquivos como entrada.  
  
 `book4.xml`  
  
```  
<!DOCTYPE book SYSTEM 'book.dtd'>  
<book ISBN = '1-861001-57-5'>  
  <title>Pride And Prejudice</title>  
  <price>19.95</price>  
</book>  
```  
  
 `book.dtd`  
  
```  
<!ELEMENT book (title,price)>   
<!ATTLIST book   
   genre CDATA "novel"  
   ISBN CDATA #REQUIRED>  
<!ELEMENT title (#PCDATA)>  
<!ELEMENT price (#PCDATA)>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public abstract bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém um valor que indica se o nó atual é um elemento vazio (por exemplo, <c> &lt;MyElement /&gt;</c>).</summary>
        <value>
          <see langword="true" />Se o nó atual é um elemento (<see cref="P:System.Xml.XmlReader.NodeType" /> é igual a <see langword="XmlNodeType.Element" />) que termina com <c> / &gt; </c>; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade permite determinar a diferença entre o seguinte:  
  
 `<item num="123"/>`(`IsEmptyElement` is `true`).  
  
 `<item num="123"></item>`(`IsEmptyElement` é `false`, embora o conteúdo do elemento está vazio).  
  
 Correspondente `EndElement` nó não é gerado para elementos vazios.  
  
 Se o conteúdo padrão foi adicionado a um elemento devido à validação de esquema, `IsEmptyElement` ainda retorna `true`. Ele não tem efeito sobre se o elemento tem um valor padrão. Em outras palavras, `IsEmptyElement` simplesmente informa se o elemento no documento de origem tinha uma marca de elemento final.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo do texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 O exemplo usa o arquivo de `elems.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsName">
      <MemberSignature Language="C#" Value="public static bool IsName (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsName(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">O nome a ser validado.</param>
        <summary>Retorna um valor que indica se o argumento de cadeia de caracteres é um nome XML válido.</summary>
        <returns>
          <see langword="true" />Se o nome é válido. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recomendação do W3C XML 1.0](http://go.microsoft.com/fwlink/?LinkId=49863) para determinar se o nome é válido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsNameToken">
      <MemberSignature Language="C#" Value="public static bool IsNameToken (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNameToken(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsNameToken(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">O token de nome para validar.</param>
        <summary>Retorna um valor que indica se o argumento de cadeia de caracteres é um token de nome XML válido.</summary>
        <returns>
          <see langword="true" />Se for um token de nome válido; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa o [recomendação do W3C XML 1.0](http://go.microsoft.com/fwlink/?LinkId=49863) para determinar se o token de nome é válido.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chama <see cref="M:System.Xml.XmlReader.MoveToContent" /> e testa se o nó de conteúdo atual é uma marca de início ou uma marca de elemento vazia.</summary>
        <returns>
          <see langword="true" /> se <see cref="M:System.Xml.XmlReader.MoveToContent" /> encontrar uma marca de início ou uma marca de elemento vazia; <see langword="false" /> se um tipo de nó diferente de <see langword="XmlNodeType.Element" /> for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ignora o espaço em branco, comentários e instruções de processamento até que o leitor está posicionado em um nó de conteúdo. O método testa se o nó atual é um elemento.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo do texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#10](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#10)]
 [!code-vb[XmlReaderBasic#10](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#10)]  
  
 O exemplo usa o arquivo de `elems.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#3](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/elems.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML incorreto é encontrado no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A cadeia de caracteres é comparada com a propriedade <see langword="Name" /> do elemento encontrado.</param>
        <summary>Chama <see cref="M:System.Xml.XmlReader.MoveToContent" /> e testa se o nó de conteúdo atual é uma marca de início ou uma marca de elemento vazio e se a propriedade <see cref="P:System.Xml.XmlReader.Name" /> que o elemento encontrou corresponde ao argumento fornecido.</summary>
        <returns>
          <see langword="true" />Se o nó resultante é um elemento e o <see langword="Name" /> propriedade corresponde a cadeia de caracteres especificada. <see langword="false" />Se um nó diferente do tipo <see langword="XmlNodeType.Element" /> foi encontrado ou se o elemento <see langword="Name" /> propriedade não coincide com a cadeia de caracteres especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ignora o espaço em branco, comentários e instruções de processamento até que o leitor está posicionado em um nó de conteúdo. O método testa se o nó atual é um elemento.  
  
   
  
## Examples  
 O exemplo a seguir exibe cada elemento de preço.  
  
 [!code-csharp[XmlReaderBasic#17](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#17)]
 [!code-vb[XmlReaderBasic#17](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML incorreto é encontrado no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="IsStartElement">
      <MemberSignature Language="C#" Value="public virtual bool IsStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.IsStartElement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">A cadeia de caracteres para correspondência com o <see langword="LocalName" /> propriedade do elemento encontrado.</param>
        <param name="ns">A cadeia de caracteres para correspondência com o <see langword="NamespaceURI" /> propriedade do elemento encontrado.</param>
        <summary>Chamadas <see cref="M:System.Xml.XmlReader.MoveToContent" /> e testa se o nó de conteúdo atual for uma marca de início ou marca de elemento vazio e se o <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> propriedades do elemento encontrado correspondem as cadeias de caracteres especificadas.</summary>
        <returns>
          <see langword="true" />Se o nó resultante é um elemento. <see langword="false" />Se um nó diferente do tipo <see langword="XmlNodeType.Element" /> foi encontrado ou se o <see langword="LocalName" /> e <see langword="NamespaceURI" /> propriedades do elemento não coincidem as cadeias de caracteres especificadas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método ignora o espaço em branco, comentários e instruções de processamento até que o leitor está posicionado em um nó de conteúdo. O método testa se o nó atual é um elemento.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML incorreto é encontrado no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[int i] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O índice do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o índice especificado.</summary>
        <value>O valor do atributo especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade não move o leitor.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos do nó atual.  
  
 [!code-csharp[XmlReaderBasic#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#1)]
 [!code-vb[XmlReaderBasic#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.Name" /> especificado.</summary>
        <value>O valor do atributo especificado. Se o atributo não for encontrado, <see langword="null" /> será retornado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade não move o leitor.  
  
 Se o leitor estiver posicionado em um `DocumentType` nó, esse método pode ser usado para obter os literais PUBLIC e do sistema, por exemplo,`reader["PUBLIC"]`  
  
   
  
## Examples  
 O exemplo a seguir obtém o valor do atributo ISBN.  
  
 [!code-csharp[XmlReaderBasic#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#7)]
 [!code-vb[XmlReaderBasic#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public virtual string this[string name, string namespaceURI] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Item(string, string)" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Item(System.String,System.String)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome local do atributo.</param>
        <param name="namespaceURI">O URI do namespace do atributo.</param>
        <summary>Quando substituído em uma classe derivada, obtém o valor do atributo com o <see cref="P:System.Xml.XmlReader.LocalName" /> e o <see cref="P:System.Xml.XmlReader.NamespaceURI" /> especificados.</summary>
        <value>O valor do atributo especificado. Se o atributo não for encontrado, <see langword="null" /> será retornado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade não move o leitor.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public abstract string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o nome local do nó atual.</summary>
        <value>O nome do nó atual com o prefixo removido. Por exemplo, <see langword="LocalName" /> é <see langword="book" /> para o elemento <c> &lt;bk:book&gt;</c>.  
  
 Para tipos de nós que não têm um nome (como <see langword="Text" />, <see langword="Comment" /> e assim por diante), essa propriedade retornará <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o nome local de cada nó, e, se existir, o prefixo e URI de namespace.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 O exemplo usa o arquivo, book2.xml, como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public abstract string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.LookupNamespace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">O prefixo cujo namespace URI que você deseja resolver. Para combinar o namespace padrão, passe uma cadeia de caracteres vazia.</param>
        <summary>Quando substituído em uma classe derivada, resolve um prefixo de namespace no escopo do elemento atual.</summary>
        <returns>O URI de namespace para o qual mapeia o prefixo ou <see langword="null" /> se nenhum prefixo correspondente for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na seguinte cadeia XML, se o leitor estiver posicionado no `href` de atributo, o prefixo `a` é resolvido chamando `reader.LookupNamespace("a")`. A cadeia de caracteres retornada é `urn:456`.  
  
```  
<root xmlns:a="urn:456">  
  <item>  
  <ref href="a:b"/>  
  </item>  
 </root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public virtual void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">O índice do atributo.</param>
        <summary>Quando substituído em uma classe derivada, é movido para o atributo com o índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe todos os atributos do nó atual.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O parâmetro tem um valor negativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do atributo.</param>
        <summary>Quando substituído em uma classe derivada, é movido para o atributo com o <see cref="P:System.Xml.XmlReader.Name" /> especificado.</summary>
        <returns>
          <see langword="true" />Se o atributo for encontrado; Caso contrário, <see langword="false" />. Se <see langword="false" />, a posição do leitor não será alterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de chamar `MoveToAttribute`, o <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, e <xref:System.Xml.XmlReader.Prefix%2A> propriedades refletem as propriedades desse atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToAttribute (string name, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToAttribute(string name, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToAttribute(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome local do atributo.</param>
        <param name="ns">O URI do namespace do atributo.</param>
        <summary>Quando substituído em uma classe derivada, passa para o atributo com especificado <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" />.</summary>
        <returns>
          <see langword="true" />Se o atributo for encontrado; Caso contrário, <see langword="false" />. Se <see langword="false" />, a posição do leitor não será alterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de chamar `MoveToAttribute`, o <xref:System.Xml.XmlReader.Name%2A>, <xref:System.Xml.XmlReader.NamespaceURI%2A>, e <xref:System.Xml.XmlReader.Prefix%2A> propriedades refletem as propriedades desse atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContent">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeType MoveToContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Xml.XmlNodeType MoveToContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica se o nó atual é um nó de conteúdo (texto sem espaço em branco, <see langword="CDATA" />, <see langword="Element" />, <see langword="EndElement" />, <see langword="EntityReference" /> ou <see langword="EndEntity" />). Se o nó não é um nó de conteúdo, o leitor avançará para o próximo nó de conteúdo ou o final do arquivo. Pula nós de tipo seguir: <see langword="ProcessingInstruction" />, <see langword="DocumentType" />, <see langword="Comment" />, <see langword="Whitespace" />, ou <see langword="SignificantWhitespace" />.</summary>
        <returns>O <see cref="P:System.Xml.XmlReader.NodeType" /> do nó atual encontrado pelo método ou <see langword="XmlNodeType.None" /> se o leitor atingiu o fim do fluxo de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o nó atual for um nó de atributo, esse método Move o leitor para o elemento que possui o atributo.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.MoveToContentAsync%2A>.  
  
   
  
## Examples  
 Isso é útil quando você quiser escrever código que pode ignorar aleatória marcação XML sem quebra. Por exemplo, suponha que você tem o seguinte código:  
  
 [!code-cpp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.MoveToContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.MoveToContent Example/VB/source.vb#1)]  
  
 Esse código pode lidar com as seguintes entradas sem separação de:  
  
```  
<price>123.4</price>  
```  
  
 e  
  
```  
<?xml version="1.0"><!DOCTYPE price SYSTEM  
  "abc"><price>123.4</price>  
```  
  
 e  
  
```  
<?xml version="1.0"><!DOCTYPE price SYSTEM "abc"  
  [<!ENTTIY p  
  "123.4">]><price>&p;</price>  
```  
  
 e  
  
```  
<!-- some test comment --><?processing  
  instruction?><price>123.4</price>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">XML incorreto encontrado no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToContentAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt; MoveToContentAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;valuetype System.Xml.XmlNodeType&gt; MoveToContentAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToContentAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;MoveToContentAsync&gt;c__async5))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Xml.XmlNodeType&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Modo assíncrono, verifica se o nó atual é um nó de conteúdo. Se o nó não é um nó de conteúdo, o leitor avançará para o próximo nó de conteúdo ou o final do arquivo.</summary>
        <returns>O <see cref="P:System.Xml.XmlReader.NodeType" /> do nó atual encontrado pelo método ou <see langword="XmlNodeType.None" /> se o leitor atingiu o fim do fluxo de entrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.MoveToContent%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public abstract bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, move para o elemento que contém o nó de atributo atual.</summary>
        <returns>
          <see langword="true" /> se o leitor estiver posicionado em um atributo (o leitor se move para o elemento que possui o atributo); <see langword="false" /> se o leitor não estiver posicionado em um atributo (a posição do leitor não é alterada).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método para retornar a um elemento depois de navegar por meio de seus atributos. Esse método Move o leitor para um dos seguintes tipos de nó: `Element`, `DocumentType`, ou `XmlDeclaration`.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos do nó atual.  
  
 [!code-csharp[XmlReaderBasic#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#4)]
 [!code-vb[XmlReaderBasic#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToFirstAttribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, move o primeiro atributo.</summary>
        <returns>
          <see langword="true" />Se um atributo existir (o leitor é movido para o primeiro atributo). Caso contrário, <see langword="false" /> (a posição do leitor não alterar).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir obtém o valor do primeiro atributo.  
  
 [!code-csharp[XmlReaderBasic#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#5)]
 [!code-vb[XmlReaderBasic#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public abstract bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.MoveToNextAttribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, vai para o atributo seguinte.</summary>
        <returns>
          <see langword="true" /> se houver um atributo seguinte; <see langword="false" /> se não houver mais nenhum atributo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o nó atual for um nó de elemento, esse método é equivalente a <xref:System.Xml.XmlReader.MoveToFirstAttribute%2A>. Se `MoveToNextAttribute` retorna `true`, o leitor se move para o próximo atributo; caso contrário, a posição do leitor não é alterado.  
  
   
  
## Examples  
 O exemplo a seguir exibe todos os atributos do nó atual.  
  
 [!code-csharp[XmlReaderBasic#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#6)]
 [!code-vb[XmlReaderBasic#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public virtual string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o nome qualificado do nó atual.</summary>
        <value>O nome qualificado do nó atual. Por exemplo, <see langword="Name" /> é <see langword="bk:book" /> para o elemento <c> &lt;bk:book&gt;</c>.  
  
 O nome retornado depende do <see cref="P:System.Xml.XmlReader.NodeType" /> do nó. Os seguintes tipos de nó retornam os valores listados. Todos os outros tipos de nó retornam uma cadeia de caracteres vazia.  
  
 <list type="table"><listheader><term>Tipo de nó  
  
 </term><description>Nome  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description>O nome do atributo.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description>O nome do tipo de documento.  
  
 </description></item><item><term><see langword="Element" /></term><description>O nome da marca.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description>O nome da entidade referenciada.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description>O destino da instrução de processamento.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description>A cadeia de caracteres literal <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public abstract string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o URI do namespace (conforme definido na especificação de Namespace do W3C) do nó no qual o leitor está posicionado.</summary>
        <value>O URI do namespace do nó atual; caso contrário, uma cadeia de caracteres vazia.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é relevante para `Element` e `Attribute` apenas nós.  
  
   
  
## Examples  
 O exemplo a seguir exibe o nome local de cada nó, e, se existir, o prefixo e URI de namespace.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 O exemplo usa o arquivo, book2.xml, como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o <see cref="T:System.Xml.XmlNameTable" /> associado a essa implementação.</summary>
        <value>O <see langword="XmlNameTable" /> que permite obter a versão atomizada de uma cadeia de caracteres no nó.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os nomes de nó e o atributo retornado de <xref:System.Xml.XmlReader> são atomizado usando o `NameTable`. Quando o mesmo nome é retornado várias vezes (por exemplo, `Customer`), em seguida, o mesmo `String` objeto será retornado para esse nome. Isso possibilita que você escreva código eficiente que o objeto comparações sobre essas cadeias de caracteres em vez de comparações de cadeia de caracteres caro.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o tipo do nó atual.</summary>
        <value>Um dos valores de enumeração que especificam o tipo do nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public abstract string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o prefixo de namespace associado com o nó atual.</summary>
        <value>O prefixo de namespace associado ao nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o nome local de cada nó, e, se existir, o prefixo e URI de namespace.  
  
 [!code-csharp[XmlReaderBasic#9](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#9)]
 [!code-vb[XmlReaderBasic#9](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#9)]  
  
 O exemplo usa o arquivo, book2.xml, como entrada.  
  
 [!code-xml[XML_Core_Files#5](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book2.xml#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public virtual char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o caractere de aspas usado para colocar o valor de um nó de atributo.</summary>
        <value>O caractere de aspas ("ou ') usado para colocar o valor de um nó de atributo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade só se aplica a um nó de atributo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public abstract bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Read" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê o próximo nó do fluxo.</summary>
        <returns>
          <see langword="true" /> se o próximo nó foi lido com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Xml.XmlReader> primeiro criados e inicializados, não há nenhuma informação disponível. Você deve chamar <xref:System.Xml.XmlReader.Read%2A> para ler o primeiro nó. O <xref:System.Xml.XmlReader.Read%2A> método define o estado do leitor de XML para iniciar <xref:System.Xml.ReadState> e move por meio do arquivo XML sequencialmente, até atingir o final do arquivo, no ponto em que o método retorna um valor de `false`.  
  
 Esse método requer pelo menos quatro bytes do fluxo de dados para começar a análise. Se menos de quatro bytes são retornados e não há nenhuma mais dados no fluxo, o método retornará `false`. Se houver mais dados no fluxo, o método bloqueará a análise até o recebimento do quarto byte.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 **Saída:**  
  
```  
<Item>Test with an entity: 123</Item><Item>Test with a child element <more> stuff</Item><Item>Test with a CDATA section <![CDATA[<456>]]]><![CDATA[]> def</Item><Item>Test with a char entity: A</Item><!-- Fourteen chars in this element.--><Item>1234567890ABCD</Item></Items>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;bool&gt; ReadAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;bool&gt; ReadAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê assincronamente o próximo nó do fluxo.</summary>
        <returns>
          <see langword="true" /> se o próximo nó for lido com êxito; <see langword="false" /> se não houver mais nenhum nó para ler.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.Read%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public abstract bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadAttributeValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, analisa o valor do atributo em um ou mais nós <see langword="Text" />, <see langword="EntityReference" /> ou <see langword="EndEntity" />.</summary>
        <returns>
          <see langword="true" /> se houver nós para retornar.  
  
 <see langword="false" /> se o leitor não estiver posicionado em um nó de atributo quando a chamada inicial for feita ou se todos os valores de atributo tiverem sido lidos.  
  
 Atributo vazio, como <c>misc = ""</c>, retorna <see langword="true" /> com um único nó com um valor de <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use este método depois de chamar <xref:System.Xml.XmlReader.MoveToAttribute%2A> ler os nós de referência de entidade ou de texto que compõem o valor do atributo. O <xref:System.Xml.XmlReader.Depth%2A> de nós de valor de atributo é um mais a profundidade do nó de atributo; ele aumenta e diminui em um quando você entrar e sair de referências de entidade geral.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.  
  
 **Observação** com a versão do .NET Framework 3.5, o valor da <c>returnType</c> parâmetro agora pode ser o <see cref="T:System.DateTimeOffset" /> tipo.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo. Por exemplo, isso pode ser usado ao converter uma <see cref="T:System.Xml.XmlQualifiedName" /> o objeto para um <c>xs: string</c>.  
  
 Este valor pode ser <see langword="null" />.</param>
        <summary>Lê o conteúdo como um objeto do tipo especificado.</summary>
        <returns>O valor de atributo ou conteúdo de texto concatenado convertido para o tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê o conteúdo de texto na posição atual do leitor e converte-o para o tipo de retorno solicitado. Texto, o espaço em branco, o espaço em branco significativo e seções CDATA são concatenados. Comentários e instruções de processamento são ignorados e referências a entidades são resolvidas automaticamente.  
  
 Esse método é usado para ler, converter se necessário e retornar conteúdo os itens de valor atômico do nó atual. Se o tipo de entrada é um mapeamentos válidos para o tipo do nó atual, em seguida, uma instância do tipo de destino que contém o valor do nó atual será retornado. Consulte a seção comentários a <xref:System.Xml.XmlReader> referencepage para obter uma lista de mapeamentos padrão.  
  
 Por exemplo, se você tiver o seguinte texto XML:  
  
```  
<elem>123 <!-- comment --> <?pi my_text?> 456 <?pi another_pi?></elem>  
```  
  
 Se os dados são digitados e uma matriz de cadeia de caracteres é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> chamada de método e, em seguida, os valores inteiros são convertidas de cadeias de caracteres de acordo com a lista de mapeamentos de tipo CLR válidos.  
  
 Se os dados não são digitados e uma matriz de cadeia de caracteres é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> da chamada do método, em seguida, o conteúdo é analisado em cadeias de caracteres separadas. Uma matriz que contém duas cadeias de caracteres é retornada com os valores "123" e "456". Os espaços não são preservados do conteúdo.  
  
 O conteúdo em geral, ao ler dados não digitados é analisado de acordo com o tipo fornecido. Por exemplo, se uma matriz de inteiros é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> da chamada do método e a cadeia de caracteres é analisada em uma matriz de inteiros {123,456}.  
  
 No exemplo a seguir o texto XML não está separado por espaços  
  
```  
<elem>123<!-- comment --><?pi my_text?>456789<?pi another_pi?></elem>  
```  
  
 Se o conteúdo é digitado e uma matriz de cadeia de caracteres é fornecida para o <xref:System.Xml.XmlReader.ReadContentAs%2A> da chamada do método, em seguida, uma matriz que contém uma cadeia de caracteres concatenada é retornada com o valor "123456789".  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadContentAsAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadContentAs%2A> método para retornar o conteúdo do elemento de cores em uma matriz de objetos de cadeia de caracteres.  
  
 [!code-csharp[XmlReader.ReadContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#2)]
 [!code-vb[XmlReader.ReadContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#2)]  
  
 O exemplo usa o arquivo `dataFile_2.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O conteúdo não está no formato correto para o tipo de destino.</exception>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="returnType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.OverflowException">Leia o <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsAsync&gt;c__async1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <summary>Lê o conteúdo de forma assíncrona como um objeto do tipo especificado.</summary>
        <returns>O valor de atributo ou conteúdo de texto concatenado convertido para o tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadContentAs%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o conteúdo e retorna os bytes binários decodificados de Base64.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método transmite o conteúdo, decodifica o `Base64` de conteúdo e retorna os bytes binários codificados (por exemplo, um embutido `Base64` codificados de imagem GIF) no buffer. Esse método pode ser chamado sucessivamente para ler grandes fluxos de texto inserido. Para obter mais informações, consulte RFC 1521, "parte MIME (Multipurpose Internet Mail Extensions) uma: mecanismos para especificar e que descreve o formato de corpos de mensagens da Internet". Você pode obter RFCs do [de comentários Web site](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
> [!NOTE]
>  Você não deve acessar qualquer uma das propriedades leitor entre as chamadas para o <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> método até que o método retorna o valor `0`.  
  
 Esse método tem o seguinte comportamento:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>Retorna o valor `0` quando ele atingiu o final do fluxo de bytes que ele estava funcionando em. O leitor é posicionado no primeiro nó de conteúdo não.  
  
-   Se você solicitar menos, ou o número exato de bytes que são deixados no fluxo o leitor permanece na posição atual.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>Não há suporte para os seguintes tipos de nós XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadContentAsBase64Async%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o conteúdo e retorna que o Base64 decodificar bytes binários de forma assíncrona.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadContentAsBase64%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o conteúdo e retorna o <see langword="BinHex" /> decodificar bytes binários.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método transmite o conteúdo, decodifica o `BinHex` de conteúdo e retorna os bytes binários codificados (por exemplo, um embutido `BinHex` codificados de imagem GIF) no buffer. Esse método pode ser chamado sucessivamente para ler grandes fluxos de texto inserido.  
  
> [!NOTE]
>  Você não deve acessar qualquer uma das propriedades leitor entre as chamadas para o <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> método até que o método retorna o valor `0`.  
  
 Esse método tem o seguinte comportamento:  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>Retorna o valor `0` quando ele atingiu o final do fluxo de bytes que ele estava funcionando em. O leitor é posicionado no primeiro nó de conteúdo não.  
  
-   Se você pedir menos ou o número exato, de bytes que são deixados no fluxo, o leitor permanece na posição atual.  
  
-   <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>Não há suporte para os seguintes tipos de nós XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation, Entity`, `DocumentFragment`.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadContentAsBinHexAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o conteúdo de forma assíncrona e retorna o <see langword="BinHex" /> decodificar bytes binários.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsBoolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um <see langword="Boolean" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado `xsd:boolean`, o leitor retorna um não demarcado <xref:System.Boolean> objeto. Se o conteúdo não for digitado `xsd:boolean`, o leitor de tenta convertê-lo para um <xref:System.Boolean> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadContentAsBoolean%2A> método para ler o atributo como um B`oolean` valor.  
  
 [!code-csharp[XmlReader.ReadContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadContentAs/CS/readContentAs.cs#1)]
 [!code-vb[XmlReader.ReadContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadContentAs/VB/readContentAs.vb#1)]  
  
 O exemplo usa o arquivo `dataFile_2.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadContentAs#3](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadContentAs/XML/dataFile_2.xml#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado `xsd:dateTime`, o leitor retorna um não demarcado <xref:System.DateTime> objeto. Se o conteúdo não for digitado `xsd:dateTime`, o leitor de tenta convertê-lo para um <xref:System.DateTime> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
> [!NOTE]
>  Você não pode depender no valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> quando o conteúdo está digitado como `xsd:gMonthDay`. <xref:System.Xml.XmlReader>sempre define o <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor 1904 nesse caso.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDateTimeOffset">
      <MemberSignature Language="C#" Value="public virtual DateTimeOffset ReadContentAsDateTimeOffset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTimeOffset ReadContentAsDateTimeOffset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDateTimeOffset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.DateTimeOffset" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.DateTimeOffset" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDecimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.Decimal" />.</summary>
        <returns>O conteúdo do texto na posição atual como uma <see cref="T:System.Decimal" /> objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado `xsd:decimal`, o leitor retorna um não demarcado <xref:System.Decimal> objeto. Se o conteúdo não for digitado `xsd:decimal`, o leitor de tenta convertê-lo para um <xref:System.Decimal> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsDouble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um número de ponto flutuante de precisão dupla.</summary>
        <returns>O conteúdo de texto como um número de ponto flutuante de precisão dupla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado `xsd:double`, o leitor retorna um número de ponto flutuante de precisão dupla. Se o conteúdo não for digitado `xsd:double`, o leitor de tenta convertê-lo para um número de ponto flutuante de precisão dupla de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte o <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsFloat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um número de ponto flutuante de precisão simples.</summary>
        <returns>O conteúdo de texto na posição atual como um número de ponto flutuante de precisão simples.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado `xsd:float`, o leitor retorna um não demarcado um número de ponto flutuante de precisão simples. Se o conteúdo não for digitado `xsd:float`, o leitor de tenta convertê-lo para um número de ponto flutuante de precisão única acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsInt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um inteiro com sinal de 32 bits.</summary>
        <returns>O conteúdo de texto como um inteiro com sinal de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado `xsd:integer`, o leitor retorna um inteiro assinado de 32 bits não Demarcado. Se o conteúdo não for digitado `xsd:integer`, o leitor de tenta convertê-lo para um inteiro assinado de 32 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsLong" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um inteiro assinado de 64 bits.</summary>
        <returns>O conteúdo de texto como um inteiro assinado de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado `xsd:long`, o leitor retorna um inteiro assinado de 64 bits não Demarcado. Se o conteúdo não for digitado `xsd:long`, o leitor de tenta convertê-lo para um inteiro assinado de 64 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 A tabela a seguir descreve este método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo do texto na posição atual como um <see cref="T:System.Object" />.</summary>
        <returns>O conteúdo do texto como o objeto CLR (Common Language Runtime) mais apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Se o conteúdo é digitado, o leitor retorna um CLR boxed do tipo mais apropriado, especificado pelo <xref:System.Xml.XmlReader.ValueType%2A> propriedade. Se o conteúdo é um tipo de lista, o leitor retorna uma matriz de objetos boxed do tipo apropriado.  
  
> [!NOTE]
>  Se ocorre um erro de validação ao analisar o conteúdo e o leitor é uma <xref:System.Xml.XmlReader> objeto criado pelo <xref:System.Xml.XmlReader.Create%2A> método, o leitor retorna o conteúdo como uma cadeia de caracteres. Em outras palavras quando a validação ocorre um erro ou aviso, o conteúdo é considerado sem tipo.  
  
 Se o conteúdo é não tipado, o leitor retorna o conteúdo como uma cadeia de caracteres.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|O valor do elemento se o leitor é um esquema de validação de leitor (<xref:System.Xml.XmlReaderSettings.ValidationType%2A> é definido como <xref:System.Xml.ValidationType.Schema>); caso contrário, uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadContentAsObjectAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsObjectAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadContentAsObjectAsync&gt;c__async0))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona o conteúdo do texto na posição atual como um <see cref="T:System.Object" />.</summary>
        <returns>O conteúdo do texto como o objeto CLR (Common Language Runtime) mais apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadContentAsObject%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo de texto na posição atual como um objeto <see cref="T:System.String" />.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método concatena o texto, o espaço em branco, o espaço em branco significativo e seções CDATA e ignora quaisquer comentários ou instruções de processamento. Referências a entidades são resolvidas automaticamente.  
  
 Esse método pode ser usado converter valores digitados em uma cadeia de caracteres, ou para ler o conteúdo de texto, ignorando comentários e instruções de processamento.  
  
 A tabela a seguir descreve como esse método trata cada tipo de nó.  
  
|XmlNodeType|Valor retornado|Comportamento do leitor|  
|-----------------|------------------|---------------------|  
|`Text`<br /><br /> `CDATA`<br /><br /> `Whitespace`<br /><br /> `SignificantWhitespace`<br /><br /> `EntityReference`<br /><br /> `EndEntity`|Concatenado conteúdo de texto, de CDATA, de espaço em branco e os nós significativos de espaço em branco convertidos para o tipo solicitado.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`Attribute`|Mesmo que chamar `XmlConvert.ToXxx` no valor do atributo.|O leitor permanece na posição atual.|  
|`Comment`<br /><br /> `ProcessingInstruction`|Ignora a instrução de processamento (PI) ou o comentário e ler o conteúdo concatenado de texto que segue o PI ou o comentário.|Move para a seguir marca de início ou elemento de extremidade. Referências a entidades são automaticamente expandidas.|  
|`EndElement`|Uma cadeia de caracteres vazia.|O leitor permanece na posição atual.|  
|`Element`<br /><br /> `XmlDeclaration`<br /><br /> `None`<br /><br /> `Document`<br /><br /> `DocumentType`<br /><br /> `Notation`<br /><br /> `Entity`<br /><br /> `DocumentFragment`|<xref:System.InvalidOperationException> é lançada.|Indefinido, embora geralmente o leitor permaneça na posição atual.|  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadContentAsStringAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">A tentativa de conversão não é válida.</exception>
        <exception cref="T:System.FormatException">O formato de cadeia de caracteres não é válido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadContentAsStringAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê de forma assíncrona o conteúdo do texto na posição atual como uma <see cref="T:System.String" /> objeto.</summary>
        <returns>O conteúdo de texto como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadContentAsString%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.  
  
 **Observação** com a versão do .NET Framework 3.5, o valor da <c>returnType</c> parâmetro agora pode ser o <see cref="T:System.DateTimeOffset" /> tipo.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <summary>Lê o conteúdo do elemento como o tipo solicitado.</summary>
        <returns>O conteúdo do elemento convertido para o objeto de tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadElementContentAs%2A> método para ler o conteúdo do `date` nó.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#5](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#5)]
 [!code-vb[XmlReader.ReadElementContentAs#5](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#5)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para o tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.OverflowException">Leia o <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAs">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAs (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAs(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAs(System.Type,System.Xml.IXmlNamespaceResolver,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.  
  
 **Observação** com a versão do .NET Framework 3.5, o valor da <c>returnType</c> parâmetro agora pode ser o <see cref="T:System.DateTimeOffset" /> tipo.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace é igual do elemento atual e lê o conteúdo de elemento como o tipo solicitado.</summary>
        <returns>O conteúdo do elemento convertido para o objeto de tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para o tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
        <exception cref="T:System.OverflowException">Leia o <see langword="Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsAsync (Type returnType, System.Xml.IXmlNamespaceResolver namespaceResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsAsync(class System.Type returnType, class System.Xml.IXmlNamespaceResolver namespaceResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsAsync(System.Type,System.Xml.IXmlNamespaceResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsAsync&gt;c__async4))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="namespaceResolver" Type="System.Xml.IXmlNamespaceResolver" />
      </Parameters>
      <Docs>
        <param name="returnType">O tipo do valor a ser retornado.</param>
        <param name="namespaceResolver">Um objeto <see cref="T:System.Xml.IXmlNamespaceResolver" /> que é usado para resolver todos os prefixos de namespace relacionados à conversão de tipo.</param>
        <summary>Lê de forma assíncrona o conteúdo do elemento como o tipo solicitado.</summary>
        <returns>O conteúdo do elemento convertido para o objeto de tipo solicitado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadElementContentAs%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o elemento e decodifica o conteúdo de <see langword="Base64" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê o conteúdo do elemento, decodifica usando `Base64` codificação e retorna os bytes binários codificados (por exemplo, um embutido `Base64`-codificados de imagem GIF) no buffer. Para obter mais informações, consulte RFC 1521, "parte MIME (Multipurpose Internet Mail Extensions) uma: mecanismos para especificar e que descreve o formato de corpos de mensagens da Internet". Você pode obter RFCs do [de comentários Web site](http://go.microsoft.com/fwlink/?LinkId=37119).  
  
 <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>somente pode ler os elementos de conteúdo simples. O elemento pode conter texto, o espaço em branco, espaço em branco significativo, seções CDATA, comentários e instruções de processamento. Ele também pode conter referências de entidade, que são expandidas automaticamente. O elemento não pode ter elementos filho.  
  
 Esse método é muito semelhante de <xref:System.Xml.XmlReader.ReadContentAsBase64%2A> método, exceto que ela só pode ser chamado em tipos de nó de elemento.  
  
 Se o `count` valor é maior que o número de bytes no documento, ou se é igual ao número de bytes no documento, o <xref:System.Xml.XmlReader> lê todos os bytes restantes no documento e retorna o número de bytes lidos. O próximo <xref:System.Xml.XmlReader> chamada de método retorna um zero e move o leitor para o nó após o `EndElement`.  
  
 Se você chamar <xref:System.Xml.XmlReader.Read%2A> antes de todo o conteúdo do elemento é consumido, o leitor pode se comportar como se o conteúdo foi consumido e, em seguida, o <xref:System.Xml.XmlReader.Read%2A> método foi chamado. Isso significa que o leitor lerá todo o texto até que o elemento final seja encontrado. Ele, em seguida, ler o nó de marca de fim, ler o próximo nó e posicionará no próximo nó subsequente.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsBase64Async%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê um embutido `Base64` imagem codificados. O `Base64` os dados são inseridos dentro de `<image>` elemento. Um <xref:System.IO.BinaryWriter> é usado para criar um novo arquivo de dados binários.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#4)]
 [!code-vb[XmlReader_Read_Write_Binary#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento contém conteúdo misto.</exception>
        <exception cref="T:System.FormatException">Não é possível converter conteúdo no tipo solicitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64Async">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBase64Async (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBase64Async(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBase64Async(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o elemento de forma assíncrona e decodifica o <see langword="Base64" /> conteúdo.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o elemento e decodifica o conteúdo de <see langword="BinHex" />.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê o conteúdo do elemento, decodifica usando `BinHex` codificação e retorna os bytes binários codificados (por exemplo, um embutido `BinHex`-codificados de imagem GIF) no buffer.  
  
 Esse método somente pode ler os elementos de conteúdo simples. O elemento pode conter texto, o espaço em branco, espaço em branco significativo, seções CDATA, comentários e instruções de processamento. Ele também pode conter referências de entidade, que são expandidas automaticamente. O elemento não pode ter elementos filho.  
  
 Esse método é muito semelhante de <xref:System.Xml.XmlReader.ReadContentAsBinHex%2A> método, exceto que ela só pode ser chamado em tipos de nó de elemento.  
  
 Se o `count` valor é maior que o número de bytes no documento, ou se é igual ao número de bytes no documento, o <xref:System.Xml.XmlReader> lê todos os bytes restantes no documento e retorna o número de bytes lidos. O próximo <xref:System.Xml.XmlReader> chamada de método retorna um zero e move o leitor para o nó após o `EndElement`.  
  
 Se você chamar <xref:System.Xml.XmlReader.Read%2A> antes de todo o conteúdo do elemento é consumido, o leitor pode se comportar como se o conteúdo foi consumido e, em seguida, o <xref:System.Xml.XmlReader.Read%2A> método foi chamado. Isso significa que o leitor lerá todo o texto até que o elemento final seja encontrado. Ele, em seguida, ler o nó de marca de fim, ler o próximo nó e posicionará no próximo nó subsequente.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsBinHexAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê um embutido `BinHex` imagem codificados. O `BinHex` os dados são inseridos dentro de `<image>` elemento. Um <xref:System.IO.BinaryWriter> é usado para criar um novo arquivo de dados binários.  
  
 [!code-csharp[XmlReader_Read_Write_Binary#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader_Read_Write_Binary/CS/readBinary.cs#2)]
 [!code-vb[XmlReader_Read_Write_Binary#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader_Read_Write_Binary/VB/readBinary.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice de buffer ou de índice + contagem é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <exception cref="T:System.Xml.XmlException">O elemento contém conteúdo misto.</exception>
        <exception cref="T:System.FormatException">Não é possível converter conteúdo no tipo solicitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHexAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadElementContentAsBinHexAsync (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadElementContentAsBinHexAsync(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBinHexAsync(System.Byte[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">O buffer para o qual o texto resultante será copiado. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento do buffer onde começar a copiar o resultado.</param>
        <param name="count">O número máximo de bytes a serem copiados para o buffer. O número real de bytes copiados é retornado deste método.</param>
        <summary>Lê o elemento de forma assíncrona e decodifica o <see langword="BinHex" /> conteúdo.</summary>
        <returns>O número de bytes gravados no buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Boolean" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo do elemento é digitado `xsd:boolean`, o leitor retorna um não demarcado <xref:System.Boolean> objeto. Se o conteúdo não for digitado `xsd:boolean`, o leitor de tenta convertê-lo para um <xref:System.Boolean> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um <see cref="T:System.Boolean" /> objeto.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBoolean">
      <MemberSignature Language="C#" Value="public virtual bool ReadElementContentAsBoolean (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadElementContentAsBoolean(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsBoolean(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Boolean" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Boolean" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:boolean`, o leitor retorna um não demarcado <xref:System.Boolean> objeto. Se o conteúdo não for digitado `xsd:boolean`, o leitor de tenta convertê-lo para um <xref:System.Boolean> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para o tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.DateTime" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:dateTime`, o leitor retorna um não demarcado <xref:System.DateTime> objeto. Se o conteúdo não for digitado `xsd:dateTime`, o leitor de tenta convertê-lo para um <xref:System.DateTime> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
> [!NOTE]
>  Você não pode depender no valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> quando o conteúdo está digitado como `xsd:gMonthDay`. <xref:System.Xml.XmlReader>sempre define o <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor 1904 nesse caso.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadElementContentAsDateTime%2A> método para ler o conteúdo do `date` elemento.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#4](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#4)]
 [!code-vb[XmlReader.ReadElementContentAs#4](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#4)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um <see cref="T:System.DateTime" /> objeto.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDateTime">
      <MemberSignature Language="C#" Value="public virtual DateTime ReadElementContentAsDateTime (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.DateTime ReadElementContentAsDateTime(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDateTime(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.DateTime" />.</summary>
        <returns>O elemento de conteúdo como um <see cref="T:System.DateTime" /> objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:dateTime`, o leitor retorna um não demarcado <xref:System.DateTime> objeto. Se o conteúdo não for digitado `xsd:dateTime`, o leitor de tenta convertê-lo para um <xref:System.DateTime> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
> [!NOTE]
>  Você não pode depender no valor de <xref:System.DateTime.Year%2A?displayProperty=nameWithType> quando o conteúdo está digitado como `xsd:gMonthDay`. <xref:System.Xml.XmlReader>sempre define o <xref:System.DateTime.Year%2A?displayProperty=nameWithType> valor 1904 nesse caso.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para o tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Decimal" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tenta converter o elemento de conteúdo para um <xref:System.Decimal> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDecimal">
      <MemberSignature Language="C#" Value="public virtual decimal ReadElementContentAsDecimal (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Decimal ReadElementContentAsDecimal(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDecimal(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.Decimal" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tenta converter o elemento de conteúdo para um <xref:System.Decimal> objeto de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um <see cref="T:System.Decimal" />.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão dupla.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão dupla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:double`, o leitor retorna um número de ponto flutuante de precisão dupla. Se o conteúdo não for digitado `xsd:double`, o leitor de tenta convertê-lo para um número de ponto flutuante de precisão dupla de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 O exemplo a seguir usa o método para retornar o conteúdo de elemento como um número de ponto flutuante de precisão dupla.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#7](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#7)]
 [!code-vb[XmlReader.ReadElementContentAs#7](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#7)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para um número de ponto flutuante de precisão dupla.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsDouble">
      <MemberSignature Language="C#" Value="public virtual double ReadElementContentAsDouble (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 ReadElementContentAsDouble(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsDouble(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace é igual do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão dupla.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão dupla.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:double`, o leitor retorna um número de ponto flutuante de precisão dupla. Se o conteúdo não for digitado `xsd:double`, o leitor de tenta convertê-lo para um número de ponto flutuante de precisão dupla de acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para o tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como número de ponto flutuante de precisão simples.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão simples.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tenta converter o conteúdo de elemento em um número de ponto flutuante de precisão única acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para um número de ponto flutuante de precisão simples.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsFloat">
      <MemberSignature Language="C#" Value="public virtual float ReadElementContentAsFloat (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float32 ReadElementContentAsFloat(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsFloat(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace é igual do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um número de ponto flutuante de precisão simples.</summary>
        <returns>O conteúdo do elemento como um número de ponto flutuante de precisão simples.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 O leitor tenta converter o conteúdo de elemento em um número de ponto flutuante de precisão única acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para um número de ponto flutuante de precisão simples.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um inteiro assinado de 32 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro assinado de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:integer`, o leitor retorna um inteiro assinado de 32 bits não Demarcado. Se o conteúdo não for digitado `xsd:integer`, o leitor de tenta convertê-lo para um inteiro assinado de 32 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um inteiro assinado de 32 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsInt">
      <MemberSignature Language="C#" Value="public virtual int ReadElementContentAsInt (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadElementContentAsInt(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsInt(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace é igual do elemento atual, o, em seguida, lê o elemento atual e retorna o conteúdo como um inteiro assinado de 32 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro assinado de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:integer`, o leitor retorna um inteiro assinado de 32 bits não Demarcado. Se o conteúdo não for digitado `xsd:integer`, o leitor de tenta convertê-lo para um inteiro assinado de 32 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um inteiro assinado de 32 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um inteiro assinado de 64 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro assinado de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:long`, o leitor retorna um inteiro assinado de 64 bits não Demarcado. Se o conteúdo não for digitado `xsd:long`, o leitor de tenta convertê-lo para um inteiro assinado de 64 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Xml.XmlReader.ReadElementContentAsLong%2A> método para ler o conteúdo do `longValue` elemento.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#3](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#3)]
 [!code-vb[XmlReader.ReadElementContentAs#3](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#3)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um inteiro assinado de 64 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsLong">
      <MemberSignature Language="C#" Value="public virtual long ReadElementContentAsLong (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 ReadElementContentAsLong(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsLong(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace é igual do elemento atual, o, em seguida, lê o elemento atual e retorna o conteúdo como um inteiro assinado de 64 bits.</summary>
        <returns>O conteúdo do elemento como um inteiro assinado de 64 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Se o conteúdo é digitado `xsd:long`, o leitor retorna um inteiro assinado de 64 bits não Demarcado. Se o conteúdo não for digitado `xsd:long`, o leitor de tenta convertê-lo para um inteiro assinado de 64 bits acordo com as regras definidas pelo [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um inteiro assinado de 64 bits.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna os conteúdos como um <see cref="T:System.Object" />.</summary>
        <returns>Um processador objeto common language runtime (CLR) do tipo mais apropriado. O <see cref="P:System.Xml.XmlReader.ValueType" /> propriedade determina o tipo CLR apropriado. Se o conteúdo é digitado como um tipo de lista, esse método retorna uma matriz de objetos boxed do tipo apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsObjectAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o método para ler o conteúdo do `price` nó. O leitor usa as informações do esquema para mapear o conteúdo para o tipo de dados correto.  
  
 [!code-csharp[XmlReader.ReadElementContentAs#6](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#6)]
 [!code-vb[XmlReader.ReadElementContentAs#6](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#6)]  
  
 O exemplo usa dois arquivos a seguir como entrada.  
  
 `item.xml`  
  
 [!code-xml[XmlReader.ReadElementContentAs#11](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xml#11)]  
  
 `item.xsd`  
  
 [!code-xml[XmlReader.ReadElementContentAs#12](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/item.xsd#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para o tipo solicitado</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObject">
      <MemberSignature Language="C#" Value="public virtual object ReadElementContentAsObject (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ReadElementContentAsObject(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObject(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace é igual do elemento atual, o, em seguida, lê o elemento atual e retorna o conteúdo como um <see cref="T:System.Object" />.</summary>
        <returns>Um processador objeto common language runtime (CLR) do tipo mais apropriado. O <see cref="P:System.Xml.XmlReader.ValueType" /> propriedade determina o tipo CLR apropriado. Se o conteúdo é digitado como um tipo de lista, esse método retorna uma matriz de objetos boxed do tipo apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido para o tipo solicitado.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsObjectAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;object&gt; ReadElementContentAsObjectAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;object&gt; ReadElementContentAsObjectAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsObjectAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsObjectAsync&gt;c__async2))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual de forma assíncrona e retorna o conteúdo como um <see cref="T:System.Object" />.</summary>
        <returns>Um processador objeto common language runtime (CLR) do tipo mais apropriado. O <see cref="P:System.Xml.XmlReader.ValueType" /> propriedade determina o tipo CLR apropriado. Se o conteúdo é digitado como um tipo de lista, esse método retorna uma matriz de objetos boxed do tipo apropriado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadElementContentAsObject%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.String" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadElementContentAsStringAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir lê o `stringValue` elemento e retorna o conteúdo de texto (ignorando o comentário e instrução de processamento).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#1)]
 [!code-vb[XmlReader.ReadElementContentAs#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#1)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um <see cref="T:System.String" /> objeto.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementContentAsString (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementContentAsString(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Verifica se o nome do local especificado e o URI de namespace correspondem àqueles do elemento atual, em seguida, lê o elemento atual e retorna o conteúdo como um objeto <see cref="T:System.String" />.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método lê a marca de início, o conteúdo do elemento e move o leitor após a marca do elemento final. Ele expande as entidades e ignora os comentários e instruções de processamento. O elemento só pode conter conteúdo simples. Ou seja, ele não pode ter elementos filho.  
  
 Para obter mais informações, consulte a seção comentários a <xref:System.Xml.XmlReader> página de referência e o [W3C XML Schema Part 2: tipos de dados](http://go.microsoft.com/fwlink/?LinkId=4871) recomendação.  
  
   
  
## Examples  
 O exemplo a seguir lê o `stringValue` elemento e retorna o conteúdo de texto (ignorando o comentário e instrução de processamento).  
  
 [!code-csharp[XmlReader.ReadElementContentAs#2](~/samples/snippets/csharp/VS_Snippets_Data/XmlReader.ReadElementContentAs/CS/readElementContentAs.cs#2)]
 [!code-vb[XmlReader.ReadElementContentAs#2](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReader.ReadElementContentAs/VB/readElementContentAs.vb#2)]  
  
 O exemplo usa o arquivo `dataFile.xml` como entrada.  
  
 [!code-xml[XmlReader.ReadElementContentAs#8](~/samples/snippets/xml/VS_Snippets_Data/XmlReader.ReadElementContentAs/XML/dataFile.xml#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.Xml.XmlException">O elemento atual contém elementos filho.  
  
 -ou-  
  
 O conteúdo do elemento não pode ser convertido em um <see cref="T:System.String" /> objeto.</exception>
        <exception cref="T:System.ArgumentNullException">O método é chamado com os argumentos <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O nome do local especificado e o URI de namespace não correspondem àqueles do elemento atual que está sendo lido.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsStringAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadElementContentAsStringAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadElementContentAsStringAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementContentAsStringAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadElementContentAsStringAsync&gt;c__async3))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o elemento atual e retorna o conteúdo de forma assíncrona uma <see cref="T:System.String" /> objeto.</summary>
        <returns>O elemento de conteúdo como um objeto <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadElementContentAsString%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadElementString">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <summary>Lê os elementos somente texto simples. No entanto, é recomendável que você use o método <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recomendamos que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> método de leitura de um elemento de texto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê um elemento somente texto. No entanto, é recomendável que você use o método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O texto contido no elemento que foi lido. Uma cadeia de caracteres vazia se o elemento está vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recomendamos que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString> método de leitura de um elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O próximo nó de conteúdo não é uma marca de início; ou o elemento encontrado não contém um valor de texto simples.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome para verificar.</param>
        <summary>Verifica se a propriedade <see cref="P:System.Xml.XmlReader.Name" /> do elemento encontrado corresponde à cadeia de caracteres fornecida antes de ler um elemento somente texto. No entanto, é recomendável que você use o método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O texto contido no elemento que foi lido. Uma cadeia de caracteres vazia se o elemento está vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recomendamos que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString> método de leitura de um elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se o próximo nó de conteúdo não é uma marca de início; Se o elemento <see langword="Name" /> não coincide com o argumento fornecido; ou se encontrar o elemento não contém um valor de texto simples.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadElementString">
      <MemberSignature Language="C#" Value="public virtual string ReadElementString (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadElementString(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadElementString(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">O nome local para verificar.</param>
        <param name="ns">O namespace URI para verificar.</param>
        <summary>Verifica se o <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> propriedades do elemento encontrado corresponde as cadeias de caracteres fornecidas antes de ler um elemento somente de texto. No entanto, é recomendável que você use o método <see cref="M:System.Xml.XmlReader.ReadElementContentAsString(System.String,System.String)" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O texto contido no elemento que foi lido. Uma cadeia de caracteres vazia se o elemento está vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recomendamos que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString%28System.String%2CSystem.String%29> método de leitura de um elemento de texto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Se o próximo nó de conteúdo não é uma marca de início; Se o elemento <see langword="LocalName" /> ou <see langword="NamespaceURI" /> não coincidem com os argumentos fornecidos; ou se encontrar o elemento não contém um valor de texto simples.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadEndElement">
      <MemberSignature Language="C#" Value="public virtual void ReadEndElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadEndElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadEndElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica se o nó de conteúdo atual é uma marca de fim e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o conteúdo do texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 O exemplo usa o `book3.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O nó atual não é uma marca de fim ou se o XML incorreto é encontrado no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXml">
      <MemberSignature Language="C#" Value="public virtual string ReadInnerXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadInnerXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê todo o conteúdo, incluindo a marcação, como uma cadeia de caracteres.</summary>
        <returns>Todo o conteúdo XML, incluindo a marcação, no nó atual. Se o nó atual não tiver nenhum filho, uma cadeia de caracteres vazia é retornada.  
  
 Se o nó atual não é um elemento nem atributo, uma cadeia de caracteres vazia é retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna todo o conteúdo do nó atual, inclusive a marcação. O nó atual (marca de início) e o nó de fim correspondente (marca de fim) não são retornados. Por exemplo, se você tiver o seguinte:  
  
```  
<node>  
 this <child id="123"/>  
</node>  
```  
  
 `ReadInnerXml` retorna `this <child id="123"/>`  
  
 Este método trata nós de elemento e atributo da seguinte maneira:  
  
|Tipo de nó|Posição antes da chamada|Fragmento XML|Valor retornado|Posição após a chamada|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na tag de início de `item1`.|\<Item1 > text1\</item1 >\<item2 > Texto2\</item2 >|text1|Na tag de início de `item2`.|  
|`Attribute`|No nó de atributo `attr1`.|\<item attr1 = attr2 "val1" = "val2" > texto \< /item >|val1|Permanece no nó de atributo `attr1`.|  
  
 Se o leitor estiver posicionado em um nó folha, chamar `ReadInnerXml` será o mesmo que chamar <xref:System.Xml.XmlReader.Read%2A>. O método retorna `String.Empty` (exceto para nós de atributo, caso em que o valor do atributo será retornado).  
  
 Este método verifica XML bem formado. Se `ReadInnerXml` é chamado de um <xref:System.Xml.XmlValidatingReader>, esse método também valida o conteúdo retornado.  
  
 Conforme implementado o <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> e `XmlValidatingReader` classes o `ReadOuterXml` método está ciente do namespace.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadInnerXmlAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir compara o `ReadInnerXml` e <xref:System.Xml.XmlReader.ReadOuterXml%2A> métodos.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 O exemplo usa `2books.xml` como entrada de arquivo.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O XML não foi bem formado, ou ocorreu um erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadInnerXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadInnerXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadInnerXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadInnerXmlAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadInnerXmlAsync&gt;c__async6))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê a todo o conteúdo, inclusive a marcação, como uma cadeia de caracteres de forma assíncrona.</summary>
        <returns>Todo o conteúdo XML, incluindo a marcação, no nó atual. Se o nó atual não tiver nenhum filho, uma cadeia de caracteres vazia é retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadInnerXml%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXml">
      <MemberSignature Language="C#" Value="public virtual string ReadOuterXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadOuterXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXml" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê o conteúdo, inclusive a marcação, que representa esse nó e todos os seus filhos.</summary>
        <returns>Se o leitor estiver posicionado em um elemento ou em um nó de atributo, esse método retornará todo o conteúdo XML, inclusive a marcação do nó atual e todos os seus filhos; caso contrário, ele retornará uma cadeia de caracteres vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é semelhante ao <xref:System.Xml.XmlReader.ReadInnerXml%2A> exceto que ele também retorna as marcas de início e término.  
  
 Este método trata nós de elemento e atributo da seguinte maneira:  
  
|Tipo de nó|Posição antes da chamada|Fragmento XML|Valor retornado|Posição após a chamada|  
|---------------|------------------------------|------------------|------------------|-----------------------------|  
|`Element`|Na tag de início de `item1`.|\<Item1 > text1\</item1 >\<item2 > Texto2\</item2 >|\<Item1 > text1\</item1 >|Na tag de início de `item2`.|  
|`Attribute`|No nó de atributo `attr1`.|\<item attr1 = attr2 "val1" = "val2" > texto \< /item >|attr1 = "val1"|Permanece no nó de atributo `attr1`.|  
  
 Se o leitor estiver posicionado em um nó folha, chamar `ReadOuterXml` será o mesmo que chamar <xref:System.Xml.XmlReader.Read%2A>. O método retorna `String.Empty` (exceto para nós de atributo, caso em que a marcação de atributo é retornada).  
  
 Este método verifica XML bem formado. Se `ReadOuterXml` é chamado de um <xref:System.Xml.XmlValidatingReader>, esse método também valida o conteúdo retornado  
  
 Conforme implementado o <xref:System.Xml.XmlNodeReader>, <xref:System.Xml.XmlTextReader> e `XmlValidatingReader` classes o `ReadOuterXml` método está ciente do namespace. Recebe o seguinte texto XML `<A xmlns:S="urn:1"><S:B>hello</S:B></A>`, se o leitor foi posicionado no `S:B` iniciar marca, `ReadOuterXml` retorna `<S:B xmlns:S="urn:1">hello<S:B/>`.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadOuterXmlAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir compara o `ReadInnerXml` e `ReadOuterXml` métodos.  
  
 [!code-csharp[XmlReaderBasic#12](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#12)]
 [!code-vb[XmlReaderBasic#12](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#12)]  
  
 O exemplo usa `2books.xml` como entrada de arquivo.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O XML não foi bem formado, ou ocorreu um erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadOuterXmlAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;string&gt; ReadOuterXmlAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;string&gt; ReadOuterXmlAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadOuterXmlAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.CompilerServices.AsyncStateMachine(typeof(System.Xml.XmlReader/&lt;ReadOuterXmlAsync&gt;c__async8))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Lê o conteúdo, inclusive a marcação, que representa este nó e todos os seus filhos de forma assíncrona.</summary>
        <returns>Se o leitor estiver posicionado em um elemento ou em um nó de atributo, esse método retornará todo o conteúdo XML, inclusive a marcação do nó atual e todos os seus filhos; caso contrário, ele retornará uma cadeia de caracteres vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadOuterXml%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Verifica se o nó atual é um elemento e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por <xref:System.Xml.XmlReader.Read%2A> para posicioná-lo sobre o conteúdo de elemento encontrado no fluxo de entrada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado um XML incorreto no fluxo de entrada.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento.</param>
        <summary>Verifica se o nó de conteúdo atual é um elemento com o <see cref="P:System.Xml.XmlReader.Name" /> fornecido e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para esse método corresponde a uma chamada para <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por uma chamada para <xref:System.Xml.XmlReader.Read%2A>.  
  
   
  
## Examples  
 O exemplo a seguir exibe o conteúdo do texto de cada elemento.  
  
 [!code-csharp[XmlReaderBasic#11](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#11)]
 [!code-vb[XmlReaderBasic#11](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#11)]  
  
 O exemplo usa o `book3.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#6](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/book3.xml#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado um XML incorreto no fluxo de entrada.  
  
 -ou-  
  
 O <see cref="P:System.Xml.XmlReader.Name" /> do elemento não corresponde ao <paramref name="name" /> fornecido.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadStartElement">
      <MemberSignature Language="C#" Value="public virtual void ReadStartElement (string localname, string ns);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReadStartElement(string localname, string ns) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadStartElement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localname" Type="System.String" />
        <Parameter Name="ns" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localname">O nome local do elemento.</param>
        <param name="ns">O URI do namespace do elemento.</param>
        <summary>Verifica se o nó de conteúdo atual é um elemento com o determinado <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> e avança o leitor para o próximo nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma chamada para esse método corresponde a uma chamada para <xref:System.Xml.XmlReader.IsStartElement%2A> seguido por uma chamada para <xref:System.Xml.XmlReader.Read%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Foi encontrado um XML incorreto no fluxo de entrada.  
  
 -ou-  
  
 O <see cref="P:System.Xml.XmlReader.LocalName" /> e <see cref="P:System.Xml.XmlReader.NamespaceURI" /> propriedades do elemento encontrado não coincidem com os argumentos determinados.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public abstract System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém o estado do leitor.</summary>
        <value>Um dos valores de enumeração que especifica o estado do leitor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xml.XmlReader.ReadState%2A> propriedade tem um dos seguintes valores:  
  
-   <xref:System.Xml.ReadState.Initial>, quando o <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> método é chamado.  
  
-   <xref:System.Xml.ReadState.Interactive>, quando o <xref:System.Xml.XmlReader.Read%2A?displayProperty=nameWithType> método foi chamado e métodos adicionais podem ser chamados do leitor.  
  
-   <xref:System.Xml.ReadState.EndOfFile>, quando o fim do documento XML foi alcançado com êxito.  
  
-   <xref:System.Xml.ReadState.Closed>, quando o <xref:System.Xml.XmlReader.Close%2A?displayProperty=nameWithType> método é chamado.  
  
-   <xref:System.Xml.ReadState.Error>, quando um erro está impedindo a operação de leitura de continuar.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public virtual string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, lê o conteúdo de um nó de elemento ou texto como uma cadeia de caracteres. No entanto, é recomendável que você use o método <see cref="Overload:System.Xml.XmlReader.ReadElementContentAsString" /> em vez disso, porque ele fornece uma maneira mais simples de lidar com essa operação.</summary>
        <returns>O conteúdo do elemento ou uma cadeia de caracteres vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Recomendamos que você use o <xref:System.Xml.XmlReader.ReadElementContentAsString%2A> método para ler o conteúdo de um nó de elemento ou texto como uma cadeia de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Erro ao analisar o XML.</exception>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadSubtree">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReader ReadSubtree ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlReader ReadSubtree() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadSubtree" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma nova instância <see langword="XmlReader" /> que pode ser usada para ler o nó atual e todos os seus descendentes.</summary>
        <returns>Uma nova instância de leitor XML definida como <see cref="F:System.Xml.ReadState.Initial" />. Uma chamada ao método <see cref="M:System.Xml.XmlReader.Read" /> posiciona o novo leitor no nó que era atual antes da chamada ao método <see cref="M:System.Xml.XmlReader.ReadSubtree" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.XmlReader.ReadSubtree%2A>pode ser chamado apenas em nós de elemento. Quando a subárvore inteira foi lido, chamadas para o <xref:System.Xml.XmlReader.Read%2A> método retornará `false`. Quando o novo leitor XML foi fechado, o original readeris posicionado no `EndElement` nó de subárvore. Portanto, se você chamou o <xref:System.Xml.XmlReader.ReadSubtree%2A> método na marca de início do elemento de catálogo, após a subárvore do novo leitor XML e leitura foi fechado, o leitor de XML original é posicionado na marca de fim do elemento de livro.  
  
 Você não deve executar qualquer operações no leitor original até que o novo leitor seja fechado. Esta ação não é suportada e pode levar ao comportamento imprevisível.  
  
> [!NOTE]
>  O <xref:System.Xml.XmlReader.ReadSubtree%2A> método não é destinado para creatingcopies dos dados XML que você pode trabalhar com independentemente. Designedto é criar um limite em torno de um elemento XML. Isso é útil se você deseja passar dados para outro componente para processamento e você deseja limitar a quantidade de dados pode acessar o componente. Quando você passa um leitor XML retornado pelo <xref:System.Xml.XmlReader.ReadSubtree%2A> método para outro aplicativo, o aplicativo pode acessar somente esse elemento XML, e não todo o documento XML.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o método <xref:System.Xml.XmlReader.ReadSubtree%2A>.  
  
 [!code-csharp[XmlReaderBasic#13](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#13)]
 [!code-vb[XmlReaderBasic#13](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#13)]  
  
 Use os seguintes dados XML para executar os exemplos neste tópico:  
  
```  
<?xml version="1.0" encoding="utf-8" ?>  
<Books>  
  <Book>  
    <Title>A Brief History of Time</Title>  
  </Book>  
  <Book>  
    <Title>Principle Of Relativity</Title>  
  </Book>  
  <Book>  
    <Title>Victory of Reason</Title>  
  </Book>  
  <Book>  
    <Title>The Unicorn that did not Fail</Title>  
  </Book>  
  <Book>  
    <Title>Rational Ontology</Title>  
  </Book>  
  <Book>  
    <Title>The Meaning of Pizza</Title>  
  </Book>  
</Books>  
  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento que você deseja mover para.</param>
        <summary>Avança o <see cref="T:System.Xml.XmlReader" /> para o próximo elemento descendente com o nome qualificado especificado.</summary>
        <returns>
          <see langword="true" />Se um elemento descendente correspondente for encontrado; Caso contrário, <see langword="false" />. Se um elemento filho correspondente não for encontrado, o <see cref="T:System.Xml.XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento.  
  
 Se o <see cref="T:System.Xml.XmlReader" /> não está posicionado em um elemento quando <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String)" /> foi chamado, esse método retorna <see langword="false" /> e a posição do <see cref="T:System.Xml.XmlReader" /> não é alterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir analisa o segundo nó de catálogo.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 O exemplo usa o arquivo de `2books.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToDescendant">
      <MemberSignature Language="C#" Value="public virtual bool ReadToDescendant (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToDescendant(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento que você deseja mover para.</param>
        <param name="namespaceURI">O URI do namespace do elemento que você deseja mover para.</param>
        <summary>Avança o <see cref="T:System.Xml.XmlReader" /> para o próximo elemento descendente com o nome local e URI do namespace especificados.</summary>
        <returns>
          <see langword="true" />Se um elemento descendente correspondente for encontrado; Caso contrário, <see langword="false" />. Se um elemento filho correspondente não for encontrado, o <see cref="T:System.Xml.XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento.  
  
 Se o <see cref="T:System.Xml.XmlReader" /> não está posicionado em um elemento quando <see cref="M:System.Xml.XmlReader.ReadToDescendant(System.String,System.String)" /> foi chamado, esse método retorna <see langword="false" /> e a posição do <see cref="T:System.Xml.XmlReader" /> não é alterado.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento.</param>
        <summary>Lê até que seja encontrado um elemento com o nome qualificado especificado.</summary>
        <returns>
          <see langword="true" />Se um elemento correspondente for encontrado; Caso contrário, <see langword="false" /> e o <see cref="T:System.Xml.XmlReader" /> está em um estado final do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é funcionalmente equivalente a executar o `following::name` expressão XPath do nó atual. Ele fornece uma maneira rápida de localizar um elemento nomeado no documento XML. Ele avança o leitor para o próximo elemento seguinte que corresponde ao nome especificado e retorna `true` se um elemento correspondente foi encontrado. Usando o exemplo a seguir, o leitor lê a primeira instância do elemento especificado ao ler para frente.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item");  
  
```  
  
 Esse método pode ser chamado em todos os tipos de nó.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToFollowing">
      <MemberSignature Language="C#" Value="public virtual bool ReadToFollowing (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToFollowing(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToFollowing(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Lê até que seja encontrado um elemento com o nome do local e o URI do namespace especificados.</summary>
        <returns>
          <see langword="true" />Se um elemento correspondente for encontrado; Caso contrário, <see langword="false" /> e o <see cref="T:System.Xml.XmlReader" /> está em um estado final do arquivo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é funcionalmente equivalente a executar o `following::name` expressão XPath do nó atual. Ele fornece uma maneira rápida de localizar um elemento nomeado no documento XML. Ele avança o leitor para o próximo elemento seguinte que corresponde ao nome especificado e retorna `true` se um elemento correspondente foi encontrado.  
  
```xml  
<!--"sample.xml"-->  
<?xmlversion="1.0">  
   <items>  
      <item xmls="urn:1"/>  
   </items>  
</xml>  
  
```  
  
```csharp  
XmlTextReader reader = newXmlTextReader("sample.xml");  
  
reader.ReadToFollowing("item", "urn:1");  
  
```  
  
 Esse método pode ser chamado em todos os tipos de nó.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento irmão para o qual você deseja realizar a movimentação.</param>
        <summary>Avança o <see langword="XmlReader" /> para o próximo elemento irmão com o nome qualificado especificado.</summary>
        <returns>
          <see langword="true" />Se um elemento irmão correspondente for encontrado; Caso contrário, <see langword="false" />. Se um elemento irmão correspondente não for encontrado, o <see langword="XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento pai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Não chame <xref:System.Xml.XmlReader.ReadToNextSibling%2A> quando o `XmlReader` é um estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> é <xref:System.Xml.ReadState.Initial>). Você pode chamar <xref:System.Xml.XmlReader.Read%2A> para avançar o `XmlReader` e, em seguida, chamar o <xref:System.Xml.XmlReader.ReadToNextSibling%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir lê o atributo ISBN em cada nó do catálogo.  
  
 [!code-csharp[XmlReaderBasic#15](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#15)]
 [!code-vb[XmlReaderBasic#15](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentException">O parâmetro é uma cadeia de caracteres vazia.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadToNextSibling">
      <MemberSignature Language="C#" Value="public virtual bool ReadToNextSibling (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool ReadToNextSibling(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadToNextSibling(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O nome local do elemento irmão que você deseja mover para.</param>
        <param name="namespaceURI">O URI do elemento irmão do namespace que você deseja mover para.</param>
        <summary>Avança o <see langword="XmlReader" /> para o próximo elemento irmão com o nome do local especificado e o URI de namespace.</summary>
        <returns>
          <see langword="true" />Se um elemento irmão correspondente for encontrado; Caso contrário, <see langword="false" />. Se um elemento irmão correspondente não for encontrado, o <see langword="XmlReader" /> é posicionado na marca de fim (<see cref="P:System.Xml.XmlReader.NodeType" /> é <see langword="XmlNodeType.EndElement" />) do elemento pai.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Não chame <xref:System.Xml.XmlReader.ReadToNextSibling%2A> quando o `XmlReader` é um estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> é <xref:System.Xml.ReadState.Initial>). Você pode chamar <xref:System.Xml.XmlReader.Read%2A> para avançar o `XmlReader` e, em seguida, chamar o <xref:System.Xml.XmlReader.ReadToNextSibling%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentNullException">Ambos os valores de parâmetro são <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunk">
      <MemberSignature Language="C#" Value="public virtual int ReadValueChunk (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ReadValueChunk(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A matriz de caracteres que serve como o buffer no qual os conteúdos de texto são gravados. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento dentro do buffer onde o <see cref="T:System.Xml.XmlReader" /> pode começar a copiar os resultados.</param>
        <param name="count">O número máximo de caracteres a serem copiados para o buffer. O número real de caracteres copiada é retornado deste método.</param>
        <summary>Lê grandes fluxos de texto inseridos em um documento XML.</summary>
        <returns>O número de caracteres lidos no buffer. O valor zero é retornado quando não há mais nenhum conteúdo de texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método permite a leitura de grandes fluxos de texto inserido em um documento XML em um modo de streaming, ou seja, um pequeno número de caracteres de cada vez, em vez de alocar uma única cadeia de caracteres para o valor inteiro. Esse método pode ser chamado em qualquer nó que possui um valor (<xref:System.Xml.XmlReader.HasValue%2A> é `true`), no entanto, streaming real do valor do nó ocorre apenas quando chamado em um texto, o espaço em branco e nós de espaço em branco significativo. Outros valores de tipo de nó são armazenados em cache, incluindo atributos e nós CDATA.  
  
 Esse método retorna apenas o conteúdo do <xref:System.Xml.XmlReader.Value%2A> propriedade e não move o <xref:System.Xml.XmlReader>.  
  
 Esse método lê o número especificado de caracteres (`count`) do valor do nó em um buffer de caractere (`buffer`) em um deslocamento especificado (`index`) e retorna o número de caracteres gravada no buffer. Retorna o `0` quando ele atingiu o final do valor. Ele não pode ser reiniciado para ler o valor novamente.  
  
 Entre chamadas para <xref:System.Xml.XmlReader.ReadValueChunk%2A> o <xref:System.Xml.XmlReader> propriedades não fazem nenhuma alteração, exceto para o <xref:System.Xml.XmlReader.Value%2A> propriedade. Quando o <xref:System.Xml.XmlReader.Value%2A> propriedade seja acessada ou pode retornar um valor parcial (com caracteres ainda não foi retornados por <xref:System.Xml.XmlReader.ReadValueChunk%2A>) ou um valor total dependendo da implementação. Todos os a <xref:System.Xml.XmlReader> implementações no <xref:System.Xml> namespace retornar um valor parcial para a <xref:System.Xml.XmlReader.Value%2A> implementação da propriedade.  
  
 Qualquer leitura método pode ser chamado entre chamadas para <xref:System.Xml.XmlReader.ReadValueChunk%2A>. Se isso ocorrer, o <xref:System.Xml.XmlReader> move para o próximo <xref:System.Xml.XmlNodeType> no fluxo e quaisquer caracteres ainda não foram retornadas serão ignorados.  
  
 Pode haver um caso quando <xref:System.Xml.XmlReader.ReadValueChunk%2A> retorna menor do que o número solicitado de caracteres. Por exemplo, se você tiver um valor longo de 200 caracteres com um par substituto em posições 127 e 128 e você chamou <xref:System.Xml.XmlReader.ReadValueChunk%2A> com um buffer de 128 caracteres, a chamada do método retornaria 127 caracteres em vez de 128 solicitada. O par substituto seria retornado, em seguida, na próxima <xref:System.Xml.XmlReader.ReadValueChunk%2A> chamar. Nesse caso, <xref:System.Xml.XmlReader.ReadValueChunk%2A> não retornou as 128 caracteres solicitadas porque fazer assim teria resultado em um par substituto incompletas no final do buffer.  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.ReadValueChunkAsync%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <exception cref="T:System.ArgumentNullException">O valor de <paramref name="buffer" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O índice do buffer ou a contagem de índices + é maior que o tamanho do buffer alocado.</exception>
        <exception cref="T:System.NotSupportedException">A implementação <see cref="T:System.Xml.XmlReader" /> não dá suporte a esse método.</exception>
        <exception cref="T:System.Xml.XmlException">Os dados XML não estão bem formados.</exception>
      </Docs>
    </Member>
    <Member MemberName="ReadValueChunkAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task&lt;int&gt; ReadValueChunkAsync (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task`1&lt;int32&gt; ReadValueChunkAsync(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ReadValueChunkAsync(System.Char[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">A matriz de caracteres que serve como o buffer no qual os conteúdos de texto são gravados. Este valor pode não ser <see langword="null" />.</param>
        <param name="index">O deslocamento dentro do buffer onde o <see cref="T:System.Xml.XmlReader" /> pode começar a copiar os resultados.</param>
        <param name="count">O número máximo de caracteres a serem copiados para o buffer. O número real de caracteres copiada é retornado deste método.</param>
        <summary>Lê grandes fluxos de texto inserido em um documento XML de forma assíncrona.</summary>
        <returns>O número de caracteres lidos no buffer. O valor zero é retornado quando não há mais nenhum conteúdo de texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.ReadValueChunk%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public abstract void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.ResolveEntity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando substituído em uma classe derivada, resolve a referência da entidade para nós <see langword="EntityReference" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o leitor estiver posicionado em uma `EntityReference` nó (`XmlNodeType.EntityReference`), se <xref:System.Xml.XmlReader.Read%2A> é chamado depois de chamar esse método, o texto de substituição da entidade é analisado. Quando o texto de substituição da entidade for concluído, um `EndEntity` nó é retornado para fechar o escopo de referência de entidade.  
  
> [!NOTE]
>  Depois de chamar esse método, se a entidade fizer parte de um valor de atributo, você deve chamar <xref:System.Xml.XmlReader.ReadAttributeValue%2A> para entrar na entidade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public virtual System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as informações de esquema que foram atribuídas ao nó atual como resultado da validação de esquema.</summary>
        <value>Um objeto <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> que contém as informações de esquema para o nó atual. Informações de esquema podem ser definidas em elementos, atributos, ou em nós de texto com não null <see cref="P:System.Xml.XmlReader.ValueType" /> (valores do tipo).  
  
 Se o nó atual não é um dos tipos de nó acima, ou se o <see langword="XmlReader" /> instância não relata informações de esquema, essa propriedade retornará <see langword="null" />.  
  
 Se essa propriedade for chamada de um <see cref="T:System.Xml.XmlTextReader" /> ou um <see cref="T:System.Xml.XmlValidatingReader" /> de objeto, essa propriedade sempre retorna <see langword="null" />. Essas <see langword="XmlReader" /> implementações não expõem informações de esquema por meio de <see langword="SchemaInfo" /> propriedade.  
  
 <block subset="none" type="note"><para>  
 Se você precisa obter o conjunto de informações de post-schema-validação (psvi POST) para um elemento, posicione o leitor a marca de fim do elemento, em vez da marca de início. Obter a psvi POST por meio de <see langword="SchemaInfo" /> propriedade de um leitor. O leitor de validação que é criado por meio de <see cref="Overload:System.Xml.XmlReader.Create" /> com o <see cref="P:System.Xml.XmlReaderSettings.ValidationType" /> propriedade definida como <see cref="F:System.Xml.ValidationType.Schema" /> tem psvi POST completa para um elemento somente quando o leitor é posicionado na marca de fim de um elemento.  
  
</para></block></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xml.Schema.IXmlSchemaInfo> interface expõe um subconjunto do Post esquema validação Infoset psvi (POST) associado a um nó XML.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Settings">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlReaderSettings Settings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlReaderSettings Settings" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Settings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlReaderSettings</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Xml.XmlReaderSettings" /> usado para criar essa instância <see cref="T:System.Xml.XmlReader" />.</summary>
        <value>O objeto <see cref="T:System.Xml.XmlReaderSettings" /> usado para criar essa instância do leitor. Se este leitor não foi criado usando o <see cref="Overload:System.Xml.XmlReader.Create" /> método, essa propriedade retornará <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  O <xref:System.Xml.XmlReaderSettings> objeto pode conter informações confidenciais, como as credenciais do usuário. Aplicativos devem ter cuidado quando este objeto de cache ou passá-lo para outro componente.  
  
 O <xref:System.Xml.XmlReaderSettings> classe é usada para especificar o conjunto de recursos para dar suporte na instância do leitor criado. O <xref:System.Xml.XmlReaderSettings> objeto retornado por essa propriedade não pode ser modificado. Qualquer tentativa de alterar configurações individuais resulta em uma exceção sendo lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public virtual void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.Skip" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ignora os filhos do nó atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No seguinte XML de entrada se o leitor estiver posicionado no `<a>` nó ou qualquer um de seus atributos, chamando `Skip` posiciona o leitor a `<b>` nó.  
  
 Se o leitor está posicionado em um nó folha já (como o `<x>` nó ou texto `abc`), chamar `Skip` é o mesmo que chamar <xref:System.Xml.XmlReader.Read%2A>.  
  
```  
<a name="bob" age="123">  
 <x/>abc<y/>  
</a>  
<b>  
...  
</b>  
```  
  
 Este método verifica XML bem formado.  
  
 Se o leitor é uma <xref:System.Xml.XmlValidatingReader>, esse método também valida o conteúdo foi ignorado.  
  
 O `XmlReader` implementação determina se ou não o `Skip` método expandirá entidades externas. A tabela a seguir descreve se a entidades externas são expandidas para vários tipos de `XmlReader` objetos.  
  
|Tipo de XmlReader|Expande a entidades externas|  
|-----------------------|-------------------------------|  
|<xref:System.Xml.XmlTextReader>|Nº|  
|<xref:System.Xml.XmlReader>instância criada pelo <xref:System.Xml.XmlReader.Create%2A> método que está lendo dados de texto.|Nº|  
|<xref:System.Xml.XmlReader>instância criada pelo <xref:System.Xml.XmlReader.Create%2A> método que está lendo dados binários.|Não aplicável.|  
|Validando um esquema <xref:System.Xml.XmlReader> instância criada pelo <xref:System.Xml.XmlReader.Create%2A> método.|Sim.|  
|<xref:System.Xml.XmlValidatingReader>|Sim.|  
|<xref:System.Xml.XmlReader>instância retornada por uma <xref:System.Xml.XPath.XPathNavigator> objeto.|Não aplicável.|  
|<xref:System.Xml.XmlNodeReader>|Nº|  
|<xref:System.Xml.XmlReader>instância encapsulada com outro <xref:System.Xml.XmlReader> instância.|Depende da implementação de base <xref:System.Xml.XmlReader>. (O `Skip` método subjacente <xref:System.Xml.XmlReader> é chamado).|  
  
 Para obter a versão assíncrona do método, consulte <xref:System.Xml.XmlReader.SkipAsync%2A>.  
  
   
  
## Examples  
 O exemplo a seguir analisa um arquivo XML iniciando no segundo nó de catálogo.  
  
 [!code-csharp[XmlReaderBasic#14](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#14)]
 [!code-vb[XmlReaderBasic#14](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#14)]  
  
 O exemplo usa o arquivo de `2books.xml`, como entrada.  
  
 [!code-xml[XML_Core_Files#7](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/2books.xml#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="SkipAsync">
      <MemberSignature Language="C#" Value="public virtual System.Threading.Tasks.Task SkipAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Threading.Tasks.Task SkipAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlReader.SkipAsync" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Assincronamente ignora os filhos do nó atual.</summary>
        <returns>O nó atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa é a versão assíncrona do <xref:System.Xml.XmlReader.Skip%2A>, com a mesma funcionalidade. Para usar esse método, você deve definir o <xref:System.Xml.XmlReaderSettings.Async%2A> sinalizador como `true`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método assíncrono <see cref="T:System.Xml.XmlReader" /> foi chamado sem definir o sinalizador <see cref="P:System.Xml.XmlReaderSettings.Async" /> como <see langword="true" />. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "Conjunto XmlReaderSettings como verdadeiro se desejar usar métodos assíncronos".</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public abstract string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando é substituído em uma classe derivada, obtém o valor do texto do nó atual.</summary>
        <value>O valor retornado depende do <see cref="P:System.Xml.XmlReader.NodeType" /> do nó. A tabela a seguir lista os tipos de nós que têm um valor a ser retornado. Todos os outros nós tipos de retorno <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term>Tipo de nó  
  
 </term><description>Valor  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description>O valor do atributo.  
  
 </description></item><item><term><see langword="CDATA" /></term><description>O conteúdo da seção CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description>O conteúdo do comentário.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description>O subconjunto interno.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description>Todo o conteúdo, exceto o destino.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description>O espaço em branco entre a marcação em um modelo de conteúdo misto.  
  
 </description></item><item><term><see langword="Text" /></term><description>O conteúdo do nó de texto.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description>O espaço em branco entre a marcação.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description>O conteúdo da declaração.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obter a versão assíncrona desta propriedade, consulte o <xref:System.Xml.XmlReader.GetValueAsync%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir lê um arquivo XML e exibe cada um de nós.  
  
 [!code-csharp[XmlReaderBasic#8](~/samples/snippets/csharp/VS_Snippets_Data/XmlReaderBasic/CS/XmlReader_Basic.cs#8)]
 [!code-vb[XmlReaderBasic#8](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlReaderBasic/VB/xmlreader_basic.vb#8)]  
  
 O exemplo usa o `items.xml` arquivo.  
  
 [!code-xml[XML_Core_Files#2](~/samples/snippets/xml/VS_Snippets_Data/XML_Core_Files/XML/items.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="ValueType">
      <MemberSignature Language="C#" Value="public virtual Type ValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ValueType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.ValueType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo CLR (Common Language Runtime) para o nó atual.</summary>
        <value>O tipo CLR que corresponde ao valor digitado do nó. O padrão é <see langword="System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Consulte [suporte a tipo nas Classes System. XML](~/docs/standard/data/xml/type-support-in-the-system-xml-classes.md) para obter uma lista de mapeamentos padrão.  
  
 Um elemento do tipo `xs:int` tem um `ValueType` de `System.Int32` por padrão. No entanto, o `ValueType` pode ser um dos tipos válidos que podem ser mapeados para `xs:int`, como `System.Int16` ou `System.Double`.  
  
 Se um nó for não digitado, ou se o nó é um elemento que contém conteúdo misto, o valor do nó é mapeado para o `System.String` tipo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
        <block subset="none" type="overrides">
          <para>Os implementadores devem fornecer um <see langword="ValueType" /> para cada nó, mesmo se ele é somente o <see langword="System.String" /> tipo.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public virtual string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém a atual <see langword="xml:lang" /> escopo.</summary>
        <value>Atual <see langword="xml:lang" /> escopo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade representa o `xml:lang` escopo no qual reside o nó atual. Por exemplo, aqui está um fragmento XML com `xml:lang` definido como inglês (EUA) no elemento raiz:  
  
```  
<root xml:lang="en-us">   
<name>Fred</name>   
</root>   
```  
  
 Quando o leitor está posicionado no `name` elemento, você pode usar essa propriedade para encontrar-se no escopo de um inglês americano `xml:lang` atributo.  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.XmlLang%2A?displayProperty=nameWithType> para obter um exemplo de como usar essa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Quando substituído em uma classe derivada, obtém a atual <see langword="xml:space" /> escopo.</summary>
        <value>Um dos valores de <see cref="T:System.Xml.XmlSpace" />. Se nenhum <see langword="xml:space" /> existe escopo, essa propriedade padroniza como <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Consulte <xref:System.Xml.XmlTextReader.XmlSpace%2A> (no `XmlTextReader` classe) para um exemplo que usa essa propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Um método <see cref="T:System.Xml.XmlReader" /> foi chamado antes do término de uma operação assíncrona anterior. Nesse caso, <see cref="T:System.InvalidOperationException" /> será lançada com a mensagem "uma operação assíncrona já está em andamento."</exception>
      </Docs>
    </Member>
  </Members>
</Type>
