<Type Name="XmlDocument" FullName="System.Xml.XmlDocument">
  <TypeSignature Language="C#" Value="public class XmlDocument : System.Xml.XmlNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlDocument extends System.Xml.XmlNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlDocument" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XmlDocument</AssemblyName>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa um documento XML. Você pode usar essa classe para carregar, validar, editar, adicionar e posicionar o XML em um documento.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="Remarks"></a>O <xref:System.Xml.XmlDocument> classe é uma representação na memória de um documento XML. Ele implementa o W3C [modelo de objeto de documento (DOM) XML](~/docs/standard/data/xml/xml-document-object-model-dom.md) principal do nível 1 e o nível de DOM principal 2.  
  
 *DOM* significa *modelo de objeto de documento*. Para saber mais sobre ele, consulte [modelo de objeto de documento (DOM) XML](~/docs/standard/data/xml/xml-document-object-model-dom.md).  
  
 Você pode carregar o XML no DOM usando o <xref:System.Xml.XmlDocument> classe e programaticamente ler, modificar e remover o documento XML.  
  
 Se você quiser forçar abrir o <xref:System.Xml.XmlDocument> classe e como ele é implementado, consulte o [fonte de referência](http://referencesource.microsoft.com/#System.Xml/Xml/System/Xml/Dom/XmlDocument.cs#f82a4c1bd1f0ee12).  
  
<a name="Common"></a>   
## <a name="tasks"></a>Tarefas  
  
-   [Carregar o XML no modelo de objeto de documento](#Load)  
  
-   [Valide-o em um esquema](#Validation)  
  
-   [Navegar na árvore do documento](#Navigate)  
  
-   [Localizar nós](#Find)  
  
-   [Editar nós](#Edit)  
  
-   [Adicionar nós](#Add)  
  
-   [Remover nós](#Remove)  
  
-   [Nós de posição](#Position)  
  
<a name="Load"></a>   
## <a name="load-xml-into-the-document-object-model"></a>Carregar o XML no modelo de objeto de documento  
 Iniciar com um documento XML como esta. Ele é apenas alguns livros em uma coleção. Mas ele contém os itens básicos que você encontraria em qualquer documento XML; um namespace, os elementos que representam os dados e os atributos que descrevem os dados.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<books xmlns="http://www.contoso.com/books">  
  <book genre="novel" ISBN="1-861001-57-8" publicationdate="1823-01-28">  
    <title>Pride And Prejudice</title>  
    <price>24.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861002-30-1" publicationdate="1985-01-01">  
    <title>The Handmaid's Tale</title>  
    <price>29.95</price>  
  </book>  
  <book genre="novel" ISBN="1-861001-45-3" publicationdate="1811-01-01">  
    <title>Sense and Sensibility</title>  
    <price>19.95</price>  
  </book>  
</books>  
```  
  
 Em seguida, carregar esses dados no DOM, para que você possa trabalhar com ele na memória. A maneira mais popular de fazer isso é se referir a um arquivo no computador local ou em uma rede.  
  
 Este exemplo carrega o XML de um arquivo. Se o arquivo não existir, ele apenas gera XML e o carrega.  
  
 [!code-cpp[XMLProcessingApp#1](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#1)]
 [!code-csharp[XMLProcessingApp#1](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#1)]
 [!code-vb[XMLProcessingApp#1](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#1)]  
  
 **Exemplo completo:** [manipular XML na memória usando a classe XmlDocument e outros tipos de relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Saiba mais:** [ler um documento XML no DOM](~/docs/standard/data/xml/reading-an-xml-document-into-the-dom.md)  
  
<a name="Validation"></a>   
## <a name="validate-it-against-a-schema"></a>Valide-o em um esquema  
 Iniciar com um esquema XML como esse. Esse esquema define os tipos de dados no XML e os atributos que são necessários.  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"  
  attributeFormDefault="unqualified"   
  elementFormDefault="qualified"  
  targetNamespace="http://www.contoso.com/books">   
  <xs:element name="books">  
    <xs:complexType>  
      <xs:sequence>  
        <xs:element maxOccurs="unbounded" name="book">  
          <xs:complexType>  
            <xs:sequence>  
              <xs:element name="title" type="xs:string" />  
              <xs:element name="price" type="xs:decimal" />  
            </xs:sequence>  
            <xs:attribute name="genre" type="xs:string" use="required" />  
            <xs:attribute name="ISBN" type="xs:string" use="required" />  
            <xs:attribute name="publicationdate" type="xs:date" use="required" />  
          </xs:complexType>  
        </xs:element>  
      </xs:sequence>  
    </xs:complexType>  
  </xs:element>  
</xs:schema>  
```  
  
 Criar um <xref:System.Xml.XmlReader> usando a esquema do objeto e, em seguida, carregar esse objeto no DOM. Crie um manipulador de eventos que é executado quando o código tentar modificar o arquivo XML de maneiras que violam as regras do esquema.  
  
 Esses blocos de código mostram métodos auxiliares que fazem tudo isso.  
  
 [!code-cpp[XMLProcessingApp#2](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#2)]
 [!code-csharp[XMLProcessingApp#2](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#2)]
 [!code-vb[XMLProcessingApp#2](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#2)]  
  
 **Exemplo completo:** [manipular XML na memória usando a classe XmlDocument e outros tipos de relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Saiba mais:** [Validando um documento XML no DOM](~/docs/standard/data/xml/validating-an-xml-document-in-the-dom.md)  
  
<a name="Navigate"></a>   
## <a name="navigate-the-document-tree"></a>Navegar na árvore do documento  
 Você pode usar propriedades para navegar em torno de um documento XML. Mas, antes de usar qualquer um deles, vamos analisar rapidamente alguns termos. O documento é composto de nós. Cada nó tem como único *pai* nó diretamente acima dele. O único nó que não tem um nó pai é a raiz do documento, porque é o nó de nível superior. A maioria de nós podem ter *filho* nós, que são nós diretamente abaixo deles. Os nós que estão no mesmo nível são *irmãos*.  
  
 Os exemplos a seguir mostram como obter o nó raiz, ir para o primeiro nó filho do nó raiz, acessar qualquer um de seus nós filho, receber de volta para o nó pai e, em seguida, navegue entre nós irmãos.  
  
 **Iniciar com o nó raiz**  
  
 Este exemplo obtém o nó raiz e, em seguida, usa esse nó para o conteúdo do documento para o console de saída.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Obter nós filho**  
  
 Este exemplo salta para o primeiro nó filho do nó raiz e, em seguida, itera por meio de nós filho do nó, se existir alguma.  
  
 [!code-cpp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.HasChildNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.HasChildNodes Example/VB/source.vb#1)]  
  
 **Voltar para o nó pai**  
  
 Use a propriedade <xref:System.Xml.XmlDocument.ParentNode%2A>.  
  
 **Consulte para o último nó filho**  
  
 Este exemplo grava o preço de um livro para o console (que é o último nó filho de um nó de catálogo).  
  
 [!code-cpp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.LastChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.LastChild Example/VB/source.vb#1)]  
  
 **Navegue para a frente entre irmãos**  
  
 Este exemplo move para frente de um catálogo para o catálogo. Nós de catálogo são irmãos um ao outro.  
  
 [!code-cpp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.NextSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.NextSibling Example/VB/source.vb#1)]  
  
 **Navegar para trás entre irmãos**  
  
 Este exemplo move com versões anteriores de um catálogo para o catálogo.  
  
 [!code-cpp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.PreviousSibling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.PreviousSibling Example/VB/source.vb#1)]  
  
<a name="Find"></a>   
## <a name="find-nodes"></a>Localizar nós  
 A maneira mais comum para localizar um ou mais nós de dados é usar uma cadeia de caracteres de consulta do XPath, mas também há métodos que não exigem um.  
  
 **Obter um único nó**  
  
 Este exemplo localiza um livro usando o número ISBN.  
  
 [!code-cpp[XMLProcessingApp#3](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#3)]
 [!code-csharp[XMLProcessingApp#3](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#3)]
 [!code-vb[XMLProcessingApp#3](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#3)]  
  
 A cadeia de caracteres usada nesse exemplo é uma consulta Xpath. Você pode encontrar mais exemplos de aqui: [exemplos de XPath](https://msdn.microsoft.com/en-us/library/ms256086.aspx).  
  
 Você também pode usar o <xref:System.Xml.XmlDocument.GetElementById%2A> para recuperar nós. Para usar essa abordagem, você precisará definir IDs nas declarações de definição de tipo de documento do arquivo XML.  
  
 Depois de obter um nó, você pode obter o valor dos atributos ou nós filho. Este exemplo faz isso com um nó de catálogo.  
  
 [!code-cpp[XMLProcessingApp#4](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#4)]
 [!code-csharp[XMLProcessingApp#4](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#4)]
 [!code-vb[XMLProcessingApp#4](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#4)]  
  
 **Obtém uma coleção de nós**  
  
 Este exemplo seleciona todos os livros, onde é o nome do autor última **Austen**e, em seguida, altera o preço desses catálogos.  
  
 [!code-cpp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlNode.SelectNodes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlNode.SelectNodes Example/VB/source.vb#1)]  
  
 Você também pode obter uma coleção de nós usando o nome do nó. Por exemplo, este exemplo obtém uma coleção de todos os títulos de livro.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 **Exemplo completo:** [manipular XML na memória usando a classe XmlDocument e outros tipos de relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Saiba mais:** [selecionar nós usando navegação XPath](~/docs/standard/data/xml/select-nodes-using-xpath-navigation.md)  
  
<a name="Edit"></a>   
## <a name="edit-nodes"></a>Editar nós  
 Este exemplo edita um nó de catálogo e seus atributos.  
  
 [!code-cpp[XMLProcessingApp#7](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#7)]
 [!code-csharp[XMLProcessingApp#7](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#7)]
 [!code-vb[XMLProcessingApp#7](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#7)]  
  
 **Saiba mais:** [modificando nós, conteúdo e os valores em um documento XML](~/docs/standard/data/xml/modifying-nodes-content-and-values-in-an-xml-document.md)  
  
 **Exemplo completo:** [manipular XML na memória usando a classe XmlDocument e outros tipos de relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
<a name="Add"></a>   
## <a name="add-nodes"></a>Adicionar nós  
 Para adicionar um nó, use o <xref:System.Xml.XmlDocument.CreateElement%2A> método ou o <xref:System.Xml.XmlDocument.CreateNode%2A> método.  
  
 Para adicionar um nó de dados como um livro, use o <xref:System.Xml.XmlDocument.CreateElement%2A> método.  
  
 Para qualquer outro tipo de nó como um comentário, espaço em branco ou nó CDATA, use o <xref:System.Xml.XmlDocument.CreateNode%2A> método.  
  
 Este exemplo cria um nó de catálogo, adiciona attrubutes para esse nó e, em seguida, adiciona o nó no documento.  
  
 [!code-cpp[XMLProcessingApp#5](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#5)]
 [!code-csharp[XMLProcessingApp#5](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#5)]
 [!code-vb[XMLProcessingApp#5](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#5)]  
  
 **Exemplo completo:** [manipular XML na memória usando a classe XmlDocument e outros tipos de relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Saiba mais:** [inserindo nós em um documento XML](~/docs/standard/data/xml/inserting-nodes-into-an-xml-document.md)  
  
<a name="Remove"></a>   
## <a name="remove-nodes"></a>Remover nós  
 Para remover um nó, use o <xref:System.Xml.XmlNode.RemoveChild%2A> método.  
  
 Este exemplo remove um livro do documento e qualquer espaço em branco que aparece antes do nó de catálogo.  
  
 [!code-cpp[XMLProcessingApp#6](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#6)]
 [!code-csharp[XMLProcessingApp#6](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#6)]
 [!code-vb[XMLProcessingApp#6](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#6)]  
  
 **Exemplo completo:** [manipular XML na memória usando a classe XmlDocument e outros tipos de relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 **Saiba mais:** [remover nós, conteúdo e os valores de um documento XML](~/docs/standard/data/xml/removing-nodes-content-and-values-from-an-xml-document.md)  
  
<a name="Position"></a>   
## <a name="position-nodes"></a>Nós de posição  
 Você pode escolher onde deseja que um nó aparecer no documento usando o <xref:System.Xml.XmlNode.InsertBefore%2A> e <xref:System.Xml.XmlNode.InsertAfter%2A> métodos.  
  
 Este exemplo mostra dois métodos auxiliares. Um deles move um nó superior em uma lista. O outro um move um nó inferior.  
  
 Esses métodos podem ser usados em um aplicativo que permite aos usuários mover manuais para cima e para baixo em uma lista de livros. Quando um usuário escolhe um livro e pressiona um backup ou para baixo do botão, o código pode chamar métodos como esses para posicionar o nó de catálogo correspondente antes ou depois de outros nós de catálogo.  
  
 [!code-cpp[XMLProcessingApp#8](~/samples/snippets/cpp/VS_Snippets_Data/xmlprocessingapp/cpp/xmldomprocessing.cpp#8)]
 [!code-csharp[XMLProcessingApp#8](~/samples/snippets/csharp/VS_Snippets_Data/xmlprocessingapp/cs/xmlhelpermethods.cs#8)]
 [!code-vb[XMLProcessingApp#8](~/samples/snippets/visualbasic/VS_Snippets_Data/xmlprocessingapp/vb/xmlhelpermethods.vb#8)]  
  
 **Exemplo completo:** [manipular XML na memória usando a classe XmlDocument e outros tipos de relacionados](https://code.msdn.microsoft.com/windowsdesktop/Manipulate-XML-in-memory-4b612d6b/view/SourceCode)  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Xml.XmlDocument" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este é um exemplo de validação de tempo de carregamento. Um tipo de documento DTD (definição) Validando <xref:System.Xml.XmlReader> é passado para o <xref:System.Xml.XmlDocument.Load%2A> método e uma <xref:System.Xml.Schema.ValidationEventHandler> é fornecido para notificar os usuários sobre os erros de validação. Neste exemplo, um erro de validação for encontrado, mas o documento ainda é carregado. Como alternativa, você pode definir uma validação <xref:System.Xml.XmlReader> para lançar uma exceção e interromper o processo de carregamento quando é encontrado um erro de validação não especificando o <xref:System.Xml.Schema.ValidationEventHandler>. Para obter mais informações sobre a validação de dados XML, consulte a seção comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 [!code-cpp[XmlDocument.cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.cctor/CPP/docload.cpp#1)]
 [!code-csharp[XmlDocument.cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.cctor/CS/docload.cs#1)]
 [!code-vb[XmlDocument.cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.cctor/VB/docload.vb#1)]  
  
 O exemplo usa o arquivo `bookDTD.xml` como entrada.  
  
 [!code-xml[XmlDocument.cctor#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.cctor/XML/bookdtd.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlDocument (System.Xml.XmlImplementation imp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlImplementation imp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlImplementation)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="imp" Type="System.Xml.XmlImplementation" />
      </Parameters>
      <Docs>
        <param name="imp">O <see langword="XmlImplementation" /> a ser usado.</param>
        <summary>Inicializa uma nova instância da classe <see langword="XmlDocument" /> com o <see cref="T:System.Xml.XmlImplementation" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlDocument (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.#ctor(System.Xml.XmlNameTable)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">O <see langword="XmlNameTable" /> a ser usado.</param>
        <summary>Inicializa uma nova instância da classe <see langword="XmlDocument" /> com o <see cref="T:System.Xml.XmlNameTable" /> especificado.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI base do nó atual.</summary>
        <value>O local do qual o nó foi carregado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um documento XML em rede é composto de partes de dados agregados usando vários mecanismos de inclusão padrão do W3C e, portanto, contém nós que vêm de diferentes locais. O `BaseURI` informa onde veio esses nós.  
  
 Para nós do documento, `BaseURI` retorna o local do documento XML. Por exemplo, se o `XmlDocument` foi carregada usando o seguinte documento de chamada. Carga ("http://server/mydata.xml"), o `BaseURI` para o documento de nó é http://server/mydata.xml. No entanto, se o <xref:System.Xml.XmlDocument.Load%2A> método é redirecionado pelo servidor para um URI diferente, `BaseURI` retorna o URI original passado para o `Load` método.  
  
 Essa propriedade é uma extensão da Microsoft do DOM (Modelo de Objeto do Documento). Para obter informações adicionais sobre `BaseURI` e como ele se comporta com outros tipos de nó, consulte <xref:System.Xml.XmlNode.BaseURI%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode CloneNode (bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XmlNode CloneNode(bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CloneNode(System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="deep">
          <see langword="true" /> para recursivamente clonar a subárvore abaixo do nó especificado; <see langword="false" /> para clonar apenas o próprio nó.</param>
        <summary>Cria uma duplicação deste nó.</summary>
        <returns>O nó <see langword="XmlDocument" /> clonado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método funciona como um construtor de cópia para nós. O nó clonado não tem nenhum pai (<xref:System.Xml.XmlNode.ParentNode%2A> retorna `null`).  
  
 Se `deep` é `true`, o nó clonado inclui todos os nós filho, caso contrário, somente o `XmlDocument` nó for clonado. Consulte o <xref:System.Xml.XmlNode.CloneNode%2A?displayProperty=nameWithType> método para ver como esse método se comporta em outros tipos de nó.  
  
   
  
## Examples  
 O exemplo a seguir mostra a diferença entre um clone profundo e superficial.  
  
 [!code-cpp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CloneNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CloneNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do atributo. Se o nome contém dois-pontos, o <see cref="P:System.Xml.XmlNode.Prefix" /> propriedade reflete a parte do nome do anterior o vírgula primeiro e o <see cref="P:System.Xml.XmlDocument.LocalName" /> propriedade reflete a parte do nome após o primeiro dois-pontos. O <see cref="P:System.Xml.XmlNode.NamespaceURI" /> permanece vazia, a menos que o prefixo é um prefixo interno reconhecido como xmlns. Nesse caso <see langword="NamespaceURI" /> tem um valor de http://www.w3.org/2000/xmlns/.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlAttribute" /> com o <see cref="P:System.Xml.XmlDocument.Name" /> especificado.</summary>
        <returns>O novo <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `XmlAttribute` podem ser adicionados a um <xref:System.Xml.XmlElement> usando o <xref:System.Xml.XmlElement.SetAttributeNode%2A> método.  
  
   
  
## Examples  
 A seguir cria um atributo e adiciona-o a um documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateAttribute Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public System.Xml.XmlAttribute CreateAttribute (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlAttribute CreateAttribute(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">O nome qualificado do atributo. Se o nome contém dois-pontos, o <see cref="P:System.Xml.XmlNode.Prefix" /> propriedade refletirá a parte do nome do anterior o vírgula e o <see cref="P:System.Xml.XmlDocument.LocalName" /> propriedade refletirão a parte do nome após os dois-pontos.</param>
        <param name="namespaceURI">O namespaceURI do atributo. Se o nome qualificado inclui um prefixo xmlns, esse parâmetro deve ser http://www.w3.org/2000/xmlns/.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlAttribute" /> com o nome e dados especificados e <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>O novo <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `XmlAttribute` podem ser adicionados a um <xref:System.Xml.XmlElement> usando o <xref:System.Xml.XmlElement.SetAttributeNode%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlAttribute CreateAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlAttribute CreateAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateAttribute(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">O prefixo do atributo (se houver). String.Empty e <see langword="null" /> são equivalentes.</param>
        <param name="localName">O nome local do atributo.</param>
        <param name="namespaceURI">O namespace URI do atributo (se houver). String.Empty e <see langword="null" /> são equivalentes. Se <c>prefixo</c> é xmlns, esse parâmetro deverá ser http://www.w3.org/2000/xmlns/; caso contrário, uma exceção será lançada.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlAttribute" /> com o <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> e <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>O novo <see langword="XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `XmlAttribute` podem ser adicionados a um <xref:System.Xml.XmlElement> usando o <xref:System.Xml.XmlElement.SetAttributeNode%2A> método.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCDataSection">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlCDataSection CreateCDataSection (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlCDataSection CreateCDataSection(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateCDataSection(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlCDataSection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">O conteúdo do novo <see langword="XmlCDataSection" />.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlCDataSection" /> que contém os dados especificados.</summary>
        <returns>O novo <see langword="XmlCDataSection" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós CDataSection são permitidos em nós de elemento e nós EntityReference quando o nó EntityReference não é um filho de um nó de atributo.  
  
   
  
## Examples  
 O exemplo a seguir cria um nó CDATA e o adiciona ao documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateCDataSection Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateCDataSection Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateComment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlComment CreateComment (string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlComment CreateComment(string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateComment(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlComment</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="data">O conteúdo do novo <see langword="XmlComment" />.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlComment" /> que contém os dados especificados.</summary>
        <returns>O novo <see langword="XmlComment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), os nós de comentário só são permitidos em nós do documento, elemento e EntityReference, quando o nó EntityReference não é um filho de um nó de atributo.  
  
   
  
## Examples  
 O exemplo a seguir cria um comentário e adiciona-o a um documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateComment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateComment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultAttribute">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.XmlAttribute CreateDefaultAttribute (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XmlAttribute CreateDefaultAttribute(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDefaultAttribute(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">O prefixo do atributo (se houver).</param>
        <param name="localName">O nome local do atributo.</param>
        <param name="namespaceURI">O namespace URI do atributo (se houver).</param>
        <summary>Cria um atributo padrão com o prefixo especificado, o nome local e o URI de namespace.</summary>
        <returns>O novo <see cref="T:System.Xml.XmlAttribute" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentFragment">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentFragment CreateDocumentFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentFragment CreateDocumentFragment() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentFragment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentFragment</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um <see cref="T:System.Xml.XmlDocumentFragment" />.</summary>
        <returns>O novo <see langword="XmlDocumentFragment" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nós DocumentFragment não podem ser inseridos em um documento. No entanto, você pode inserir os filhos do nó de DocumentFragment em um documento.  
  
   
  
## Examples  
 O exemplo a seguir acrescenta novos nós em um documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentFragment Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentFragment Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType CreateDocumentType (string name, string publicId, string systemId, string internalSubset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDocumentType CreateDocumentType(string name, string publicId, string systemId, string internalSubset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateDocumentType(System.String,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="publicId" Type="System.String" />
        <Parameter Name="systemId" Type="System.String" />
        <Parameter Name="internalSubset" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome do tipo de documento.</param>
        <param name="publicId">O identificador público do tipo de documento ou <see langword="null" />. Você pode especificar um URI público e também um identificador de sistema para identificar o local do subconjunto DTD externo.</param>
        <param name="systemId">O identificador do sistema do tipo de documento ou <see langword="null" />. Especifica a URL do local do arquivo para o subconjunto DTD externo.</param>
        <param name="internalSubset">O subconjunto DTD interno do tipo de documento ou <see langword="null" />.</param>
        <summary>Retorna um novo objeto <see cref="T:System.Xml.XmlDocumentType" />.</summary>
        <returns>O novo <see langword="XmlDocumentType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nó retornado será ter analisado <xref:System.Xml.XmlDocumentType.Entities%2A> e <xref:System.Xml.XmlDocumentType.Notations%2A> coleções.  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós DocumentType só são permitidas em nós do documento. Cada <xref:System.Xml.XmlDocument> pode ter apenas um nó de DocumentType. O nó de DocumentType também deve ser inserido antes do elemento raiz da `XmlDocument` (se o documento já contém um elemento raiz, você não pode adicionar um nó de DocumentType).  
  
 Se os parâmetros passados não combinar para criar um arquivo `XmlDocumentType`, uma exceção será lançada.  
  
   
  
## Examples  
 O exemplo a seguir cria um nó de DocumentType e adiciona-o a um documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateDocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateDocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Esse método tem uma demanda de herança. Confiança total é necessária para substituir o <see langword="CreateDocumentType" /> método.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado do elemento. Se o nome contém dois-pontos, o <see cref="P:System.Xml.XmlNode.Prefix" /> propriedade reflete a parte do nome do anterior o vírgula e o <see cref="P:System.Xml.XmlDocument.LocalName" /> propriedade reflete a parte do nome após os dois-pontos. O nome qualificado não pode incluir um prefixo of'xmlns '.</param>
        <summary>Cria um elemento com o nome especificado.</summary>
        <returns>O novo <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Observe que a instância retornada implementa o `XmlElement` interface, portanto os atributos padrão pode ser criados diretamente no objeto retornado.  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós de elemento são permitidos dentro do documento e nós de elemento e nós EntityReference quando o nó EntityReference não é um filho de um nó de atributo.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo elemento e o adiciona ao documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement CreateElement (string qualifiedName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlElement CreateElement(string qualifiedName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="qualifiedName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="qualifiedName">O nome qualificado do elemento. Se o nome contém dois-pontos, o <see cref="P:System.Xml.XmlNode.Prefix" /> propriedade refletirá a parte do nome do anterior o vírgula e o <see cref="P:System.Xml.XmlDocument.LocalName" /> propriedade refletirão a parte do nome após os dois-pontos. O nome qualificado não pode incluir um prefixo of'xmlns '.</param>
        <param name="namespaceURI">O URI do namespace do elemento.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlElement" /> com o nome qualificado e <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>O novo <see langword="XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O código c# a seguir  
  
```  
XmlElement elem;  
elem=doc.CreateElement("xy:item", "urn:abc");  
```  
  
 resultados em um elemento que é equivalente à seguinte texto XML.  
  
```  
<xy:item  
       xmlns:xy="urn:abc"/>  
```  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós de elemento são permitidos dentro do documento e nós de elemento e nós EntityReference quando o nó EntityReference não é um filho de um nó de atributo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement CreateElement (string prefix, string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement CreateElement(string prefix, string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateElement(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">O prefixo do novo elemento (se houver). String.Empty e <see langword="null" /> são equivalentes.</param>
        <param name="localName">O nome local do novo elemento.</param>
        <param name="namespaceURI">O namespace URI do novo elemento (se houver). String.Empty e <see langword="null" /> são equivalentes.</param>
        <summary>Cria um elemento com o <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.LocalName" /> e <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>O novo <see cref="T:System.Xml.XmlElement" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O código c# a seguir  
  
```  
XmlElement elem;  
elem=doc.CreateElement("xy", "item", "urn:abc");  
```  
  
 cria um elemento equivalente para o seguinte texto XML:  
  
```  
<xy:item xmlns:xy="urn:abc"/>  
```  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós de elemento são permitidos dentro do documento e nós de elemento e nós EntityReference quando EntityReference está fora de um nó de atributo.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir adiciona um novo elemento no documento XML existente.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateEntityReference">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlEntityReference CreateEntityReference (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlEntityReference CreateEntityReference(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateEntityReference(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlEntityReference</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome da referência da entidade.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlEntityReference" /> com o nome especificado.</summary>
        <returns>O novo <see langword="XmlEntityReference" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a entidade referenciada é conhecido, lista de filhos a `XmlEntityReference` nó torna-se o mesmo que o correspondente <xref:System.Xml.XmlEntity> nó.  
  
 Os namespaces usados no texto de substituição para a referência de entidade são associados ao tempo que o pai do nó de referência de entidade é definido pela primeira vez (por exemplo, quando o nó de referência de entidade é inserido no documento). Por exemplo, dada a entidade a seguir:  
  
```  
<!ENTITY a "<b>test</b>">  
```  
  
 Se você chamar `CreateEntityReference("a")` você obtém um único nó do tipo EntityReference sem filhos. Se você adicionar este nó como um filho do nó seguinte,  
  
```  
<item xmlns="urn:1"/>  
```  
  
 em seguida, no momento da chamada <xref:System.Xml.XmlNode.AppendChild%2A>, o pai do nó de referência de entidade criado recentemente é definido e os filhos são expandidos neste contexto de namespace. O nó de elemento filho `b` terá NamespaceURI igual a `urn:1`. Os nós filho da referência de entidade permanecem os mesmos, mesmo se você mover a referência de entidade para um local no documento que tem um contexto de namespace padrão diferente. Isso não acontece para nós de referência de entidade existentes quando você remove e inseri-los ou para referências de entidade que você clonar com <xref:System.Xml.XmlDocument.CloneNode%2A>. Isso acontece apenas para referências de entidade criado recentemente.  
  
 Se a entidade correspondente não está definida no DocumentType quando o nó de referência de entidade é adicionado, porque a referência de entidade não está definida, o único nó filho será um nó de texto vazio.  
  
 O amp entidades internas, lt, gt, apos; quot também são permitidos, e eles terão um nó de texto filho com o valor do caractere expandido apropriado.  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós EntityReference só são permitidas em nós de elemento, atributo e EntityReference.  
  
   
  
## Examples  
 O exemplo a seguir cria dois nós de referência de entidade e insere em um documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateEntityReference Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateEntityReference Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome é inválido (por exemplo, nomes que começam com '#' são inválidos.)</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="public override System.Xml.XPath.XPathNavigator CreateNavigator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para navegar nesse documento.</summary>
        <returns>Um objeto <see cref="T:System.Xml.XPath.XPathNavigator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> para obter um exemplo usando esse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNavigator">
      <MemberSignature Language="C#" Value="protected virtual System.Xml.XPath.XPathNavigator CreateNavigator (System.Xml.XmlNode node);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Xml.XPath.XPathNavigator CreateNavigator(class System.Xml.XmlNode node) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNavigator(System.Xml.XmlNode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XPath.XPathNavigator</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="node">O <see cref="T:System.Xml.XmlNode" /> no qual você deseja que o navegador seja inicialmente posicionado.</param>
        <summary>Cria um objeto <see cref="T:System.Xml.XPath.XPathNavigator" /> para navegar neste documento posicionado no <see cref="T:System.Xml.XmlNode" /> especificado.</summary>
        <returns>Um objeto <see cref="T:System.Xml.XPath.XPathNavigator" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 Consulte <xref:System.Xml.XmlNode.CreateNavigator%2A?displayProperty=nameWithType> para obter um exemplo usando esse método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (string nodeTypeString, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(string nodeTypeString, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodeTypeString" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nodeTypeString">Versão de cadeia de caracteres do <see cref="T:System.Xml.XmlNodeType" /> do novo nó. Esse parâmetro deve ser um dos valores listados na tabela a seguir.</param>
        <param name="name">O nome qualificado do novo nó. Se o nome contém dois-pontos, ela é analisada em <see cref="P:System.Xml.XmlNode.Prefix" /> e <see cref="P:System.Xml.XmlDocument.LocalName" /> componentes.</param>
        <param name="namespaceURI">O namespace URI do novo nó.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlNode" /> com o tipo de nó especificado, <see cref="P:System.Xml.XmlDocument.Name" /> e <see cref="P:System.Xml.XmlNode.NamespaceURI" />.</summary>
        <returns>O novo <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `nodeTypeString` parâmetro diferencia maiusculas de minúsculas e deve ser um dos valores na tabela a seguir.  
  
|nodeTypeString|XmlNodeType|  
|--------------------|-----------------|  
|Atributo|Atributo|  
|cdatasection|CDATA|  
|comment|Comentário|  
|documento|Documento|  
|DocumentFragment|DocumentFragment|  
|DocumentType|DocumentType|  
|Elemento|Elemento|  
|EntityReference|EntityReference|  
|instrução de processamento|ProcessingInstruction|  
|SignificantWhitespace|SignificantWhitespace|  
|texto|Texto|  
|espaço em branco|Whitespace|  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 A tabela a seguir mostra quais NodeType [linha] é permitida dentro de outro NodeType [coluna] acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Documento|DocumentType|XmlDeclaration|Elemento|Atributo|Texto|CDATA|Marcação|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|sim|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|Sim *|no|no|no|no|no|no|no|no|  
|`Element`|sim|no|no|sim|no|no|no|no|Sim * * *|  
|`Attribute`|no|no|no|Sim * * *|no|no|no|no|no|  
|`Text`|no|no|no|sim|sim|no|no|no|sim|  
|`CDATA`|no|no|no|sim|no|no|no|no|Sim * * *|  
|`Markup**`|sim|no|no|sim|no|no|no|no|no|  
|`EntityReference`|no|no|no|sim|sim|no|no|no|sim|  
  
 \*O nó de XmlDeclaration deve ser o primeiro filho do nó do documento.  
  
 * * Marcação inclui nós de instrução de processamento e o comentário.  
  
 Nós de elemento e CDATA só são permitidos em nós EntityReference ao nó ' EntityReference não é um filho de um nó de atributo.  
  
 Atributos não são filhos de um nó de elemento. Atributos estão contidos dentro de uma coleção de atributos que pertence a um nó de elemento.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir cria um novo elemento e insere no documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome não foi fornecido e o <see langword="XmlNodeType" /> requer um nome ou <paramref name="nodeTypeString" /> não é uma das cadeias de caracteres listadas abaixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O <see langword="XmlNodeType" /> do novo nó.</param>
        <param name="name">O nome qualificado do novo nó. Se o nome contém dois-pontos, ela é analisada em <see cref="P:System.Xml.XmlNode.Prefix" /> e <see cref="P:System.Xml.XmlDocument.LocalName" /> componentes.</param>
        <param name="namespaceURI">O namespace URI do novo nó.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlNode" /> com o <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlDocument.Name" /> e <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>O novo <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 A tabela a seguir mostra quais NodeType [linha] é permitida dentro de outro NodeType [coluna] acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Documento|DocumentType|XmlDeclaration|Elemento|Atributo|Texto|CDATA|Marcação|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|sim|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|Sim *|no|no|no|no|no|no|no|no|  
|`Element`|sim|no|no|sim|no|no|no|no|Sim * * *|  
|`Attribute`|no|no|no|Sim * * *|no|no|no|no|no|  
|`Text`|no|no|no|sim|sim|no|no|no|sim|  
|`CDATA`|no|no|no|sim|no|no|no|no|Sim * * *|  
|`Markup**`|sim|no|no|sim|no|no|no|no|no|  
|`EntityReference`|no|no|no|sim|sim|no|no|no|sim|  
  
 \*O nó de XmlDeclaration deve ser o primeiro filho do nó do documento.  
  
 * * Marcação inclui nós de instrução de processamento e o comentário.  
  
 Nós de elemento e CDATA só são permitidos em nós EntityReference ao nó ' EntityReference não é um filho de um nó de atributo.  
  
 Atributos não são filhos de um nó de elemento. Atributos estão contidos dentro de uma coleção de atributos que pertence a um nó de elemento.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir cria um novo elemento e insere em um documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome não foi fornecido e o <see langword="XmlNodeType" /> exige um nome.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode CreateNode (System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode CreateNode(valuetype System.Xml.XmlNodeType type, string prefix, string name, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateNode(System.Xml.XmlNodeType,System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Xml.XmlNodeType" />
        <Parameter Name="prefix" Type="System.String" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O <see langword="XmlNodeType" /> do novo nó.</param>
        <param name="prefix">O prefixo do novo nó.</param>
        <param name="name">O nome local do novo nó.</param>
        <param name="namespaceURI">O namespace URI do novo nó.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlNode" /> com o <see cref="T:System.Xml.XmlNodeType" />, <see cref="P:System.Xml.XmlNode.Prefix" />, <see cref="P:System.Xml.XmlDocument.Name" /> e <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>O novo <see langword="XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 A tabela a seguir mostra quais NodeType [linha] é permitida dentro de outro NodeType [coluna] acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210).  
  
||Documento|DocumentType|XmlDeclaration|Elemento|Atributo|Texto|CDATA|Marcação|EntityReference|  
|------|--------------|------------------|--------------------|-------------|---------------|----------|-----------|------------|---------------------|  
|`Document`|no|no|no|no|no|no|no|no|no|  
|`DocumentType`|sim|no|no|no|no|no|no|no|no|  
|`XmlDeclaration`|Sim *|no|no|no|no|no|no|no|no|  
|`Element`|sim|no|no|sim|no|no|no|no|Sim * * *|  
|`Attribute`|no|no|no|Sim * * *|no|no|no|no|no|  
|`Text`|no|no|no|sim|sim|no|no|no|sim|  
|`CDATA`|no|no|no|sim|no|no|no|no|Sim * * *|  
|`Markup**`|sim|no|no|sim|no|no|no|no|no|  
|`EntityReference`|no|no|no|sim|sim|no|no|no|sim|  
  
 \*O nó de XmlDeclaration deve ser o primeiro filho do nó do documento.  
  
 * * Marcação inclui nós de instrução de processamento e o comentário.  
  
 Nós de elemento e CDATA só são permitidos em nós EntityReference ao nó ' EntityReference não é um filho de um nó de atributo.  
  
 Atributos não são filhos de um nó de elemento. Atributos estão contidos dentro de uma coleção de atributo que pertence ao nó de elemento.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir adiciona um novo elemento no documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateNode2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateNode2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O nome não foi fornecido e o <see langword="XmlNodeType" /> exige um nome.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateProcessingInstruction">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlProcessingInstruction CreateProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlProcessingInstruction CreateProcessingInstruction(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateProcessingInstruction(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlProcessingInstruction</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">O nome da instrução de processamento.</param>
        <param name="data">Os dados para a instrução de processamento.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlProcessingInstruction" /> com o nome e dados especificados.</summary>
        <returns>O novo <see langword="XmlProcessingInstruction" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós de instrução de processamento só são permitidas em nós do documento, elemento e EntityReference, quando o nó EntityReference não é um filho de um nó de atributo.  
  
   
  
## Examples  
 O exemplo a seguir cria um nó de instrução de processamento e o adiciona ao documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateProcessingInstruction Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateProcessingInstruction Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSignificantWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlSignificantWhitespace CreateSignificantWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateSignificantWhitespace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSignificantWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">A cadeia de caracteres deve conter somente os seguintes caracteres &amp;#20; &amp;#10; &amp;#13; e &amp;#9;</param>
        <summary>Cria um nó <see cref="T:System.Xml.XmlSignificantWhitespace" />.</summary>
        <returns>Um novo nó <see langword="XmlSignificantWhitespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM). Ele é usado quando você deseja formatar manualmente seu documento.  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
   
  
## Examples  
 O exemplo a seguir adiciona o espaço em branco significativo para o documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateSignificantWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateSignificantWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateTextNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlText CreateTextNode (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlText CreateTextNode(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateTextNode(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlText</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">O texto para o nó Texto.</param>
        <summary>Cria um <see cref="T:System.Xml.XmlText" /> com o texto especificado.</summary>
        <returns>O novo nó <see langword="XmlText" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), nós de texto só são permitidos em nós de elemento, atributo e EntityReference.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo elemento e o adiciona ao documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateWhitespace">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlWhitespace CreateWhitespace (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlWhitespace CreateWhitespace(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateWhitespace(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWhitespace</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">A cadeia de caracteres deve conter somente os seguintes caracteres &amp;#20; &amp;#10; &amp;#13; e &amp;#9;</param>
        <summary>Cria um nó <see cref="T:System.Xml.XmlWhitespace" />.</summary>
        <returns>Um novo nó <see langword="XmlWhitespace" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM). Ele é usado quando você deseja formatar manualmente seu documento.  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
   
  
## Examples  
 O exemplo a seguir adiciona o espaço em branco ao documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateWhitespace Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXmlDeclaration">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDeclaration CreateXmlDeclaration (string version, string encoding, string standalone);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlDeclaration CreateXmlDeclaration(string version, string encoding, string standalone) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.CreateXmlDeclaration(System.String,System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDeclaration</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="version" Type="System.String" />
        <Parameter Name="encoding" Type="System.String" />
        <Parameter Name="standalone" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="version">A versão deve ser “1.0”.</param>
        <param name="encoding">O valor do atributo de codificação. Isso é a codificação usada quando você salvar o <see cref="T:System.Xml.XmlDocument" /> para um arquivo ou um fluxo; portanto, ele deve ser definido como uma cadeia de caracteres com suporte a <see cref="T:System.Text.Encoding" /> classe, caso contrário <see cref="M:System.Xml.XmlDocument.Save(System.String)" /> falhar. Se isso for <see langword="null" /> ou Empty, o <see langword="Save" /> método não grava um atributo de codificação na declaração XML e, portanto, o padrão de codificação UTF-8, é usado.  
  
 Observação: Se o <see langword="XmlDocument" /> é salvo como um <see cref="T:System.IO.TextWriter" /> ou um <see cref="T:System.Xml.XmlTextWriter" />, esse valor de codificação é descartado. Em vez disso, a codificação do <see langword="TextWriter" /> ou <see langword="XmlTextWriter" /> é usado. Isso garante que leia o XML é gravado usando a codificação correta.</param>
        <param name="standalone">O valor deve ser "Sim" ou "não". Se isso for <see langword="null" /> ou Empty, o <see langword="Save" /> método não grava um atributo autônomo na declaração XML.</param>
        <summary>Cria um nó <see cref="T:System.Xml.XmlDeclaration" /> com os valores especificados.</summary>
        <returns>O novo nó <see langword="XmlDeclaration" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os atributos são expostos como propriedades especiais sobre a `XmlDeclaration` nó e não como <xref:System.Xml.XmlAttribute> nós.  
  
 Embora esse método cria um novo objeto no contexto do documento, ele não adiciona automaticamente o novo objeto a árvore do documento. Para adicionar o novo objeto, você deve chamar explicitamente um dos métodos de inserção de nó.  
  
 De acordo com a recomendação do W3C Extensible Markup Language (XML) 1.0 (www.w3.org/TR/1998/REC-xml-19980210), o `XmlDeclaration` nó deve ser o primeiro nó no documento.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir cria uma declaração XML e o adiciona ao documento.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateXmlDeclaration Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateXmlDeclaration Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Os valores de <paramref name="version" /> ou <paramref name="standalone" /> são diferentes daqueles especificados acima.</exception>
      </Docs>
    </Member>
    <Member MemberName="DocumentElement">
      <MemberSignature Language="C#" Value="public System.Xml.XmlElement DocumentElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlElement DocumentElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a raiz <see cref="T:System.Xml.XmlElement" /> para o documento.</summary>
        <value>O <see langword="XmlElement" /> que representa a raiz da árvore do documento XML. Se não existir nenhuma raiz, será retornado <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe o elemento raiz do documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentElement Example/VB/source.vb#1)]  
  
 **Saída:**  
  
```  
<book genre="novel" ISBN="1-861001-57-5"><title>Pride And Prejudice</title></book>   
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DocumentType">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlDocumentType DocumentType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocumentType DocumentType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.DocumentType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocumentType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nó que contém a declaração DOCTYPE.</summary>
        <value>O <see cref="T:System.Xml.XmlNode" /> que contém o DocumentType (declaração DOCTYPE).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um `XmlDocument` pode ter apenas um filho com <xref:System.Xml.XmlNodeType> igual a DocumentType.  
  
> [!NOTE]
>  Esta propriedade é somente para leitura. Para alterar o nó de DocumentType, excluir o nó existente, crie um novo usando um o <xref:System.Xml.XmlDocument.CreateDocumentType%2A> método e adicionar o novo nó ao documento.  
  
   
  
## Examples  
 O exemplo a seguir obtém e exibe a declaração de DOCTYPE do documento.  
  
 [!code-cpp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.DocumentType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.DocumentType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlElement GetElementById (string elementId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlElement GetElementById(string elementId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementById(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementId" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementId">A ID do atributo a ser correspondida.</param>
        <summary>Obtém o <see cref="T:System.Xml.XmlElement" /> com a ID especificada.</summary>
        <returns>O <see langword="XmlElement" /> com a ID correspondente, ou <see langword="null" />, se nenhum elemento correspondente for encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o documento possui vários elementos com a ID de correspondência, esse método retorna o primeiro elemento correspondente no documento.  
  
> [!NOTE]
>  A implementação do DOM deve ter informações que define os atributos que são do tipo ID. Embora os atributos do tipo ID podem ser definidos em esquemas XSD ou DTDs, esta versão do produto suporta apenas aquelas definidas em DTDs. Atributos com o nome "ID" não é do tipo ID, a menos que então definido no DTD. Implementações em que é desconhecido se os atributos são do tipo ID devem retornar `null`.  
  
   
  
## Examples  
 O exemplo a seguir usa o método `GetElementById`.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementById Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementById Example/VB/source.vb#1)]  
  
 O exemplo usa o arquivo de `ids.xml`, como entrada.  
  
```xml  
<!DOCTYPE root [  
  <!ELEMENT root ANY>   
  <!ELEMENT Person ANY>   
  <!ELEMENT Customer EMPTY>  
  <!ELEMENT Team EMPTY>  
  <!ATTLIST Person SSN ID #REQUIRED>  
  <!ATTLIST Customer id IDREF #REQUIRED >  
  <!ATTLIST Team members IDREFS #REQUIRED>]>  
<root>  
  <Person SSN='A111' Name='Fred'/>  
  <Person SSN='A222' Name='Tom'/>  
  <Customer id='A222334444'/>  
  <Team members='A222334444 A333445555'/>  
</root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome qualificado para correspondência. Ele é comparado com o <see langword="Name" /> propriedade do nó correspondente. O valor especial "*" corresponde a todas as marcas.</param>
        <summary>Retorna um <see cref="T:System.Xml.XmlNodeList" /> que contém uma lista de todos os elementos descendentes que correspondem ao <see cref="P:System.Xml.XmlDocument.Name" /> especificado.</summary>
        <returns>Um <see cref="T:System.Xml.XmlNodeList" /> que contém uma lista de todos os nós correspondentes. Se nenhum nó corresponder a <paramref name="name" />, a coleção retornada estará vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nós são colocados na ordem em que eles seriam encontrados no documento.  
  
> [!NOTE]
>  É recomendável que você use o <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> ou <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> método em vez do <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir cria um `XmlDocument` objeto e usa o `GetElementsByTagName` método e resultante <xref:System.Xml.XmlNodeList> objeto para exibir todos os títulos de livro.  
  
 [!code-cpp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.GetElementsByTagName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.GetElementsByTagName Example/VB/source.vb#1)]  
  
 O exemplo usa o arquivo `books.xml` como entrada.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNodeList GetElementsByTagName (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNodeList GetElementsByTagName(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.GetElementsByTagName(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeList</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">O LocalName de correspondência. O valor especial "*" corresponde a todas as marcas.</param>
        <param name="namespaceURI">NamespaceURI para corresponder.</param>
        <summary>Retorna um <see cref="T:System.Xml.XmlNodeList" /> que contém uma lista de todos os elementos descendentes que correspondem ao <see cref="P:System.Xml.XmlDocument.LocalName" /> e <see cref="P:System.Xml.XmlNode.NamespaceURI" /> especificados.</summary>
        <returns>Um <see cref="T:System.Xml.XmlNodeList" /> que contém uma lista de todos os nós correspondentes. Se nenhum nó corresponder aos <paramref name="localName" /> e <paramref name="namespaceURI" /> especificados, a coleção retornada ficará vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os nós são colocados na ordem em que eles seriam encontrados na árvore do documento.  
  
> [!NOTE]
>  É recomendável que você use o <xref:System.Xml.XmlNode.SelectNodes%2A?displayProperty=nameWithType> ou <xref:System.Xml.XmlNode.SelectSingleNode%2A?displayProperty=nameWithType> método em vez do <xref:System.Xml.XmlDocument.GetElementsByTagName%2A> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Implementation">
      <MemberSignature Language="C#" Value="public System.Xml.XmlImplementation Implementation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlImplementation Implementation" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Implementation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlImplementation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xml.XmlImplementation" /> objeto para o documento atual.</summary>
        <value>O <see langword="XmlImplementation" /> objeto para o documento atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `XmlDocument`objetos criados da mesma `XmlImplementation` compartilham o mesmo <xref:System.Xml.XmlNameTable>. Isso permite que os usuários comparar nomes de elementos e atributos como objetos em vez de cadeias de caracteres.  
  
 Embora o `XmlDocument` objetos compartilham a mesma implementação, mover os nós de um documento para outro, você deve usar o <xref:System.Xml.XmlDocument.ImportNode%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo `XmlDocument` usando a implementação do outro documento.  
  
 [!code-cpp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Implementation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Implementation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImportNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ImportNode (System.Xml.XmlNode node, bool deep);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ImportNode(class System.Xml.XmlNode node, bool deep) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ImportNode(System.Xml.XmlNode,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="node" Type="System.Xml.XmlNode" />
        <Parameter Name="deep" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="node">O nó que está sendo importado.</param>
        <param name="deep">
          <see langword="true" />para executar um clone profundo; Caso contrário, <see langword="false" />.</param>
        <summary>Importa um nó de outro documento para o documento atual.</summary>
        <returns>Importado <see cref="T:System.Xml.XmlNode" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nó retornado não tem pai. O nó de origem não é alterado ou removido do documento original. `ImportNode` cria uma cópia do nó de origem.  
  
 Um nó de importação cria um `XmlNode` objeto pertencente o importar o documento, com <xref:System.Xml.XmlNode.Name%2A> e <xref:System.Xml.XmlNode.NodeType%2A> idênticas ao nó de origem. O novo objeto também tem os atributos relacionados aos namespaces (<xref:System.Xml.XmlNode.Prefix%2A>, <xref:System.Xml.XmlNode.LocalName%2A>, e <xref:System.Xml.XmlNode.NamespaceURI%2A>).  
  
 Dependendo do tipo de nó do nó importado e o valor de `deep` parâmetro, informações adicionais é copiado conforme apropriado. Esse método tentará espelho o comportamento esperado se um fragmento de origem XML ou HTML foi copiado de um documento para outro (reconhecer que, no caso de XML, os dois documentos podem ter diferentes DTDs).  
  
 A tabela a seguir descreve o comportamento específico para cada <xref:System.Xml.XmlNodeType>.  
  
|XmlNodeType|ImportNode(true)|ImportNode(false)|  
|-----------------|------------------------|-------------------------|  
|Atributo|O <xref:System.Xml.XmlAttribute.Specified%2A> está definida como `true` em gerado <xref:System.Xml.XmlAttribute>. Os descendentes de origem `XmlAttribute` recursivamente importados e os nós resultantes reorganizados para formar a subárvore correspondente.|O `deep` parâmetro não se aplica a `XmlAttribute` nós; eles sempre ter seus filhos com eles quando importado.|  
|CData|Copia o nó, incluindo seus dados.|Copia o nó, incluindo seus dados.|  
|Comentário|Copia o nó, incluindo seus dados.|Copia o nó, incluindo seus dados.|  
|DocumentFragment|Os descendentes nó de origem recursivamente serão importados e os nós resultantes são remontados para formar a subárvore correspondente.|Vazio <xref:System.Xml.XmlDocumentFragment> é gerado.|  
|DocumentType|Copia o nó, incluindo seu data.*|Copia o nó, incluindo seu data.*|  
|Elemento|Os descendentes do elemento de origem e de seus nós de atributo especificado são recursivamente importados e nós resultantes reorganizados para formar a subárvore correspondente.<br /><br /> Observação: Os atributos padrão não são copiados. Se o documento que está sendo importado define atributos padrão para este nome de elemento, esses são atribuídos.|Especificado como atributo nós de elemento de origem são importados e gerado `XmlAttribute` nós são anexados ao gerado <xref:System.Xml.XmlElement>.<br /><br /> Observação: Os atributos padrão não são copiados. Se o documento que está sendo importado define atributos padrão para este nome de elemento, esses são atribuídos.|  
|EntityReference|Como os documentos de origem e de destino podem ter entidades definidas de forma diferente, esse método apenas copia o <xref:System.Xml.XmlEntityReference> nó. O texto de substituição não é incluído. Se o documento de destino tem a entidade definida, o valor é atribuído.|Como os documentos de origem e de destino podem ter entidades definidas de forma diferente, esse método apenas copia o <xref:System.Xml.XmlEntityReference> nó. O texto de substituição não é incluído. Se o documento de destino tem a entidade definida, o valor é atribuído.|  
|ProcessingInstruction|Copia o destino e o valor do nó importado.|Copia o destino e o valor do nó importado.|  
|Texto|Copia o nó, incluindo seus dados.|Copia o nó, incluindo seus dados.|  
|SignificantWhitespace|Copia o nó, incluindo seus dados.|Copia o nó, incluindo seus dados.|  
|Whitespace|Copia o nó, incluindo seus dados.|Copia o nó, incluindo seus dados.|  
|XmlDeclaration|Copia o destino e o valor do nó importado.|Copia o destino e o valor do nó importado.|  
|Todos os outros tipos de nó.|Esses tipos de nós não podem ser importados.|Esses tipos de nós não podem ser importados.|  
  
 * Embora DocumentType nós podem ser importados, um documento só pode ter um DocumentType. Se o documento tem um nó DocumenType, ele deve ser removido antes de adicionar um novo.  
  
   
  
## Examples  
 O exemplo a seguir importa um nó de catálogo de um segundo documento XML para o documento XML original.  
  
 [!code-cpp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ImportNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ImportNode Example/VB/source.vb#1)]  
  
 O exemplo usa o arquivo de `books.xml`, como entrada.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Chamando esse método em um tipo de nó que não pode ser importado.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public override string InnerText { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Aciona um <see cref="T:System.InvalidOperationException" /> em todos os casos.</summary>
        <value>Os valores do nó e todos os seus nós filho.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade não é implementada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="InnerXml">
      <MemberSignature Language="C#" Value="public override string InnerXml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerXml" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.InnerXml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a marcação que representa os filhos do nó atual.</summary>
        <value>A marcação dos filhos do nó atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A definição dessa propriedade substitui os filhos do nó com o conteúdo analisado da cadeia de caracteres especificada. A análise é feita no contexto do namespace atual.  
  
 `InnerXml`Remove as declarações de namespace redundantes. Como resultado, várias operações de recortar e colar não aumentam o tamanho do documento com declarações redundantes de namespace. Considere o seguinte documento XSL:  
  
```  
<xsl:stylesheet version="1.0"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     <xsl:template match="stock">  
         ...  
     </xsl:template>  
    </xsl:stylesheet>  
```  
  
 O `InnerXml` propriedade no nó de folha de estilos retorna a cadeia de caracteres a seguir:  
  
```  
<xsl:template match="stock"   
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform">  
     ...  
    </xsl:template>  
```  
  
 Observe a declaração de namespace xmlns: XSL adicional que é usada para preservar a identidade do nó. Se você inserir novamente essa cadeia de caracteres XML interna, você obterá novamente o documento original. Em outras palavras, `InnerXml` reconhece que a declaração de namespace xmlns: XSL é redundante, considerando que o elemento de XSL: stylesheet pai já tem o delcaration de namespace xmlns: XSL e, portanto, remove-lo.  
  
 Se você mover `InnerXml` de um documento sem namespace padrão para um documento com um namespace padrão, o comportamento é um pouco diferente. Considere a seguinte cadeia de caracteres XML:  
  
```  
<test>  
      <item>123</item>  
    </test>  
```  
  
 `InnerXml`Retorna uma cadeia de caracteres XML simples com nenhum declarações de namespace:  
  
```  
<item>123</item>  
```  
  
 Se você inserir essa cadeia de caracteres em um documento que tem um namespace padrão, como o seguinte:  
  
```  
<test2 xmlns="urn:1">  
    </test>  
```  
  
 `InnerXml`analisa a cadeia de caracteres no contexto e os novos nós pegar o namespace urn: 1. O resultado tem esta aparência:  
  
```  
<test2 xmlns="urn:1">  
      <item>123</item>  
    </test>  
```  
  
 Agora quando você pedir a `InnerXml` você recebe o seguinte:  
  
```  
<item xmlns="urn:1">123</item>  
```  
  
 Se você quiser explicitamente o item inserido para preservar o fato de que ela foi originada de um documento que não tinha nenhum namespace, você precisa adicionar manualmente um xmlns = "" declaração e inserir a cadeia de caracteres resultante:  
  
```  
<item xmlns="">123</item>  
```  
  
 O efeito líquido de tudo que isso é como segue:  
  
1.  Recortando e colando `InnerXml` entre documentos que não usam espaços para nome é limpa e simples e não cria "xmlns" redundância em suas cadeias de caracteres.  
  
2.  `InnerXml`também pode ser usado para recortar e colar entre documentos que têm mais de um namespace (ou seja, folhas de estilo XSL).  
  
3.  declarações xmlns: XSL automaticamente aparecem em suas cadeias de caracteres e desaparecem em suas hierarquias de nó.  
  
4.  No caso em que você está movendo `InnerXml` de um documento que não tem namespace padrão para um documento que tem um namespace padrão, os novos nós escolherá o novo namespace padrão.  
  
 Se `InnerXml` é definido com o texto que contém referências a entidades que não estão atualmente definidas no documento, a árvore resultante conterá nós EntityReference vazios.  
  
 Essa propriedade é uma extensão da Microsoft do DOM (Modelo de Objeto do Documento).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">O XML especificado ao definir essa propriedade não está bem formado.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public override bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o nó atual é somente leitura.</summary>
        <value>
          <see langword="true" /> se o nó atual for somente leitura; caso contrário, <see langword="false" />. Os nós <see langword="XmlDocument" /> sempre retornam <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um nó somente leitura é um cujas propriedades, atributos ou filhos não pode ser alterado. Você pode remover um nó somente leitura da árvore e inseri-lo em outro lugar.  
  
 Essa propriedade é uma extensão da Microsoft do DOM (Modelo de Objeto do Documento).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o `IsReadOnly` propriedade.  
  
 [!code-cpp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.IsReadOnly Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.IsReadOnly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.Stream inStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.Stream inStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="inStream">O fluxo que contém o documento XML a ser carregado.</param>
        <summary>Carrega o documento XML do fluxo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  O `Load` método sempre preserva espaço em branco significativo. O <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propriedade determina se o espaço em branco insignificante, que é o espaço em branco no conteúdo do elemento, é preservado. O padrão é `false`; o espaço em branco no conteúdo do elemento não é preservado.  
  
 Se você deseja que ocorra validação, você pode criar uma validação <xref:System.Xml.XmlReader> instância usando o <xref:System.Xml.XmlReaderSettings> classe e o <xref:System.Xml.XmlReader.Create%2A> método. Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 Este método detecta automaticamente o formato de cadeia de caracteres de entrada XML (por exemplo, UTF-8, ANSI e assim por diante). Se seu aplicativo precisa saber qual codificação é usado para ler o fluxo, considere usar um <xref:System.Xml.XmlTextReader> para ler o fluxo do objeto e, em seguida, use o <xref:System.Xml.XmlTextReader.Encoding%2A?displayProperty=nameWithType> propriedade para determinar a codificação. Se você precisar usar um <xref:System.Xml.XmlDocument> objeto para trabalhar com o XML, você pode usar o <xref:System.Xml.XmlTextReader> objeto para criar um. Para obter mais informações, consulte [leitura de dados XML usando XPathDocument e XmlDocument](~/docs/standard/data/xml/reading-xml-data-using-xpathdocument-and-xmldocument.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Há um erro de análise de carga no XML. Nesse caso, um <see cref="T:System.IO.FileNotFoundException" /> é acionado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.IO.TextReader txtReader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.IO.TextReader txtReader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.IO.TextReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="txtReader" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="txtReader">O <see langword="TextReader" /> usado para alimentar os dados XML no documento.</param>
        <summary>Carrega o documento XML da <see cref="T:System.IO.TextReader" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  O `Load` método sempre preserva espaço em branco significativo. O <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propriedade determina se o espaço em branco insignificante, que é o espaço em branco no conteúdo do elemento, é preservado. O padrão é `false`; o espaço em branco no conteúdo do elemento não é preservado.  
  
 Se você deseja que ocorra validação, você pode criar uma validação <xref:System.Xml.XmlReader> instância usando o <xref:System.Xml.XmlReaderSettings> classe e o <xref:System.Xml.XmlReader.Create%2A> método. Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.IO.StringReader> classe para carregar uma cadeia de caracteres de dados XML para o `XmlDocument` objeto.  
  
 [!code-cpp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.CreateElement2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.CreateElement2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Há um erro de análise de carga no XML. Nesse caso, o documento permanece vazio.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">URL do arquivo que contém o documento XML a ser carregado. A URL pode ser um arquivo local ou uma URL de HTTP (um endereço da Web).</param>
        <summary>Carrega o documento XML da URL especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  O `Load` método sempre preserva espaço em branco significativo. O <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propriedade determina se o espaço em branco insignificante, que é o espaço em branco no conteúdo do elemento, é preservado. O padrão é `false`; o espaço em branco no conteúdo do elemento não é preservado.  
  
 Se você deseja que ocorra validação, você pode criar uma validação <xref:System.Xml.XmlReader> instância usando o <xref:System.Xml.XmlReaderSettings> classe e o <xref:System.Xml.XmlReader.Create%2A> método. Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Há um erro de análise de carga no XML. Nesse caso, um <see cref="T:System.IO.FileNotFoundException" /> é acionado.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="filename" /> é uma cadeia de comprimento zero, contém somente espaços em branco ou um ou mais caracteres inválidos, conforme definido por <see cref="F:System.IO.Path.InvalidPathChars" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="filename" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IO.PathTooLongException">O caminho especificado, o nome de arquivo, ou ambos excedem o tamanho máximo definido pelo sistema. Por exemplo, em plataformas com base no Windows, os caminhos devem ter menos que 248 caracteres e os nomes de arquivo devem ter menos que 260 caracteres.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">O caminho especificado é inválido (por exemplo, ele está em uma unidade não mapeada).</exception>
        <exception cref="T:System.IO.IOException">Um erro de E/S ocorreu ao abrir o arquivo.</exception>
        <exception cref="T:System.UnauthorizedAccessException">
          <paramref name="filename" /> especificou um arquivo somente leitura.  
  
 -ou-  
  
 Não há suporte para essa operação na plataforma atual.  
  
 -ou-  
  
 <paramref name="filename" /> especificou um diretório.  
  
 -ou-  
  
 O chamador não tem a permissão necessária.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado em <paramref name="filename" /> não foi encontrado.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="filename" /> está em um formato inválido.</exception>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public virtual void Load (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Load(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Load(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O <see langword="XmlReader" /> usado para alimentar os dados XML no documento.</param>
        <summary>Carrega o documento XML da <see cref="T:System.Xml.XmlReader" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  O `Load` método sempre preserva espaço em branco significativo. O <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> propriedade determina se o espaço em branco insignificante, que é o espaço em branco no conteúdo do elemento, é preservado. O padrão é `false`; o espaço em branco no conteúdo do elemento não é preservado.  
  
 Se o leitor estiver no estado inicial (<xref:System.Xml.XmlReader.ReadState%2A> = ReadState.Initial), `Load` consome todo o conteúdo do leitor e cria o DOM do que encontrar.  
  
 Se o leitor já está posicionado em um nó em profundidade "n", esse método carrega esse nó e todos os irmãos subsequentes até a marca de fim que fecha a profundidade "n". Isso tem os seguintes resultados.  
  
 Se o nó atual e seus irmãos a seguinte aparecem:  
  
```  
<!--comment--><element1>one</element1><element2>two</element2>  
```  
  
 `Load`gera uma exceção porque um documento não pode ter dois elementos de nível de raiz. Se o nó atual e seus irmãos a seguinte aparecem:  
  
```  
<!--comment--><?process instruction?><!--comment--></endtag>  
```  
  
 `Load`for bem-sucedida, mas você tem uma árvore DOM incompleta porque não há nenhum elemento de nível raiz. Antes de salvar o documento, você deve adicionar um elemento de nível raiz, caso contrário <xref:System.Xml.XmlDocument.Save%2A> lançará uma exceção.  
  
 Se o leitor está posicionado em um nó de folha é inválido para o nível raiz de um documento, por exemplo um espaço em branco ou um nó de atributo, o leitor continua a ler até que ele seja posicionado em um nó que pode ser usado para a raiz. O documento começa a carregar no momento.  
  
 Se você deseja que ocorra validação, você pode criar uma validação <xref:System.Xml.XmlReader> instância usando o <xref:System.Xml.XmlReaderSettings> classe e o <xref:System.Xml.XmlReader.Create%2A> método. Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir carrega o último nó de catálogo do `books.xml` arquivo no documento XML.  
  
 [!code-cpp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Load2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Load2 Example/VB/source.vb#1)]  
  
 O exemplo usa o arquivo de `books.xml`, como entrada.  
  
 [!code-xml[Classic WebData XslTransform.Transform7 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XslTransform.Transform7 Example/XML/books.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Há um erro de análise de carga no XML. Nesse caso, o documento permanece vazio.</exception>
      </Docs>
    </Member>
    <Member MemberName="LoadXml">
      <MemberSignature Language="C#" Value="public virtual void LoadXml (string xml);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadXml(string xml) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.LoadXml(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xml" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xml">Cadeia de caracteres que contém o documento XML a ser carregado.</param>
        <summary>Carrega o documento XML da cadeia de caracteres especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão o `LoadXml` método não preservar o espaço em branco ou espaço em branco significativo.  
  
 Esse método analisa DTDs, mas não a validação de DTD ou esquema. Se você deseja que ocorra validação, você pode criar uma validação <xref:System.Xml.XmlReader> instância usando o <xref:System.Xml.XmlReaderSettings> classe e o <xref:System.Xml.XmlReader.Create%2A> método. Para obter mais informações, consulte a seção de Comentários da página de referência <xref:System.Xml.XmlReader>.  
  
 Se você quiser carregar de uma <xref:System.IO.Stream>, <xref:System.String>, <xref:System.IO.TextReader>, ou <xref:System.Xml.XmlReader>, use o método Load em vez desse método.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir carrega o XML em um `XmlDocument` de objeto e salva-o em um arquivo.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Há um erro de análise de carga no XML. Nesse caso, o documento permanece vazio.</exception>
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome local do nó.</summary>
        <value>Para nós <see langword="XmlDocument" />, o nome local é #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome local retornado depende do <xref:System.Xml.XmlDocument.NodeType%2A> do nó. Para ver uma tabela que descreve o nome local retornado para cada tipo de nó, consulte o <xref:System.Xml.XmlNode.LocalName%2A> propriedade o <xref:System.Xml.XmlNode> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome qualificado do nó.</summary>
        <value>Para nós <see langword="XmlDocument" />, o nome é #document.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O nome retornado depende do <xref:System.Xml.XmlDocument.NodeType%2A> do nó. Para ver uma tabela que descreve o nome retornado para cada tipo de nó, consulte o <xref:System.Xml.XmlNode.Name%2A> propriedade o <xref:System.Xml.XmlNode> classe.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xml.XmlNameTable" /> associado à essa implementação.</summary>
        <value>Um <see langword="XmlNameTable" /> que permite obter a versão atomizada de uma cadeia de caracteres dentro do documento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada `XmlDocument` objeto tem um <xref:System.Xml.NameTable> objeto. Nomes de elementos e atributos são armazenados no `NameTable` como atomizadas cadeias de caracteres. Isso significa que mesmo se um nome é referenciado no documento várias vezes ele é armazenado somente uma vez no `NameTable`. Por exemplo, se o documento possui vários elementos com o nome "Cliente", `NameTable` retorna o mesmo objeto sempre que ele receber uma solicitação para esse nome. Como resultado, os usuários podem escrever o código usando comparações de objeto essas cadeias de caracteres em vez de comparações de cadeias de caracteres mais caras.  
  
 Para obter mais informações sobre cadeias de caracteres atomizadas, consulte <xref:System.Xml.XmlNameTable>.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeChanged">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanged" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o <see cref="P:System.Xml.XmlNode.Value" /> de um nó que pertencem a este documento foi alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento só se aplica a nós que têm um valor.  
  
 Todos os nós criados por este documento, se elas foram inseridas no documento, ou não são incluídos nesse evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeChanging">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeChanging" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeChanging" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando o <see cref="P:System.Xml.XmlNode.Value" /> de um nó que pertencem a este documento está prestes a ser alterado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento permite que o usuário fazer a verificação adicional e, se necessário, gerar uma exceção para interromper a operação. Se uma exceção for lançada a `XmlDocument` retorna ao estado original. Esse evento só se aplica a nós que têm um valor.  
  
 Todos os nós criados por este documento, se elas foram inseridas no documento, ou não são incluídos nesse evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeInserted">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserted;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserted" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserted" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um nó que pertencem a este documento foi inserido em outro nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os nós criados por este documento, se elas foram inseridas no documento, ou não são incluídos nesse evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeInserting">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeInserting;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeInserting" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeInserting" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um nó que pertencem a este documento está prestes a ser inserido em outro nó.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento permite que o usuário fazer a verificação adicional e, se necessário, gerar uma exceção para interromper a operação. Se uma exceção for lançada a `XmlDocument` retorna ao estado original.  
  
 Todos os nós criados por este documento, se elas foram inseridas no documento, ou não são incluídos nesse evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeRemoved">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoved;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoved" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoved" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um nó que pertencem a este documento foi removido do seu pai.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todos os nós criados por este documento, se elas foram inseridas no documento, ou não são incluídos nesse evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeRemoving">
      <MemberSignature Language="C#" Value="public event System.Xml.XmlNodeChangedEventHandler NodeRemoving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Xml.XmlNodeChangedEventHandler NodeRemoving" />
      <MemberSignature Language="DocId" Value="E:System.Xml.XmlDocument.NodeRemoving" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um nó que pertencem a este documento está prestes a ser removido do documento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse evento permite que o usuário fazer a verificação adicional e, se necessário, gerar uma exceção para interromper a operação. Se uma exceção for lançada a `XmlDocument` retorna ao estado original.  
  
 Todos os nós criados por este documento, se elas foram inseridas no documento, ou não são incluídos nesse evento.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do nó atual.</summary>
        <value>O tipo de nó. Para nós <see langword="XmlDocument" />, esse valor é XmlNodeType.Document.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerDocument">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlDocument OwnerDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlDocument OwnerDocument" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.OwnerDocument" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Xml.XmlDocument" /> ao qual pertence o nó atual.</summary>
        <value>Para <see langword="XmlDocument" /> nós (<see cref="P:System.Xml.XmlDocument.NodeType" /> é igual a XmlNodeType.Document), essa propriedade sempre retorna <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParentNode">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNode ParentNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNode ParentNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.ParentNode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nó pai desse nó (para os nós que podem ter pais).</summary>
        <value>Sempre retorna <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreserveWhitespace">
      <MemberSignature Language="C#" Value="public bool PreserveWhitespace { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PreserveWhitespace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.PreserveWhitespace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se os espaços em branco devem ser preservados no conteúdo do elemento.</summary>
        <value>
          <see langword="true" /> para preservar espaços em branco; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade determina como o espaço em branco é tratado durante o carregamento e processo de salvamento.  
  
 Se `PreserveWhitespace` é `true` antes de <xref:System.Xml.XmlDocument.Load%2A> ou <xref:System.Xml.XmlDocument.LoadXml%2A> é chamado, nós de espaços em branco são preservados; caso contrário, se essa propriedade for `false`, espaço em branco significativo é preservado, espaço em branco não é.  
  
 Se `PreserveWhitespace` é `true` antes de <xref:System.Xml.XmlDocument.Save%2A> é chamado, o espaço em branco no documento é preservado na saída; caso contrário, se essa propriedade for `false`, `XmlDocument` recuos automaticamente a saída.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
   
  
## Examples  
 O exemplo a seguir mostra como ajustar o espaço em branco de um arquivo.  
  
 [!code-cpp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.PreserveWhitespace Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/VB/source.vb#1)]  
  
 O exemplo usa o arquivo `book.xml` como entrada.  
  
 [!code-xml[Classic WebData XmlDocument.PreserveWhitespace Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.PreserveWhitespace Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadNode">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlNode ReadNode (System.Xml.XmlReader reader);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Xml.XmlNode ReadNode(class System.Xml.XmlReader reader) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.ReadNode(System.Xml.XmlReader)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reader" Type="System.Xml.XmlReader" />
      </Parameters>
      <Docs>
        <param name="reader">O código-fonte XML</param>
        <summary>Cria um objeto <see cref="T:System.Xml.XmlNode" /> com base nas informações no <see cref="T:System.Xml.XmlReader" />. O leitor deve ser posicionado em um nó ou atributo.</summary>
        <returns>O novo <see langword="XmlNode" /> ou <see langword="null" /> não se houver mais nenhum nó.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Lê um `XmlNode` do leitor fornecido e posiciona o leitor no próximo nó. Esse método cria o tipo de `XmlNode` correspondentes a <xref:System.Xml.XmlNode.NodeType%2A> em que o leitor está atualmente posicionado. (Se o leitor estiver no estado inicial, `ReadNode` avança o leitor para o primeiro nó e, em seguida, opera nesse nó.)  
  
 Se o leitor está posicionado no início de um elemento `ReadNode` lê qualquer filho e todos os atributos de nós, até e incluindo a marca de fim do nó atual. O `XmlNode` retornado contém subárvore representando tudo de leitura. O leitor é posicionado imediatamente após a marca de fim.  
  
 `ReadNode`também pode ler atributos, mas nesse caso ele não Avançar o leitor para o próximo atributo. Isso permite que você escreva o código c# a seguir:  
  
```  
XmlDocument doc = new XmlDocument();  
while (reader.MoveToNextAttribute())  
{  
  XmlNode a = doc.ReadNode(reader);  
  // Do some more processing.  
}  
```  
  
 `ReadNode`consumir o valor do atributo, que significa que depois de chamar `ReadNode` em um atributo, <xref:System.Xml.XmlReader.ReadAttributeValue%2A?displayProperty=nameWithType> retorna `false`.  
  
   
  
## Examples  
 O exemplo a seguir usa `ReadNode` para criar um novo nó e, em seguida, insere o novo nó no documento.  
  
 [!code-cpp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.ReadNode Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/VB/source.vb#1)]  
  
 O exemplo usa o arquivo de `cd.xml`, como entrada.  
  
 [!code-xml[Classic WebData XmlDocument.ReadNode Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlDocument.ReadNode Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">O leitor é posicionado em um tipo de nó que não converte em um nó DOM válido (por exemplo, EndElement ou EndEntity).</exception>
        <block subset="none" type="overrides">
          <para>Esse método tem uma demanda de herança. Confiança total é necessária para substituir o <see langword="ReadNode" /> método.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.Stream outStream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.Stream outStream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.Stream)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="outStream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="outStream">O fluxo no qual você deseja salvar.</param>
        <summary>Salva o documento XML no fluxo especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espaço em branco é preservado somente se <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> é definido como `true`.  
  
 XmlDeclaration de atual `XmlDocument` objeto determina o atributo de codificação do documento salvo. O valor do atributo de codificação é obtido do <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propriedade. Se o `XmlDocument` does não tem uma XmlDeclaration ou se o XmlDeclaration não tem um atributo de codificação, o documento salvo não terá uma ou.  
  
 Quando o documento é salvo, os atributos xmlns são gerados para manter a identidade do nó (local nome + namespace URI) corretamente. Por exemplo, o código c# a seguir  
  
```  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 gera esse atributo xmls `<item xmls="urn:1"/>`.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 Observe que apenas o <xref:System.Xml.XmlDocument.Save%2A> método impõe um documento XML bem formado. Todos os outros `Save` sobrecargas apenas garantem um fragmento bem formado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">A operação não resultaria em um documento XML bem formado (por exemplo, sem declarações XML duplicadas ou elementos do documento).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.IO.TextWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">O <see langword="TextWriter" /> no qual você deseja salvar.</param>
        <summary>Salva o documento XML no <see cref="T:System.IO.TextWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A codificação de `TextWriter` determina a codificação é gravado (a codificação do nó ' XmlDeclaration é substituída pela codificação do `TextWriter`). Se não havia nenhuma codificação especificada no `TextWriter`, o `XmlDocument` é salvo sem um atributo de codificação.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 Observe que apenas o <xref:System.Xml.XmlDocument.Save%2A> método impõe um documento XML bem formado. Todos os outros `Save` sobrecargas apenas garantem um fragmento bem formado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">A operação não resultaria em um documento XML bem formado (por exemplo, sem declarações XML duplicadas ou elementos do documento).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">O local do arquivo em que você deseja salvar o documento.</param>
        <summary>Salva o documento XML no arquivo especificado. Se o arquivo especificado existir, este método o substituirá.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espaço em branco é preservado na saída arquivo somente se <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> é definido como `true`.  
  
 XmlDeclaration de atual `XmlDocument` objeto determina o atributo de codificação do documento salvo. O valor do atributo de codificação é obtido do <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propriedade. Se o `XmlDocument` does não tem uma XmlDeclaration ou se o XmlDeclaration não tem um atributo de codificação, o documento salvo não terá uma ou.  
  
 Quando o documento é salvo, os atributos xmlns são gerados para manter a identidade do nó (local nome + namespace URI) corretamente. Por exemplo, o código c# a seguir  
  
```  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 gera esse atributo xmls `<item xmls="urn:1"/>`.  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 Observe que apenas o <xref:System.Xml.XmlDocument.Save%2A> método impõe um documento XML bem formado. Todos os outros `Save` sobrecargas apenas garantem um fragmento bem formado.  
  
   
  
## Examples  
 O exemplo a seguir carrega o XML em um objeto XmlDocument, modifica e salva-o em um arquivo chamado Data.  
  
 [!code-cpp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.Save Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.Save Example/VB/source.vb#1)]  
  
 O arquivo de data contém o seguinte XML: `<item><name>wrench</name><price>10.95</price></item>`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">A operação não resultaria em um documento XML bem formado (por exemplo, sem declarações XML duplicadas ou elementos do documento).</exception>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public virtual void Save (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Save(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Save(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">O <see langword="XmlWriter" /> no qual você deseja salvar.</param>
        <summary>Salva o documento XML no <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Espaço em branco é preservado somente se <xref:System.Xml.XmlDocument.PreserveWhitespace%2A> é definido como `true`.  
  
 A codificação de `XmlWriter` determina a codificação é gravado (a codificação do nó ' XmlDeclaration é substituída pela codificação do `XmlWriter`). Se não havia nenhuma codificação especificada no `XmlWriter`, o `XmlDocument` é salvo sem um atributo de codificação.  
  
 Quando o documento é salvo, os atributos xmlns são gerados para manter a identidade do nó (LocalName + NamespaceURI) corretamente. Por exemplo, o código c# a seguir  
  
```  
XmlDocument doc = new XmlDocument();  
doc.AppendChild(doc.CreateElement("item","urn:1"));  
doc.Save(Console.Out);  
```  
  
 gera esse atributo xmls:  
  
```  
<item  
    xmls="urn:1"/>  
```  
  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM).  
  
 Observe que apenas o <xref:System.Xml.XmlDocument.Save%2A> método impõe um documento XML bem formado. Todos os outros `Save` sobrecargas apenas garantem um fragmento bem formado.  
  
   
  
## Examples  
 O exemplo a seguir carrega o XML em um `XmlDocument` de objeto e salva-o em um arquivo.  
  
 [!code-cpp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.LoadXml Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.LoadXml Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">A operação não resultaria em um documento XML bem formado (por exemplo, sem declarações XML duplicadas ou elementos do documento).</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemaInfo">
      <MemberSignature Language="C#" Value="public override System.Xml.Schema.IXmlSchemaInfo SchemaInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.IXmlSchemaInfo SchemaInfo" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.SchemaInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.IXmlSchemaInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Retorna o Post-Schema-validação-Infoset psvi (POST) do nó.</summary>
        <value>O <see cref="T:System.Xml.Schema.IXmlSchemaInfo" /> objeto que representa a psvi POST do nó.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conteúdo de psvi POST dessa propriedade é definido depois que o nó é validado.  
  
 Essa propriedade é uma extensão da Microsoft do DOM (Modelo de Objeto do Documento).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Schemas">
      <MemberSignature Language="C#" Value="public System.Xml.Schema.XmlSchemaSet Schemas { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Schema.XmlSchemaSet Schemas" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.Schemas" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Schema.XmlSchemaSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto <see cref="T:System.Xml.Schema.XmlSchemaSet" /> associado a esse <see cref="T:System.Xml.XmlDocument" />.</summary>
        <value>Um objeto <see cref="T:System.Xml.Schema.XmlSchemaSet" /> que contém os esquemas XSD (linguagem de definição de esquema XML) associados a esse <see cref="T:System.Xml.XmlDocument" />, caso contrário, um objeto <see cref="T:System.Xml.Schema.XmlSchemaSet" /> vazio.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os esquemas contidos em um <xref:System.Xml.Schema.XmlSchemaSet> objeto associado a um <xref:System.Xml.XmlDocument> objeto são usados para validação quando o <xref:System.Xml.XmlDocument.Validate%2A> método de um <xref:System.Xml.XmlDocument> é executado.  
  
 Quando um <xref:System.Xml.XmlDocument> objeto é inicializado com dados XML de um <xref:System.Xml.XmlReader> objeto, o <xref:System.Xml.Schema.XmlSchemaSet> objeto é carregado o <xref:System.Xml.XmlReaderSettings.Schemas%2A> propriedade do <xref:System.Xml.XmlReader> objeto.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">O objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" /> que recebe informações sobre erros e avisos de validação de esquema.</param>
        <summary>Valida o <see cref="T:System.Xml.XmlDocument" /> em relação aos esquemas XSD (Linguagem de Definição de Esquema XML) contidos na propriedade <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xml.XmlDocument.Validate%2A> método valida os dados XML no <xref:System.Xml.XmlDocument> em relação aos esquemas contidos no <xref:System.Xml.XmlDocument.Schemas%2A> propriedade. O <xref:System.Xml.XmlDocument.Validate%2A> método executa infoset aumento. Especificamente, após a validação for bem-sucedida, padrões de esquema são aplicados, os valores de texto são convertidos em valores atômicos conforme necessário e informações de tipo são associadas a itens de informações validadas. O resultado é uma árvore de subdiretório anteriormente sem tipo XML no <xref:System.Xml.XmlDocument> substituído por uma subárvore digitada.  
  
 Eis as observações importantes a considerar ao usar o <xref:System.Xml.XmlDocument.Validate%2A> método.  
  
-   Dicas de local de esquema, como `xsi:schemaLocation` ou `xsi:noNamespaceSchemaLocation` são ignorados.  
  
-   Esquemas embutidos serão ignoradas.  
  
-   Se ocorrerem erros de validação de esquema durante a validação de <xref:System.Xml.XmlDocument> torna-se parcialmente validada com alguns nós com as informações do tipo correto e outras sem.  
  
-   O processo de validação inclui a verificação de restrições de exclusividade e de referência (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, e `xs:unique`).  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Xml.XmlDocument.Validate%2A>. O exemplo cria um <xref:System.Xml.XmlDocument> que contém um esquema XSD associado usando o <xref:System.Xml.XmlReaderSettings> e <xref:System.Xml.XmlReader> objetos. O exemplo usa o <xref:System.Xml.XPath.XPathNavigator> classe incorretamente, modifique o valor digitado de um elemento no documento XML, gerando um erro de validação de esquema.  
  
 [!code-cpp[XPathValidation#1](~/samples/snippets/cpp/VS_Snippets_Data/XPathValidation/CPP/XPathValidation.cpp#1)]
 [!code-csharp[XPathValidation#1](~/samples/snippets/csharp/VS_Snippets_Data/XPathValidation/CS/XPathValidation.cs#1)]
 [!code-vb[XPathValidation#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XPathValidation/VB/XPathValidation.vb#1)]  
  
 O exemplo usa o `contosoBooks.xml` e `contosoBooks.xsd` arquivos como entrada.  
  
 [!code-xml[XPathXMLExamples#2](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xml#2)]  
  
 [!code-xml[XPathXMLExamples#3](~/samples/snippets/xml/VS_Snippets_Data/XPathXMLExamples/XML/contosoBooks.xsd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Ocorreu um evento de validação de esquema e nenhum objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" /> foi especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Validate">
      <MemberSignature Language="C#" Value="public void Validate (System.Xml.Schema.ValidationEventHandler validationEventHandler, System.Xml.XmlNode nodeToValidate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Validate(class System.Xml.Schema.ValidationEventHandler validationEventHandler, class System.Xml.XmlNode nodeToValidate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.Validate(System.Xml.Schema.ValidationEventHandler,System.Xml.XmlNode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationEventHandler" Type="System.Xml.Schema.ValidationEventHandler" />
        <Parameter Name="nodeToValidate" Type="System.Xml.XmlNode" />
      </Parameters>
      <Docs>
        <param name="validationEventHandler">O objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" /> que recebe informações sobre erros e avisos de validação de esquema.</param>
        <param name="nodeToValidate">O <see cref="T:System.Xml.XmlNode" /> objeto criado a partir de um <see cref="T:System.Xml.XmlDocument" /> para validar.</param>
        <summary>Valida o objeto <see cref="T:System.Xml.XmlNode" /> especificado para os esquemas de XSD (Linguagem de Definição de Esquema XML) contidos na propriedade <see cref="P:System.Xml.XmlDocument.Schemas" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Xml.XmlDocument.Validate%2A> método valida os dados XML no <xref:System.Xml.XmlNode> objeto em relação aos esquemas contidos no <xref:System.Xml.XmlDocument.Schemas%2A> propriedade. O <xref:System.Xml.XmlDocument.Validate%2A> método executa infoset aumento. Especificamente, após a validação for bem-sucedida, padrões de esquema são aplicados, os valores de texto são convertidos em valores atômicos conforme necessário e informações de tipo são associadas a itens de informações validadas. O resultado é uma árvore de subdiretório anteriormente sem tipo XML no <xref:System.Xml.XmlDocument> substituído por uma subárvore digitada.  
  
 Eis as observações importantes a considerar ao usar o <xref:System.Xml.XmlDocument.Validate%2A> método.  
  
-   Dicas de local de esquema, como `xsi:schemaLocation` ou `xsi:noNamespaceSchemaLocation` são ignorados.  
  
-   Esquemas embutidos serão ignoradas.  
  
-   Se ocorrerem erros de validação de esquema durante a validação de <xref:System.Xml.XmlDocument> torna-se parcialmente validada com alguns nós com as informações do tipo correto e outras sem.  
  
 Se o nó a ser validado é o nó raiz, o processo de validação inclui a verificação de restrições de exclusividade e de referência (`xs:ID`, `xs:IDREF`, `xs:key`, `xs:keyref`, e `xs:unique`); caso contrário, as restrições de exclusividade e de referência são omitidas.  
  
   
  
## Examples  
 Para obter um exemplo de <xref:System.Xml.XmlDocument.Validate%2A> método, consulte o <xref:System.Xml.XmlDocument.Validate%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Xml.XmlNode" /> parâmetro de objeto não foi criado de um <see cref="T:System.Xml.XmlDocument" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Xml.XmlNode" /> parâmetro de objeto não é um elemento, atributo, fragmento de documento ou o nó raiz.</exception>
        <exception cref="T:System.Xml.Schema.XmlSchemaValidationException">Ocorreu um evento de validação de esquema e nenhum objeto <see cref="T:System.Xml.Schema.ValidationEventHandler" /> foi especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteContentTo">
      <MemberSignature Language="C#" Value="public override void WriteContentTo (System.Xml.XmlWriter xw);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteContentTo(class System.Xml.XmlWriter xw) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteContentTo(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xw" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="xw">O <see langword="XmlWriter" /> no qual você deseja salvar.</param>
        <summary>Salva todos os filhos do nó <see langword="XmlDocument" /> para o <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM). É funcionalmente equivalente ao <xref:System.Xml.XmlDocument.InnerXml%2A> propriedade.  
  
 O <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propriedade determina a codificação é gravado. Se o `Encoding` propriedade não tem um valor, o `XmlDocument` é gravado sem um atributo de codificação.  
  
   
  
## Examples  
 O exemplo a seguir exibe o documento na tela.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteContentTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteContentTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter w);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter w) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlDocument.WriteTo(System.Xml.XmlWriter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XmlDocument</AssemblyName>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="w" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="w">O <see langword="XmlWriter" /> no qual você deseja salvar.</param>
        <summary>Salva o nó <see langword="XmlDocument" /> no <see cref="T:System.Xml.XmlWriter" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é uma extensão da Microsoft para modelo de objeto de documento (DOM). É funcionalmente equivalente ao <xref:System.Xml.XmlNode.OuterXml%2A> propriedade.  
  
 O <xref:System.Xml.XmlDeclaration.Encoding%2A?displayProperty=nameWithType> propriedade determina a codificação é gravado. Se o `Encoding` propriedade não tem um valor, o `XmlDocument` é gravado sem um atributo de codificação.  
  
   
  
## Examples  
 O exemplo a seguir exibe o documento na tela.  
  
 [!code-cpp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlDocument.WriteTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlDocument.WriteTo Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public virtual System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlDocument.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Define o <see cref="T:System.Xml.XmlResolver" /> que será usado para resolver recursos externos.</summary>
        <value>O <see langword="XmlResolver" /> a ser usado.  
  
 Na versão 1.1 do.NET Framework, o chamador deve ser totalmente confiável para especificar um <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `XmlResolver` pode ser usado para carregar DTDs ou expandir as referências de entidade. Usando o <xref:System.Xml.XmlResolver.Credentials%2A?displayProperty=nameWithType> propriedade, você pode definir as credenciais no `XmlResolver` para acessar os recursos armazenados em um recurso de rede segura.  
  
-   Se o documento não foi carregado usando um <xref:System.Xml.XmlReader> (ou seja, se ele foi carregado usando um fluxo, arquivo e assim por diante) o `XmlResolver` no `XmlDocument` sempre é usado.  
  
-   Se o documento foi carregado com um <xref:System.Xml.XmlTextReader>, o resolvedor no `XmlTextReader` é usado para resolver quaisquer referências DTD no nó ' DocumentType. O resolvedor na `XmlDocument` é usada para expandir as referências de entidade.  
  
-   Se o documento foi carregado com um <xref:System.Xml.XmlValidatingReader>, o resolvedor no `XmlDocument` nunca é usado.  
  
-   Se o documento foi carregado com uma classe que estende o `XmlReader` e `XmlReader` não é possível resolver entidades (<xref:System.Xml.XmlReader.CanResolveEntity%2A> retorna `false`), o `XmlResolver` no `XmlDocument` é usado para resolver todas as referências no nó ' DocumentType e expandir as referências de entidade.  
  
> [!NOTE]
>  Se o `XmlDocument` são carregados usando um <xref:System.Xml.XmlReader> que tinha um `XmlResolver` definido, o `XmlResolver` no `XmlReader` não é armazenado em cache pelo `XmlDocument` depois <xref:System.Xml.XmlDocument.Load%2A> for concluída.  
  
 Na versão 1.1 do.NET Framework, se essa propriedade não é definida, o nível de confiança do aplicativo determina o comportamento padrão.  
  
 `Fully trusted code:`O documento usa um padrão <xref:System.Xml.XmlUrlResolver> sem credenciais de usuário. Se a autenticação é necessária para acessar um recurso de rede, use o `XmlResolver` propriedade para especificar um `XmlResolver` com as credenciais necessárias.  
  
 `Semi-trusted code:`O `XmlResolver` está definida como `null`. Recursos externos não são resolvidos.  
  
 Para obter mais informações sobre segurança e o `XmlResolver` propriedade, consulte [Resolvendo recursos externos](~/docs/standard/data/xml/resolving-external-resources.md).  
  
 Essa propriedade é uma extensão da Microsoft do DOM (Modelo de Objeto do Documento).  
  
   
  
## Examples  
 O exemplo a seguir carrega um documento XML que inclui uma referência a um arquivo DTD. O `XmlResolver` propriedade é usada para definir as credenciais necessárias para acessar o recurso de rede.  
  
 [!code-cpp[XmlDocument.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlDocument.XmlResolver/CPP/docresolver.cpp#1)]
 [!code-csharp[XmlDocument.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlDocument.XmlResolver/CS/docresolver.cs#1)]
 [!code-vb[XmlDocument.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlDocument.XmlResolver/VB/docresolver.vb#1)]  
  
 O exemplo usa os seguintes arquivos de dados como entrada.  
  
 `book5.xml`  
  
 [!code-xml[XmlDocument.XmlResolver#2](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/book5.xml#2)]  
  
 `books.dtd`  
  
 [!code-xml[XmlDocument.XmlResolver#3](~/samples/snippets/xml/VS_Snippets_Data/XmlDocument.XmlResolver/XML/books.dtd#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Essa propriedade é definida como <see langword="null" /> e uma entidade ou DTD externo é encontrada.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
