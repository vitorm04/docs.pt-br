<Type Name="Roles" FullName="System.Web.Security.Roles">
  <TypeSignature Language="C#" Value="public static class Roles" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Roles extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.Security.Roles" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Gerencia a associação do usuário em funções para autorização de verificação em um aplicativo ASP.NET. Essa classe não pode ser herdada.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gerenciamento de função do ASP.NET permite que você gerencie a autorização para seu aplicativo com base em grupos de usuários, conhecidos como funções. Ao atribuir usuários a funções, você pode controlar o acesso a partes diferentes recursos de seu aplicativo Web com base na função em vez de, ou além de, especificando a autorização com base no nome de usuário. Por exemplo, um aplicativo do funcionário pode ter funções como gerentes, funcionários, diretores e assim por diante, onde diferentes privilégios forem especificados para cada função.  
  
 Os usuários podem pertencer a mais de uma função. Por exemplo, se seu site for um fórum de discussão, alguns usuários podem ser a função de membros e moderadores. Você pode definir cada função para ter privilégios diferentes no site, e um usuário que está em ambas as funções, em seguida, teria dois conjuntos de privilégios.  
  
 Para habilitar o gerenciamento de função para seu aplicativo ASP.NET, use o elemento do `system.web` seção no arquivo Web. config para seu aplicativo, conforme mostrado no exemplo a seguir.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
  <roleManager defaultProvider="SqlProvider"   
    enabled="true"  
    cacheRolesInCookie="true"  
    cookieName=".ASPROLES"  
    cookieTimeout="30"  
    cookiePath="/"  
    cookieRequireSSL="false"  
    cookieSlidingExpiration="true"  
    cookieProtection="All" >  
    <providers>  
      <add  
        name="SqlProvider"  
        type="System.Web.Security.SqlRoleProvider"  
        connectionStringName="SqlServices"  
        applicationName="SampleApplication" />  
      </providers>  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Você pode especificar regras de autorização no arquivo de configuração para o aplicativo Web ou por meio de programação em seu código. Por exemplo, a seção a seguir de um arquivo Web. config requer que os usuários façam logon (negando a usuários anônimos) e, em seguida, permite que somente usuários na função de administradores tenham acesso.  
  
```  
<authorization>  
  <deny users="?" />  
  <allow roles="Administrators" />  
  <deny users="*" />  
</authorization>  
```  
  
 Se você usar o `authorization` seção no arquivo Web. config de seu aplicativo para especificar a autorização baseada em funções, usuários do seu aplicativo deve fornecer uma identidade de usuário autenticado. Você pode autenticar os usuários usando a autenticação do Windows ou formulários. Usuários anônimos não podem ser atribuídos a uma função. Funções podem ser usadas de forma independente ou em conjunto com o ASP.NET <xref:System.Web.Security.Membership> classes.  
  
 Para verificar a associação de função por meio de programação, você pode usar o <xref:System.Web.Security.Roles> classe ou o <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> propriedade com o <xref:System.Web.Security.Roles.IsUserInRole%2A> método, ou você pode usar o <xref:System.Web.UI.Page.User%2A?displayProperty=nameWithType> propriedade com o <xref:System.Security.Principal.IPrincipal.IsInRole%2A?displayProperty=nameWithType> método. Para o código de exemplo que verifica a associação de função programaticamente, consulte a seção de exemplo neste tópico.  
  
 O <xref:System.Web.Security.Roles> classe também permite que você criar e excluir funções e adicionar usuários ou remover usuários das funções.  
  
> [!NOTE]
>  Se você tiver configurado seu aplicativo para usar o <xref:System.Web.Security.WindowsTokenRoleProvider> classe, você não pode modificar funções ou associação de função. O <xref:System.Web.Security.WindowsTokenRoleProvider> apenas grupos de associação classverifies na segurança do Windows. Nesse caso, você deve usar o gerenciamento de contas de usuário do Windows em vez de funções do ASP.NET para criar e excluir grupos e gerenciar a associação de grupo.  
  
 Você pode armazenar informações de função em várias fontes de dados.  
  
-   Você pode usar o <xref:System.Web.Security.WindowsTokenRoleProvider> classe para recuperar informações de função com base na associação de grupos do Windows.  
  
-   Você pode armazenar informações de função em um banco de dados do SQL Server usando o <xref:System.Web.Security.SqlRoleProvider> classe.  
  
-   Se você tiver informações de função existente, ou armazenar informações de função em e recuperar informações de função de uma fonte de dados que não sejam Windows, um repositório de autorização ou o SQL Server, você pode implementar um provedor de função personalizada, criando uma classe que herda de <xref:System.Web.Security.RoleProvider> classe abstrata. Para obter mais informações, consulte [implementando um provedor de função](http://msdn.microsoft.com/library/851671ce-bf9b-43f2-aba4-bc9d28b11c7d).  
  
 Se o navegador do usuário aceitar cookies, você pode armazenar informações da função de usuário em um cookie no computador do usuário. Em cada solicitação de página, o ASP.NET lê as informações de função de usuário do cookie. Isso pode melhorar o desempenho do aplicativo, reduzindo a quantidade de comunicação necessária com a fonte de dados para recuperar informações de função. Se as informações de função para um usuário são muito longos para armazenar em um cookie, o ASP.NET armazena apenas as informações de função usadas recentemente no cookie e, em seguida, procura informações de função adicionais na fonte de dados conforme necessário. Se o navegador do usuário não dá suporte a cookies ou os cookies estão desabilitados, informações de função não é armazenado em cache em um cookie.  
  
 Você pode melhorar a confiabilidade dos nomes de função em cache em um cookie, especificando um <xref:System.Web.Security.Roles.CookieProtectionValue%2A> propriedade ao configurar as funções do ASP.NET. O padrão <xref:System.Web.Security.Roles.CookieProtectionValue%2A> é `All`, que criptografa os nomes de função no cookie e valida que o conteúdo do cookie não foram alterado.  
  
   
  
## Examples  
 O exemplo a seguir mostra o arquivo Web. config para um aplicativo configurado para usar a associação do ASP.NET e funções do ASP.NET e usar o <xref:System.Web.Security.SqlRoleProvider> para armazenar informações de associação e funções em um banco de dados do SQL Server. Os usuários são autenticados com autenticação de formulários e apenas os usuários à função administradores têm permissão para acessar o aplicativo.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=localhost;Initial Catalog=aspnetdb;Integrated Security=SSPI;" />  
  </connectionStrings>  
  
  <system.web>  
    <authentication mode="Forms" >  
      <forms loginUrl="login.aspx"  
      name=".ASPXFORMSAUTH" />  
    </authentication>  
  
    <authorization>  
      <deny users="?" />  
      <allow roles="Administrators" />  
      <deny users="*" />  
    </authorization>  
  
    <membership defaultProvider="AspNetSqlProvider" userIsOnlineTimeWindow="15">  
    </membership>  
  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="true"  
      cookieSlidingExpiration="true"  
      cookieProtection="All" >  
  
      <providers>  
        <clear />  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="SampleApplication" />  
        </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 O exemplo de código a seguir programaticamente verifica se o logon do usuário está na função de administradores antes de permitir que o usuário exibir as funções de outros usuários.  
  
  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="AddUsersToRole">
      <MemberSignature Language="C#" Value="public static void AddUsersToRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRole(System.String[],System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário para adicionar à função especificada.</param>
        <param name="roleName">A função para adicionar os nomes de usuário especificado.</param>
        <summary>Adiciona os usuários especificados à função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUsersToRole%2A> método chama o provedor de função padrão para associar os usuários especificados com a função especificada na fonte de dados.  
  
 Se seu aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que já está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um ou mais usuários a uma função ou remove um usuário de uma função com base na entrada do usuário. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos elementos em <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 - ou -  
  
 Um do elementos em <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="usernames" />contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUsersToRoles">
      <MemberSignature Language="C#" Value="public static void AddUsersToRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUsersToRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUsersToRoles(System.String[],System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário para adicionar às funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de nomes de função à qual adicionar os nomes de usuário.</param>
        <summary>Adiciona os usuários especificados às funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUsersToRoles%2A> método chama o provedor de função padrão para associar os usuários especificados com as funções especificadas na fonte de dados.  
  
 Se seu aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.AddUsersToRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que já está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um ou mais usuários para uma ou mais funções. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/adduserstorolescs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.Roles#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/adduserstorolesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções no <paramref name="roleNames" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos usuários no <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções em <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 Um do usuários em <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="roleNames" />contém um elemento duplicado.  
  
 -ou-  
  
 <paramref name="usernames" />contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRole">
      <MemberSignature Language="C#" Value="public static void AddUserToRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRole(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O nome de usuário a ser adicionado à função especificada.</param>
        <param name="roleName">A função para adicionar o nome de usuário especificado ao.</param>
        <summary>Adiciona o usuário especificado à função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUserToRole%2A> método chama o provedor de função padrão para associar o usuário especificado com a função especificada na fonte de dados.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um usuário a uma função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.Roles#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.  
  
 -ou-  
  
 O usuário já foi atribuído à função especificada.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddUserToRoles">
      <MemberSignature Language="C#" Value="public static void AddUserToRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddUserToRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.AddUserToRoles(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">O nome de usuário a ser adicionado às funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de funções às quais adicionar os nomes de usuário especificados.</param>
        <summary>Adiciona o usuário especificado às funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.AddUserToRoles%2A> método chama o provedor de função padrão para associar o usuário especificado com as funções especificadas na fonte de dados.  
  
 Se seu aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.Roles.AddUserToRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que já está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
> [!NOTE]
>  Nomes de usuário e nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir adiciona um usuário a uma ou mais funções. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/addusertorolescs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.Roles#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/addusertorolesvb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções no <paramref name="roleNames" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções em <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="roleNames" />contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ApplicationName">
      <MemberSignature Language="C#" Value="public static string ApplicationName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string ApplicationName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.ApplicationName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome do aplicativo no qual as informações de função serão armazenadas e recuperadas.</summary>
        <value>O nome do aplicativo no qual as informações de função serão armazenadas e recuperadas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade é usada pelo <xref:System.Web.Security.Roles> classe para associar usuários e funções diferentes aplicativos. Isso permite que vários aplicativos usam a mesma fonte de dados para armazenar informações de usuário e função sem exibir conflitos entre nomes duplicados ou nomes de função duplicada. Vários aplicativos ASP.NET podem usar a mesma fonte de dados, especificando o mesmo valor no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade. Você pode definir o <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade programaticamente, ou você pode defini-lo declarativamente no arquivo de configuração para o aplicativo Web usando o `applicationName` atributo.  
  
 Se seu aplicativo Web é usando o <xref:System.Web.Security.SqlRoleProvider> classe e um valor não for especificado para o `applicationName` atributo no arquivo de configuração, o <xref:System.Web.HttpRequest.ApplicationPath%2A?displayProperty=nameWithType> valor da propriedade atual <xref:System.Web.HttpContext.Request%2A?displayProperty=nameWithType> propriedade é usada.  
  
> [!CAUTION]
>  Como uma instância do provedor de função única padrão é usada para todas as solicitações atendidas por um <xref:System.Web.HttpApplication> do objeto, você pode ter várias solicitações de execução simultaneamente e a tentativa de definir o <xref:System.Web.Security.Roles.ApplicationName%2A> o valor da propriedade. O <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade não é thread safe para várias gravações e alterando o <xref:System.Web.Security.Roles.ApplicationName%2A> o valor da propriedade pode resultar em comportamento inesperado para vários usuários de um aplicativo. Evite escrever código para permitir que os usuários definam a <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade, a menos que necessário. Um exemplo de um aplicativo em que a configuração de <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade pode ser necessária é um aplicativo administrativo que gerencia os dados de função para vários aplicativos. Esse aplicativo deve ser um aplicativo de usuário único e não é um aplicativo Web.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `applicationName` atributo `MyApplication`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheRolesInCookie">
      <MemberSignature Language="C#" Value="public static bool CacheRolesInCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CacheRolesInCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CacheRolesInCookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se as funções do usuário atual são armazenadas em cache em um cookie.</summary>
        <value>
          <see langword="true" /> se as funções do usuário atual são armazenadas em cache em um cookie. Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> está definida como `true` no arquivo Web. config, informações de função para cada usuário são armazenadas em um cookie. Quando o gerenciamento de função verifica para ver se um usuário está em uma função específica, o cookie de funções é verificado antes do provedor de função é chamado para verificar a lista de funções na fonte de dados. O cookie é atualizado dinamicamente para armazenar em cache os nomes de função validados mais recentemente.  
  
 Você pode melhorar a confiabilidade dos nomes de função em cache em um cookie, especificando um <xref:System.Web.Security.Roles.CookieProtectionValue%2A> propriedade ao configurar as funções do ASP.NET. O padrão <xref:System.Web.Security.Roles.CookieProtectionValue%2A> é `All`, que criptografa os nomes de função no cookie e valida que o conteúdo do cookie não foram alterado.  
  
> [!NOTE]
>  Como os nomes de função podem ser armazenados em cache além da fonte de dados, é possível que alterações para o gerenciamento de função na fonte de dados não deve ser refletidas nos valores armazenados em cache. Nesse caso, o usuário deve fechar e reabrir o navegador para limpar o valor do cookie em cache.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `cacheRolesInCookie` atributo `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
   </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieName">
      <MemberSignature Language="C#" Value="public static string CookieName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookieName" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do cookie em que os nomes de função são armazenados em cache.</summary>
        <value>O nome do cookie em que os nomes de função são armazenados em cache. O padrão é. ASPXROLES.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar o nome do cookie em funções são armazenadas em cache para seu aplicativo, definindo o `cookieName` atributo no arquivo Web. config para seu aplicativo ASP.NET. Isso é útil quando você deseja identificar exclusivamente um cookie para o seu aplicativo ou quando um cookie é compartilhado entre vários aplicativos, como um cookie de domínio.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `cookieName` atributo. ASPROLES.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookiePath">
      <MemberSignature Language="C#" Value="public static string CookiePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CookiePath" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookiePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho para o cookie de nomes de função em cache.</summary>
        <value>O caminho do cookie em que os nomes de função são armazenados em cache. O padrão é /.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar o caminho do cookie em funções são armazenadas em cache para seu aplicativo, definindo o `cookiePath` atributo no arquivo Web. config para seu aplicativo ASP.NET. Para obter mais informações sobre caminhos de cookie, consulte <xref:System.Web.HttpCookie.Path%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `cookiePath` a /MyApplication de atributo.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieProtectionValue">
      <MemberSignature Language="C#" Value="public static System.Web.Security.CookieProtection CookieProtectionValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Web.Security.CookieProtection CookieProtectionValue" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieProtectionValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.CookieProtection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica como os nomes de função armazenadas em cache em um cookie são protegidos.</summary>
        <value>Uma da <see cref="T:System.Web.Security.CookieProtection" /> valores de enumeração que indica como os nomes das funções que são armazenados em cache em um cookie são protegidos. O padrão é <see langword="All" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar a proteção do cookie em funções são armazenadas em cache para seu aplicativo, definindo o `cookieProtection` atributo no arquivo Web. config para seu aplicativo ASP.NET. O `cookieProtection` atributo toma uma <xref:System.Web.Security.CookieProtection> valor de enumeração que indica se os nomes de função são criptografados, validado, ambos ou nenhum deles.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `cookieProtection` atributo `Encrypted`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieRequireSSL">
      <MemberSignature Language="C#" Value="public static bool CookieRequireSSL { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieRequireSSL" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieRequireSSL" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o cookie de nomes de função requer SSL a fim de ser retornado para o servidor.</summary>
        <value>
          <see langword="true" />Se o SSL é necessário para retornar o cookie de nomes de função para o servidor. Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar se o SSL (Secure Sockets Layer) é necessária para retornar o cookie de nomes de função para o servidor em seu aplicativo, definindo o `cookieRequireSSL` atributo no arquivo Web. config para seu aplicativo ASP.NET. Para obter mais informações, consulte <xref:System.Web.HttpCookie.Secure%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `cookieRequireSSL` para `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieSlidingExpiration">
      <MemberSignature Language="C#" Value="public static bool CookieSlidingExpiration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CookieSlidingExpiration" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieSlidingExpiration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se a data de expiração do cookie de nomes de função e a hora serão reinicializadas periodicamente.</summary>
        <value>
          <see langword="true" />Se a data de expiração do cookie de nomes de função e a hora serão redefinidas periodicamente; Caso contrário, <see langword="false" />. O padrão é <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode especificar se a data de expiração do cookie de nomes de função e hora será redefinida com cada resposta usando o `cookieSlidingExpiration` atributo no arquivo Web. config para seu aplicativo ASP.NET. Se `true`, a expiração do cookie será inicialmente definida como a data e hora atuais mais o <xref:System.Web.Security.Roles.CookieTimeout%2A> em minutos. Enquanto o usuário continua a usar ativamente o aplicativo ASP.NET, a data de expiração do cookie serão atualizados automaticamente se há menos da metade do <xref:System.Web.Security.Roles.CookieTimeout%2A> restantes. Para obter mais informações, consulte a propriedade <xref:System.Web.HttpCookie.Expires%2A>.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> propriedade `false`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="false"  
  cookieProtection="Encrypted" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CookieTimeout">
      <MemberSignature Language="C#" Value="public static int CookieTimeout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CookieTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CookieTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de minutos antes da expiração do cookie de funções.</summary>
        <value>Um inteiro que especifica o número de minutos antes da expiração do cookie de funções. O padrão é 30 minutos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.CookieTimeout%2A> propriedade é usada quando o <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> é de propriedade `true` e especifica o tempo de vida em minutos para o cookie de funções. Para definir o <xref:System.Web.Security.Roles.CookieTimeout%2A> valor, adicione o `cookieTimeout` de atributos para o elemento no arquivo Web. config para o aplicativo ASP.NET e especificar um valor inteiro.  
  
 Se <xref:System.Web.Security.Roles.CookieSlidingExpiration%2A> é `false`, essa propriedade será ignorada.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de <xref:System.Web.Security.Roles.CookieTimeout%2A> propriedade para 30 minutos.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/MyApplication"  
  cookieRequireSSL="true"  
  cookieSlidingExpiration="true"  
  cookieProtection="Encrypted" >  
  <providers>  
  <add  
    name="SqlProvider"  
    type="System.Web.Security.SqlRoleProvider"  
    connectionStringName="SqlServices"  
    applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreatePersistentCookie">
      <MemberSignature Language="C#" Value="public static bool CreatePersistentCookie { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CreatePersistentCookie" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.CreatePersistentCookie" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o cookie de nomes de função é baseado em sessão ou persistente.</summary>
        <value>
          <see langword="true" /> se o cookie de nomes de função é um cookie persistente; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.CreatePersistentCookie%2A> o valor da propriedade é definido na configuração de um aplicativo ASP.NET usando o `createPersistentCookie` atributo do elemento de configuração.  
  
 Quando `false`, o cookie de nomes de função é um cookie de sessão, ou seja, o cookie é perdido quando o navegador for fechado. Quando `true`, o cookie de nomes de função é um cookie persistente que está disponível em várias sessões do navegador. A data de expiração do cookie persistente e a hora estão definidas para a data e hora atuais mais o <xref:System.Web.Security.Roles.CookieTimeout%2A> valor em minutos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRole">
      <MemberSignature Language="C#" Value="public static void CreateRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CreateRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.CreateRole(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser criada.</param>
        <summary>Adiciona uma nova função à fonte de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.CreateRole%2A> método adiciona um nome de função para a fonte de dados. <xref:System.Web.Security.Roles.CreateRole%2A>chama o <xref:System.Web.Security.RoleProvider.CreateRole%2A> método do provedor de função padrão para adicionar a função especificada para a fonte de dados.  
  
> [!NOTE]
>  Os nomes de função não podem conter vírgulas.  
  
   
  
## Examples  
 O exemplo de código a seguir cria uma nova função na fonte de dados. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia.  
  
 -ou-  
  
 <paramref name="roleName" /> contém uma vírgula.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteCookie">
      <MemberSignature Language="C#" Value="public static void DeleteCookie ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void DeleteCookie() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Exclui o cookie onde os nomes de função são armazenados em cache.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.DeleteCookie%2A> método limpa o conteúdo do cookie é usado para nomes de função de cache. Para obter mais informações sobre o cache de nomes de função, consulte <xref:System.Web.Security.Roles.CacheRolesInCookie%2A>.  
  
   
  
## Examples  
 O código a seguir exemplo chama o <xref:System.Web.Security.Roles.DeleteCookie%2A> método para limpar qualquer armazenado em cache os nomes de função quando um usuário efetua login. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/logincs.aspx#5)]
 [!code-aspx-vb[System.Web.Security.Roles#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/loginvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser excluída.</param>
        <summary>Remove uma função da fonte de dados.</summary>
        <returns>
          <see langword="true" />Se <paramref name="roleName" /> foi excluído da fonte de dados; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.DeleteRole%2A> método Remove um nome de função da fonte de dados. <xref:System.Web.Security.Roles.DeleteRole%2A>chama o <xref:System.Web.Security.RoleProvider.DeleteRole%2A> método do provedor de função padrão para remover a função especificada da fonte de dados.  
  
 Se a função identificado pelo `roleName` parâmetro tem um ou mais membros, em seguida, uma exceção será lançada e a função não será excluída.  
  
   
  
## Examples  
 O exemplo de código a seguir exclui uma função da fonte de dados. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" />tem um ou mais membros.  
  
 -ou-  
  
 O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="DeleteRole">
      <MemberSignature Language="C#" Value="public static bool DeleteRole (string roleName, bool throwOnPopulatedRole);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool DeleteRole(string roleName, bool throwOnPopulatedRole) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.DeleteRole(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="throwOnPopulatedRole" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser excluída.</param>
        <param name="throwOnPopulatedRole">Se <see langword="true" />, lança uma exceção <c>roleName</c> tem um ou mais membros.</param>
        <summary>Remove uma função da fonte de dados.</summary>
        <returns>
          <see langword="true" />Se <paramref name="roleName" /> foi excluído da fonte de dados; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.DeleteRole%2A> método Remove um nome de função da fonte de dados. <xref:System.Web.Security.Roles.DeleteRole%2A>chama o <xref:System.Web.Security.RoleProvider.DeleteRole%2A> método do provedor de função padrão para remover a função especificada da fonte de dados.  
  
 Se `throwOnPopulatedRole` é `true`, em seguida, uma exceção será lançada e a função não será excluída se a função identificado pelo `roleName` parâmetro tem um ou mais membros. Se `throwOnPopulatedRole` é `false`, em seguida, a função será excluída se ela estiver vazia ou não.  
  
   
  
## Examples  
 O exemplo de código a seguir exclui uma função da fonte de dados. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/deleterolecs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/deleterolevb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">
          <paramref name="roleName" />tem um ou mais membros e <paramref name="throwOnPopulatedRole" /> é <see langword="true" />.  
  
 -ou-  
  
 O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public static string Domain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Domain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor do domínio do cookie de nomes de função.</summary>
        <value>O <see cref="P:System.Web.HttpCookie.Domain" /> do cookie de nomes de função.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.Domain%2A> o valor da propriedade é definido na configuração de um aplicativo ASP.NET usando o `domain` atributo do elemento de configuração.  
  
 Se nenhum valor for especificado na configuração para o atributo de domínio, o <xref:System.Web.Security.Roles.Domain%2A> propriedade retorna `null` e o domínio do cookie de nomes de função padrão é o comportamento do <xref:System.Web.HttpCookie> <xref:System.Web.HttpCookie.Domain%2A> propriedade.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public static bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o gerenciamento de função está habilitado para o aplicativo Web atual.</summary>
        <value>
          <see langword="true" />Se o gerenciamento de função está ativado. Caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `enabled` atributo `true`.  
  
```  
<roleManager defaultProvider="SqlProvider"   
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All" >  
  <providers>  
    <add  
      name="SqlProvider"  
      type="System.Web.Security.SqlRoleProvider"  
      connectionStringName="SqlServices"  
      applicationName="MyApplication" />  
  </providers>  
</roleManager>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FindUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] FindUsersInRole (string roleName, string usernameToMatch);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] FindUsersInRole(string roleName, string usernameToMatch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.FindUsersInRole(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
        <Parameter Name="usernameToMatch" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">A função a ser pesquisada.</param>
        <param name="usernameToMatch">O nome de usuário a ser pesquisado.</param>
        <summary>Obtém uma lista de usuários em uma função especificada em que o nome de usuário contém o nome de usuário especificado a ser correspondido.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todos os usuários cujo nome de usuário corresponde a <paramref name="usernameToMatch" /> e que são membros da função especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.Security.Roles.FindUsersInRole%2A>Retorna uma lista de usuários em uma função onde o nome de usuário contém uma correspondência de fornecido `usernameToMatch` configurado `applicationName`. Por exemplo, se o `usernameToMatch` parâmetro for definido como "usuário" e, em seguida, os usuários "Usuário1", "Usuário2", "usuário3", e assim por diante são retornados. Os usuários são retornados em ordem alfabética por nome de usuário.  
  
 O <xref:System.Web.Security.SqlRoleProvider> executa a pesquisa usando uma cláusula LIKE em relação a `usernameToMatch` parâmetro. Todos os curingas são suportados pelo SQL Server em que as cláusulas podem ser usadas no `usernameToMatch` o valor do parâmetro.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.FindUsersInRole%2A> método para exibir a associação de função com base na entrada do usuário. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.Roles#11](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/FindUsersInRolecs.aspx#11)]
 [!code-aspx-vb[System.Web.Security.Roles#11](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/FindUsersInRolevb.aspx#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" /> (<see langword="Nothing" /> no Visual Basic).  
  
 -ou-  
  
 <paramref name="usernameToMatch" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="usernameToMatch" /> é uma cadeia de caracteres vazia.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAllRoles">
      <MemberSignature Language="C#" Value="public static string[] GetAllRoles ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetAllRoles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetAllRoles" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma lista de todas as funções do aplicativo.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todas as funções armazenadas na fonte de dados do aplicativo.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetAllRoles%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.GetAllRoles%2A?displayProperty=nameWithType> método do provedor de função padrão para obter uma lista de todas as funções da fonte de dados para um aplicativo. Somente as funções para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetAllRoles%2A> método para obter a lista de funções para um aplicativo e associar os resultados para um <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma lista das funções nas quais o usuário conectado no momento está.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todas as funções nas quais o usuário conectado no momento está.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetRolesForUser%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> as funções que o usuário conectado no momento está no método do provedor de função padrão para recuperar a partir dos dados da fonte. O usuário conectado no momento é identificado pelo <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propriedade <xref:System.Web.HttpContext?displayProperty=nameWithType>, ou <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> para HTTP não ambientes de hospedagem. Se nenhum usuário estiver conectado, uma exceção será lançada. Somente as funções para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
 Se <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> é `true`, em seguida, os resultados do <xref:System.Web.Security.Roles.GetRolesForUser%2A> método pode ser retornado do cache de função em vez do provedor de função especificado.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetRolesForUser%2A> método para recuperar uma lista de funções para um usuário especificado e associar as funções retornadas para um <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Não há nenhum usuário de logon atual.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetRolesForUser">
      <MemberSignature Language="C#" Value="public static string[] GetRolesForUser (string username);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetRolesForUser(string username) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetRolesForUser(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O usuário para o qual será retornada uma lista de funções.</param>
        <summary>Obtém uma lista das funções de que o usuário faz parte.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todas as funções que o usuário especificado está em.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetRolesForUser%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.GetRolesForUser%2A?displayProperty=nameWithType> as funções que o usuário está no método do provedor de função padrão para recuperar a partir dos dados da fonte. Somente as funções para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
 Se `username` é igual ao usuário atual conectado e <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> é `true`, os resultados do <xref:System.Web.Security.Roles.GetRolesForUser%2A> método pode ser retornado do cache de função em vez de especificado <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetRolesForUser%2A> método para recuperar uma lista de funções para um usuário especificado e associar as funções retornadas para um <xref:System.Web.UI.WebControls.GridView?displayProperty=nameWithType> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.Roles#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="username" /> contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUsersInRole">
      <MemberSignature Language="C#" Value="public static string[] GetUsersInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetUsersInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.GetUsersInRole(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">A função para obter a lista de usuários.</param>
        <summary>Obtém uma lista de usuários na função especificada.</summary>
        <returns>Uma matriz de cadeia de caracteres que contém os nomes de todos os usuários que são membros da função especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.GetUsersInRole%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.GetUsersInRole%2A> método do provedor de função padrão para recuperar os nomes de usuário associados a uma função da fonte de dados. Somente as funções para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.GetUsersInRole%2A> método para obter uma lista de usuários em uma função específica e associa os resultados para um <xref:System.Web.UI.WebControls.GridView> controle. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função a ser pesquisada.</param>
        <summary>Obtém um valor que indica se o usuário conectado no momento está na função especificada. A API é destinada a ser chamada apenas no contexto de um thread de solicitação do ASP.NET e, nesse caso de uso sancionado, é thread-safe.</summary>
        <returns>
          <see langword="true" />Se o usuário conectado no momento está na função especificada. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.IsUserInRole%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.IsUserInRole%2A?displayProperty=nameWithType> método do provedor de função padrão para determinar se o usuário conectado no momento está associado uma função da fonte de dados para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade. O usuário conectado no momento é identificado pelo <xref:System.Web.HttpContext.User%2A?displayProperty=nameWithType> propriedade <xref:System.Web.HttpContext?displayProperty=nameWithType>, ou <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> para HTTP não ambientes de hospedagem. Se nenhum usuário estiver conectado, uma exceção será lançada. Somente as funções para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade são recuperadas.  
  
 Se <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> é `true`, em seguida, `roleName` podem ser verificados em relação o cache de funções em vez do provedor de função especificado.  
  
   
  
## Examples  
 O exemplo de código a seguir programaticamente verifica se o usuário conectado no momento é a função de administradores antes de permitir que o usuário exibir as definições de funções para o aplicativo. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
 -ou-  
  
 Não há nenhum usuário de logon atual.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsUserInRole">
      <MemberSignature Language="C#" Value="public static bool IsUserInRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsUserInRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.IsUserInRole(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O nome do usuário a ser pesquisado.</param>
        <param name="roleName">O nome da função a ser pesquisada.</param>
        <summary>Obtém um valor que indica se o usuário especificado está na função especificada para a função especificada. A API é destinada a ser chamada apenas no contexto de um thread de solicitação do ASP.NET e, nesse caso de uso sancionado, é thread-safe.</summary>
        <returns>
          <see langword="true" />Se o usuário especificado está na função especificada. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.IsUserInRole%2A> chamadas de método de <xref:System.Web.Security.RoleProvider.IsUserInRole%2A> método do provedor de função padrão para determinar se um nome de usuário está associado uma função da fonte de dados para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade.  
  
 Se `username` é igual ao usuário atual conectado e o <xref:System.Web.Security.Roles.CacheRolesInCookie%2A> é o valor da propriedade `true`, `roleName` podem ser verificados em relação o cache de função em vez de especificado <xref:System.Web.Security.Roles.Provider%2A>.  
  
   
  
## Examples  
 O exemplo de código a seguir programaticamente verifica se um usuário está na função de administradores antes de permitir que o usuário exibir as definições de funções para o aplicativo. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/ViewRolescs.aspx#4)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/ViewRolesvb.aspx#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="username" /> contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="MaxCachedResults">
      <MemberSignature Language="C#" Value="public static int MaxCachedResults { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxCachedResults" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.MaxCachedResults" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número máximo de nomes de função a ser armazenado em cache para um usuário.</summary>
        <value>O número máximo de nomes de função a ser armazenado em cache para um usuário. O padrão é 25.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.MaxCachedResults%2A> propriedade é definida usando o `maxCachedResults` atributo de configuração. O valor de `maxCachedResults` atributo de configuração deve ser definido como um valor inteiro maior que zero.  
  
   
  
## Examples  
 O exemplo a seguir mostra o elemento de `system.web` seção do arquivo Web. config para um aplicativo ASP.NET. Especifica que o aplicativo usa um <xref:System.Web.Security.SqlRoleProvider> instância e conjuntos de `maxCachedResults` de atributo para 10.  
  
```  
<roleManager  
  enabled="true"  
  cacheRolesInCookie="true"  
  cookieName=".ASPROLES"  
  cookieTimeout="30"  
  cookiePath="/"  
  cookieRequireSSL="false"  
  cookieSlidingExpiration="true"  
  cookieProtection="All"   
  maxCachedResults="10" />  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Provider">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProvider Provider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProvider Provider" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Provider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o provedor de função padrão do aplicativo.</summary>
        <value>O provedor de função padrão do aplicativo, que é exposto como uma classe que herda a classe abstrata <see cref="T:System.Web.Security.RoleProvider" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.Provider%2A> propriedade permite que você referenciar diretamente o provedor de função padrão para um aplicativo. Isso é normalmente usado para acessar membros personalizados do provedor de função que não são parte do <xref:System.Web.Security.RoleProvider> classe abstrata.  
  
 Por exemplo, o <xref:System.Web.Security.WindowsTokenRoleProvider> classe inclui uma sobrecarga de <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> método que permite que você determine se um usuário está em uma função comum do Windows usando um <xref:System.Security.Principal.WindowsBuiltInRole> valor de enumeração. Uma referência para o <xref:System.Web.Security.WindowsTokenRoleProvider> classe para um aplicativo pode ser obtido usando o <xref:System.Web.Security.Roles.Provider%2A> propriedade e podem ser convertidas um <xref:System.Web.Security.WindowsTokenRoleProvider> para fazer referência ao <xref:System.Web.Security.WindowsTokenRoleProvider.IsUserInRole%2A> sobrecarga.  
  
 Se vários provedores de função são configurados para um aplicativo, você pode acessar os provedores de função diferente usando o <xref:System.Web.Security.Roles.Providers%2A> coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir converte o provedor de função padrão como um <xref:System.Web.Security.WindowsTokenRoleProvider> e verifica se o usuário conectado no momento está na função de administradores antes de permitir que o usuário exibir as definições de funções para o aplicativo. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.WindowsTokenRoleProvider>.  
  
 [!code-aspx-csharp[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/CS/ViewRoles2cs.aspx#2)]
 [!code-aspx-vb[System.Web.Security.WindowsTokenRoleProvider#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.WindowsTokenRoleProvider/VB/ViewRoles2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="Providers">
      <MemberSignature Language="C#" Value="public static System.Web.Security.RoleProviderCollection Providers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Web.Security.RoleProviderCollection Providers" />
      <MemberSignature Language="DocId" Value="P:System.Web.Security.Roles.Providers" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.Security.RoleProviderCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de provedores de função para o aplicativo ASP.NET.</summary>
        <value>Um <see cref="T:System.Web.Security.RoleProviderCollection" /> que contém os provedores de função configurados para o aplicativo ASP.NET.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.Providers%2A> propriedade faz referência a todos os provedores de função habilitados para um aplicativo, incluindo quaisquer provedores adicionados no arquivo Web. config. Você pode controlar qual função provedores estão disponíveis para um aplicativo usando o `providers` elemento da seção no arquivo Web. config para seu aplicativo.  
  
 O exemplo a seguir mostra uma seção que remove quaisquer provedores existentes (como aquelas especificadas no arquivo Machine. config) e adiciona um <xref:System.Web.Security.SqlRoleProvider> instância como o provedor de função para o aplicativo.  
  
```  
<configuration>  
  <connectionStrings>  
    <add name="SqlServices" connectionString="Data Source=MySqlServer;Integrated Security=SSPI;Initial Catalog=aspnetdb;" />  
  </connectionStrings>  
  
  <system.web>  
    <roleManager defaultProvider="SqlProvider"   
      enabled="true"  
      cacheRolesInCookie="true"  
      cookieName=".ASPROLES"  
      cookieTimeout="30"  
      cookiePath="/"  
      cookieRequireSSL="false"  
      cookieSlidingExpiration="true"  
      cookieProtection="Encrypted">  
  
      <providers>  
        <clear/>  
        <add  
          name="SqlProvider"  
          type="System.Web.Security.SqlRoleProvider"  
          connectionStringName="SqlServices"  
          applicationName="MyApplication" />  
         </providers>  
  
    </roleManager>  
  </system.web>  
</configuration>  
```  
  
 Você pode obter uma referência para um provedor de digitada o <xref:System.Web.Security.Roles.Providers%2A> coleção por indexação o provedor de função por nome e convertê-la como o tipo desejado.  
  
 Você pode obter uma referência para o provedor padrão para um aplicativo usando o <xref:System.Web.Security.Roles.Provider%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir lista os provedores habilitados para um aplicativo e seus respectivos tipos.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#7](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/Providerscs.aspx#7)]
 [!code-aspx-vb[System.Web.Security.Roles#7](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/Providersvb.aspx#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRole (string username, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRole(string username, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRole(System.String,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="username">O usuário a ser removido da função especificada.</param>
        <param name="roleName">A função para remover o usuário especificado.</param>
        <summary>Remove o usuário indicado da função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUserFromRole%2A> método chama o provedor de função padrão para remover o usuário especificado da função especificada na fonte de dados.  
  
   
  
## Examples  
 O exemplo de código a seguir remove um usuário de uma função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/adduserstorolecs.aspx#3)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/adduserstorolevb.aspx#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,)  
  
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUserFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUserFromRoles (string username, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUserFromRoles(string username, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUserFromRoles(System.String,System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="username" Type="System.String" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="username">O usuário a ser removido das funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de nomes de função os quais remover o usuário especificado.</param>
        <summary>Remove o usuário especificado das funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> método chama o provedor de função padrão para remover o usuário especificado das funções especificadas na fonte de dados.  
  
 Se o aplicativo está configurado para usar o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que não está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RemoveUserFromRoles%2A> método para remover um usuário de uma ou mais funções. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#10](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUserFromRolescs.aspx#10)]
 [!code-aspx-vb[System.Web.Security.Roles#10](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUserFromRolesvb.aspx#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções no <paramref name="roleNames" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="username" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções em <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="username" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="roleNames" />contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRole">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRole (string[] usernames, string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRole(string[] usernames, string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRole(System.String[],System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário para remover das funções especificadas.</param>
        <param name="roleName">O nome da função para remover os usuários especificados.</param>
        <summary>Remove os usuários especificados da função especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> método chama o provedor de função padrão para remover os usuários especificados da função especificada na fonte de dados.  
  
 Se o aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que não está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RemoveUsersFromRole%2A> método para remover um ou mais usuários de uma função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#9](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolecs.aspx#9)]
 [!code-aspx-vb[System.Web.Security.Roles#9](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolevb.aspx#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" />.  
  
 -ou-  
  
 Nomes de um usuário em <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 Nomes de um usuário em <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="usernames" />contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveUsersFromRoles">
      <MemberSignature Language="C#" Value="public static void RemoveUsersFromRoles (string[] usernames, string[] roleNames);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveUsersFromRoles(string[] usernames, string[] roleNames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RemoveUsersFromRoles(System.String[],System.String[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="usernames" Type="System.String[]" />
        <Parameter Name="roleNames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="usernames">Uma matriz de cadeia de caracteres de nomes de usuário para remover das funções especificadas.</param>
        <param name="roleNames">Uma matriz de cadeia de caracteres de nomes de função para remover os usuários especificados.</param>
        <summary>Remove os nomes de usuários especificados das funções especificadas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> método chama o provedor de função padrão para remover os usuários especificados das funções especificadas na fonte de dados.  
  
 Se o aplicativo usa o <xref:System.Web.Security.SqlRoleProvider> classe, as atualizações de banco de dados que são executadas durante a chamada para o <xref:System.Web.Security.SqlRoleProvider.RemoveUsersFromRoles%2A> método são feitas em uma transação. Se um erro for encontrado, como um nome de usuário que não está em uma função especificada, a transação é revertida e nenhuma atualização será executada.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RemoveUsersFromRoles%2A> método para remover um ou mais usuários de uma ou mais funções com base na entrada do usuário. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
 [!code-aspx-csharp[System.Web.Security.Roles#8](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.Roles/CS/RemoveUsersFromRolescs.aspx#8)]
 [!code-aspx-vb[System.Web.Security.Roles#8](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.Roles/VB/RemoveUsersFromRolesvb.aspx#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Uma das funções especificadas no <paramref name="roleNames" /> é <see langword="null" />.  
  
 -ou-  
  
 Um dos usuários especificados na <paramref name="usernames" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Uma das funções especificadas no <paramref name="roleNames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 Um dos usuários especificados no <paramref name="usernames" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).  
  
 -ou-  
  
 <paramref name="roleNames" />contém um elemento duplicado.  
  
 -ou-  
  
 <paramref name="usernames" />contém um elemento duplicado.</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
    <Member MemberName="RoleExists">
      <MemberSignature Language="C#" Value="public static bool RoleExists (string roleName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool RoleExists(string roleName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.Security.Roles.RoleExists(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="roleName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="roleName">O nome da função pela qual pesquisar na fonte de dados.</param>
        <summary>Obtém um valor que indica se o nome da função especificada já existe na fonte de dados de função.</summary>
        <returns>
          <see langword="true" />Se o nome da função já existe na fonte de dados; Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Web.Security.Roles.RoleExists%2A> chamadas de método de `RoleExists` método do provedor de função padrão para determinar se um nome de função existe na fonte de dados para o aplicativo especificado no <xref:System.Web.Security.Roles.ApplicationName%2A> propriedade.  
  
   
  
## Examples  
 O seguinte exemplo de código usa o <xref:System.Web.Security.Roles.RoleExists%2A> método para determinar se um nome de função já existe antes de criar a função. Para obter um exemplo de um arquivo Web. config que permita o gerenciamento de função, consulte <xref:System.Web.Security.Roles>.  
  
> [!IMPORTANT]
>  Este exemplo contém uma caixa de texto que aceita a entrada do usuário, que é uma possível ameaça à segurança. Por padrão, a páginas da Web ASP.NET validam a entrada do usuário não inclui elementos HTML ou script. Para obter mais informações, consulte [visão geral sobre scripts maliciosos](http://msdn.microsoft.com/library/772c7312-211a-4eb3-8d6e-eec0aa1dcc07).  
  
 [!code-aspx-csharp[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/CS/createrolecs.aspx#1)]
 [!code-aspx-vb[System.Web.Security.SqlRoleProvider#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.Security.SqlRoleProvider/VB/createrolevb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="roleName" /> é <see langword="null" /> (<see langword="Nothing" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="roleName" /> é uma cadeia de caracteres vazia ou contém uma vírgula (,).</exception>
        <exception cref="T:System.Configuration.Provider.ProviderException">O gerenciamento de função não está habilitado.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
