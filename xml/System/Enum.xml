<Type Name="Enum" FullName="System.Enum">
  <TypeSignature Language="C#" Value="public abstract class Enum : ValueType, IComparable, IConvertible, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Enum extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Enum" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece a classe base para enumerações.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma enumeração é um conjunto de constantes nomeadas cujo tipo subjacente é qualquer tipo integral. Se nenhum tipo subjacente é explicitamente declarado, <xref:System.Int32> é usado. <xref:System.Enum>é a classe base para todas as enumerações do .NET Framework. Tipos de enumeração são definidos pelo `enum` palavra-chave em c# e o `Enum`... `End Enum` construir no Visual Basic.  
  
 <xref:System.Enum>fornece métodos para comparar as instâncias dessa classe, converter o valor de uma instância em sua representação de cadeia de caracteres, converter a representação de cadeia de caracteres de um número em uma instância dessa classe e criar uma instância de uma enumeração especificado e o valor.  
  
 Você também pode tratar uma enumeração como um campo de bits. Para obter mais informações, consulte o [membros não-exclusivo e o atributo Flags](#Flags) seção e <xref:System.FlagsAttribute> tópico.  
  
 Neste tópico:  
  
 [Criando um tipo de enumeração](#Creating)   
 [Criando um tipo de enumeração](#Instantiating)   
 [Práticas recomendadas de enumeração](#BestPractices)   
 [Executar operações com enumerações](#Operations)   
 [Executar conversões](#conversions)  
 [Análise de valores de enumeração](#parsing)  
 [Formatação de valores de enumeração](#formatting)  
[Membros de enumeração de iteração](#iterating)  
[Membros não-exclusivo e o atributo Flags](#Flags)  
[Adicionar métodos de enumeração](#methods)  
  
<a name="Creating"></a>   
## <a name="creating-an-enumeration-type"></a>Criando um tipo de enumeração  
 Linguagens de programação normalmente fornecem a sintaxe para declarar uma enumeração que consiste em um conjunto de constantes nomeadas e seus valores. O exemplo a seguir ilustra a sintaxe usada por c# e Visual Basic para definir uma enumeração. Ele cria uma enumeração denominada `ArrivalStatus` que tem três membros: `ArrivalStatus.Early`, `ArrivalStatus.OnTime`, e `ArrivalStatus.Late`. Observe que em ambos os casos, a enumeração não explicitamente herda de <xref:System.Enum>; a relação de herança é tratada implicitamente pelo compilador.  
  
 [!code-csharp[System.Enum.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#1)]
 [!code-vb[System.Enum.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#1)]  
  
> [!WARNING]
>  Você nunca deve criar um tipo de enumeração cujo tipo subjacente é não integral ou <xref:System.Char>. Embora você possa criar um tipo de enumeração tais por meio de reflexão, chamadas de método que usa o tipo resultante não são confiáveis e também podem lançar exceções adicionais.  
  
<a name="Instantiating"></a>   
## <a name="instantiating-an-enumeration-type"></a>Criando um tipo de enumeração  
 Você pode instanciar um tipo de enumeração, assim como você cria uma instância em qualquer outro tipo de valor: declarando uma variável e atribuindo uma das constantes da enumeração a ele. O exemplo a seguir cria um `ArrivalStatus` cujo valor é `ArrivalStatus.OnTime`.  
  
 [!code-csharp[System.Enum.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class1.cs#2)]
 [!code-vb[System.Enum.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class1.vb#2)]  
  
 Você também pode instanciar um valor de enumeração das seguintes maneiras:  
  
-   Usando recursos de uma determinada linguagem de programação cast (como em c#) ou converter um valor inteiro (como Visual Basic) para um valor de enumeração. O exemplo a seguir cria um `ArrivalStatus` objeto cujo valor é `ArrivalStatus.Early` dessa maneira.  
  
     [!code-csharp[System.Enum.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#4)]
     [!code-vb[System.Enum.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#4)]  
  
-   Chamando o construtor padrão implícito. Como mostra o exemplo a seguir, neste caso o valor subjacente da instância de enumeração é 0. No entanto, isso não é necessariamente o valor de uma constante válido na enumeração.  
  
     [!code-csharp[System.Enum.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#3)]
     [!code-vb[System.Enum.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#3)]  
  
-   Chamando o <xref:System.Enum.Parse%2A> ou <xref:System.Enum.TryParse%2A> método para analisar uma cadeia de caracteres que contém o nome de uma constante na enumeração. Para obter mais informações, consulte o [análise valores de enumeração](#parsing) seção.  
  
-   Chamando o <xref:System.Enum.ToObject%2A> método para converter um valor inteiro para um tipo de enumeração. Para obter mais informações, consulte o [executar conversões](#conversions) seção.  
  
<a name="BestPractices"></a>   
## <a name="enumeration-best-practices"></a>Práticas recomendadas de enumeração  
 É recomendável que você use as seguintes práticas recomendadas quando você define os tipos de enumeração:  
  
-   Se você não tiver definido um membro de enumeração cujo valor é 0, considere a criação de um `None` constante enumerada. Por padrão, a memória usada para a enumeração é inicializada a zero, o common language runtime. Consequentemente, se você não definir uma constante cujo valor é zero, a enumeração conterá um valor ilegal quando ele é criado.  
  
-   Se houver um caso padrão óbvio que seu aplicativo precisa representar, considere o uso de um enumerada constante cujo valor é zero para representá-lo. Se não houver nenhum caso padrão, considere o uso de uma constante enumerada cujo valor é zero para especificar o caso em que não esteja representado por qualquer uma das outras constantes enumeradas.  
  
-   Não especifique constantes enumeradas são reservados para uso futuro.  
  
-   Quando você define um método ou propriedade que utiliza uma constante enumerada como um valor, considere a possibilidade de validação do valor. O motivo é que você pode converter um valor numérico para o tipo de enumeração, mesmo se esse valor numérico não está definido na enumeração.  
  
 Práticas recomendadas adicionais para tipos de enumeração cujos constantes são campos de bits são listadas no [membros não-exclusivo e o atributo Flags](#Flags) seção.  
  
<a name="Operations"></a>   
## <a name="performing-operations-with-enumerations"></a>Executar operações com enumerações  
 Não é possível definir novos métodos, quando você estiver criando uma enumeração. No entanto, um tipo de enumeração herda um conjunto completo de estático e métodos de instância do <xref:System.Enum> classe. As seções a seguir pesquisa a maioria desses métodos, além de vários outros métodos que são usados ao trabalhar com valores de enumeração.  
  
<a name="conversions"></a>   
### <a name="performing-conversions"></a>Executar conversões  
 Você pode converter entre um membro de enumeração e seu tipo subjacente usando uma conversão (em c#) ou o operador de conversão (no Visual Basic). O exemplo a seguir usa os operadores de conversão ou para realizar conversões de um número inteiro para um valor de enumeração e de um valor de enumeração a um número inteiro.  
  
 [!code-csharp[System.Enum.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#5)]
 [!code-vb[System.Enum.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#5)]  
  
 O <xref:System.Enum> classe também inclui um <xref:System.Enum.ToObject%2A> método que converte um valor de qualquer tipo integral para um valor de enumeração. O exemplo a seguir usa o <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> método para converter um <xref:System.Int32> para um `ArrivalStatus` valor. Observe que, como o <xref:System.Enum.ToObject%2A> retorna um valor do tipo <xref:System.Object>, o uso de um operador de conversão ou ainda pode ser necessário converter o objeto para o tipo de enumeração.  
  
 [!code-csharp[System.Enum.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/class2.cs#6)]
 [!code-vb[System.Enum.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/class2.vb#6)]  
  
 Ao converter um inteiro para um valor de enumeração, é possível atribuir um valor que não é realmente um membro da enumeração. Para evitar isso, você pode passar o inteiro para o <xref:System.Enum.IsDefined%2A> método antes de executar a conversão. O exemplo a seguir usa esse método para determinar se os elementos em uma matriz de valores de inteiro podem ser convertidos em `ArrivalStatus` valores.  
  
 [!code-csharp[System.Enum.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion1.cs#7)]
 [!code-vb[System.Enum.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion1.vb#7)]  
  
 Embora o <xref:System.Enum> classe fornece implementações de interface explícita do <xref:System.IConvertible> interface para a conversão de um valor de enumeração para um tipo integral, você deve usar os métodos do <xref:System.Convert> classe, como <xref:System.Convert.ToInt32%2A>, para executar essas conversões. O exemplo a seguir ilustra como você pode usar o <xref:System.Enum.GetUnderlyingType%2A> método junto com o <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> método para converter um valor de enumeração para seu tipo subjacente. Observe que este exemplo não requer que o tipo subjacente da enumeração conhecido em tempo de compilação.  
  
 [!code-csharp[System.Enum.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classconversion2.cs#8)]
 [!code-vb[System.Enum.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classconversion2.vb#8)]  
  
<a name="parsing"></a>   
### <a name="parsing-enumeration-values"></a>Análise de valores de enumeração  
 O <xref:System.Enum.Parse%2A> e <xref:System.Enum.TryParse%2A> métodos permitem que você converta a representação de cadeia de caracteres de um valor de enumeração para o valor. A representação de cadeia de caracteres pode ser o nome ou o valor subjacente de uma constante de enumeração. Observe que os métodos de análise com êxito converterá representações de cadeia de caracteres de números que não são membros de uma enumeração específico se as cadeias de caracteres podem ser convertidas em um valor de tipo subjacente da enumeração. Para evitar isso, o <xref:System.Enum.IsDefined%2A> método pode ser chamado para garantir que o resultado do método de análise é um valor de enumeração válidos. O exemplo ilustra essa abordagem e demonstra chamadas para ambos os <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> e <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29?displayProperty=nameWithType> métodos. Observe que o método de análise não genérico retorna um objeto que talvez você precise cast (em c#) ou converta (no Visual Basic) para o tipo de enumeração apropriado.  
  
 [!code-csharp[System.Enum.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classparse1.cs#9)]
 [!code-vb[System.Enum.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classparse1.vb#9)]  
  
<a name="formatting"></a>   
### <a name="formatting-enumeration-values"></a>Formatação de valores de enumeração  
 Você pode converter valores de enumeração em suas representações de cadeia de caracteres chamando estático <xref:System.Enum.Format%2A> método, bem como as sobrecargas da instância <xref:System.Enum.ToString%2A> método. Você pode usar uma cadeia de caracteres de formato para controlar o modo exato em que um valor de enumeração é representado como uma cadeia de caracteres. Para obter mais informações, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md). O exemplo a seguir usa a cada uma das cadeias de caracteres de formato de enumeração com suporte ("G" ou "g", "D" ou "d", "X" ou "x" e "F" ou "f") para converter um membro do `ArrivalStatus` enumeração para suas representações de cadeia de caracteres.  
  
 [!code-csharp[System.Enum.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classformat1.cs#10)]
 [!code-vb[System.Enum.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classformat1.vb#10)]  
  
<a name="iterating"></a>   
### <a name="iterating-enumeration-members"></a>Membros de enumeração de iteração  
 O <xref:System.Enum> tipo não implementa o <xref:System.Collections.IEnumerable> ou <xref:System.Collections.Generic.IEnumerable%601> interface, que permitem que você iterar membros de uma coleção usando um `foreach` (em c#) ou `For Each` (no Visual Basic) construir. No entanto, você pode enumerar os membros de duas maneiras.  
  
-   Você pode chamar o <xref:System.Enum.GetNames%2A> método para recuperar uma matriz de cadeia de caracteres que contém os nomes dos membros de enumeração. Em seguida, para cada elemento da matriz de cadeia de caracteres, você pode chamar o <xref:System.Enum.Parse%2A> método para converter a cadeia de caracteres para seu valor de enumeração equivalente. O exemplo a seguir ilustra esta abordagem.  
  
     [!code-csharp[System.Enum.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#11)]
     [!code-vb[System.Enum.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#11)]  
  
-   Você pode chamar o <xref:System.Enum.GetValues%2A> método para recuperar uma matriz que contém subjacente valores na enumeração. Em seguida, para cada elemento da matriz, você pode chamar o <xref:System.Enum.ToObject%2A> método para converter o valor inteiro para o valor de enumeração equivalente. O exemplo a seguir ilustra esta abordagem.  
  
     [!code-csharp[System.Enum.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classiterate.cs#12)]
     [!code-vb[System.Enum.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classiterate.vb#12)]  
  
<a name="Flags"></a>   
## <a name="non-exclusive-members-and-the-flags-attribute"></a>Membros não-exclusivo e o atributo Flags  
 É um uso comum de uma enumeração representar um conjunto de valores mutuamente exclusivos. Por exemplo, um `ArrivalStatus` instância pode ter um valor de `Early`, `OnTime`, ou `Late`. Não faz sentido para o valor de um `ArrivalStatus` instância para refletir a mais de uma constante de enumeração.  
  
 Em outros casos, no entanto, o valor de um objeto de enumeração pode incluir vários membros de enumeração, e cada membro representa um campo de bit no valor de enumeração. O <xref:System.FlagsAttribute> atributo pode ser usado para indicar que a enumeração consiste em campos de bits. Por exemplo, uma enumeração denominada `Pets` pode ser usado para indicar os tipos de animais de estimação em uma casa. Ela pode ser definida da seguinte maneira.  
  
 [!code-csharp[System.Enum.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#13)]
 [!code-vb[System.Enum.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#13)]  
  
 O `Pets` enumeração pode ser usada como mostrado no exemplo a seguir.  
  
 [!code-csharp[System.Enum.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#14)]
 [!code-vb[System.Enum.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#14)]  
  
 Práticas recomendadas a seguir devem ser usadas ao definir um bit a bit de enumeração e aplicar o <xref:System.FlagsAttribute> atributo.  
  
-   Use o <xref:System.FlagsAttribute> atributo personalizado para uma enumeração somente se for uma operação bit a bit (AND, OR exclusivo ou) a ser executada em um valor numérico.  
  
-   Defina constantes de enumeração em potências de dois, ou seja, 1, 2, 4, 8 e assim por diante. Isso significa que os sinalizadores individuais em constantes de enumeração combinado não se sobrepõem.  
  
-   Considere a criação de uma constante enumerada para combinações de sinalizador usadas com frequência. Por exemplo, se você tiver uma enumeração usada para operações de e/s de arquivo que contém as constantes enumeradas `Read = 1` e `Write = 2`, considere a criação de constante enumerada `ReadWrite = Read OR Write`, que combina o `Read` e `Write` sinalizadores. Além disso, a operação OR bit a bit usada para combinar os sinalizadores pode ser considerada um conceito avançado em algumas circunstâncias que não devem ser necessários para tarefas simples.  
  
-   Tenha cuidado se você definir um número negativo como uma constante enumerada sinalizador porque várias posições de sinalizador podem ser definidas como 1, o que pode tornar o código confuso e incentivar erros de codificação.  
  
-   Uma maneira conveniente para testar se um sinalizador é definido em um valor numérico é chamar a instância <xref:System.Enum.HasFlag%2A> método, conforme mostrado no exemplo a seguir.  
  
     [!code-csharp[System.Enum.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#15)]
     [!code-vb[System.Enum.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#15)]  
  
     É equivalente a executar uma operação AND de bit a bit entre o valor numérico e a constante enumerada sinalizador, que define todos os bits no valor numérico para zero não corresponde ao sinalizador, e, em seguida, teste se o resultado dessa operação é igual a constante enumerada de sinalizador. Isso é ilustrado no exemplo a seguir.  
  
     [!code-csharp[System.Enum.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#16)]
     [!code-vb[System.Enum.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#16)]  
  
-   Use `None` o nome do sinalizador enumerados constante cujo valor é zero. Não é possível usar o `None` constante enumerada em uma operação AND bit a bit para testar um sinalizador porque o resultado sempre será zero. No entanto, você pode executar uma operação lógica, não uma comparação bit a bit entre o valor numérico e `None` constante enumerado para determinar se qualquer bit no valor numérico está definida. Isso é ilustrado no exemplo a seguir.  
  
     [!code-csharp[System.Enum.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/classbitwise1.cs#17)]
     [!code-vb[System.Enum.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/classbitwise1.vb#17)]  
  
-   Não defina um valor de enumeração exclusivamente para espelhar o estado de enumeração em si. Por exemplo, não definem uma constante enumerada que simplesmente marca o fim da enumeração. Se você precisar determinar o último valor da enumeração, verificar esse valor explicitamente. Além disso, você pode executar uma verificação de intervalo para a constante enumerada primeira e o última se todos os valores dentro do intervalo válidos.  
  
<a name="methods"></a>   
## <a name="adding-enumeration-methods"></a>Adicionar métodos de enumeração  
 Como tipos de enumeração são definidos pelas estruturas de idioma, como `enum` (c#) e `Enum` (Visual Basic), você não pode definir métodos personalizados para um tipo de enumeração que não sejam os métodos herdados do <xref:System.Enum> classe.  No entanto, você pode usar métodos de extensão para adicionar funcionalidade a um tipo de enumeração específico.  
  
 No exemplo a seguir, a enumeração `Grades` representa as letras possíveis que um aluno pode receber em uma classe. Um método de extensão chamado `Passing` é adicionado ao tipo `Grades` de forma que cada instância desse tipo agora "sabe" se ele representa uma nota de aprovação ou não.       O `Extensions` classe também contém uma variável estática de leitura / gravação que define o nível mínimo de passagem. O valor de retorno de `Passing` método de extensão reflete o valor atual da variável.  
  
 [!code-csharp[System.Enum.Class#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.class/cs/Extensions.cs#18)]
 [!code-vb[System.Enum.Class#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.class/vb/Extensions.vb#18)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar uma enumeração para representar valores nomeados e outra enumeração para representar os campos de bits nomeado.  
  
 [!code-cpp[enummain#1](~/samples/snippets/cpp/VS_Snippets_CLR/enummain/CPP/EnumMain.cpp#1)]
 [!code-csharp[enummain#1](~/samples/snippets/csharp/VS_Snippets_CLR/enummain/CS/EnumMain.cs#1)]
 [!code-vb[enummain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enummain/VB/EnumMain.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Enum ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.#ctor" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Enum" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.CompareTo(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="target">Um objeto a ser comparado ou <see langword="null" />.</param>
        <summary>Compara essa instância com um objeto especificado e retorna uma indicação dos valores relativos.</summary>
        <returns>Um número com sinal que indica os valores relativos dessa instância e <paramref name="target" />.  
  
 <list type="table"><listheader><term>Valor  
  
 </term><description>Significado  
  
 </description></listheader><item><term>Menor que zero  
  
 </term><description>O valor desta instância é menor que o valor de <paramref name="target" />.  
  
 </description></item><item><term>Zero  
  
 </term><description>O valor desta instância é igual ao valor de <paramref name="target" />.  
  
 </description></item><item><term>Maior que zero  
  
 </term><description>O valor desta instância é maior que o valor de <paramref name="target" />.  
  
 -ou-  
  
 <paramref name="target" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir ilustra o uso de `CompareTo` no contexto de `Enum`.  
  
 [!code-cpp[enumcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumcompareto/CPP/EnumCompareTo.cpp#1)]
 [!code-csharp[enumcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumcompareto/CS/EnumCompareTo.cs#1)]
 [!code-vb[enumcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumcompareto/VB/EnumCompareTo.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> e esta instância não são do mesmo tipo.</exception>
        <exception cref="T:System.InvalidOperationException">Esta instância não é do tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> ou <see cref="T:System.UInt64" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Equals(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
        <summary>Retorna um valor que indica se essa instância é igual a um objeto especificado.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> for um valor de enumeração do mesmo tipo e com o mesmo valor subjacente que essa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.Equals%28System.Object%29?displayProperty=nameWithType> substituições de método <xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType> para definir como os membros de enumeração são avaliados quanto à igualdade.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Enum.Equals%2A>.  
  
 [!code-cpp[enumequals#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumequals/CPP/EnumEquals.cpp#1)]
 [!code-csharp[enumequals#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumequals/CS/EnumEquals.cs#1)]
 [!code-vb[enumequals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumequals/VB/EnumEquals.vb#1)]  
  
 O exemplo a seguir define dois tipos de enumeração, `SledDog` e `WorkDog`. O `SledDog` enumeração tem dois membros, `SledDog.AlaskanMalamute` e `SledDog.Malamute`, que têm o mesmo valor subjacente. A chamada para o <xref:System.Enum.Equals%2A> método indica que esses valores são iguais porque seus valores subjacentes são os mesmos. O `SledDog.Malamute` e `WorkDog.Newfoundland` os membros têm o mesmo valor subjacente, embora eles representam tipos diferentes de enumeração. Uma chamada para o <xref:System.Enum.Equals%2A> método indica que esses valores não são iguais.  
  
 [!code-csharp[System.Enum.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.equals/cs/enumequals.cs#1)]
 [!code-vb[System.Enum.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.equals/vb/enumequals.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (Type enumType, object value, string format);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.Type enumType, object value, string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Format(System.Type,System.Object,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração do valor a ser convertido.</param>
        <param name="value">O valor a ser convertido.</param>
        <param name="format">O formato de saída a ser usado.</param>
        <summary>Converte o valor especificado de um tipo enumerado especificado em sua representação de cadeia de caracteres equivalente de acordo com o formato especificado.</summary>
        <returns>Uma representação da cadeia de caracteres de <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra os valores válidos para o `format` parâmetro.  
  
|Formatar|Descrição|  
|------------|-----------------|  
|"G" ou "g"|Se `value` é igual a uma constante enumerada nomeada, o nome do que a constante é retornado; caso contrário, o decimal equivalente de `value` é retornado.<br /><br /> Por exemplo, suponha que a constante enumerada apenas chama vermelho e seu valor é 1. Se `value` é especificada como 1, esse formato retorna "Vermelho". No entanto, se `value` é especificado como 2, esse formato retorna "2".<br /><br /> -ou-<br /><br /> Se o <xref:System.FlagsAttribute> atributo personalizado é aplicado para a enumeração `value` é tratado como um campo de bits que contém um ou mais sinalizadores que consistem em um ou mais bits.<br /><br /> Se `value` é igual a uma combinação de chamada constantes enumeradas, uma lista separada por delimitador dos nomes dessas constantes é retornada. `value`é procurado sinalizadores, indo de sinalizador com o maior valor para o menor valor. Para cada sinalizador que corresponde a um campo de bits em `value`, o nome da constante é concatenado a lista separada por delimitador. O valor do sinalizador é excluído da consideração adicional e continua a pesquisa para o sinalizador Avançar.<br /><br /> Se `value` não é igual a uma combinação de chamada constantes enumeradas, o decimal equivalente de `value` é retornado.|  
|"X" ou "x"|Representa `value` em formato hexadecimal sem um principal "0x".|  
|"D" ou "d"|Representa `value` em formato decimal.|  
|"F" ou "f"|Se comporta de forma idêntica a "G" ou "g", exceto pelo fato do <xref:System.FlagsAttribute> não precisa estar presente no <xref:System.Enum> declaração.|  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de `Format` no contexto de `Enum`.  
  
 [!code-cpp[enumformat#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumformat/CPP/EnumFormat.cpp#1)]
 [!code-csharp[enumformat#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumformat/CS/EnumFormat.cs#1)]
 [!code-vb[enumformat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumformat/VB/EnumFormat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="enumType" />, <paramref name="value" /> ou <paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O parâmetro <paramref name="enumType" /> não é um tipo <see cref="T:System.Enum" />.  
  
 -ou-  
  
 O <paramref name="value" /> é de uma enumeração que difere no tipo de <paramref name="enumType" />.  
  
 -ou-  
  
 O tipo de <paramref name="value" /> não é um tipo subjacente de <paramref name="enumType" />.</exception>
        <exception cref="T:System.FormatException">O parâmetro <paramref name="format" /> contém um valor inválido.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> igual a "X", mas o tipo de enumeração é desconhecido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetHashCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para o valor dessa instância.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public static string GetName (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetName(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetName(System.Type,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Um tipo de enumeração.</param>
        <param name="value">O valor de uma constante enumerada específica em termos de seu tipo subjacente.</param>
        <summary>Recupera o nome da constante na enumeração especificada que tem o valor especificado.</summary>
        <returns>Uma cadeia de caracteres que contém o nome da constante enumerada no <paramref name="enumType" /> cujo valor é <paramref name="value" />, ou <see langword="null" />, se tal constante não for encontrada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se vários membros de enumeração têm o mesmo valor subjacente, o <xref:System.Enum.GetName%2A> método garante que ele retornará o nome de um dos membros de enumeração. No entanto, ele não garante que ele sempre retornará o nome do membro de enumeração mesmo. Como resultado, quando vários membros de enumeração têm o mesmo valor, o código do aplicativo deve nunca dependem do método retornando o nome do membro específico.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de `GetName`.  
  
 [!code-cpp[enumgetname#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetname/CPP/EnumGetName.cpp#1)]
 [!code-csharp[enumgetname#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetname/CS/EnumGetName.cs#1)]
 [!code-vb[enumgetname#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetname/VB/EnumGetName.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> ou <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.  
  
 -ou-  
  
 <paramref name="value" /> não é do tipo <paramref name="enumType" /> e não tem o mesmo tipo subjacente que <paramref name="enumType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetNames">
      <MemberSignature Language="C#" Value="public static string[] GetNames (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetNames(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetNames(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Um tipo de enumeração.</param>
        <summary>Recupera uma matriz de nomes de constantes em uma enumeração especificada.</summary>
        <returns>Uma matriz de cadeia de caracteres dos nomes das constantes em <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos da matriz de valores de retorno são classificados pelos valores binários das constantes enumeradas (isto é, por sua magnitude sem sinal). O exemplo a seguir fornece exibe informações sobre a matriz retornada pelo <xref:System.Enum.GetNames%2A> método para uma enumeração que inclui um valor positivo, negativo e zero.  
  
 [!code-csharp[System.Enum.GetNames#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getnames/cs/getnames1.cs#1)]
 [!code-vb[System.Enum.GetNames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getnames/vb/getnames1.vb#1)]  
  
 Se houver constantes enumeradas com o mesmo valor, a ordem de seus nomes correspondentes é especificada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do método <xref:System.Enum.GetNames%2A>.  
  
 [!code-cpp[enumgetnames#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetnames/CPP/EnumGetNames.cpp#1)]
 [!code-csharp[enumgetnames#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetnames/CS/EnumGetNames.cs#1)]
 [!code-vb[enumgetnames#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetnames/VB/EnumGetNames.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          O parâmetro <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código de tipo do tipo subjacente desse membro de enumeração.</summary>
        <returns>O código de tipo do tipo subjacente desta instância.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">O tipo de enumeração é desconhecido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUnderlyingType">
      <MemberSignature Language="C#" Value="public static Type GetUnderlyingType (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetUnderlyingType(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetUnderlyingType(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">A enumeração cujo tipo subjacente será recuperada.</param>
        <summary>Retorna o tipo subjacente da enumeração especificada.</summary>
        <returns>O tipo subjacente de <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum> estrutura permite que os valores sejam representadas como constantes nomeadas. O tipo de dados dos valores da enumeração é conhecido como seu tipo subjacente. Por exemplo, o tipo subjacente do <xref:System.DayOfWeek> enumeração, que consiste em constantes que representam cada dia da semana (<xref:System.DayOfWeek?displayProperty=nameWithType>, <xref:System.DayOfWeek?displayProperty=nameWithType>, e assim por diante), é <xref:System.Int32>.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Enum.GetUnderlyingType%2A> método para exibir o tipo subjacente de alguns membros de enumeração.  
  
 [!code-csharp[System.Enum.GetUnderlyingType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getunderlyingtype/cs/getunderlyingtype1.cs#1)]
 [!code-vb[System.Enum.GetUnderlyingType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getunderlyingtype/vb/getunderlyingtype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public static Array GetValues (Type enumType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array GetValues(class System.Type enumType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.GetValues(System.Type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="enumType">Um tipo de enumeração.</param>
        <summary>Recupera uma matriz de valores de constantes em uma enumeração especificada.</summary>
        <returns>Uma matriz que contém os valores das constantes em <paramref name="enumType" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os elementos da matriz são classificados pelos valores binários das constantes de enumeração (isto é, por sua magnitude sem sinal). O exemplo a seguir exibe informações sobre a matriz retornada pelo <xref:System.Enum.GetValues%2A> método para uma enumeração que inclui um valor negativo, zero e um valor positivo.  
  
 [!code-csharp[System.Enum.GetValues#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues1.cs#1)]
 [!code-vb[System.Enum.GetValues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues1.vb#1)]  
  
 O <xref:System.Enum.GetValues%2A> método retorna uma matriz que contém um valor para cada membro de `enumType` enumeração. Se vários membros têm o mesmo valor, a matriz retornada inclui valores duplicados. Nesse caso, chamando o <xref:System.Enum.GetName%2A> método com cada valor na matriz retornada não restaura os nomes exclusivos atribuídos aos membros que têm valores duplicados. Para recuperar todos os nomes de membros de enumeração com êxito, chame o <xref:System.Enum.GetNames%2A> método.  
  
 O <xref:System.Enum.GetValues%2A> método não pode ser chamado por meio de reflexão em um contexto exclusivo de reflexão. Em vez disso, você pode recuperar o valor de todos os membros de enumeração usando o <xref:System.Type.GetFields%2A?displayProperty=nameWithType> método para obter uma matriz de <xref:System.Reflection.FieldInfo> objetos que representam os membros de enumeração e, em seguida, chamar o <xref:System.Reflection.FieldInfo.GetRawConstantValue%2A?displayProperty=nameWithType> método em cada elemento da matriz. O exemplo a seguir ilustra essa técnica. Ele requer que você defina a enumeração a seguir em um assembly chamado Enumerations.dll:  
  
 [!code-csharp[System.Enum.GetValues#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#2)]
 [!code-vb[System.Enum.GetValues#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#2)]  
  
 O assembly é carregado em um contexto exclusivo de reflexão, um <xref:System.Type> objeto que representa o `Pets` enumeração é instanciada, uma matriz de <xref:System.Reflection.FieldInfo> objetos são recuperados e os valores de campo são exibidos no console.  
  
 [!code-csharp[System.Enum.GetValues#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.getvalues/cs/getvalues_reflectiononly.cs#3)]
 [!code-vb[System.Enum.GetValues#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.getvalues/vb/getvalues_reflectiononly.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso de <xref:System.Enum.GetValues%2A>.  
  
 [!code-cpp[enumgetvalues#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumgetvalues/CPP/EnumGetValues.cpp#1)]
 [!code-csharp[enumgetvalues#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumgetvalues/CS/EnumGetValues.cs#1)]
 [!code-vb[enumgetvalues#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumgetvalues/VB/EnumGetValues.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
        <exception cref="T:System.InvalidOperationException">O método é invocado por reflexão em um contexto de somente reflexão,  
  
 -ou-  
  
 <paramref name="enumType" /> é um tipo de um assembly carregado em um contexto de somente reflexão.</exception>
      </Docs>
    </Member>
    <Member MemberName="HasFlag">
      <MemberSignature Language="C#" Value="public bool HasFlag (Enum flag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool HasFlag(class System.Enum flag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.HasFlag(System.Enum)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="flag" Type="System.Enum" />
      </Parameters>
      <Docs>
        <param name="flag">Um valor de enumeração.</param>
        <summary>Determina se um ou mais campos de bits são definidos na instância atual.</summary>
        <returns>
          <see langword="true" /> se os campos de bits definidos no <paramref name="flag" /> também forem definidos na instância atual; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.HasFlag%2A> retorna o resultado da expressão booliana seguinte.  
  
```  
thisInstance And flag = flag   
```  
  
 Se o valor subjacente do `flag` for zero, o método retornará `true`. Se esse comportamento não é desejável, você pode usar o <xref:System.Enum.Equals%2A> método para testar a igualdade com zero e chame <xref:System.Enum.HasFlag%2A> somente se o valor subjacente do `flag` é diferente de zero, como mostra o exemplo a seguir.  
  
 [!code-csharp[System.Enum.HasFlag#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag0.cs#1)]
 [!code-vb[System.Enum.HasFlag#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag0.vb#1)]  
  
 O <xref:System.Enum.HasFlag%2A> método foi projetado para ser usado com tipos de enumeração que são marcados com o <xref:System.FlagsAttribute> de atributos e pode ser usado para determinar se os vários campos de bits são definidos. Para tipos de enumeração que não são marcados com o <xref:System.FlagsAttribute> atributo, chame o <xref:System.Enum.Equals%2A> método ou o <xref:System.Enum.CompareTo%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir define um `ItemsOrdered` enumeração que reflete as categorias de itens que um cliente pode classificar em um restaurante. O exemplo testa se o cliente tem solicitou uma entrada e uma bebidas.  
  
 [!code-csharp[System.Enum.HasFlag#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.hasflag/cs/hasflag1.cs#2)]
 [!code-vb[System.Enum.HasFlag#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.hasflag/vb/hasflag1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="flag" /> é um tipo diferente da instância atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public static bool IsDefined (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsDefined(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.IsDefined(System.Type,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">Um tipo de enumeração.</param>
        <param name="value">O valor ou o nome de uma constante em <c>enumType</c>.</param>
        <summary>Retorna uma indicação se existe uma constante com um valor especificado em uma enumeração especificada.</summary>
        <returns>
          <see langword="true" /> se uma constante no <paramref name="enumType" /> tiver um valor igual a <paramref name="value" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O parâmetro `value` pode ser um dos seguintes:  
  
-   Qualquer membro do tipo `enumType`.  
  
-   Uma variável cujo valor é um membro de enumeração do tipo `enumType`.  
  
-   A representação de cadeia de caracteres do nome de um membro de enumeração. Os caracteres na cadeia de caracteres devem ter o mesmo caso como o nome do membro de enumeração.  
  
-   Um valor do tipo subjacente de `enumType`.  
  
 Se as constantes em `enumType` definir um conjunto de campos de bits e `value` contém os valores, nomes ou valores subjacentes de vários campos de bits, o <xref:System.Enum.IsDefined%2A> método retornará `false`. Em outras palavras, para enumerações que definem um conjunto de campos de bits, o método determina apenas se um campo de bits única pertence à enumeração. Para determinar se os vários campos de bits são definidos em um tipo de enumeração que é marcado com o <xref:System.FlagsAttribute> atributo, você pode chamar o <xref:System.Enum.HasFlag%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir define uma enumeração denominada `PetType` que consiste em campos de bits individuais. Depois, ele chama o <xref:System.Enum.IsDefined%2A> método com possíveis valores de enumeração, nomes de cadeia de caracteres e valores compostos que resultam da definição de vários campos de bit de base.  
  
 [!code-csharp[System.Enum.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined1.cs#1)]
 [!code-vb[System.Enum.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/IsDefined1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> ou <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see langword="Enum" />.  
  
 -ou-  
  
 O tipo de <paramref name="value" /> é uma enumeração, mas não é uma enumeração de tipo <paramref name="enumType" />.  
  
 -ou-  
  
 O tipo de <paramref name="value" /> não é um tipo subjacente de <paramref name="enumType" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <paramref name="value" /> não é o tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> ou <see cref="T:System.UInt64" /> ou <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage">
          <para>Se <paramref name="enumType" /> é uma enumeração que é definida usando o <see cref="T:System.FlagsAttribute" /> de atributo, o método retorna <see langword="false" /> se campos de bits múltiplas na <paramref name="value" /> são definidos, mas <paramref name="value" /> não corresponde a um valor de enumeração composto, ou se <paramref name="value" /> é uma concatenação de cadeia de caracteres de nomes de vários sinalizadores de bit. No exemplo a seguir, uma <c>animais de estimação</c> enumeração está definida com o <see cref="T:System.FlagsAttribute" /> atributo. O <see cref="M:System.Enum.IsDefined(System.Type,System.Object)" /> método retorna <see langword="false" /> quando você passa-um valor de enumeração que tem o bit de dois campos (<c>Pets.Dog</c> e <c>Pets.Cat</c>) definida, e quando você passá-lo a representação de cadeia de caracteres do que valor de enumeração ("Dog, Cat").  
  
 [!code-csharp[System.Enum.IsDefined#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.IsDefined/cs/isdefined2.cs#2)]
 [!code-vb[System.Enum.IsDefined#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.IsDefined/vb/isdefined2.vb#2)]  
  
 Você pode determinar se vários campos de bits são definidos chamando o <see cref="M:System.Enum.HasFlag(System.Enum)" /> método.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="enumType">Um tipo de enumeração.</param>
        <param name="value">Uma cadeia de caracteres que contém o nome ou o valor a ser convertido.</param>
        <summary>Converte a representação da cadeia de caracteres do nome ou do valor numérico de uma ou mais constantes enumeradas em um objeto enumerado equivalente.</summary>
        <returns>Um objeto do tipo <paramref name="enumType" /> cujo valor é representado por <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro contém a representação de cadeia de caracteres do valor subjacente de um membro de enumeração ou constante nomeada ou uma lista de chamada constantes delimitadas por vírgulas (,). Um ou mais espaços em branco podem preceder ou execute cada valor, um nome ou uma vírgula na `value`. Se `value` é uma lista, o valor de retorno é o valor dos nomes especificados combinado com um bit a bit `OR` operação.  
  
 Se `value` é um nome que não corresponde a uma constante nomeada de `enumType`, o método gera uma <xref:System.ArgumentException>. Se `value` é a representação de cadeia de caracteres de um número inteiro que representa um valor subjacente do `enumType` enumeração, o método retorna um membro de enumeração cujo valor subjacente for `value` convertido em um tipo integral. Se esse comportamento é desejável, chame o <xref:System.Enum.IsDefined%2A> método para garantir que uma representação de cadeia de caracteres específica de um inteiro, na verdade, um membro de `enumType`. O exemplo a seguir define uma `Colors` enumeração, chamadas a <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para converter cadeias de caracteres para seus valores de enumeração correspondente e chama o <xref:System.Enum.IsDefined%2A> método para garantir a base de valores integrais específicos de valores no `Colors` enumeração.  
  
 [!code-csharp[System.Enum.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample1.cs#1)]
 [!code-vb[System.Enum.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample1.vb#1)]  
  
 Essa operação diferencia maiusculas de minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para analisar uma matriz de cadeias de caracteres que são criadas chamando o <xref:System.Enum.GetNames%2A> método. Ele também usa o <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para analisar um valor de enumeração que consiste em um campo de bits.  
  
 [!code-cpp[enumparse#1](~/samples/snippets/cpp/VS_Snippets_CLR/enumparse/CPP/EnumParse.cpp#1)]
 [!code-csharp[enumparse#1](~/samples/snippets/csharp/VS_Snippets_CLR/enumparse/CS/EnumParse.cs#1)]
 [!code-vb[enumparse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enumparse/VB/EnumParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> ou <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.  
  
 -ou-  
  
 <paramref name="value" /> é uma cadeia de caracteres vazia ou contém apenas espaços em branco.  
  
 -ou-  
  
 <paramref name="value" /> é um nome, mas não uma das constantes nomeadas definidas para a enumeração.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> está fora do intervalo do tipo subjacente de <paramref name="enumType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static object Parse (Type enumType, string value, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object Parse(class System.Type enumType, string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse(System.Type,System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="enumType">Um tipo de enumeração.</param>
        <param name="value">Uma cadeia de caracteres que contém o nome ou o valor a ser convertido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar maiúsculas e minúsculas; <see langword="false" /> levar maiúsculas e minúsculas em consideração.</param>
        <summary>Converte a representação da cadeia de caracteres do nome ou do valor numérico de uma ou mais constantes enumeradas em um objeto enumerado equivalente. Um parâmetro especifica se a operação não diferencia maiúsculas de minúsculas.</summary>
        <returns>Um objeto do tipo <paramref name="enumType" /> cujo valor é representado por <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `value` parâmetro contém a representação de cadeia de caracteres do valor subjacente de um membro de enumeração ou constante nomeada ou uma lista de chamada constantes delimitadas por vírgulas (,). Um ou mais espaços em branco podem preceder ou execute cada valor, um nome ou uma vírgula na `value`. Se `value` é uma lista, o valor de retorno é o valor dos nomes especificados combinado com um bit a bit `OR` operação.  
  
 Se `value` é um nome que não corresponde a uma constante nomeada de `enumType`, o método gera uma <xref:System.ArgumentException>. Se `value` é a representação de cadeia de caracteres de um número inteiro que representa um valor subjacente do `enumType` enumeração, o método retorna um membro de enumeração cujo valor subjacente for `value` convertido em um tipo integral. Se esse comportamento é desejável, chame o <xref:System.Enum.IsDefined%2A> método para garantir que uma representação de cadeia de caracteres específica de um inteiro, na verdade, um membro de `enumType`. O exemplo a seguir define uma `Colors` enumeração, chamadas a <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> método para converter cadeias de caracteres para seus valores de enumeração correspondente e chama o <xref:System.Enum.IsDefined%2A> método para garantir a base de valores integrais específicos de valores no `Colors` enumeração.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 O `ignoreCase` parâmetro especifica se essa operação diferencia maiusculas de minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> método para analisar uma matriz de cadeias de caracteres que são criadas chamando o <xref:System.Enum.GetNames%2A> método. Ele também usa o <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método para analisar um valor de enumeração que consiste em um campo de bits.  
  
 [!code-csharp[System.Enum.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Enum.Parse/cs/ParseExample2.cs#2)]
 [!code-vb[System.Enum.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Enum.Parse/vb/ParseExample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> ou <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.  
  
 -ou-  
  
 <paramref name="value" /> é uma cadeia de caracteres vazia ("") ou contém apenas espaços em branco.  
  
 -ou-  
  
 <paramref name="value" /> é um nome, mas não uma das constantes nomeadas definidas para a enumeração.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> está fora do intervalo do tipo subjacente de <paramref name="enumType" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static TEnum Parse&lt;TEnum&gt; (string value, bool ignoreCase) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TEnum Parse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.Parse``1(System.String,System.Boolean)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TEnum</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">To be added.</typeparam>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#GetTypeCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um valor booleano com base no tipo base.</summary>
        <returns>Este membro sempre lança uma exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente não implementado. Sempre lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um inteiro não assinado de 8 bits com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um caractere Unicode com base no tipo base.</summary>
        <returns>Este membro sempre lança uma exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente não implementado. Sempre lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um <see cref="T:System.DateTime" /> com base no tipo base.</summary>
        <returns>Este membro sempre lança uma exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente não implementado. Sempre lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um <see cref="T:System.Decimal" /> com base no tipo base.</summary>
        <returns>Este membro sempre lança uma exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente não implementado. Sempre lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um flutuante de precisão dupla ponto número com base no tipo base.</summary>
        <returns>Este membro sempre lança uma exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente não implementado. Sempre lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um inteiro assinado de 16 bits com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual em um inteiro com sinal de 32 bits com base no tipo subjacente.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um inteiro assinado de 64 bits com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um inteiro assinado de 8 bits com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um número de ponto flutuante de precisão simples com base no tipo base.</summary>
        <returns>Este membro sempre lança uma exceção.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Atualmente não implementado. Sempre lança uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidCastException">Em todos os casos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para o qual converter.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um tipo especificado com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um inteiro não assinado de 16 bits com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um inteiro não assinado de 32 bits com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Converte o valor atual para um inteiro não assinado de 64 bits com base no tipo base.</summary>
        <returns>O valor convertido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Usa <xref:System.Convert> para realizar a conversão.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IFormattable.ToString">
      <MemberSignature Language="C#" Value="string IFormattable.ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IFormattable.ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.System#IFormattable#ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Byte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o inteiro sem sinal de 8 bits especificado para um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.Byte%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o inteiro com sinal de 16 bits especificado em um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.Int16%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o inteiro com sinal de 32 bits especificado para um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.Int32%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o inteiro assinado de 64 bits especificado em um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.Int64%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro da enumeração.</param>
        <summary>Converte o objeto especificado com um valor inteiro em um membro da enumeração.</summary>
        <returns>Um objeto de enumeração cujo valor é <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.Object%29> método converte o valor integral `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> ou <paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.  
  
 - ou -  
  
 <paramref name="value" /> não é do tipo <see cref="T:System.SByte" />, <see cref="T:System.Int16" />, <see cref="T:System.Int32" />, <see cref="T:System.Int64" />, <see cref="T:System.Byte" />, <see cref="T:System.UInt16" />, <see cref="T:System.UInt32" /> ou <see cref="T:System.UInt64" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.SByte)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o valor de inteiro assinado de 8 bits especificado para um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.SByte%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt16)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o valor de inteiro não assinado de 16 bits especificado para um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt16%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o valor de inteiro não assinado de 32 bits especificado para um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt32%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToObject">
      <MemberSignature Language="C#" Value="public static object ToObject (Type enumType, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object ToObject(class System.Type enumType, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToObject(System.Type,System.UInt64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="enumType">O tipo de enumeração a ser retornado.</param>
        <param name="value">O valor a ser convertido em um membro de enumeração.</param>
        <summary>Converte o valor de inteiro não assinado de 64 bits especificado para um membro de enumeração.</summary>
        <returns>Uma instância da enumeração definida como <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Enum.ToObject%28System.Type%2CSystem.UInt64%29> método converte `value` para um membro de enumeração cujo valor subjacente for `value`. A conversão é bem-sucedida mesmo se o valor está fora dos limites de membros `enumType`. Para garantir que `value` seja um valor válido subjacente da enumeração `enumType`, passe-o para o método <xref:System.Enum.IsDefined%2A>.  
  
 Este método de conversão retorna um valor do tipo <xref:System.Object>. Em seguida, é possível convertê-lo em um objeto do tipo `enumType`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="enumType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="enumType" /> não é um <see cref="T:System.Enum" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o valor dessa instância na representação da cadeia de caracteres equivalente.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é formatado com o especificador de formato geral ("G"). Ou seja, se o <xref:System.FlagsAttribute> não é aplicado a este tipo enumerado e há uma constante nomeada igual ao valor desta instância, o valor de retorno é uma cadeia de caracteres que contém o nome da constante. Se o <xref:System.FlagsAttribute> é aplicada e uma combinação de uma ou mais constantes nomeadas é igual ao valor desta instância, em seguida, o valor de retorno é uma cadeia de caracteres contendo uma lista separada por delimitador de nomes de constantes. Caso contrário, o valor de retorno é a representação de cadeia de caracteres do valor numérico dessa instância. Para obter mais informações sobre formatação de valores de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md). Para obter mais informações sobre formatação em geral, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como converter um valor enumerado em uma cadeia de caracteres.  
  
 [!code-cpp[Classic Enum.ToString2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Enum.ToString2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/CS/source.cs#1)]
 [!code-vb[Classic Enum.ToString2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Enum.ToString2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Se vários membros de enumeração têm o mesmo valor subjacente e você tentar recuperar a representação de cadeia de caracteres do nome de um membro de enumeração com base em seu valor subjacente, seu código não deve fazer suposições sobre qual nome do método será retornado. Por exemplo, a enumeração a seguir define dois membros, <c>Shade.Gray</c> e <c>Shade.Grey</c>, que têm o mesmo valor subjacente.  
  
 [!code-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)]
 [!code-vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)]  
  
 A chamada de método a seguir tenta recuperar o nome de um membro do <c>tonalidade</c> enumeração cujo valor subjacente é 1. O método pode retornar "Cinza" ou "Cinza" e seu código não deve fazer suposições sobre qual cadeia de caracteres será retornada.  
  
 [!code-csharp[System.Enum.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#2)]
 [!code-vb[System.Enum.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#2)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString().")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">(obsoleto)</param>
        <summary>Essa sobrecarga de método é obsoleta; use <see cref="M:System.Enum.ToString" />.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Uma cadeia de caracteres de formato.</param>
        <summary>Converte o valor dessa instância para sua representação de cadeia de caracteres equivalente usando o formato especificado.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `format` parâmetro pode conter a "G" ou "g", "D" ou "d", "X" ou "x" e "F" ou "f" cadeias de caracteres de formato (a cadeia de caracteres de formato não diferencia maiusculas de minúsculas). Se `format` é `null` ou uma cadeia de caracteres vazia (""), o especificador de formato geral ("G") é usado. Para obter mais informações sobre as cadeias de caracteres de formato de enumeração e os valores de enumeração de formatação, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md). Para obter mais informações sobre formatação em geral, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como converter um valor enumerado em uma cadeia de caracteres.  
  
 [!code-cpp[enum.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/enum.tostring/CPP/tostr.cpp#1)]
 [!code-csharp[enum.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/enum.tostring/CS/tostr.cs#1)]
 [!code-vb[enum.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/enum.tostring/VB/tostr.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> contém uma especificação inválida.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> igual a "X", mas o tipo de enumeração é desconhecido.</exception>
        <block subset="none" type="usage">
          <para>Se vários membros de enumeração têm o mesmo valor subjacente e você tentar recuperar a representação de cadeia de caracteres do nome de um membro de enumeração com base em seu valor subjacente, seu código não deve fazer suposições sobre qual nome do método será retornado. Por exemplo, a enumeração a seguir define dois membros, <c>Shade.Gray</c> e <c>Shade.Grey</c>, que têm o mesmo valor subjacente.  
  
 [!code-csharp[System.Enum.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#1)]
 [!code-vb[System.Enum.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#1)]  
  
 A chamada de método a seguir tenta recuperar o nome de um membro do <c>tonalidade</c> enumeração cujo valor subjacente é 1. O método pode retornar "Cinza" ou "Cinza" e seu código não deve fazer suposições sobre qual cadeia de caracteres será retornada.  
  
 [!code-csharp[System.Enum.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tostring/cs/tostringbyvalue1.cs#3)]
 [!code-vb[System.Enum.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tostring/vb/tostringbyvalue1.vb#3)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.ToString(System.String,System.IFormatProvider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The provider argument is not used. Please use ToString(String).")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Uma especificação do formato.</param>
        <param name="provider">(Obsoleto.)</param>
        <summary>Essa sobrecarga de método é obsoleta; use <see cref="M:System.Enum.ToString(System.String)" />.</summary>
        <returns>A representação da cadeia de caracteres do valor dessa instância conforme especificado por <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `format` parâmetro pode conter a "G" ou "g", "D" ou "d", "X" ou "x" e "F" ou "f" cadeias de caracteres de formato (a cadeia de caracteres de formato não diferencia maiusculas de minúsculas). Se `format` é `null` ou uma cadeia de caracteres vazia (""), o especificador de formato geral ("G") é usado. Para obter mais informações sobre as cadeias de caracteres de formato de enumeração e os valores de enumeração de formatação, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md). Para obter mais informações sobre formatação em geral, consulte [tipos de formatação](~/docs/standard/base-types/formatting-types.md).  
  
 Especifique apenas `format`; o `provider` parâmetro está obsoleto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> não contém uma especificação de formato válida.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="format" /> igual a "X", mas o tipo de enumeração é desconhecido.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (Type enumType, string value, bool ignoreCase, out object result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(class System.Type enumType, string value, bool ignoreCase, [out] object&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse(System.Type,System.String,System.Boolean,System.Object@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="enumType" Type="System.Type" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="System.Object&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="enumType">To be added.</param>
        <param name="value">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,``0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="TEnum&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">O tipo de enumeração para o qual converter <c>valor</c>.</typeparam>
        <param name="value">A representação de cadeia de caracteres do nome de enumeração ou do valor subjacente a ser convertido.</param>
        <param name="result">Quando este método retorna, <c>resultados</c> contém um objeto do tipo <c>TEnum</c> cujo valor é representado por <c>valor</c> se a operação de análise for bem-sucedida. Se a operação de análise falhar, <c>resultados</c> contém o valor padrão do tipo subjacente de <c>TEnum</c>. Observe que esse valor não precisa ser um membro do <c>TEnum</c> enumeração. Este parâmetro é passado não inicializado.</param>
        <summary>Converte a representação da cadeia de caracteres do nome ou do valor numérico de uma ou mais constantes enumeradas em um objeto enumerado equivalente. O valor de retorno indica se a conversão foi bem-sucedida.</summary>
        <returns>
          <see langword="true" /> caso o parâmetro <paramref name="value" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29>é idêntico de <xref:System.Enum.Parse%28System.Type%2CSystem.String%29> método, exceto que, em vez de gerar uma exceção, ele retorna `false` se a conversão falhar. Elimina a necessidade de ao analisar a representação de cadeia de caracteres de um valor de enumeração de tratamento de exceção.  
  
 O `value` parâmetro contém a representação de cadeia de caracteres do valor subjacente de um membro de enumeração ou constante nomeada ou uma lista de constantes nomeadas ou subjacente de valores delimitados por vírgulas (,). Se `value` inclui vários denominado constantes ou valores, um ou mais espaços em branco podem preceder ou execute cada valor, um nome ou uma vírgula na `value`. Se `value` é uma lista, `result` reflete o valor dos nomes especificados ou valores, combinados com um bit a bit de base `OR` operação. Se `value` é a representação de cadeia de caracteres do nome de um valor de enumeração, a comparação de `value` com a enumeração de nomes diferencia maiusculas de minúsculas.  
  
 Se `value` é um nome que não corresponde a uma constante nomeada de `TEnum`, o método retornará `false`. Se `value` é a representação de cadeia de caracteres de um número inteiro que representa um valor subjacente do `TEnum` enumeração, o método retorna um membro de enumeração cujo valor subjacente for `value` convertido em um tipo integral. Se esse comportamento é desejável, chame o <xref:System.Enum.IsDefined%2A> método para garantir que uma representação de cadeia de caracteres específica de um inteiro, na verdade, um membro de `TEnum`.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Colors` enumeração, chamadas a <xref:System.Enum.TryParse%60%601%28System.String%2C%60%600%40%29> método para converter cadeias de caracteres para seus valores de enumeração correspondente e chama o <xref:System.Enum.IsDefined%2A> método para garantir a base de valores integrais específicos de valores no `Colors` enumeração.  
  
 [!code-csharp[System.Enum.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Enum.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> não é um tipo de enumeração.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryParse&lt;TEnum&gt;">
      <MemberSignature Language="C#" Value="public static bool TryParse&lt;TEnum&gt; (string value, bool ignoreCase, out TEnum result) where TEnum : struct;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse&lt;struct .ctor (class System.ValueType) TEnum&gt;(string value, bool ignoreCase, [out] !!TEnum&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Enum.TryParse``1(System.String,System.Boolean,``0@)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TEnum">
          <Constraints>
            <ParameterAttribute>DefaultConstructorConstraint</ParameterAttribute>
            <ParameterAttribute>NotNullableValueTypeConstraint</ParameterAttribute>
            <BaseTypeName>System.ValueType</BaseTypeName>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="result" Type="TEnum&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <typeparam name="TEnum">O tipo de enumeração para o qual converter <c>valor</c>.</typeparam>
        <param name="value">A representação de cadeia de caracteres do nome de enumeração ou do valor subjacente a ser convertido.</param>
        <param name="ignoreCase">
          <see langword="true" /> para ignorar as maiúsculas e minúsculas, <see langword="false" /> considerar as maiúsculas e minúsculas.</param>
        <param name="result">Quando este método retorna, <c>resultados</c> contém um objeto do tipo <c>TEnum</c> cujo valor é representado por <c>valor</c> se a operação de análise for bem-sucedida. Se a operação de análise falhar, <c>resultados</c> contém o valor padrão do tipo subjacente de <c>TEnum</c>. Observe que esse valor não precisa ser um membro do <c>TEnum</c> enumeração. Este parâmetro é passado não inicializado.</param>
        <summary>Converte a representação da cadeia de caracteres do nome ou do valor numérico de uma ou mais constantes enumeradas em um objeto enumerado equivalente. Um parâmetro especifica se a operação diferencia maiúsculas de minúsculas. O valor de retorno indica se a conversão foi bem-sucedida.</summary>
        <returns>
          <see langword="true" /> caso o parâmetro <paramref name="value" /> tenha sido convertido com êxito; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29>é idêntico de <xref:System.Enum.Parse%28System.Type%2CSystem.String%2CSystem.Boolean%29> método, exceto que, em vez de gerar uma exceção, ele retorna `false` se a conversão falhar. Elimina a necessidade de ao analisar a representação de cadeia de caracteres de um valor de enumeração de tratamento de exceção.  
  
 O `value` parâmetro contém a representação de cadeia de caracteres do valor subjacente de um membro de enumeração ou constante nomeada ou uma lista de constantes nomeadas ou subjacente de valores delimitados por vírgulas (,). Se `value` inclui vários denominado constantes ou valores, um ou mais espaços em branco podem preceder ou execute cada valor, um nome ou uma vírgula na `value`. Se `value` é uma lista, `result` reflete o valor dos nomes especificados ou valores, combinados com um bit a bit de base `OR` operação. Se `value` é a representação de cadeia de caracteres do nome de um valor de enumeração, a comparação de `value` com a enumeração nomes depende do `ignoreCase` parâmetro. Se `true`, a comparação diferencia maiusculas de minúsculas; se `false`, diferencia maiusculas de minúsculas.  
  
 Se `value` é um nome que não corresponde a uma constante nomeada de `TEnum`, o método retornará `false`. Se `value` é a representação de cadeia de caracteres de um número inteiro que representa um valor subjacente do `TEnum` enumeração, o método retorna um membro de enumeração cujo valor subjacente for `value` convertido em um tipo integral. Se esse comportamento é desejável, chame o <xref:System.Enum.IsDefined%2A> método para garantir que uma representação de cadeia de caracteres específica de um inteiro, na verdade, um membro de `TEnum`.  
  
   
  
## Examples  
 O exemplo a seguir define uma `Colors` enumeração, chamadas a <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> método para converter cadeias de caracteres para seus valores de enumeração correspondente e chama o <xref:System.Enum.IsDefined%2A> método para garantir a base de valores integrais específicos de valores no `Colors` enumeração. O <xref:System.Enum.TryParse%60%601%28System.String%2CSystem.Boolean%2C%60%600%40%29> método usa a comparação diferencia maiusculas de minúsculas ao tentar converter as representações de cadeia de caracteres de nome constantes para os valores de enumeração equivalente.  
  
 [!code-csharp[System.Enum.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.enum.tryparse/cs/tryparse2.cs#2)]
 [!code-vb[System.Enum.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.enum.tryparse/vb/tryparse2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="TEnum" /> não é um tipo de enumeração.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
