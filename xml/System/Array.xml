<Type Name="Array" FullName="System.Array">
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece métodos para criar, manipular, pesquisar e classificar matrizes, servindo assim como a classe base para todas as matrizes no Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exibir o código-fonte do .NET Framework para este tipo, consulte o [fonte de referência](http://referencesource.microsoft.com/#mscorlib/system/array.cs#156e066ecc4ccedf). Percorra o código-fonte online, baixe a referência para exibição offline e percorrer as fontes (incluindo atualizações e patches) durante a depuração; consulte [instruções](http://referencesource.microsoft.com/).  
  
 O <xref:System.Array> a classe não é parte do <xref:System.Collections> namespaces. No entanto, ela ainda será considerada uma coleção porque ele se baseia o <xref:System.Collections.IList> interface.  
  
 O <xref:System.Array> classe é a classe base para implementações de linguagem que oferece suporte a matrizes. No entanto, somente o sistema e os compiladores podem derivar explicitamente o <xref:System.Array> classe. Os usuários devem empregar as construções de matriz fornecidas pela linguagem.  
  
 Um elemento é um valor em um <xref:System.Array>. O comprimento de um <xref:System.Array> é o número total de elementos que ele pode conter. O limite inferior de um <xref:System.Array> é o índice do seu primeiro elemento. Um <xref:System.Array> pode ter qualquer limite inferior, mas ele tem um limite inferior de zero por padrão. Um limite inferior diferente pode ser definido ao criar uma instância do <xref:System.Array> classe usando <xref:System.Array.CreateInstance%2A>. Um multidimensionais <xref:System.Array> pode ter limites diferentes para cada dimensão. Uma matriz pode ter um máximo de 32 dimensões.  
  
 Ao contrário das classes no <xref:System.Collections> namespaces, <xref:System.Array> tem uma capacidade fixa. Para aumentar a capacidade, você deve criar um novo <xref:System.Array> de objeto com a capacidade necessária, copiar os elementos do antigo <xref:System.Array> do objeto para o novo e excluir o antigo <xref:System.Array>.  
  
 Por padrão, o tamanho máximo de um <xref:System.Array> é de 2 gigabytes (GB). Em um ambiente de 64 bits, você pode evitar a restrição de tamanho, definindo o `enabled` atributo o [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento de configuração para `true` no ambiente de tempo de execução. No entanto, a matriz ainda será limitada a um total de elementos de 4 bilhões e um índice máximo de 0X7FEFFFFF em uma determinada dimensão (0X7FFFFFC7 para matrizes de bytes e matrizes de estruturas de byte único).  
  
 Matrizes unidimensionais implementam o <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> e <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfaces genéricas. As implementações são fornecidas para matrizes em tempo de execução, e como resultado, as interfaces genéricas não aparecem na sintaxe de declaração para o <xref:System.Array> classe. Além disso, não há nenhum tópicos de referência para os membros de interface que são acessíveis somente por conversão de uma matriz para o tipo de interface genérica (implementações explícitas da interface). O mais importante estar atento ao converter uma matriz para uma dessas interfaces é que os membros que adicionam, inserir ou remover elementos throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type>objetos fornecem informações sobre declarações de tipo de matriz. <xref:System.Array>objetos com o mesmo tipo de matriz compartilham o mesmo <xref:System.Type> objeto.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType>e <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> podem não retornar os resultados esperados com <xref:System.Array> porque se uma matriz é convertida para o tipo <xref:System.Array>, o resultado é um objeto, não uma matriz. Ou seja, `typeof(System.Array).IsArray` retorna `false`, e `typeof(System.Array).GetElementType` retorna `null`.  
  
 O <xref:System.Array.Copy%2A?displayProperty=nameWithType> método copia não apenas entre matrizes do mesmo tipo, mas também entre matrizes de padrão de tipos diferentes de elementos; ele trata automaticamente de conversão de tipos.  
  
 Alguns métodos, como <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, e <xref:System.Array.SetValue%2A>, fornecem sobrecargas que aceitam números inteiros de 64 bits como parâmetros para acomodar as matrizes de capacidade grande. <xref:System.Array.LongLength%2A>e <xref:System.Array.GetLongLength%2A> retornam números inteiros de 64 bits que indica o comprimento da matriz.  
  
 O <xref:System.Array> não é garantida a ser classificada.  Você deve classificar o <xref:System.Array> antes de executar operações (como <xref:System.Array.BinarySearch%2A>) que exigem o <xref:System.Array> a ser classificada.  
  
 Usando um <xref:System.Array> objeto dos ponteiros em código nativo não é compatível e gerará um <xref:System.NotSupportedException> para vários métodos.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como <xref:System.Array.Copy%2A?displayProperty=nameWithType> copia os elementos entre uma matriz de tipo inteiro e uma matriz do tipo <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir cria e inicializa um <xref:System.Array> e exibe suas propriedades e seus elementos.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.  
  
 Esta implementação não oferece um sincronizado wrapper (thread-safe) para um <see cref="T:System.Array" />; no entanto, classes do .NET Framework com base em <see cref="T:System.Array" /> fornecer sua própria versão sincronizada de coleção usando o <see cref="P:System.Array.SyncRoot" /> propriedade.  
  
 A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, para encapsular em somente leitura <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper.</param>
        <summary>Retorna um wrapper somente leitura para a matriz especificada.</summary>
        <returns>Um wrapper somente leitura <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> para a matriz especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar modificações para a matriz, expor a matriz apenas por esse wrapper.  
  
 Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir encapsula uma matriz em somente leitura <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa uma matriz unidimensional inteira classificada por um elemento específico, usando a <see cref="T:System.IComparable" /> interface implementada por cada elemento da matriz e o objeto especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 O `value` ou cada elemento de `array` deve implementar o <xref:System.IComparable> interface, que é usada para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se`value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar <xref:System.Array.BinarySearch%2A> para localizar um objeto específico em um <xref:System.Array>.  
  
> [!NOTE]
>  A matriz é criada com seus elementos em ordem de classificação crescente. O <xref:System.Array.BinarySearch%2A> método requer que a matriz a ser classificada em ordem crescente.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Pesquisa um valor usando a interface <see cref="T:System.Collections.IComparer" /> especificada em uma matriz classificada unidimensional inteira.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.IComparer> implementação. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Se`comparer` é `null`, a comparação é feita usando o <xref:System.IComparable> implementação fornecida pelo próprio elemento ou valor especificado. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `comparer` é `null` e `value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa um intervalo de elementos em uma matriz unidimensional classificada para um valor, usando a interface <see cref="T:System.IComparable" /> implementada por cada elemento da matriz e pelo valor especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 O `value` ou cada elemento de `array` deve implementar o <xref:System.IComparable> interface, que é usada para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Pesquisa uma variedade de elementos em uma matriz classificada unidimensional para um valor usando a interface <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.IComparer> implementação. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Caso `comparer` seja `null`, a comparação é feita usando-se a implementação de <xref:System.IComparable> fornecida pelo próprio elemento ou pelo valor especificado. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `comparer` é `null` e `value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null`sempre podem ser comparados com qualquer outro tipo de referência; Portanto, as comparações com `null` não geram uma exceção ao usar <xref:System.IComparable>.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa uma matriz unidimensional inteira classificada por um elemento específico, usando a interface <see cref="T:System.IComparable`1" /> genérica implementada por cada elemento da <see cref="T:System.Array" /> e o objeto especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Se `array` não contém o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 `T`deve implementar o <xref:System.IComparable%601> interface genérica, que é usado para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico. Uma matriz de cadeias de caracteres é criada, em nenhuma ordem específica.  
  
 A matriz é exibida, classificada e exibida novamente. Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%2A> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo se a cadeia de caracteres não estiver na matriz, portanto, o `ShowWhere` método usa o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor`-1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a pesquisa str ER.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> não implementa a interface genérica <see cref="T:System.IComparable`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Pesquisa uma matriz classificada unidimensional completa para um valor usando a interface genérica de <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação de interface genérica. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Se `comparer` é `null`, a comparação é feita usando o <xref:System.IComparable%601> implementação de interface genérica fornecida pelo `T`. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `comparer` é `null` e `value` não implementa o <xref:System.IComparable%601> interface genérica, os elementos de `array` não são testadas para <xref:System.IComparable%601> antes de começa a pesquisa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable%601>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 A matriz é exibida, classificada e exibida novamente. Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <paramref name="comparer" /> é <see langword="null" /> e <paramref name="T" /> não implementa a interface genérica de <see cref="T:System.IComparable`1" /></exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa um intervalo de elementos em uma matriz unidimensional classificada em busca de um valor, usando a interface genérica <see cref="T:System.IComparable`1" /> implementada por cada elemento do <see cref="T:System.Array" /> e pelo valor especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Se a matriz não contém o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 `T`deve implementar o <xref:System.IComparable%601> interface genérica, que é usado para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="T" /> não implementa a interface genérica <see cref="T:System.IComparable`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Pesquisa uma variedade de elementos em uma matriz classificada unidimensional para um valor usando a interface genérica de <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos. `array`deve ser classificada antes de chamar esse método.  
  
 Se a matriz não contém o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação de interface genérica. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Se `comparer` é `null`, a comparação é feita usando o <xref:System.IComparable%601> fornecida para o tipo de implementação de interface genérica `T`. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null`sempre podem ser comparados com qualquer outro tipo de referência; Portanto, as comparações com `null` não geram uma exceção ao usar <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          O <paramref name="comparer" /> é <see langword="null" /> e <paramref name="T" /> não implementa a interface genérica de <see cref="T:System.IComparable`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz cujos elementos precisam ser limpos.</param>
        <param name="index">O índice inicial do intervalo de elementos a limpar.</param>
        <param name="length">O número de elementos a limpar.</param>
        <summary>Define um intervalo de elementos em uma matriz como o valor padrão de cada tipo de elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método redefine cada elemento em uma matriz para o valor padrão do tipo de elemento. Define elementos de tipos de referência (incluindo <xref:System.String> elementos) para `null`e define os elementos de tipos de valor para os valores padrão mostrados na tabela a seguir.  
  
|Tipo|Valor|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Todos os tipos numéricos de ponto flutuante e integral|0 (zero)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Outros tipos de valor|Valor padrão de campos do tipo|  
  
 O intervalo de desmarcada elementos wrap a cada linha em uma matriz multidimensional.  
  
 Esse método limpa somente os valores dos elementos; ele não exclui os próprios elementos. Uma matriz tem um tamanho fixo; Portanto, os elementos não podem ser adicionados ou removidos.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.Clear%2A> método para redefinir valores inteiros em uma matriz unidimensional, bidimensional e tridimensional.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 O exemplo a seguir define uma `TimeZoneTime` estrutura que inclui um <xref:System.TimeZoneInfo> campo e um <xref:System.DateTimeOffset> campo. Depois, ele chama o <xref:System.Array.Clear%2A> método para limpar um elemento em uma matriz de dois elementos de `TimeZoneTime` valores. O método define o valor do elemento desmarcado para o valor padrão de um <xref:System.TimeZoneInfo> objeto, que é `null`e o valor padrão de um <xref:System.DateTimeOffset> objeto, que é <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.  
  
 -ou-  
  
 A soma de <paramref name="index" /> e <paramref name="length" /> é maior que o tamanho do <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia superficial do <see cref="T:System.Array" />.</summary>
        <returns>Uma cópia superficial do <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma cópia superficial de uma <xref:System.Array> copia somente os elementos do <xref:System.Array>, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a. As referências no novo <xref:System.Array> apontam para o mesmo objetos que as referências no original <xref:System.Array> aponte para.  
  
 Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 O clone é do mesmo <xref:System.Type> original <xref:System.Array>.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 O código a seguir exemplo clones um <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> de matriz e demonstra o comportamento de uma cópia superficial.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="sourceIndex">Um inteiro de 32 bits que representa o índice no <c>sourceArray</c> no qual a cópia começa.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="destinationIndex">Um inteiro de 32 bits que representa o índice no <c>destinationArray</c> no qual armazenar começa.</param>
        <param name="length">Um inteiro de 32 bits que representa o número de elementos a se copiar.</param>
        <summary>Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado.  Garante que todas as alterações serão desfeitas se a cópia não foi bem-sucedida por completo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões.  O `sourceArray` tipo deve ser igual ou derivado de `destinationArray` tipo; caso contrário, um <xref:System.ArrayTypeMismatchException> é gerada.  Ao contrário de <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifica a compatibilidade dos tipos de matriz antes de executar qualquer operação.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna). Para iniciar a cópia do elemento da terceira linha (ou coluna), segunda `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o comprimento da segunda linha (ou coluna) e dois.  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor.  Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Se esse método lançará uma exceção durante a cópia, o `destinationArray` permanece inalterado; portanto, <xref:System.Array.ConstrainedCopy%2A> pode ser usado dentro de uma região de execução restrita (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">O tipo <paramref name="sourceArray" /> não é igual nem derivado do tipo <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="destinationIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="destinationArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">O tipo dos elementos da matriz de origem.</typeparam>
        <typeparam name="TOutput">O tipo dos elementos da matriz de destino.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero para converter para um tipo de destino.</param>
        <param name="converter">Um <see cref="T:System.Converter`2" /> que converte cada elemento de um tipo em outro tipo.</param>
        <summary>Converte uma matriz de um tipo para uma matriz de outro tipo.</summary>
        <returns>Uma matriz do tipo de destino que contém os elementos convertidos da matriz de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Converter%602> é um delegado para um método que converte um objeto para o tipo de destino.  Os elementos de `array` individualmente são passados para o <xref:System.Converter%602>, e os elementos convertidos são salvos na nova matriz.  
  
 A fonte `array` permanece inalterado.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir define um método chamado `PointFToPoint` que converte um <xref:System.Drawing.PointF> estrutura para um <xref:System.Drawing.Point> estrutura. O exemplo cria uma matriz de <xref:System.Drawing.PointF> estruturas, cria um `Converter<PointF, Point>` delegar (`Converter(Of PointF, Point)` no Visual Basic) para representar o `PointFToPoint` método e passa o delegado para o <xref:System.Array.ConvertAll%2A> método. O <xref:System.Array.ConvertAll%2A> método passa cada elemento da lista de entrada para o `PointFToPoint` método e coloca os elementos convertidos em uma nova lista de <xref:System.Drawing.Point> estruturas. Ambas as listas são exibidas.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="converter" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="length">Um inteiro de 32 bits que representa o número de elementos a se copiar.</param>
        <summary>Copia um intervalo de elementos de uma <see cref="T:System.Array" /> iniciando no primeiro elemento e cola-o em outro <see cref="T:System.Array" />, iniciando no primeiro elemento. O comprimento é especificado como um inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> é maior que o número de elementos em <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é maior que o número de elementos em <paramref name="destinationArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="length">Um inteiro de 64 bits que representa o número de elementos a se copiar. O inteiro deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Copia um intervalo de elementos de uma <see cref="T:System.Array" /> iniciando no primeiro elemento e cola-o em outro <see cref="T:System.Array" />, iniciando no primeiro elemento. O tamanho é especificado como um inteiro de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> é menor que 0 ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> é maior que o número de elementos em <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é maior que o número de elementos em <paramref name="destinationArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="sourceIndex">Um inteiro de 32 bits que representa o índice no <c>sourceArray</c> no qual a cópia começa.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="destinationIndex">Um inteiro de 32 bits que representa o índice no <c>destinationArray</c> no qual armazenar começa.</param>
        <param name="length">Um inteiro de 32 bits que representa o número de elementos a se copiar.</param>
        <summary>Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado. A altura e os índices são especificados como inteiros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos desde o `destinationIndex` posição para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna). Para iniciar a cópia do elemento da terceira linha (ou coluna), segunda `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o comprimento da segunda linha (ou coluna) e dois.  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> do tipo <xref:System.Object> para outro <xref:System.Array> do tipo inteiro.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="destinationIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="destinationArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="sourceIndex">Um inteiro de 64 bits que representa o índice no <c>sourceArray</c> no qual a cópia começa.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="destinationIndex">Um inteiro de 64 bits que representa o índice no <c>destinationArray</c> no qual armazenar começa.</param>
        <param name="length">Um inteiro de 64 bits que representa o número de elementos a se copiar. O inteiro deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado. O tamanho e os índices são especificados como inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos desde o `destinationIndex` posição para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna). Para iniciar a cópia do elemento da terceira linha (ou coluna), segunda `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o comprimento da segunda linha (ou coluna) e dois.  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> do tipo <xref:System.Object> para outro <xref:System.Array> do tipo inteiro.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="sourceArray" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="sourceIndex" /> está fora do intervalo de índices válidos para o <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="destinationIndex" /> está fora do intervalo de índices válidos para o <paramref name="destinationArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que 0 ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.  
  
 -ou-  
  
 <paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional que é o destino dos elementos copiados da matriz atual.</param>
        <param name="index">Um inteiro de 32 bits que representa o índice na <c>matriz</c> no qual a cópia começa.</param>
        <summary>Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada começando no índice de matriz de destino especificado. O índice é especificado como um inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia todos os elementos da instância atual de matriz para o `array` matriz de destino, começando no índice `index`. O `array` a matriz de destino já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os elementos copiados. Caso contrário, o método gera uma exceção.  
  
 Este método oferece suporte a <xref:System.Collections.ICollection?displayProperty=nameWithType> interface. Se a implementação <xref:System.Collections.ICollection?displayProperty=nameWithType> é necessário não foi explicitamente, use <xref:System.Array.Copy%2A> para evitar uma inversão de controle extra.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `array` é indefinido.  
  
 Esse método é um O (`n`) operação, onde `n` é <xref:System.Array.Length%2A>. Ele executa somente uma cópia superficial.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array> com um limite inferior diferente de zero. Observe que toda a origem <xref:System.Array> é copiado, incluindo elementos vazios que substituem elementos existentes no destino <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> é multidimensional.  
  
 -ou-  
  
 O número de elementos na matriz de origem é maior do que o número de elementos disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">O tipo do <see cref="T:System.Array" /> de origem não pode ser convertido automaticamente no tipo do <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.RankException">A matriz de origem é multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento no <see cref="T:System.Array" /> de origem não pode ser convertido no tipo de <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional que é o destino dos elementos copiados da matriz atual.</param>
        <param name="index">Um inteiro de 64 bits que representa o índice na <c>matriz</c> no qual a cópia começa.</param>
        <summary>Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada começando no índice de matriz de destino especificado. O índice é especificado como um inteiro de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia todos os elementos da instância atual de matriz para o `array` matriz de destino, começando no índice `index`. O `array` a matriz de destino já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os elementos copiados. Caso contrário, o método gera uma exceção.  
  
 Este método oferece suporte a <xref:System.Collections.ICollection?displayProperty=nameWithType> interface. Se a implementação <xref:System.Collections.ICollection?displayProperty=nameWithType> é necessário não foi explicitamente, use <xref:System.Array.Copy%2A> para evitar uma inversão de controle extra.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `array` é indefinido.  
  
 Esse método é um O (`n`) operação, onde `n` é <xref:System.Array.Length%2A>. Ele executa somente uma cópia superficial.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array> com um limite inferior diferente de zero. Observe que toda a origem <xref:System.Array> é copiado, incluindo elementos vazios que substituem elementos existentes no destino <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="array" /> é multidimensional.  
  
 -ou-  
  
 O número de elementos na matriz de origem é maior do que o número de elementos disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">O tipo do <see cref="T:System.Array" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.RankException">A fonte <see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento no <see cref="T:System.Array" /> de origem não pode ser convertido no tipo de <paramref name="array" /> de destino.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="length">O tamanho do <see cref="T:System.Array" /> a ser criado.</param>
        <summary>Cria um <see cref="T:System.Array" /> unidimensional do <see cref="T:System.Type" /> especificado e tamanho, com a indexação com base em zero.</summary>
        <returns>Um novo <see cref="T:System.Array" /> unidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um unidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
 -ou-  
  
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lengths">Uma matriz de inteiros de 32 bits que representa o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <summary>Cria um <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base zero. Os tamanhos da dimensão são especificados em uma matriz de inteiros de 32 bits.</summary>
        <returns>Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos especificados para cada dimensão, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 O número de elementos de `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>. Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) operação, onde `n` é o produto de todos os valores `lengths`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um multidimensionais <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="lengths" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.  
  
 -ou-  
  
 A matriz <paramref name="lengths" /> contém menos de um elemento.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
 -ou-  
  
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer valor em <paramref name="lengths" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lengths">Uma matriz de inteiros de 64 bits que representa o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criada. Cada inteiro na matriz deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Cria um <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base zero. Os tamanhos da dimensão são especificados em uma matriz de inteiros de 64 bits.</summary>
        <returns>Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos especificados para cada dimensão, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 O número de elementos de `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>. Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) operação, onde `n` é o produto de todos os valores `lengths`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um multidimensionais <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="lengths" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.  
  
 -ou-  
  
 A matriz <paramref name="lengths" /> contém menos de um elemento.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
 -ou-  
  
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer valor em <paramref name="lengths" /> é menor que zero ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="length1">O tamanho da primeira dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <param name="length2">O tamanho da segunda dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <summary>Cria um <see cref="T:System.Array" /> bidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base em zero.</summary>
        <returns>Um novo <see cref="T:System.Array" /> bidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado para cada dimensão, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) operação, onde `n` é o produto de `length1` e `length2`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um bidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
 -ou-  
  
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="length2" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lengths">Uma matriz unidimensional que contém o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lowerBounds">Uma matriz unidimensional que contém o limite inferior (índice inicial) de cada dimensão do <see cref="T:System.Array" /> a ser criado.</param>
        <summary>Cria um <see cref="T:System.Array" /> multidimensional com o <see cref="T:System.Type" /> especificado e com os tamanhos da dimensão, com os limites inferiores especificados.</summary>
        <returns>Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado e o limite inferior de cada dimensão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 O `lengths` e `lowerBounds` matrizes devem ter o mesmo número de elementos. O número de elementos de `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>.  
  
 Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.  
  
 Cada elemento do `lowerBounds` matriz deve especificar o limite inferior da dimensão correspondente no novo <xref:System.Array>. Em geral, a biblioteca de classes do .NET Framework e muitas linguagens de programação não lidar com limites inferiores do zero.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) operação, onde `n` é o produto de todos os valores `lengths`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um multidimensionais <xref:System.Array> com limites inferiores do especificado.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="lengths" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="lowerBounds" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.  
  
 -ou-  
  
 A matriz <paramref name="lengths" /> contém menos de um elemento.  
  
 -ou-  
  
 As matrizes <paramref name="lengths" /> e <paramref name="lowerBounds" /> não contêm o mesmo número de elementos.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
 -ou-  
  
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer valor em <paramref name="lengths" /> é menor que zero.  
  
 -ou-  
  
 Qualquer valor em <paramref name="lowerBounds" /> é muito grande, de modo que a soma do limite inferior e do tamanho de uma dimensão é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="length1">O tamanho da primeira dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <param name="length2">O tamanho da segunda dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <param name="length3">O tamanho da terceira dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <summary>Cria um <see cref="T:System.Array" /> tridimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base em zero.</summary>
        <returns>Um novo <see cref="T:System.Array" /> tridimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado para cada dimensão, usando a indexação baseada em zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) operação, onde `n` é o produto de `length1`, `length2`, e `length3`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um tridimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="elementType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
 -ou-  
  
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="length1" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="length2" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="length3" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <summary>Retorna uma matriz vazia.</summary>
        <returns>Retorna um <see cref="T:System.Array" /> vazio.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Determina se a matriz especificada contém elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>
          <see langword="true" /> se <paramref name="array" /> contiver um ou mais elementos que correspondem às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, e o processamento será interrompido quando uma correspondência for encontrada.  
  
> [!NOTE]
>  Em c# e Visual Basic, não é necessário criar a <xref:System.Predicate%601> delegar explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir especifica as condições de correspondência para o <xref:System.Array.Exists%2A> expressões de usinglambda método para verificar se um planeta começa com uma letra determinada ou se o planeta está localizado na matriz fornecida.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 O exemplo a seguir usa o <xref:System.Array.Exists%2A> método para indicar se todos os nomes em uma matriz de cadeia de caracteres começam com um caractere especificado. O exemplo cria um `StringSearcher` objeto passando a cadeia de caracteres para pesquisar para o construtor de classe. O `StringSearcher.StartsWith` método tem a mesma assinatura que o <xref:System.Predicate%601> delegate. Quando o <xref:System.Array.Exists%2A> método é chamado, cada membro da matriz é passado para o representante até ele retornar `true` ou itera todos os elementos na matriz.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Você pode também usar uma expressão lambda em vez de definir explicitamente um método cuja assinatura corresponde do delegado. O exemplo a seguir substitui o `StringSearcher` classe e seu `StartsWith` método com uma expressão lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="match">O predicado que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O primeiro elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um delegado para um método ou uma expressão lambda que retorna `true` se o objeto passado para ele corresponde às condições definidas no delegado ou expressão lambda.  Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, começando com o primeiro elemento e terminando com o último elemento.  O processamento será interrompido quando uma correspondência for encontrada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir usa uma <xref:System.Predicate%601> delegar com o <xref:System.Array.Find%2A> método genérico para pesquisar uma matriz de <xref:System.Drawing.Point> estruturas. O método que o delegado representa, `ProductGT10`, retorna `true` se o produto dos campos de X e Y é maior que 100.000. O <xref:System.Array.Find%2A> método chama o representante para cada elemento da matriz, retornando o primeiro ponto que atende a condição de teste.  
  
> [!NOTE]
>  Visual Basic e c# usuários é necessário criar o representante explicitamente ou especificar o argumento de tipo do método genérico. Os compiladores determinam os tipos necessários dos argumentos de método que você fornecer.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Em vez de definir explicitamente um método com a assinatura necessária, criando um <xref:System.Predicate%601> delegar e passando o delegado para o <xref:System.Array.Find%2A> método, é comum usar uma expressão lambda. O exemplo a seguir é idêntico ao anterior, exceto que ele usa uma expressão lambda como o `match` argumento.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Recupera todos os elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>Um <see cref="T:System.Array" /> que contém todos os elementos que correspondem às condições definidas pelo predicado especificado, se encontrado; caso contrário, um <see cref="T:System.Array" /> vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, e os elementos que correspondem às condições são salvos na matriz retornada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de números aleatórios 50 com valores podem variar de 0 a 1.000. Depois, ele chama o <xref:System.Array.FindAll%2A> método com uma expressão lambda que retorna os valores que variam de 300 a 600. Observe que a expressão lambda é passada um parâmetro denominado `x`;  Isso representa o membro de matriz individual que é passado para o <xref:System.Predicate%601>. Observe também que o local `lBound` e `uBound` variáveis são acessíveis dentro da expressão lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 O exemplo de código a seguir demonstra o <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> métodos genéricos. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.Find%2A> método genérico atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa para quando o método `EndsWithSaurus` retorna `true` para o elemento "Amargasaurus".  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLast%2A> método genérico é usado para pesquisar a matriz com versões anteriores do final. Ele localiza o elemento "Dilophosaurus" na posição 5. O <xref:System.Array.FindAll%2A> método genérico é usado para retornar uma matriz que contém todos os elementos que terminam em "saurus". Os elementos são exibidos.  
  
 O exemplo de código também demonstra o <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> métodos genéricos.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado forward iniciando no primeiro elemento e terminando no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 1.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continua até o fim da matriz. Localiza o elemento na posição 5. Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2. Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> que se estende do índice especificado ao último elemento.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado forward começando em `startIndex` e terminando no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Esse método é um O (`n`) operação, onde `n` é o número de elementos do `startIndex` ao final da `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 1.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continua até o fim da matriz. Localiza o elemento na posição 5. Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2. Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que coincida com as condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos na <see cref="T:System.Array" /> que começa no índice especificado e contém o número de elementos especificado.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado forward começando em `startIndex` e final em `startIndex` mais `count` menos 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 1.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continua até o fim da matriz. Localiza o elemento na posição 5. Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2. Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O último elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, movendo para trás o <xref:System.Array>, começando com o último elemento e terminando com o primeiro elemento.  O processamento será interrompido quando uma correspondência for encontrada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> métodos genéricos. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.Find%2A> método genérico atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa para quando o método `EndsWithSaurus` retorna `true` para o elemento "Amargasaurus".  
  
> [!NOTE]
>  Em c# e Visual Basic, não é necessário criar a`Predicate<string>` delegar (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLast%2A> método genérico é usado para pesquisar a matriz com versões anteriores do final. Ele localiza o elemento "Dilophosaurus" na posição 5. O <xref:System.Array.FindAll%2A> método genérico é usado para retornar uma matriz que contém todos os elementos que terminam em "saurus". Os elementos são exibidos.  
  
 O exemplo de código também demonstra o <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> métodos genéricos.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz com versões anteriores do final, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 5.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continuar para trás até o início da matriz. Localiza o elemento na posição 1. Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e funcionando (ou seja, 2, 3 e 4). Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Esse método é um O (`n`) operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz com versões anteriores do final, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 5.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continuar para trás até o início da matriz. Localiza o elemento na posição 1. Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e funcionando (ou seja, 2, 3 e 4). Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa por um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência no intervalo de elementos no <see cref="T:System.Array" /> que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e final em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz com versões anteriores do final, passando a cada elemento sucessivamente para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 5.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continuar para trás até o início da matriz. Localiza o elemento na posição 1. Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e funcionando (ou seja, 2, 3 e 4). Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero em cujos elementos a ação deve ser executada.</param>
        <param name="action">O <see cref="T:System.Action`1" /> para executar em cada elemento de <c>matriz</c>.</param>
        <summary>Executa a ação especificada em cada elemento da matriz especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Action%601> um delegado para um método que executa uma ação no objeto passado para ele.  Os elementos de `array` são passados individualmente para o <xref:System.Action%601>.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar <xref:System.Array.ForEach%2A> para exibir os quadrados de cada elemento em uma matriz de inteiros.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="action" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Array" />.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.  Nesta posição, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Por isso, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> ser chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.  
  
 O enumerador não tem acesso exclusivo à coleção; Portanto, enumerando através de uma coleção intrinsecamente não é um procedimento de segurança do thread.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar <xref:System.Array.GetEnumerator%2A> para listar os elementos de uma matriz.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero do <see cref="T:System.Array" /> cujo comprimento precisa ser determinado.</param>
        <summary>Obtém um inteiro de 32 bits que representa o número de elementos na dimensão especificada do <see cref="T:System.Array" />.</summary>
        <returns>Um inteiro de 32 bits que representa o número de elementos na dimensão especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um exemplo de <xref:System.Array.GetLength%2A> é `GetLength(0)`, que retorna o número de elementos na primeira dimensão do <xref:System.Array>.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar <xref:System.Array.GetLength%2A> para exibir as dimensões de duas matrizes com diferentes classificações.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> é menor que zero.  
  
 - ou -  
  
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero do <see cref="T:System.Array" /> cujo comprimento precisa ser determinado.</param>
        <summary>Obtém um inteiro de 64 bits que representa o número de elementos na dimensão especificada do <see cref="T:System.Array" />.</summary>
        <returns>Um inteiro de 64 bits que representa o número de elementos na dimensão especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um exemplo de <xref:System.Array.GetLongLength%2A> é `GetLongLength(0)`, que retorna o número de elementos na primeira dimensão do <xref:System.Array>.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> é menor que zero.  
  
 - ou -  
  
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero da matriz cujo índice inicial precisa ser determinado.</param>
        <summary>Obtém o índice do primeiro elemento da dimensão especificada na matriz.</summary>
        <returns>O índice do primeiro elemento da dimensão especificada na matriz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)`Retorna o índice inicial da primeira dimensão da matriz, e `GetLowerBound(Rank - 1)` retorna o índice inicial da última dimensão da matriz.  
  
 O <xref:System.Array.GetLowerBound%2A> método sempre retorna um valor que indica o índice do que o limite inferior da matriz, mesmo se a matriz está vazia.  
  
 Observe que, embora a maioria das matrizes no .NET Framework são baseadas em zero (isto é, o <xref:System.Array.GetLowerBound%2A> método retorna zero para cada dimensão de uma matriz), o .NET Framework oferece suporte a matrizes que não são baseadas em zero. Essas matrizes podem ser criados com o <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> método e também podem ser retornados do código não gerenciado.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos para exibir os limites de uma matriz unidimensional e bidimensional e exibir os valores de seus elementos de matriz.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> é menor que zero.  
  
 - ou -  
  
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero da matriz cujo limite superior precisa ser determinado.</param>
        <summary>Obtém o índice do último elemento da dimensão especificada na matriz.</summary>
        <returns>O índice do último elemento da dimensão especificada na matriz, ou -1, se a dimensão especificada estiver vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)`Retorna o último índice na primeira dimensão da matriz, e `GetUpperBound(Rank - 1)` retorna o último índice da última dimensão da matriz.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos para exibir os limites de uma matriz unidimensional e bidimensional e exibir os valores de seus elementos de matriz.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="dimension" /> é menor que zero.  
  
 - ou -  
  
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Um inteiro de 32 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Uma matriz unidimensional de inteiros de 32 bits que representa os índices especificando a posição do elemento <see cref="T:System.Array" /> a se obter.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Um inteiro de 64 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Uma matriz unidimensional de inteiros de 64 bits que representam os índices que especifica a posição do <see cref="T:System.Array" /> elemento ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiro de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do <see cref="T:System.Array" /> elemento ser obtido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do <see cref="T:System.Array" /> elemento ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiros de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index3">Um inteiro de 32 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> tridimensional. Os índices são especificados como inteiro de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do <see cref="T:System.Array" /> elemento ser obtido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do <see cref="T:System.Array" /> elemento ser obtido.</param>
        <param name="index3">Um inteiro de 64 bits que representa o índice de outra dimensão do <see cref="T:System.Array" /> elemento ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> tridimensional. Os índices são especificados como inteiros de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da primeira ocorrência em uma matriz unidimensional.</summary>
        <returns>O índice da primeira ocorrência de <paramref name="value" /> no <paramref name="array" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa todos os elementos de um arrayfor unidimensional `value`. Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade chamando cada elemento `Equals` método até encontrar uma correspondência. Isso significa que, se o elemento substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, essa substituição é chamada.  
  
 Como a maioria das matrizes têm um limite inferior de zero, este método geralmente retorna -1 se`value` não for encontrado. No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` não for encontrado, este método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres de matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <summary>Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo se estende de um índice especificado ao final da matriz.</summary>
        <returns>O índice da primeira ocorrência de <paramref name="value" />, se encontrado, no intervalo de elementos em <paramref name="array" /> que se estende de <paramref name="startIndex" /> até o último elemento; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa uma matriz unidimensional a partir do elemento no índice `startIndex` para o último elemento. Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `Equals` método de cada elemento até encontrar uma correspondência. Isso significa que, se o elemento substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, essa substituição é chamada.  
  
 Como a maioria das matrizes têm um limite inferior de zero, este método geralmente retorna -1 se `value` não for encontrado. No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` não for encontrado, este método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Se `startIndex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1. Se `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.  
  
 Esse método é um O (`n`) operação, onde `n` é o número de elementos do `startIndex` ao final da `array`.  
  
   
  
## Examples  
 O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres de matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <param name="count">O número de elementos a serem pesquisados.</param>
        <summary>Pesquisa pelo objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo estende-se de um índice especificado a um número especificado de elementos.</summary>
        <returns>O índice da primeira ocorrência de <paramref name="value" />, se ele foi encontrado no <paramref name="array" /> do índice <paramref name="startIndex" /> para <paramref name="startIndex" />  +  <paramref name="count" /> - 1; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa os elementos de um unidimensional arrayfrom `startIndex` para `startIndex` mais `count` menos 1, se `count` for maior que 0. Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `Equals` método de cada elemento até encontrar uma correspondência. Isso significa que, se o elemento substitui o <xref:System.Object.Equals%2A?displayProperty=nameWithType> método, essa substituição é chamada.  
  
 Matrizes de Becausemost têm um limite inferior de zero, geralmente, esse método retorna-1 quando `value` não foi encontrada. No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) e `value` não for encontrado, este método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Se `startindex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1. Se `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres de matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz. Para determinar o valor da `count` argumento, ele subtrai o limite superior da matriz do índice inicial e adiciona um.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da primeira ocorrência em uma matriz unidimensional.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="value" /> em todo o <paramref name="array" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa todos os elementos de uma matriz unidimensional para `value`. Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `T.Equals` método em cada elemento. Isso significa que se `T` substitui o <xref:System.Object.Equals%2A> método, essa substituição é chamada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início da matriz com o local de índice 3 e continua até o fim da matriz e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <summary>Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo se estende de um índice especificado ao final da matriz.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="value" /> dentro do intervalo de elementos em <paramref name="array" /> que se estende de <paramref name="startIndex" /> ao último elemento, se encontrado; caso contrário, –1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa uma matriz unidimensional a partir do elemento em `startIndex` até o final da matriz. Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `T.Equals` método em cada elemento. Isso significa que se `T` substitui o <xref:System.Object.Equals%2A> método, essa substituição é chamada.  
  
 Se `startIndex` é igual a <xref:System.Array.Length%2A>, o método retornará - 1.If `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.  
  
 Esse método é um O (`n`) operação, onde `n` é o número de elementos do `startIndex` ao final da `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início da matriz com o local de índice 3 e continua até o fim da matriz e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo estende-se de um índice especificado a um número especificado de elementos.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que começa em <paramref name="startIndex" /> e que contém o número de elementos especificados no <paramref name="count" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementos de searchesthe esse método de uma matriz unidimensional de `startIndex` para `startIndex` mais `count` menos 1, se `count` for maior que 0. Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `T.Equals` método em cada elemento. Isso significa que se `T` substitui o <xref:System.Object.Equals%2A> método, essa substituição é chamada.  
  
 Se `startIndex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1.  Se `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início da matriz com o local de índice 3 e continua até o fim da matriz e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa todos os elementos do tipo de valor <see cref="T:System.Array" /> chamando o construtor padrão do tipo de valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é projetado para ajudar a compiladores oferece suporte a matrizes de tipo de valor; a maioria dos usuários não é necessário para este método. Ele não deve ser usado em matrizes de tipo de referência.  
  
 Se o <xref:System.Array> não é um tipo de valor <xref:System.Array> ou se o tipo de valor não tem um construtor padrão, o <xref:System.Array> não é modificado.  
  
 O tipo de valor <xref:System.Array> pode ter qualquer limite inferior e qualquer número de dimensões.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Você pode usar esse método somente nos tipos de valor que tem construtores; No entanto, os tipos de valor são nativos em c# não tem construtores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Array" /> tem um tamanho fixo.</summary>
        <value>Esta propriedade é sempre <see langword="true" /> para todas as matrizes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementa o <xref:System.Array.IsFixedSize%2A> propriedade porque ele é necessário para o <xref:System.Collections.IList?displayProperty=nameWithType> interface.  
  
 Uma matriz com um tamanho fixo não permite a adição ou remoção de elementos depois que a matriz é criada, mas permite a modificação de elementos existentes.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Array" /> é somente leitura.</summary>
        <value>Esta propriedade é sempre <see langword="false" /> para todas as matrizes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementa o <xref:System.Array.IsReadOnly%2A> propriedade porque ele é necessário para o <xref:System.Collections.IList?displayProperty=nameWithType> interface. Uma matriz que é somente leitura não permite a adição, remoção ou modificação de elementos depois que a matriz é criada.  
  
 Se você precisar de uma coleção somente leitura, use um <xref:System.Collections> classe que implementa o <xref:System.Collections.IList?displayProperty=nameWithType> interface.  
  
 Se você converter ou converter uma matriz para um <xref:System.Collections.IList> objeto de interface, o <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> propriedade retorna `false`. No entanto, se você converter ou converter uma matriz para um <xref:System.Collections.Generic.IList%601> interface, o `IsReadOnly` propriedade retorna `true`.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Array" /> é sincronizado (thread-safe).</summary>
        <value>Esta propriedade é sempre <see langword="false" /> para todas as matrizes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array>implementa o <xref:System.Array.IsSynchronized%2A> propriedade porque ele é necessário para o <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.  
  
 Classes do .NET framework com base em <xref:System.Array> fornecer sua própria versão sincronizada de coleção usando o <xref:System.Array.SyncRoot%2A> propriedade.  
  
 Classes que usam matrizes também podem implementar seus próprios sincronização usando o <xref:System.Array.SyncRoot%2A> propriedade. O código de sincronização necessário realizar operações no `SyncRoot` da coleção, não diretamente na coleção. Isso garante a operação apropriada das coleções que são derivadas de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificar a coleção. Observe que algumas implementações de <xref:System.Array.SyncRoot%2A> pode retornar o <xref:System.Array> em si.  
  
 Enumerar através de uma coleção intrinsecamente não é um procedimento de segurança do thread. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como uma matriz de bloqueio durante toda a enumeração usando o <xref:System.Array.SyncRoot%2A> propriedade.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser procurado.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro de toda a <see cref="T:System.Array" /> unidimensional.</summary>
        <returns>O índice da última ocorrência de <paramref name="value" /> na <paramref name="array" /> inteira, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O unidimensional <xref:System.Array> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria –1 quando `value` não fosse encontrado. No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe. Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.  
  
 <xref:System.IComparable.CompareTo%2A>métodos do `item` parâmetro nos objetos na coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser procurado.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial da pesquisa inversa.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro do intervalo de elementos no unidimensional <see cref="T:System.Array" /> que se estende do primeiro elemento para o índice especificado.</summary>
        <returns>O índice da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que se estende do primeiro elemento a ser <paramref name="startIndex" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O unidimensional <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria –1 quando `value` não fosse encontrado. No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.  
  
 Esse método é um O (`n`) operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.  
  
 No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe. Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser procurado.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência no intervalo de elementos no <see cref="T:System.Array" /> unidimensional que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice da última ocorrência de <paramref name="value" /> no intervalo de elementos em <paramref name="array" /> que contém o número de elementos especificado em <paramref name="count" /> e termina em <paramref name="startIndex" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O unidimensional <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e final em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Se o tipo de elemento é um tipo não intrínsecas (definido pelo usuário), o`Equals` implementação desse tipo é usada.  
  
 Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria –1 quando `value` não fosse encontrado. No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
 No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe. Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz. Observe que o <xref:System.Array.LastIndexOf%2A> método é uma pesquisa para trás; portanto, `count` deve ser menor ou igual a (`startIndex` menos o limite inferior da matriz de mais de 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro de toda a <see cref="T:System.Array" />.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="value" /> em todo o <paramref name="array" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método de pesquisa a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início de matriz com versões anteriores com o local de índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro do intervalo de elementos de <see cref="T:System.Array" /> que se estende do primeiro elemento para o índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que se estende do primeiro elemento a ser <paramref name="startIndex" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Esse método é um O (`n`) operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método de pesquisa a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início de matriz com versões anteriores com o local de índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="value">O objeto a ser localizado na <c>matriz</c>.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro do intervalo de elementos de <see cref="T:System.Array" /> que contém o número especificado de elementos e termina no índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que contém o número de elementos especificados na <paramref name="count" /> e termina no <paramref name="startIndex" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e final em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método de pesquisa a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início de matriz com versões anteriores com o local de índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="count" /> é menor que zero.  
  
 -ou-  
  
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</summary>
        <value>O número total de elementos em todas as dimensões do <see cref="T:System.Array" />; zero se não houver elementos na matriz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.Length%2A> propriedade para obter o número total de elementos em uma matriz. Ele também usa o <xref:System.Array.GetUpperBound%2A> método para determinar o número de elementos em cada dimensão de uma matriz multidimensional.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">A matriz é multidimensional e contém mais de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um inteiro de 64 bits que representa o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</summary>
        <value>Um inteiro de 64 bits que representa o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a classificação (número de dimensões) do <see cref="T:System.Array" />. Por exemplo, uma matriz unidimensional retorna 1, uma matriz bidimensional retorna 2 e assim por diante.</summary>
        <value>A classificação (número de dimensões) do <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, o código do Visual Basic  
  
```  
Dim TDArray(0,0,0) As Integer  
```  
  
 e o código c#  
  
```  
int[,,] TDArray = new int[1,1,1];  
```  
  
 Crie uma matriz de três dimensões com um <xref:System.Array.Rank%2A> propriedade cujo valor é 3.  
  
 Uma matriz denteada (uma matriz de matrizes) é uma matriz unidimensional; o valor de seu <xref:System.Array.Rank%2A> propriedade é 1.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir inicializa uma matriz unidimensional, uma matriz bidimensional e uma matriz denteada e recupera o <xref:System.Array.Rank%2A> propriedade de cada um.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional baseada em zero a ser redimensionada, ou <see langword="null" /> para criar uma nova matriz com o tamanho especificado.</param>
        <param name="newSize">O tamanho da nova matriz.</param>
        <summary>Altera o número de elementos de uma matriz unidimensional para o novo tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método aloca uma nova matriz com o tamanho especificado, copia os elementos da matriz antiga para o novo e, em seguida, substitui o array antigo pelo novo.`array` deve ser uma matriz unidimensional.  
  
 Se `array` é `null`, esse método cria uma nova matriz com o tamanho especificado.  
  
 Se `newSize` é maior do que o <xref:System.Array.Length%2A> da matriz antiga, uma nova matriz é alocada e todos os elementos são copiados da matriz antiga para o novo.  Se `newSize` é menor do que o <xref:System.Array.Length%2A> da matriz antiga, uma nova matriz é alocada e elementos copiados da matriz antiga para o novo até que o novo nome é preenchido; o restante dos elementos na matriz antigo são ignorados.  Se `newSize` é igual de <xref:System.Array.Length%2A> da matriz antiga, esse método não fará nada.  
  
 Este método é uma operação O(`n`), em que `n` é `newSize`.  
  
 O <xref:System.Array.Resize%2A> método redimensiona apenas uma matriz unidimensional. O <xref:System.Array> classe não tem um método de redimensionamento de matrizes multidimensionais. Para fazer isso, você deve fornecer seu próprio código ou chamar um método especial em uma biblioteca de terceiros. O código a seguir ilustra uma possível implementação de um método que redimensiona uma matriz de * n * dimensões.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir mostra como redimensionar afeta a matriz.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="newSize" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser invertido.</param>
        <summary>Inverte a sequência dos elementos em todo o <see cref="T:System.Array" /> unidimensional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Após uma chamada para esse método, o elemento no `myArray[i]`, onde `i` qualquer índice na matriz, move para `myArray[j]`, onde `j` é igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 Como mostra o exemplo a seguir, o <xref:System.Array.Reverse%2A> método pode ser usado para reverter uma matriz denteada. Inicializa uma matriz denteada com um elemento para cada mês do ano atual no calendário da cultura atual. Cada elemento contém uma matriz com elementos desse mês tem dias. O exemplo exibe o conteúdo da matriz, chama o <xref:System.Array.Reverse%2A> método e, em seguida, exibe o conteúdo da matriz invertida.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como reverter a classificação dos valores em um <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser invertido.</param>
        <param name="index">O índice inicial da seção a ser invertido.</param>
        <param name="length">O número de elementos na seção a ser invertida.</param>
        <summary>Inverte a sequência dos elementos em toda gama de elementos no <see cref="T:System.Array" /> unidimensional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Após uma chamada para esse método, o elemento no `myArray[i]`, onde `i` qualquer índice na matriz, move para `myArray[j]`, onde `j` é igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 O <xref:System.Array.Reverse%2A> método pode ser usado para reverter uma matriz denteada.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como reverter a classificação dos valores em um intervalo de elementos em um <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index">Um inteiro de 32 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="indices">Uma matriz unidimensional de inteiros de 32 bits que representam os índices que especificam a posição do elemento a ser definido.</param>
        <summary>Define um valor para o elemento na posição especificada na <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 O <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos podem determinar se qualquer um dos valores a `indices` matriz está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index">Um inteiro de 64 bits que representa a posição de <see cref="T:System.Array" /> elemento a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="indices">Uma matriz unidimensional de inteiros de 64 bits que representam os índices que especifica a posição do elemento a ser definido.</param>
        <summary>Define um valor para o elemento na posição especificada na <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 O <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos podem determinar se qualquer um dos valores a `indices` matriz está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do <see cref="T:System.Array" /> elemento a ser definido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do <see cref="T:System.Array" /> elemento a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index3">Um inteiro de 32 bits que representa o índice de outra dimensão do <see cref="T:System.Array" /> elemento a ser definido.</param>
        <summary>Define um valor para o elemento na posição especificada no tridimensional <see cref="T:System.Array" />. Os índices são especificados como inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do <see cref="T:System.Array" /> elemento a ser definido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do <see cref="T:System.Array" /> elemento a ser definido.</param>
        <param name="index3">Um inteiro de 64 bits que representa o índice de outra dimensão do <see cref="T:System.Array" /> elemento a ser definido.</param>
        <summary>Define um valor para o elemento na posição especificada no tridimensional <see cref="T:System.Array" />. Os índices são especificados como inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.InvalidCastException">
          <paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser classificado.</param>
        <summary>Classifica os elementos em todo um <see cref="T:System.Array" /> unidimensional usando a implementação <see cref="T:System.IComparable" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um[classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O unidimensional <see cref="T:System.Array" /> que contém os itens que correspondem a cada uma das chaves no <c>chaves</c><see cref="T:System.Array" />.  
  
 -ou-  
  
 <see langword="null" />Para classificar somente o <c>chaves</c><see cref="T:System.Array" />.</param>
        <summary>Classifica um par de objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação <see cref="T:System.IComparable" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
 -ou-  
  
 O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser classificada.</param>
        <param name="comparer">A implementação a ser usada ao comparar elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica os elementos em um <see cref="T:System.Array" /> unidimensional usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` é `null`, cada elemento do `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo uma `ReverseComparer` classe inverte a ordem de classificação padrão para instâncias de um tipo e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir classifica os valores em um arrayby de cadeia de caracteres usando o comparador padrão. Ele também define um personalizado <xref:System.Collections.IComparer> implementação denominada `ReverseComparer` que inverte a ordem de classificação padrão de um objeto ao executar uma comparação de cadeia de caracteres de maiusculas e minúsculas. Observe que a saída pode variar dependendo da cultura atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O unidimensional <see cref="T:System.Array" /> que contém os itens que correspondem a cada uma das chaves no <c>chaves</c><see cref="T:System.Array" />.  
  
 -ou-  
  
 <see langword="null" />Para classificar somente o <c>chaves</c><see cref="T:System.Array" />.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica um par objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` é `null`, cada chave no `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo uma <xref:System.Collections.IComparer> implementação que inverte a ordem de classificação padrão e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
 -ou-  
  
 O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
 -ou-  
  
 A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que previouslythrew <see cref="T:System.ArgumentException" /> não gerará uma exceção, porque os algoritmos de classificação e heapsort de inserção não detectam um comparador inválido. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser classificado.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> unidimensional usando a implementação <see cref="T:System.IComparable" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O unidimensional <see cref="T:System.Array" /> que contém os itens que correspondem a cada uma das chaves no <c>chaves</c><see cref="T:System.Array" />.  
  
 -ou-  
  
 <see langword="null" />Para classificar somente o <c>chaves</c><see cref="T:System.Array" />.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica um intervalo de elementos em um par de objetos <see cref="T:System.Array" /> unidirecionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Array" /> usando a implementação <see cref="T:System.IComparable" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
 -ou-  
  
 O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser classificado.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> unidimensional usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` é `null`, cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo uma `ReverseComparer` classe inverte a ordem de classificação padrão para instâncias de um tipo e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">
          <paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
 -ou-  
  
 A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O unidimensional <see cref="T:System.Array" /> que contém os itens que correspondem a cada uma das chaves no <c>chaves</c><see cref="T:System.Array" />.  
  
 -ou-  
  
 <see langword="null" />Para classificar somente o <c>chaves</c><see cref="T:System.Array" />.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
 -ou-  
  
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` é `null`, cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo um personalizado <xref:System.Collections.IComparer> implementação que inverte a ordem de classificação padrão e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
 -ou-  
  
 O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.  
  
 -ou-  
  
 A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado.</param>
        <summary>Classifica os elementos em todo um <see cref="T:System.Array" /> usando a implementação de interface genérica do <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento de `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico. Uma matriz de cadeias de caracteres é criada, em nenhuma ordem específica.  
  
 A matriz é exibida, classificada e exibida novamente.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%2A> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica os elementos em um <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` é `null`, cada elemento do `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 A matriz é exibida, classificada e exibida novamente. Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</param>
        <param name="comparison">O <see cref="T:System.Comparison`1" /> a ser usado na comparação de elementos.</param>
        <summary>Classifica os elementos em um <see cref="T:System.Array" /> usando o <see cref="T:System.Comparison`1" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Esse método usa o algoritmo de classificação introspectiva (introsort) da seguinte maneira:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecarga do método.  
  
 O exemplo de código define um método alternativo de comparação para cadeias de caracteres, denominado `CompareDinosByLength`. Esse método funciona da seguinte maneira: primeiro, o comparandsare testado para`null`, e uma referência nula é tratada como menor que não null. Segundo, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais longa é considerada maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Uma matriz de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, em nenhuma ordem específica. A lista também inclui uma cadeia de caracteres vazia e uma referência nula. A lista é exibida, classificados usando um <xref:System.Comparison%601> delegado genérico que representa o `CompareDinosByLength` método e exibida novamente.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="comparison" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparison" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparison" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> usando a implementação de interface genérica do <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico e o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico para um intervalo em uma matriz de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauro, consiste em três herbivores seguidos de três carnivores (tyrannosaurids, para ser preciso). O <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico é usada para classificar os três últimos elementos da matriz, que é exibido. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada com `ReverseCompare` para classificar os três últimos elementos na ordem inversa. Dinossauros completamente confundidos são exibidos novamente.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` é `null`, cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico e o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico para um intervalo em uma matriz de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauro, consiste em três herbivores seguidos de três carnivores (tyrannosaurids, para ser preciso). O <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico é usada para classificar os três últimos elementos da matriz, que é exibido. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada com `ReverseCompare` para classificar os três últimos elementos na ordem inversa. Dinossauros completamente confundidos são exibidos novamente.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
 -ou-  
  
 A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">Unidimensional, com base em zero <see cref="T:System.Array" /> que contém os itens que correspondem às chaves no <c>chaves</c>, ou <see langword="null" /> para classificar somente <c>chaves</c>.</param>
        <summary>Classifica um par de objetos <see cref="T:System.Array" /> (um contém as chaves e outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação da interface genérica <see cref="T:System.IComparable`1" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra as sobrecargas de método genérico <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> para pares de matrizes de classificação que representam chaves e valores.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">Unidimensional, com base em zero <see cref="T:System.Array" /> que contém os itens que correspondem às chaves no <c>chaves</c>, ou <see langword="null" /> para classificar somente <c>chaves</c>.</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica um par de objetos <see cref="T:System.Array" /> (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` é `null`, cada chave no `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico para pares de matrizes que representam as chaves e valores de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga e uma instância de `ReverseCompare` são usados para inverter a ordem de classificação das matrizes emparelhadas.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
 -ou-  
  
 A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">Unidimensional, com base em zero <see cref="T:System.Array" /> que contém os itens que correspondem às chaves no <c>chaves</c>, ou <see langword="null" /> para classificar somente <c>chaves</c>.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> (um contém as chaves e outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação da interface genérica <see cref="T:System.IComparable`1" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico, para pares de matrizes que representam as chaves e valores de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.  
  
-   O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > sobrecarga é usada para classificar os três últimos elementos de matrizes.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">Unidimensional, com base em zero <see cref="T:System.Array" /> que contém os itens que correspondem às chaves no <c>chaves</c>, ou <see langword="null" /> para classificar somente <c>chaves</c>.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` é `null`, cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceder 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7d%29 > sobrecargas de método genérico para pares de matrizes que representam as chaves e valores de classificação.  
  
 O exemplo de código define um comparador alternativo para cadeias de caracteres, denominado `ReverseCompare`, que implementa o `IComparer<string>`(`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.  
  
-   O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga é usada para classificar os três últimos elementos de ambos matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
 -ou-  
  
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
 -ou-  
  
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
 -ou-  
  
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.  
  
 -ou-  
  
 A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage">
          <para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Array" />.</summary>
        <value>Um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade implementa o <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.  
  
 Classes do .NET framework com base em <xref:System.Array> fornecer sua própria versão sincronizada de coleção usando o <xref:System.Array.SyncRoot%2A> propriedade.  
  
 Classes que usam matrizes também podem implementar seus próprios sincronização usando o <xref:System.Array.SyncRoot%2A> propriedade. O código de sincronização necessário realizar operações no `SyncRoot` da coleção, não diretamente na coleção. Isso garante a operação apropriada das coleções que são derivadas de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificar a coleção. Observe que algumas implementações de <xref:System.Array.SyncRoot%2A> pode retornar o <xref:System.Array> em si.  
  
 Enumerar através de uma coleção intrinsecamente não é um procedimento de segurança do thread. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como uma matriz de bloqueio durante toda a enumeração usando o <xref:System.Array.SyncRoot%2A> propriedade.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos contidos no <see cref="T:System.Array" />.</summary>
        <value>O número de elementos contidos na coleção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser adicionado ao <see cref="T:System.Collections.IList" />.</param>
        <summary>A chamada desse método sempre gera uma exceção <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Não há suporte à adição de um valor a uma matriz. Nenhum valor é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em geral, um <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementação adiciona um membro a uma coleção. No entanto, como matrizes têm um tamanho fixo (o <xref:System.Array.IsFixedSize%2A> propriedade sempre retorna `true`), esse método sempre gerará um <xref:System.NotSupportedException> exceção.  
  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os itens do <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser localizado na lista atual. O elemento a ser localizado pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Determina se um elemento está no <see cref="T:System.Collections.IList" />.</summary>
        <returns>
          <see langword="true" /> se <paramref name="value" /> for encontrado no <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser localizado na lista atual.</param>
        <summary>Determina o índice de um item específico em <see cref="T:System.Collections.IList" />.</summary>
        <returns>O índice do valor se encontrado na lista; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">O índice no qual <c>valor</c> devem ser inseridos.</param>
        <param name="value">O objeto a ser inserido.</param>
        <summary>Insere um item na <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.  
  
 - ou -  
  
 O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
        <exception cref="T:System.NullReferenceException">
          <paramref name="value" /> é uma referência nula no <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice do elemento a ser obtido ou definido.</param>
        <summary>Obtém ou define o elemento no índice especificado.</summary>
        <value>O elemento no índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que zero.  
  
 - ou -  
  
 <paramref name="index" /> é igual a ou maior que <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a remover do <see cref="T:System.Collections.IList" />.</param>
        <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.  
  
 - ou -  
  
 O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice do elemento a ser removido.</param>
        <summary>Remove o item <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.  
  
 - ou -  
  
 O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado com a instância atual.</param>
        <param name="comparer">Um objeto que compara o objeto atual e <c>outros</c>.</param>
        <summary>Determina se o objeto da coleção atual precede, ocorre na mesma posição ou segue a outro objeto na ordem de classificação.</summary>
        <returns>Um inteiro que indica a relação do objeto da coleção atual para outro, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term>Valor de retorno  
  
 </term><description>Descrição  
  
 </description></listheader><item><term> -1  
  
 </term><description>A instância atual é anterior <paramref name="other" />.  
  
 </description></item><item><term> 0  
  
 </term><description>A instância atual e <paramref name="other" /> são iguais.  
  
 </description></item><item><term> 1  
  
 </term><description>A instância atual segue <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralComparable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado com a instância atual.</param>
        <param name="comparer">Um objeto que determina se a instância atual e <c>outros</c> são iguais.</param>
        <summary>Determina se um objeto é igual à instância atual.</summary>
        <returns>
          <see langword="true" /> se os dois objetos forem iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Um objeto que calcula o código hash do objeto atual.</param>
        <summary>Retorna um código hash para a instância atual.</summary>
        <returns>O código hash da instância atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero a ser verificado em relação às condições.</param>
        <param name="match">O predicado que define as condições a serem verificadas nos elementos.</param>
        <summary>Determina se cada elemento na matriz corresponde às condições definidas pelo predicado especificado.</summary>
        <returns>
          <see langword="true" /> se cada elemento no <paramref name="array" /> corresponder às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />. Se não houver nenhum elemento na matriz, o valor retornado será <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um delegado para um método que retorna`true` se o objeto passado para ele corresponde às condições definidas no delegado.  Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, e o processamento será interrompido quando o delegado retorna `false` para qualquer elemento.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir determina se o último caractere de cada elemento em uma matriz de cadeia de caracteres é um número. Ele cria duas matrizes de cadeia de caracteres. A primeira arrayincludes cadeias de caracteres que terminam com caracteres alfabéticos e cadeias de caracteres que terminam com caracteres numéricos. A segunda matriz consiste apenas em cadeias de caracteres que terminam com caracteres numéricos. O exemplo também define um `EndWithANumber` método cuja assinatura coincide com o <xref:System.Predicate%601> delegate. O exemplo passa cada matriz para o <xref:System.Array.TrueForAll%2A> método junto com um delegado que representa o `EndsWithANumber` método.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 O exemplo a seguir é semelhante ao primeiro, exceto que ele passa a matriz de cadeia de caracteres para o <xref:System.Array.TrueForAll%2A> método junto com uma expressão lambda que determina se um elemento de matriz específico termina com a representação de cadeia de caracteres de um número.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 Em ambos os casos, o <xref:System.Array.TrueForAll%2A> método retorna `false` assim que encontrar o primeiro elemento da matriz que não terminam em um número. Caso contrário, retornará `true` após a iteração de todos os elementos na matriz.  
  
> [!NOTE]
>  Como ambos os exemplos mostram, em c# e Visual Basic, não é necessário criar o `Predicate<string>` delegar (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="array" /> é <see langword="null" />.  
  
 -ou-  
  
 <paramref name="match" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>
